[
  {
    "path": "projects/2025/100577218/",
    "title": "Conflict in Sub-Suharan Africa",
    "description": "A graph representing conflict in 2021 - 2022.",
    "author": [
      {
        "name": "Benjamin Sam",
        "url": {}
      }
    ],
    "date": "2025-12-16",
    "categories": [
      "2025"
    ],
    "contents": "\n\nContents\nINTRODUCTION\nREPLICATION\nPACKAGES\nCLEANING THE DATA\nBASE MAP\nCOUNTRY ARC PLOTS\nBOXES\nKEY\nPLOT FINAL MAP\n\nIMPROVEMENT\nRATIONALE FOR IMPROVEMENT\nIMPROVEMENT GRAPH\n\n\nINTRODUCTION\nAs we went through the data visualisation journey, one of the classes\nthat grabbed me the most was the one involving maps. I hadn’t thought of\nusing R to build much more than statistical representations so the idea\nof a map wormed it’s way into my brain and seemed novel.\nI also had it in my head to do the project on an interesting topic - I\ndidn’t want to choose something dry beacuse the data was easier to work\nwith. I settled on conflict in sub-suharan africa as it is a significant\nseries of international armed conflicts that consistently go\nunder-reported. With that as a target, I came across a map of conflict\nin sub-suharan Africa from 2022.\nThe replication process was more complicated than anticipated and I\nstrugged at times. Annotations at scale are not for the faint of heart!\nREPLICATION\nPACKAGES\n\n\nlibrary(giscoR)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(ggforce)\nlibrary(patchwork)\n#library(dplyr)\nlibrary(grid)\nlibrary(png)\nlibrary(tidyverse)\n#library(lubridate)\n\n\nCLEANING THE DATA\n\n\ndata <- read_csv(\"data/Africa_aggregated_data_up_to-2025-11-29.csv\")\n\ndata <- \n  data |> \n  mutate(WEEK = dmy(WEEK))\n\nfiltered_data <- \n  data |> \n  filter(WEEK >= as.Date(\"2021-03-01\") & WEEK <= as.Date(\"2022-04-30\"))\n\ncountry_list <- c(\"Mali\", \"Burkina Faso\", \"Niger\", \"Chad\", \n                  \"Sudan\", \"Nigeria\", \"Cameroon\", \"Central African Republic\", \n                  \"South Sudan\", \"Ethiopia\", \"Somalia\", \n                  \"Democratic Republic of Congo\", \"Uganda\", \"Mozambique\")\n\nfiltered_data <- \n  filtered_data |>\n  filter(COUNTRY %in% country_list) |> \n  group_by(COUNTRY) |> \n  summarise(total_fatalities = sum(FATALITIES))\n\n# lookup table\nvalues_lookup <- \n  tribble(\n    ~COUNTRY, ~human_impact, ~incidence, ~geopolitical_impact,\n    \"Burkina Faso\", 10, 15, 17,\n    \"Cameroon\", 6, 7, 7,\n    \"Central African Republic\", 8, 5, 44,\n    \"Chad\", 2, 1, 23,\n    \"Democratic Republic of Congo\", 32, 25, 42,\n    \"Ethiopia\", 24, 13, 8,\n    \"Mali\", 5, 10, 48,\n    \"Mozambique\", 4, 4, 24,\n    \"Niger\", 2, 3, 33,\n    \"Nigeria\", 26, 27, 12,\n    \"Somalia\", 20, 24, 42,\n    \"South Sudan\", 19, 7, 45,\n    \"Sudan\",19, 6, 30,\n    \"Uganda\", 0, 3, 7\n)\n\nfiltered_data <- \n  filtered_data |> \n  left_join(values_lookup, by = \"COUNTRY\")\n\n\nBASE MAP\nCOLOURS FOR ARC GRAPHS\n\n\ncolor_points <- tibble(\n  value = c(0, 5, 10, 15, 17, 20, 23, 30, 32, 42, 44, 48),\n  color = c(\"#FAF8B2\", \"#FAF3B0\", \"#F6E5A8\", \"#F0DA9F\", \"#EFD69C\",\n            \"#EDCF97\", \"#E9C790\", \"#E4B585\", \"#E3B080\", \"#D89670\",\n            \"#D9956D\", \"#CF8A69\")\n) %>%\n  arrange(value)\n\nvalue_to_color <- function(val) {\n  if (val %in% color_points$value) {\n    return(color_points$color[color_points$value == val])\n  } else {\n    lower_idx <- max(which(color_points$value < val))\n    upper_idx <- min(which(color_points$value > val))\n    \n    lower_val <- color_points$value[lower_idx]\n    upper_val <- color_points$value[upper_idx]\n    lower_col <- color_points$color[lower_idx]\n    upper_col <- color_points$color[upper_idx]\n    \n    weight <- (val - lower_val) / (upper_val - lower_val)\n    return(colorRamp(c(lower_col, upper_col))(weight) %>%\n             rgb(maxColorValue = 255))\n  }\n}\n\n# Get African countries from giscoR\ncountries <- gisco_get_countries(\n  year = \"2020\",\n  epsg = \"4326\",\n  resolution = \"20\"\n)\n\n# Filter to region\nbbox <- st_bbox(c(xmin = -27, xmax = 64, ymin = -31, ymax = 41),\n                crs = st_crs(4326))\nbbox_poly <- st_as_sfc(bbox)\ncountries_in_view <- countries[st_intersects(countries, bbox_poly, sparse = FALSE), ]\n\n# Define country colors\n# Orange: conflict-affected countries\n# White: other Sub-Saharan countries\n# Beige: Other countries on the map\ncountry_colors <- tribble(\n  ~COUNTRY, ~color,\n  # Conflict-affected (orange-y)\n  \"Mali\", \"#ED8758\",\n  \"Burkina Faso\", \"#EC8657\",\n  \"Niger\", \"#F29464\",\n  \"Chad\", \"#F7B88D\",\n  \"Sudan\", \"#F18B5C\",\n  \"Abyei\", \"#F08A5B\",\n  \"South Sudan\", \"#F08A5B\",\n  \"Ethiopia\", \"#DD6F4B\",\n  \"Somalia\", \"#ED8556\",\n  \"Uganda\", \"#F6D1A5\",\n  \"Democratic Republic of The Congo\", \"#E67D52\",\n  \"Mozambique\", \"#F19F70\",\n  \"Nigeria\", \"#D46443\",\n  \"Cameroon\", \"#F3A172\",\n  \"Central African Republic\", \"#F28C5D\",\n  # Other Sub-Saharan (white)\n  \"Mauritania\", \"#FFFFFF\",\n  \"Senegal\", \"#FFFFFF\",\n  \"Gambia\", \"#FFFFFF\",\n  \"Guinea-Bissau\", \"#FFFFFF\",\n  \"Cape Verde\", \"#FFFFFF\",\n  \"Guinea\", \"#FFFFFF\",\n  \"Sierra Leone\", \"#FFFFFF\",\n  \"Côte D’Ivoire\", \"#FFFFFF\",\n  \"Ghana\", \"#FFFFFF\",\n  \"Togo\", \"#FFFFFF\",\n  \"Benin\", \"#FFFFFF\",\n  \"Gabon\", \"#FFFFFF\",\n  \"Congo\", \"#FFFFFF\",\n  \"Angola\", \"#FFFFFF\",\n  \"Zambia\", \"#FFFFFF\",\n  \"Namibia\", \"#FFFFFF\",\n  \"Botswana\", \"#FFFFFF\",\n  \"Zimbabwe\", \"#FFFFFF\",\n  \"South Africa\", \"#FFFFFF\",\n  \"Madagascar\", \"#FFFFFF\",\n  \"Malawi\", \"#FFFFFF\",\n  \"United Republic of Tanzania\", \"#FFFFFF\",\n  \"Burundi\", \"#FFFFFF\",\n  \"Rwanda\", \"#FFFFFF\",\n  \"Kenya\", \"#FFFFFF\",\n  \"Eritrea\", \"#FFFFFF\",\n  \"Djibouti\", \"#FFFFFF\",\n  \"Liberia\", \"#FFFFFF\",\n  \"Equatorial Guinea\", \"#FFFFFF\",\n  \"Eswatini\", \"#FFFFFF\",\n  \"Lesotho\", \"#FFFFFF\",\n)\n\n# Merge colors with map data\ncountries_in_view_colored <- countries_in_view %>%\n  left_join(country_colors, by = c(\"NAME_ENGL\" = \"COUNTRY\")) %>%\n  mutate(fill_color = ifelse(is.na(color), \"#F0EDE3\", color))\n\n# Create coastline\nall_countries_union <- st_union(countries_in_view)\ncoastline <- st_cast(st_boundary(all_countries_union), \"LINESTRING\")\n\n# COUNTRY LABELS\n# Auto-labeled countries (using centroids)\nauto_countries <- c(\n  \"Niger\", \n  \"Chad\", \n  \"Senegal\",  \n  \"Liberia\", \n  \"Togo\", \n  \"Gabon\", \n  \"Angola\", \n  \"Namibia\",\n  \"South Africa\", \n  \"Botswana\", \n  \"Zimbabwe\",  \n  \"Malawi\",\n  \"Madagascar\", \n  \"Burundi\", \n  \"Rwanda\", \n  \"Kenya\",\n  \"Djibouti\"\n)\n\ncountries_auto <- countries_in_view |>\n  filter(NAME_ENGL %in% auto_countries)\n\n# Precisely positioned countries (many did not behave well. Here the text at \n# the base of the plot about the sources of the data was plotted as well)\ncustom_positions <- tribble(\n  ~name, ~lon, ~lat,\n    \"SOUTH\\nSUDAN\", 30, 8.0,\n  \"CENTRAL AFRICAN\\nREPUBLIC\", 20.0, 6.5,\n  \"SOMALIA\", 45.5, 4.2,\n  \"ETHIOPIA\", 40.5, 9.0,\n  \"BURKINA\\nFASO\", -0.5, 12.5,\n  \"MOZAMBIQUE\", 35.0, -18.0,\n  \"UGANDA\", 33, 2.5,\n  \"SUDAN\", 30.0, 15.0,\n  \"CABO\\nVERDE\", -23.5, 18.5,\n  \"MALI\", -7, 14,\n  \"ERITREA\", 38, 17,\n  \"TANZANIA\", 35, -6,\n  \"CÔTE\\nD'IVOIRE\", -5.2, 8,\n  \"DEMOCRATIC\\nREPUBLIC\\nOF THE CONGO\", 23.5, -5,\n  \"GUINEA-\\nBISSAU\", -18, 11,\n  \"REPUBLIC\\nOF CONGO\", 16, 1,\n  \"EQUATORIAL\\nGUINEA\", 5.5, 2,\n  \"CAMEROON\", 12, 5,\n  \"BENIN\", 2.5, 10.5,\n  \"GHANA\", -1.5, 6.5,\n  \"SIERRA\\nLEONE\", -11.5, 9,\n  \"GUINEA\", -11, 11,\n  \"THE GAMBIA\", -18, 13,\n  \"MAURITANIA\", -13, 19.5,\n  \"NIGERIA\", 6.5, 9.5,\n  \"ZAMBIA\", 25, -15,\n  \"Sources: Armed Conflict Location & Event Data Project (ACLED), \n  www.acleddata.com; IISS analysis\", -6, -29\n) |>\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\n# FINAL MAP\n# Incorporates countries with colours, the coastline, the labels and the ocean \n# colour\nbase_map <- ggplot() +\n  geom_sf(data = countries_in_view_colored,\n          aes(fill = fill_color),\n          color = \"#B8C0BE\",\n          linewidth = 0.2) +\n  scale_fill_identity() +\n  geom_sf(data = coastline, color = \"#387298\", linewidth = 0.2) +\n  geom_sf_text(data = countries_auto,\n               aes(label = toupper(NAME_ENGL)),\n               fontface = \"plain\", \n               size = 2.3, \n               lineheight = 0.9) +\n  geom_sf_text(data = custom_positions,\n               aes(label = name),\n               fontface = \"plain\",\n               size = 2.3,\n               lineheight = 0.9) +\n  coord_sf(xlim = c(-27, 64), ylim = c(-31, 41), expand = FALSE) +\n  theme_void() +\n  theme(panel.background = element_rect(fill = \"#DCE8F2\"),\n        plot.background = element_rect(fill = \"white\"))\n\n\nUPDATED DATA CREATION FOR COUNTRY GRAPHS\nFunction to create country data\nI found myself repeating the same lines of code many, many times, so\nI used Claude to help me build a function to avoid the repetition\n\n\ncreate_country_data <- function(country_name, filtered_data, value_to_color) {\n  filtered_data |> \n    filter(COUNTRY == country_name) |> \n    pivot_longer(\n      cols = c(human_impact, incidence, geopolitical_impact),\n      names_to = \"category\",\n      values_to = \"value\"\n    ) |> \n    mutate(original_segment = row_number()) |> \n    arrange(desc(row_number())) |> \n    mutate(\n      color = map_chr(value, value_to_color),\n      segment = row_number(),\n      original_start = pi - ((original_segment - 1) / 3 * pi),\n      original_end = pi - (original_segment / 3 * pi),\n      start_angle = (pi - ((segment - 1) / 3 * pi)) - pi/2,\n      end_angle = (pi - (segment / 3 * pi)) - pi/2,\n      mid_angle = (original_start + original_end) / 2,\n      label_x = cos(mid_angle) * 1.08,\n      label_y = sin(mid_angle) * 1.08\n    )\n}\n\n# Create all country data frames using the function\ncameroon_data <- create_country_data(\"Cameroon\", filtered_data, value_to_color)\ncentral_african_republic_data <- create_country_data(\"Central African Republic\", \n                                                     filtered_data, value_to_color)\nchad_data <- create_country_data(\"Chad\", filtered_data, value_to_color)\ndemocratic_republic_of_congo_data <- create_country_data(\"Democratic Republic of Congo\", filtered_data, value_to_color)\nethiopia_data <- create_country_data(\"Ethiopia\", filtered_data, value_to_color)\nmali_data <- create_country_data(\"Mali\", filtered_data, value_to_color)\nmozambique_data <- create_country_data(\"Mozambique\", filtered_data, value_to_color)\nniger_data <- create_country_data(\"Niger\", filtered_data, value_to_color)\nnigeria_data <- create_country_data(\"Nigeria\", filtered_data, value_to_color)\nsomalia_data <- create_country_data(\"Somalia\", filtered_data, value_to_color)\nsouth_sudan_data <- create_country_data(\"South Sudan\", filtered_data, value_to_color)\nsudan_data <- create_country_data(\"Sudan\", filtered_data, value_to_color)\nuganda_data <- create_country_data(\"Uganda\", filtered_data, value_to_color)\nburkina_faso_data <- create_country_data(\"Burkina Faso\", filtered_data, value_to_color)\n\n\nCOUNTRY ARC PLOTS\nFunction to create arc plots\nThese proved unexpectedly challenging. There was a package that\nworked when I began the project to plot parliament graphs, however\nthis stopped working midway through writing the project. I resorted\nto stack exchange and Claude to help me build the graphs.\n\n\ncreate_arc_plot <- function(data, country_name, is_tall = FALSE) {\n  ymin_val <- if(is_tall) -0.8 else -0.6\n  ylim_val <- if(is_tall) c(-0.8, 1.0) else c(-0.6, 1.0)\n  text_y <- if(is_tall) -0.55 else -0.42\n  \n  # Create base plot\n  p <- ggplot(data) +\n    annotate(\"rect\", xmin = -1.2, xmax = 1.2, ymin = ymin_val, ymax = 1,\n             fill = alpha(\"white\", 0.5), color = \"black\", linewidth = 0.2) +\n    geom_arc_bar(aes(x0 = 0, y0 = -0.3, r0 = 0.6, r = 0.9,\n                     start = start_angle, end = end_angle, fill = color),\n                 color = \"white\", linewidth = 0.2) +\n    scale_fill_identity()\n  \n  # Add text layers conditionally based on the height of the plot (the \n  # placement of the text differs for 2 of the plots as the names of the \n  # countries are longer, so they needed to be taller.)\n  \n  if (is_tall) {\n    p <- p +\n      geom_text(aes(x = label_x * 1.05, y = (label_y - 0.3) * 1.05, \n                    label = value),\n                fontface = \"plain\", size = 2.75, lineheight = 0.9) +\n      annotate(\"text\", x = 0, y = text_y, label = country_name, \n               fontface = \"bold\", size = 2.75, lineheight = 0.9)\n  } else {\n    p <- p +\n      geom_text(aes(x = label_x * 1.05, y = (label_y - 0.3) * 1.05, \n                    label = value),\n                fontface = \"plain\", size = 2.75, lineheight = 0.9) +\n      annotate(\"text\", x = 0, y = text_y, label = country_name, \n               fontface = \"bold\", size = 2.75, lineheight = 0.9)\n  }\n  \n  p <- p +\n    coord_fixed(xlim = c(-1.3, 1.3), ylim = ylim_val) +\n    theme_void() +\n    theme(plot.background = element_rect(fill = NA, color = NA),\n          plot.margin = margin(0, 0, 0, 0),\n          text = element_text(size = rel(1)))\n  \n  return(p)\n}\n\n# Create all arc plots\ncameroon_plot <- create_arc_plot(cameroon_data, \"Cameroon\")\ncentral_african_republic_plot <- create_arc_plot(central_african_republic_data, \n                                  \"Central African\\nRepublic\", is_tall = TRUE)\nchad_plot <- create_arc_plot(chad_data, \"Chad\")\ndemocratic_republic_of_congo_plot <- \n  create_arc_plot(democratic_republic_of_congo_data, \n                  \"Democratic Rep.\\nof the Congo\", is_tall = TRUE)\nethiopia_plot <- create_arc_plot(ethiopia_data, \"Ethiopia\")\nmali_plot <- create_arc_plot(mali_data, \"Mali\")\nmozambique_plot <- create_arc_plot(mozambique_data, \"Mozambique\")\nniger_plot <- create_arc_plot(niger_data, \"Niger\")\nnigeria_plot <- create_arc_plot(nigeria_data, \"Nigeria\")\nsomalia_plot <- create_arc_plot(somalia_data, \"Somalia\")\nsouth_sudan_plot <- create_arc_plot(south_sudan_data, \"South Sudan\")\nsudan_plot <- create_arc_plot(sudan_data, \"Sudan\")\nuganda_plot <- create_arc_plot(uganda_data, \"Uganda\")\nburkina_faso_plot <- create_arc_plot(burkina_faso_data, \"Burkina Faso\")\n\n\nBASE MAP + LINES FROM ARC PLOTS\nHelper function to convert pixels to lon/lat coordinates\nThis let me measure the positions of the lines as a number of pixels\n(in preview on mac this appears when you drag a selection box on an\nimage) and have that series of “pixel co-ordinates” converted to\nlatitude and longitude to plot on the map.\n\n\npixel_to_lonlat <- function(x_pixels, y_pixels, \n                            map_width = 2232, map_height = 1783,\n                            lon_min = -27, lon_max = 64,\n                            lat_min = -31, lat_max = 41) {\n  x_prop <- x_pixels / map_width\n  y_prop <- y_pixels / map_height\n  lon <- lon_min + x_prop * (lon_max - lon_min)\n  lat <- lat_max - y_prop * (lat_max - lat_min)\n  return(list(lon = lon, lat = lat))\n}\n\n# ALL CONNECTION LINES (these are the pixel measurements discussed above. \n# You read them as pairs; distance from the keft edge of the map is the x and \n# from the top is the y. Taken together they define points for the lines \n# to be plotted to.)\nconnections <- list(\n  #arc graphs\n  mali = list(\n    x = c(298, 298, 445, 445),\n    y = c(212, 250, 250, 670)\n  ),\n  burkina_faso = list(\n    x = c(586, 586),\n    y = c(209, 714)\n  ),\n  niger = list(\n    x = c(869, 869),\n    y = c(209, 531)\n  ),\n  chad = list(\n    x = c(1131, 1131),\n    y = c(209, 600)\n  ),\n  sudan = list(\n    x = c(1379, 1379),\n    y = c(209, 576)\n  ),\n  south_sudan = list(\n    x = c(1630, 1630, 1459, 1459),\n    y = c(330, 519, 519, 886)\n  ),\n  ethiopia = list(\n    x = c(1967, 1612, 1612),\n    y = c(627, 627, 768)\n  ),\n  somalia = list(\n    x = c(1967, 1871, 1871, 1800),\n    y = c(810, 810, 887, 887)\n  ),\n  uganda = list(\n    x = c(1967, 1450),\n    y = c(992, 992)\n  ),\n  drc = list(\n    x = c(1967, 1351),\n    y = c(1185, 1185)\n  ),\n  mozambique = list(\n    x = c(1967, 1477),\n    y = c(1593, 1593)\n  ),\n  central_african_republic = list(\n    x = c(1090, 1126, 1126, 1090),\n    y = c(1197, 1197, 885, 885)\n  ),\n  cameroon = list(\n    x = c(557, 874, 874, 955, 955),\n    y = c(1051, 1051, 940, 940, 921)\n  ),\n  nigeria = list(\n    x = c(308, 840, 840),\n    y = c(924, 924, 807)\n  ),\n  #country/flag boxes\n  the_sahel_left = list(\n    x = c(613, 613),\n    y = c(553, 600)\n  ),\n  the_sahel_middle = list(\n    x = c(644, 644),\n    y = c(553, 661)\n  ),\n  the_sahel_right = list(\n    x = c(804, 804),\n    y = c(553, 605)\n  ),\n  lake_chad_basin_top_left = list(\n    x = c(975, 975, 882),\n    y = c(664, 609, 609)\n  ),\n  lake_chad_basin_bottom_left = list(\n    x = c(902, 902, 862),\n    y = c(790, 822, 822)\n  ),\n  lake_chad_basin_bottom = list(\n    x = c(971, 971),\n    y = c(790, 841)\n  ),\n  lake_chad_basin_right = list(\n    x = c(1129, 1157, 1157),\n    y = c(721, 721, 662)\n  ),\n  great_lakes_region_bottom = list(\n    x = c(1252, 1252),\n    y = c(1061, 1084)\n  ),\n  great_lakes_region_right = list(\n    x = c(1340, 1447),\n    y = c(1023, 1023)\n  ),\n  rawanda_eu_sadcmm = list(\n    x = c(1697, 1697, 1550),\n    y = c(1370, 1437, 1437)\n  ),\n  turkey_uk_us_au_eu = list(\n    x = c(1773, 1773),\n    y = c(1022, 942)\n  ),\n  eritrea = list(\n    x = c(1657, 1681),\n    y = c(862, 862)\n  ),\n  un_top = list(\n    x = c(1332, 1332),\n    y = c(687, 653)\n  ),\n  un_bottom = list(\n    x = c(1333, 1333),\n    y = c(750, 850)\n  ),\n  russia_rwanda_un = list(\n    x = c(1252, 1252, 1191),\n    y = c(445, 785, 785)\n  )\n)\n\n# white endpoints\n# The lines used for the arc graphs and countries involved in the various \n# conflicts are differentiated by the colour of the end points they use.\nwhite_endpoints <- c(\"the_sahel_left\", \n                     \"the_sahel_middle\", \n                     \"the_sahel_right\", \n                     \"lake_chad_basin_top_left\", \n                     \"lake_chad_basin_bottom_left\", \n                     \"lake_chad_basin_bottom\",\n                     \"lake_chad_basin_right\",\n                     \"great_lakes_region_bottom\",\n                     \"great_lakes_region_right\",\n                     \"rawanda_eu_sadcmm_bottom\",\n                     \"rawanda_eu_sadcmm\",\n                     \"turkey_uk_us_au_eu\",\n                     \"eritrea\",\n                     \"un_top\",\n                     \"un_bottom\",\n                     \"russia_rwanda_un\")\n\n# Lines\nlines_df <- map_dfr(names(connections), function(country) {\n  coords <- pixel_to_lonlat(\n    x_pixels = connections[[country]]$x,\n    y_pixels = connections[[country]]$y\n  )\n  data.frame(\n    x = coords$lon,\n    y = coords$lat,\n    country = country\n  )\n})\n\n# Endpoints\n# This section makes a dataframe using the final coordinates of the lines as \n# the position of the endpoint.\nendpoints_df <- map_dfr(names(connections), function(country) {\n  n <- length(connections[[country]]$x)\n  coords <- pixel_to_lonlat(\n    x_pixels = connections[[country]]$x[n],\n    y_pixels = connections[[country]]$y[n]\n  )\n  data.frame(\n    x = coords$lon, \n    y = coords$lat, \n    country = country,\n    is_white = country %in% white_endpoints\n  )\n})\n\n# Split into black and white endpoints\nblack_endpoints <- endpoints_df |> filter(!is_white)\nwhite_endpoints_df <- endpoints_df |> filter(is_white)\n\n# Add lines and endpoints to map\nbase_map <- base_map +\n  geom_path(data = lines_df,\n            aes(x = x, y = y, group = country),\n            color = \"black\",\n            linewidth = 0.3) +\n  # Black endpoints (fill and color both black)\n  geom_point(data = black_endpoints,\n             aes(x = x, y = y),\n             color = \"black\",\n             fill = \"black\",\n             shape = 21,\n             size = 1.5,\n             stroke = 0.3) +\n  # White endpoints\n  geom_point(data = white_endpoints_df,\n             aes(x = x, y = y),\n             color = \"black\",\n             fill = \"white\",\n             shape = 21,\n             size = 1.5,\n             stroke = 0.3)\n\n\nBASE MAP + ARC GRAPHS\n\n\n# Standard arc box dimensions\n# These dimensions applied for the majority of the arc graphs\narc_w <- 215 / 2232\narc_h <- 156 / 1783\n\n# CAR and DRC dimensions\n# I realised quite late that these graphs were subtly different in height due \n# to the length of the country name needing to fit in the box\ncar_drc_h <- 183 / 1783\n\n# Map dimensions\nmap_width <- 2232\nmap_height <- 1783\n\n# Helper function for positioning\n# I reused the same method as for the lines, this time measuring to the left \n# edge of the plots and the bottom edge.\npixel_to_prop <- function(left_px, top_px, height_px = 156) {\n  list(\n    left = left_px / map_width,\n    bottom = 1 - (top_px + height_px) / map_height\n  )\n}\n\n# Helper function to add inset to map\nadd_inset <- function(map, plot, left, bottom, width, height) {\n  map + inset_element(\n    plot,\n    left = left,\n    right = left + width,\n    bottom = bottom,\n    top = bottom + height\n  )\n}\n\n# Define all arc plot configurations\narc_configs <- list(\n  list(plot = mali_plot, pos = pixel_to_prop(190, 77), w = arc_w, h = arc_h),\n  list(plot = burkina_faso_plot, pos = pixel_to_prop(487, 77), \n       w = arc_w, h = arc_h),\n  list(plot = niger_plot, pos = pixel_to_prop(754, 77), w = arc_w, h = arc_h),\n  list(plot = chad_plot, pos = pixel_to_prop(1020, 77), w = arc_w, h = arc_h),\n  list(plot = sudan_plot, pos = pixel_to_prop(1272, 77), w = arc_w, h = arc_h),\n  list(plot = south_sudan_plot, pos = pixel_to_prop(1528, 196), \n       w = arc_w, h = arc_h),\n  list(plot = ethiopia_plot, pos = pixel_to_prop(1947, 547), w = arc_w, h = arc_h),\n  list(plot = somalia_plot, pos = pixel_to_prop(1947, 733), w = arc_w, h = arc_h),\n  list(plot = uganda_plot, pos = pixel_to_prop(1947, 914), w = arc_w, h = arc_h),\n  list(plot = democratic_republic_of_congo_plot, \n       pos = pixel_to_prop(1947, 1108, height_px = 183), \n       w = arc_w, h = car_drc_h),\n  list(plot = mozambique_plot, pos = pixel_to_prop(1947, 1517), \n       w = arc_w, h = arc_h),\n  list(plot = nigeria_plot, pos = pixel_to_prop(114, 836), \n       w = arc_w, h = arc_h),\n  list(plot = cameroon_plot, pos = pixel_to_prop(364, 943), \n       w = arc_w, h = arc_h),\n  list(plot = central_african_republic_plot, \n       pos = pixel_to_prop(897, 1104, height_px = 183), \n       w = arc_w, h = car_drc_h)\n)\n\n# Add all arc plots to map\nfor (config in arc_configs) {\n  base_map <- add_inset(base_map, config$plot, config$pos$left, \n                        config$pos$bottom, config$w, config$h)\n}\n\n\nBOXES\nSAHEL BOX\nI used a different approach here as there were a lot of elements to\nposition. I measured the flags and overall box size in pixels and\nthen positioned them relative to the left and bottom edges of the\nboxes. This was fiddly, so I ended up measuring the margins, flag\nwidth, gap between the flags and plotting these for each box (you\ncan see this in the code for the other boxes below)\n\n\ncreate_sahel_box <- function() {\n  france_flag <- readPNG(\"flags_and_logos/france.png\")\n  italy_flag <- readPNG(\"flags_and_logos/italy.png\")\n  usa_flag <- readPNG(\"flags_and_logos/us.png\")\n  eu_logo <- readPNG(\"flags_and_logos/eu.png\")\n  un_logo <- readPNG(\"flags_and_logos/un.png\")\n  au_logo <- readPNG(\"flags_and_logos/au.png\")\n  g5_logo <- readPNG(\"flags_and_logos/sahel_g5.png\")\n  \n  flag_width <- 65 / 245\n  flag_height <- 43 / 205\n  logo_width <- 65 / 245\n  logo_height <- 43 / 205\n  logo_circle_width <- 43 / 245\n  logo_circle_height <- 43 / 205\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotate(\"text\", x = 0.5, y = 0.92, label = \"The Sahel\",\n             hjust = 0.5, fontface = \"bold\", size = 2.75, lineheight = 0.9) +\n    annotation_raster(france_flag, \n                      xmin = 0.08, xmax = 0.08 + flag_width, \n                      ymin = 0.62, ymax = 0.62 + flag_height) +\n    annotation_raster(italy_flag, \n                      xmin = 0.5 - (flag_width / 2), xmax = 0.5 + \n                        (flag_width / 2), \n                      ymin = 0.62, ymax = 0.62 + flag_height) +\n    annotation_raster(usa_flag, \n                      xmin = 0.92 - flag_width, xmax = 0.92, \n                      ymin = 0.62, ymax = 0.62 + flag_height) +\n    annotation_raster(eu_logo, \n                      xmin = 0.08, xmax = 0.08 + logo_width, \n                      ymin = 0.30, ymax = 0.30 + logo_height) +\n    annotation_raster(un_logo, \n                      xmin = 0.5 - (logo_width / 2), xmax = 0.5 + \n                        (logo_width / 2), \n                      ymin = 0.30, ymax = 0.30 + logo_height) +\n    annotation_raster(au_logo, \n                      xmin = 0.92 - logo_width, xmax = 0.92, \n                      ymin = 0.30, ymax = 0.30 + logo_height) +\n    annotation_raster(g5_logo, \n                      xmin = 0.5 - (logo_circle_width / 2), \n                      xmax = 0.5 + (logo_circle_width / 2), \n                      ymin = 0.02, \n                      ymax = 0.02 + logo_circle_height) +\n    coord_fixed(ratio = 205/245, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nLAKE CHAD BOX\n\n\ncreate_lake_chad_box <- function() {\n  france_flag <- readPNG(\"flags_and_logos/france.png\")\n  uk_flag <- readPNG(\"flags_and_logos/uk.png\")\n  usa_flag <- readPNG(\"flags_and_logos/us.png\")\n  multi_jtf_logo <- readPNG(\"flags_and_logos/multi.png\")\n  \n  left_margin <- 50 / 235\n  flag_width <- 65 / 235\n  gap <- 5 / 235\n  flag_height <- 43 / 145\n  logo_width <- 65 / 235\n  logo_height <- 43 / 145\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotate(\"text\", x = 0.5, y = 0.88, label = \"Lake Chad Basin\",\n             hjust = 0.5, fontface = \"bold\", size = 2.75, lineheight = 0.9) +\n    annotation_raster(france_flag, \n                      xmin = left_margin, \n                      xmax = left_margin + flag_width, \n                      ymin = 0.4, \n                      ymax = 0.4 + flag_height) +\n    annotation_raster(uk_flag, \n                      xmin = left_margin + flag_width + gap, \n                      xmax = left_margin + flag_width + gap + flag_width, \n                      ymin = 0.4, \n                      ymax = 0.4 + flag_height) +\n    annotation_raster(usa_flag, \n                      xmin = left_margin, \n                      xmax = left_margin + flag_width, \n                      ymin = 0.06, \n                      ymax = 0.06 + flag_height) +\n    annotation_raster(multi_jtf_logo, \n                      xmin = left_margin + flag_width + gap, \n                      xmax = left_margin + flag_width + gap + logo_width, \n                      ymin = 0.06, \n                      ymax = 0.06 + logo_height) +\n    coord_fixed(ratio = 145/235, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nGREAT LAKES BOX\n\n\ncreate_great_lakes_box <- function() {\n  un_logo <- readPNG(\"flags_and_logos/un.png\")\n  au_logo <- readPNG(\"flags_and_logos/au.png\")\n  rwanda_flag <- readPNG(\"flags_and_logos/rwanda.png\")\n  burundi_flag <- readPNG(\"flags_and_logos/burundi.png\")\n  \n  box_width <- 177\n  box_height <- 177\n  left_margin <- 13 / box_width\n  flag_width <- 65 / box_width\n  gap <- 25 / box_width\n  flag_height <- 43 / box_height\n  logo_width <- 65 / box_width\n  logo_height <- 43 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotate(\"text\", x = 0.5, y = 0.88, label = \"Great\\nLakes Region\",\n             hjust = 0.5, fontface = \"bold\", size = 2.75, lineheight = 0.9) +\n    annotation_raster(au_logo, \n                      xmin = left_margin, \n                      xmax = left_margin + flag_width, \n                      ymin = 0.4, \n                      ymax = 0.4 + flag_height) +\n    annotation_raster(un_logo, \n                      xmin = left_margin + flag_width + gap, \n                      xmax = left_margin + flag_width + gap + flag_width, \n                      ymin = 0.4, \n                      ymax = 0.4 + flag_height) +\n    annotation_raster(rwanda_flag, \n                      xmin = left_margin, \n                      xmax = left_margin + flag_width, \n                      ymin = 0.06, \n                      ymax = 0.06 + flag_height) +\n    annotation_raster(burundi_flag, \n                      xmin = left_margin + flag_width + gap, \n                      xmax = left_margin + flag_width + gap + logo_width, \n                      ymin = 0.06, \n                      ymax = 0.06 + logo_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nRWANDA EU SADCMM BOX\n\n\ncreate_two_row_box <- function() {\n  rwanda_flag <- readPNG(\"flags_and_logos/rwanda.png\")\n  eu_logo <- readPNG(\"flags_and_logos/eu.png\")\n  sadcmm_flag <- readPNG(\"flags_and_logos/sadcmm.png\")\n  \n  box_width <- 195\n  box_height <- 135\n  top_margin <- 65 / box_width\n  top_flag_width <- 65 / box_width\n  bottom_left_margin <- 22 / box_width\n  bottom_flag_width <- 65 / box_width\n  bottom_gap <- 21 / box_width\n  flag_height <- 43 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotation_raster(rwanda_flag, \n                      xmin = top_margin, \n                      xmax = top_margin + top_flag_width, \n                      ymin = 0.55, \n                      ymax = 0.55 + flag_height) +\n    annotation_raster(eu_logo, \n                      xmin = bottom_left_margin, \n                      xmax = bottom_left_margin + bottom_flag_width, \n                      ymin = 0.15, \n                      ymax = 0.15 + flag_height) +\n    annotation_raster(sadcmm_flag, \n                      xmin = bottom_left_margin + bottom_flag_width + \n                        bottom_gap, \n                      xmax = bottom_left_margin + bottom_flag_width + \n                        bottom_gap + bottom_flag_width, \n                      ymin = 0.15, \n                      ymax = 0.15 + flag_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nTURK UK US AU EU BOX\n\n\ncreate_three_two_box <- function() {\n  top_flag1 <- readPNG(\"flags_and_logos/turkey.png\")\n  top_flag2 <- readPNG(\"flags_and_logos/uk.png\")\n  top_flag3 <- readPNG(\"flags_and_logos/us.png\")\n  bottom_flag1 <- readPNG(\"flags_and_logos/au.png\")\n  bottom_flag2 <- readPNG(\"flags_and_logos/eu.png\")\n  \n  box_width <- 245\n  box_height <- 138\n  top_space <- 12.5 / box_width\n  top_flag_width <- 65 / box_width\n  bottom_flag_width <- 65 / box_width\n  bottom_gap <- 10 / box_width\n  bottom_margin <- 52.5 / box_width\n  flag_height <- 43 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotation_raster(top_flag1, \n                      xmin = top_space, \n                      xmax = top_space + top_flag_width, \n                      ymin = 0.55, \n                      ymax = 0.55 + flag_height) +\n    annotation_raster(top_flag2, \n                      xmin = top_space * 2 + top_flag_width, \n                      xmax = top_space * 2 + top_flag_width * 2, \n                      ymin = 0.55, \n                      ymax = 0.55 + flag_height) +\n    annotation_raster(top_flag3, \n                      xmin = top_space * 3 + top_flag_width * 2, \n                      xmax = top_space * 3 + top_flag_width * 3, \n                      ymin = 0.55, \n                      ymax = 0.55 + flag_height) +\n    annotation_raster(bottom_flag1, \n                      xmin = bottom_margin, \n                      xmax = bottom_margin + bottom_flag_width, \n                      ymin = 0.15, \n                      ymax = 0.15 + flag_height) +\n    annotation_raster(bottom_flag2, \n                      xmin = bottom_margin + bottom_flag_width + bottom_gap, \n                      xmax = bottom_margin + bottom_flag_width + bottom_gap + \n                        bottom_flag_width, \n                      ymin = 0.15, \n                      ymax = 0.15 + flag_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nERITREA BOX\n\n\ncreate_single_flag_box <- function() {\n  eritrea_flag <- readPNG(\"flags_and_logos/eritrea.png\")\n  \n  box_width <- 95\n  box_height <- 65\n  flag_margin <- 15 / box_width\n  flag_width <- 65 / box_width\n  flag_height <- 43 / box_height\n  flag_y_margin <- 11 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotation_raster(eritrea_flag, \n                      xmin = flag_margin, \n                      xmax = flag_margin + flag_width, \n                      ymin = flag_y_margin, \n                      ymax = flag_y_margin + flag_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nUN BOX\n\n\ncreate_single_flag_box_2 <- function() {\n  un_logo <- readPNG(\"flags_and_logos/un.png\")\n  \n  box_width <- 95\n  box_height <- 65\n  flag_margin <- 15 / box_width\n  flag_width <- 65 / box_width\n  flag_height <- 43 / box_height\n  flag_y_margin <- 11 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotation_raster(un_logo, \n                      xmin = flag_margin, \n                      xmax = flag_margin + flag_width, \n                      ymin = flag_y_margin, \n                      ymax = flag_y_margin + flag_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nRUSSIA RWANDA UN BOX\n\n\ncreate_three_flag_row_box <- function() {\n  russia_flag <- readPNG(\"flags_and_logos/russia.png\")\n  rwanda_flag <- readPNG(\"flags_and_logos/rwanda.png\")\n  un_logo <- readPNG(\"flags_and_logos/un.png\")\n  \n  box_width <- 205\n  box_height <- 84\n  space <- 2.5 / box_width\n  flag_width <- 65 / box_width\n  flag_height <- 43 / box_height\n  flag_y_margin <- (box_height - 43) / 2 / box_height\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n             fill = \"white\", color = NA) +\n    annotation_raster(russia_flag, \n                      xmin = space, \n                      xmax = space + flag_width, \n                      ymin = flag_y_margin, \n                      ymax = flag_y_margin + flag_height) +\n    annotation_raster(rwanda_flag, \n                      xmin = space * 2 + flag_width, \n                      xmax = space * 2 + flag_width * 2, \n                      ymin = flag_y_margin, \n                      ymax = flag_y_margin + flag_height) +\n    annotation_raster(un_logo, \n                      xmin = space * 3 + flag_width * 2, \n                      xmax = space * 3 + flag_width * 3, \n                      ymin = flag_y_margin, \n                      ymax = flag_y_margin + flag_height) +\n    coord_fixed(ratio = box_height/box_width, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = \"white\", color = \"black\", \n                                     linewidth = 0.5, radius = unit(0, \"pt\")),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nCREATE ALL BOX PLOTS\n\n\nsahel_box <- create_sahel_box()\nlake_chad_box <- create_lake_chad_box()\ngreat_lakes_box <- create_great_lakes_box()\ntwo_row_box <- create_two_row_box()\nthree_two_box <- create_three_two_box()\nsingle_flag_box <- create_single_flag_box()\nsingle_flag_box_2 <- create_single_flag_box_2()\nthree_flag_row_box <- create_three_flag_row_box()\n\n### DEFINE ALL BOX CONFIGURATIONS ###\n# Here I position the boxes relative to the overall map\nbox_configs <- list(\n  list(plot = sahel_box, left = 0.27, bottom = 0.68, w = 245/2232, \n       h = 205/1783),\n  list(plot = lake_chad_box, left = 0.4, bottom = 0.55, w = 235/2232, \n       h = 145/1783),\n  list(plot = great_lakes_box, left = 0.52, bottom = 0.4, w = 177/2232, \n       h = 177/1783),\n  list(plot = two_row_box, left = 0.71, bottom = 0.22, w = 195/2232, \n       h = 135/1783),\n  list(plot = three_two_box, left = 0.76, bottom = 0.35, w = 245/2232, \n       h = 138/1783),\n  list(plot = single_flag_box, left = 0.70, bottom = 0.50, w = 95/2232, \n       h = 65/1783),\n  list(plot = single_flag_box_2, left = 0.58, bottom = 0.577, w = 95/2232, \n       h = 65/1783),\n  list(plot = three_flag_row_box, left = 0.515, bottom = 0.75, w = 205/2232, \n       h = 84/1783)\n)\n\n\nADD ALL BOXES TO MAP\n\n\nfor (config in box_configs) {\n  base_map <- add_inset(base_map, config$plot, config$left, config$bottom, \n                        config$w, config$h)\n}\n\n\nKEY\nThis creates the grey legend arc plot data using the same method as\nthe other arc plots. #### GREY ARC\n\n\ngrey_legend_data <- tibble(\n  segment = 1:3,\n  label = c(\"A\", \"B\", \"C\"),\n  value = c(\"A\", \"B\", \"C\"),\n  color = \"#D7D7D5\",\n  original_segment = 1:3\n) |>\n  arrange(desc(row_number())) |>\n  mutate(\n    segment = row_number(),\n    original_start = pi - ((original_segment - 1) / 3 * pi),\n    original_end = pi - (original_segment / 3 * pi),\n    start_angle = (pi - ((segment - 1) / 3 * pi)) - pi/2,\n    end_angle = (pi - (segment / 3 * pi)) - pi/2,\n    mid_angle = (original_start + original_end) / 2,\n    label_x = cos(mid_angle) * 0.77,\n    label_y = sin(mid_angle) * 0.77\n  )\n\n# Plotting the grey legend arc plot\ngrey_legend_arc <- ggplot(grey_legend_data) +\n  annotate(\"rect\", xmin = -1.2, xmax = 1.2, ymin = -0.6, ymax = 1,\n           fill = \"white\", color = NA) +\n  geom_arc_bar(aes(x0 = 0, y0 = -0.3, r0 = 0.6, r = 0.9,\n                   start = start_angle, end = end_angle, fill = color),\n               color = \"white\", linewidth = 0.2) +\n  scale_fill_identity() +\n  geom_text(aes(x = label_x * 1.05, y = (label_y - 0.3) * 1.05, label = value),\n            fontface = \"bold\", size = 2.75, lineheight = 0.9) +\n  coord_fixed(xlim = c(-1.3, 1.3), ylim = c(-0.6, 1.0)) +\n  theme_void() +\n  theme(plot.background = element_rect(fill = \"white\", color = NA),\n        plot.margin = margin(0, 0, 0, 0),\n        text = element_text(size = rel(1)))\n\n\nTEXT\n\n\nwhite_rectangle <- ggplot() +\n  annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n           fill = \"white\") +\n  \n  # Text - line 1\n  annotate(\"text\", x = 0.02, y = 1.00,\n           label = \"ACGRI pillars: IISS calculation based on multiple sources\",\n           hjust = 0, vjust = 1, size = 2.5) +\n  \n  # Text - line 2\n  annotate(\"text\", x = 0.02, y = 0.93,\n           label = \"for 2021 and January–April 2022 (scale: 0–100)\",\n           hjust = 0, vjust = 1, size = 2.5) +\n  \n  # Text to the right of arc - line 1\n  annotate(\"text\", x = 0.35, y = 0.80,\n           label = \"A: human impact, B: Incidence;\",\n           hjust = 0, vjust = 1, size = 2.5) +\n  \n  # Text to the right of arc - line 2\n  annotate(\"text\", x = 0.35, y = 0.73,\n           label = \"C: Geopolitical impact\",\n           hjust = 0, vjust = 1, size = 2.5) +\n  \n  # tText below arc\n  annotate(\"text\", x = 0.02, y = 0.59,\n         label = \"Number of fatalities, March 2021–April 2022\",\n         hjust = 0, vjust = 1, size = 2.5) +\n  \n  # Text left of bar\n  annotate(\"text\", x = 0.02, y = 0.49, label = \"High\", hjust = 0, vjust = 0.5, \n           size = 2.5) +\n  \n  # Text right of bar\n  annotate(\"text\", x = 0.62, y = 0.49, label = \"Low\", hjust = 0, vjust = 0.5, \n           size = 2.5) +\n  \n  # Text below bar\n  annotate(\"text\", x = 0.02, y = 0.41,\n         label = \"Involvement of third-party countries\",\n         hjust = 0, vjust = 1, size = 2.5) +\n  \n  # Peacekeeping text\n  annotate(\"text\", x = 0.02, y = 0.23, \n           label = \"Peacekeeping, stabilisation and military-training \n           operations\",\n           hjust = 0, vjust = 1, size = 2.5) +\n  \n  coord_fixed(ratio = 582/833, xlim = c(0, 1), ylim = c(0, 1)) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(fill = \"white\", color = \"black\", \n                                   linewidth = 0.5),\n    plot.margin = margin(0, 0, 0, 0)\n  )\n\n\nPOSITION AND ADD\n\n\nwhite_rect_w <- 833 / 2232\nwhite_rect_h <- 582 / 1783\nwhite_rect_left <- 50 / 2232\nwhite_rect_bottom <- 80 / 1783\n\n# Add white rectangle to map\nbase_map <- base_map +\n  inset_element(\n    white_rectangle,\n    left = white_rect_left,\n    right = white_rect_left + white_rect_w,\n    bottom = white_rect_bottom,\n    top = white_rect_bottom + white_rect_h\n  )\n\n# Add grey arc\ngrey_arc_w_map <- 215 / 2232\ngrey_arc_h_map <- 156 / 1783\n\n# Position it inside the white rectangle\ngrey_arc_left <- white_rect_left + (20 / 2232)\ngrey_arc_bottom <- white_rect_bottom + (345 / 1783)\n\nbase_map <- base_map +\n  inset_element(\n    grey_legend_arc,\n    left = grey_arc_left,\n    right = grey_arc_left + grey_arc_w_map,\n    bottom = grey_arc_bottom,\n    top = grey_arc_bottom + grey_arc_h_map\n  )\n\n\nHORIZONTAL BAR\n\n\n# Colours\ncolor_scale_data <- tibble(\n  x = seq(0, 48, length.out = 100),\n  y = 1,\n  fill_color = map_chr(x, value_to_color)\n)\n\n# Colour bar\ncolor_scale_bar_only <- ggplot(color_scale_data, aes(x = x, y = y, \n                                                     fill = fill_color)) +\n  geom_tile(width = 0.5, height = 1) +\n  scale_fill_identity() +\n  scale_x_reverse(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_fixed(ratio = 5, xlim = c(0, 48), ylim = c(0.5, 1.5)) +\n  theme_void() +\n  theme(\n    plot.background = element_rect(fill = \"white\", color = NA),\n    plot.margin = margin(0, 0, 0, 0)\n  )\n\n\nFLAGS COUNTRIUES\n\n\ncreate_involvement_flags <- function() {\n  # Load flag images\n  burundi_flag <- readPNG(\"flags_and_logos/burundi.png\")\n  eritrea_flag <- readPNG(\"flags_and_logos/eritrea.png\")\n  france_flag <- readPNG(\"flags_and_logos/france.png\")\n  italy_flag <- readPNG(\"flags_and_logos/italy.png\")\n  russia_flag <- readPNG(\"flags_and_logos/russia.png\")\n  rwanda_flag <- readPNG(\"flags_and_logos/rwanda.png\")\n  south_africa_flag <- readPNG(\"flags_and_logos/south_africa.png\")\n  turkey_flag <- readPNG(\"flags_and_logos/turkey.png\")\n  uk_flag <- readPNG(\"flags_and_logos/uk.png\")\n  us_flag <- readPNG(\"flags_and_logos/us.png\")\n  \n  # Flag dimensions and spacing\n  flag_width_px <- 54\n  flag_height_px <- 37\n  flag_width <- flag_width_px / 833\n  flag_height <- flag_height_px / 582\n  n_flags <- 10\n  total_flags_width <- n_flags * flag_width\n  spacing <- (1 - total_flags_width) / (n_flags + 1)\n  \n  # Helper function to calculate flag position\n  flag_x <- function(i) spacing + (i * (flag_width + spacing))\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1, fill = NA, \n             color = NA) +\n    \n    # Burundi\n    annotation_raster(burundi_flag,\n                      xmin = flag_x(0), xmax = flag_x(0) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(0) + flag_width/2, y = 0.58, \n             label = \"Burundi\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # Eritrea\n    annotation_raster(eritrea_flag,\n                      xmin = flag_x(1), xmax = flag_x(1) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(1) + flag_width/2, y = 0.58, \n             label = \"Eritrea\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # France\n    annotation_raster(france_flag,\n                      xmin = flag_x(2), xmax = flag_x(2) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(2) + flag_width/2, y = 0.58, \n             label = \"France\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # Italy\n    annotation_raster(italy_flag,\n                      xmin = flag_x(3), xmax = flag_x(3) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(3) + flag_width/2, y = 0.58, \n             label = \"Italy\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # Russia\n    annotation_raster(russia_flag,\n                      xmin = flag_x(4), xmax = flag_x(4) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(4) + flag_width/2, y = 0.58, \n             label = \"Russia\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # Rwanda\n    annotation_raster(rwanda_flag,\n                      xmin = flag_x(5), xmax = flag_x(5) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(5) + flag_width/2, y = 0.58, \n             label = \"Rwanda\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # South Africa\n    annotation_raster(south_africa_flag,\n                      xmin = flag_x(6), xmax = flag_x(6) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(6) + flag_width/2, y = 0.58, \n             label = \"S.Africa\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # Turkey\n    annotation_raster(turkey_flag,\n                      xmin = flag_x(7), xmax = flag_x(7) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(7) + flag_width/2, y = 0.58, \n             label = \"Turkey\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # UK\n    annotation_raster(uk_flag,\n                      xmin = flag_x(8), xmax = flag_x(8) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(8) + flag_width/2, y = 0.58, \n             label = \"UK\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    # US\n    annotation_raster(us_flag,\n                      xmin = flag_x(9), xmax = flag_x(9) + flag_width,\n                      ymin = 0.6, ymax = 0.6 + flag_height) +\n    annotate(\"text\", x = flag_x(9) + flag_width/2, y = 0.58, \n             label = \"US\", hjust = 0.5, vjust = 1, size = 2) +\n    \n    coord_fixed(ratio = 582/833, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = NA, color = NA),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n\nADD ALL PARTS TO THE WHITE BOX\n\n\n# Plot flags\nflags_plot <- create_involvement_flags()\n\n# Position the bar\nbar_w_map <- 600 / 2232\nbar_h_map <- 30 / 1783\nbar_left <- white_rect_left + (0.02 * (833 / 2232)) + (5 / 2232)\nbar_bottom <- white_rect_bottom + (260 / 1783)\n\n# Add the bar\nbase_map <- base_map +\n  inset_element(\n    color_scale_bar_only,\n    left = bar_left,\n    right = bar_left + bar_w_map,\n    bottom = bar_bottom,\n    top = bar_bottom + bar_h_map\n  )\n\n# Add flags\nflags_w_map <- 833 / 2232\nflags_h_map <- 600 / 1783\n\nbase_map <- base_map +\n  inset_element(\n    flags_plot,\n    left = white_rect_left,\n    right = white_rect_left + flags_w_map,\n    bottom = white_rect_bottom - (400 / 1783),\n    top = white_rect_bottom + (50 / 1783) + flags_h_map\n  )\n\n\nPEACEKEEPING LOGOS\n\n\ncreate_peacekeeping_logos <- function() {\n  # Load logo images\n  un_logo <- readPNG(\"flags_and_logos/un.png\")\n  eu_logo <- readPNG(\"flags_and_logos/eu.png\")\n  au_logo <- readPNG(\"flags_and_logos/au.png\")\n  g5_logo <- readPNG(\"flags_and_logos/sahel_g5.png\")\n  multi_logo <- readPNG(\"flags_and_logos/multi.png\")\n  sadcmm_logo <- readPNG(\"flags_and_logos/sadcmm.png\")\n  \n  # Logo dimensions\n  logo_width_px <- 54\n  logo_height_px <- 37\n  logo_width <- logo_width_px / 833\n  logo_height <- logo_height_px / 582\n  \n  # Manual positioning\n  spacing_left <- 0.02\n  logo_gap <- 0.12\n  logo_x <- function(i) spacing_left + (i * logo_gap)\n  last_logo_x <- 0.75\n  \n  p <- ggplot() +\n    annotate(\"rect\", xmin = 0, xmax = 1, ymin = 0, ymax = 1, fill = NA, \n             color = NA) +\n    \n    # UN\n    annotation_raster(un_logo,\n                      xmin = logo_x(0), xmax = logo_x(0) + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = logo_x(0) + logo_width/2, y = 0.48, \n             label = \"UN\", hjust = 0.5, vjust = 1, size = 2, lineheight = 0.9) +\n    \n    # EU\n    annotation_raster(eu_logo,\n                      xmin = logo_x(1), xmax = logo_x(1) + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = logo_x(1) + logo_width/2, y = 0.48, \n             label = \"EU\", hjust = 0.5, vjust = 1, size = 2, lineheight = 0.9) +\n    \n    # AU\n    annotation_raster(au_logo,\n                      xmin = logo_x(2), xmax = logo_x(2) + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = logo_x(2) + logo_width/2, y = 0.48, \n             label = \"African\\nUnion\", hjust = 0.5, vjust = 1, size = 2, \n             lineheight = 0.9) +\n    \n    # G5 Sahel\n    annotation_raster(g5_logo,\n                      xmin = logo_x(3), xmax = logo_x(3) + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = logo_x(3) + logo_width/2, y = 0.48, \n             label = \"G5\\nSahel\", hjust = 0.5, vjust = 1, size = 2, \n             lineheight = 0.9) +\n    \n    # MNJTF\n    annotation_raster(multi_logo,\n                      xmin = logo_x(4), xmax = logo_x(4) + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = logo_x(4) + logo_width/2, y = 0.48, \n             label = \"Multinational\\nJoint Task\\nForce\", hjust = 0.5, vjust = 1, \n             size = 2, lineheight = 0.9) +\n    \n    # SADCMM\n    annotation_raster(sadcmm_logo,\n                      xmin = last_logo_x, xmax = last_logo_x + logo_width,\n                      ymin = 0.5, ymax = 0.5 + logo_height) +\n    annotate(\"text\", x = last_logo_x + logo_width/2, y = 0.48, \n             label = \"Southern African\\nDevelopment Community\\nMission in \n             Mozambique\", hjust = 0.5, vjust = 1, size = 2, lineheight = 0.9) +\n    \n    coord_fixed(ratio = 582/833, xlim = c(0, 1), ylim = c(0, 1)) +\n    theme_void() +\n    theme(\n      plot.background = element_rect(fill = NA, color = NA),\n      plot.margin = margin(0, 0, 0, 0)\n    )\n  \n  return(p)\n}\n\n# Create logos plot\nlogos_plot <- create_peacekeeping_logos()\n\nlogos_w_map <- 833 / 2232\nlogos_h_map <- 200 / 1783\n\nbase_map <- base_map +\n  inset_element(\n    logos_plot,\n    left = white_rect_left,\n    right = white_rect_left + logos_w_map,\n    bottom = white_rect_bottom - (620 / 1783),\n    top = white_rect_bottom + (590 / 1783) + logos_h_map\n  )\n\n\nPLOT FINAL MAP\n\n\nbase_map\n\n\n\nIMPROVEMENT\nRATIONALE FOR IMPROVEMENT\nIMPROVEMENT GRAPH\n\n\n\n\n\n\n",
    "preview": "projects/2025/100577218/100577218_files/figure-html5/unnamed-chunk-25-1.png",
    "last_modified": "2026-01-11T23:34:47+01:00",
    "input_file": "100577218.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100431024/",
    "title": "Press Freedom Index 2024",
    "description": "Global ranking of press freedom in each country in 2024, by Reporters without Borders (RSF).",
    "author": [
      {
        "name": "Rocío Galeote",
        "url": {}
      }
    ],
    "date": "2025-06-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction: Journalism under political pressure\nReplica\nImprovement\n\nIntroduction: Journalism under political pressure\nPress freedom around the world is being threatened by the very people who should be its guarantors – political authorities. Reporters without Borders (RSF) conducts a global ranking of press freedom in each country every year, by analyzing several socioeconomic and political indicators.\nAccording to the RSF, the purpose of the World Press Freedom Index is to compare the level of freedom enjoyed by journalists and media in 180 countries and territories. But what do they define as press freedom to conduct this analysis?\nIt is “the ability of journalists as individuals and collectives to select, produce, and disseminate news in the public interest independent of political, economic, legal, and social interference and in the absence of threats to their physical and mental safety.” In the following stacked column chart, we observe the press freedom index around the world in 2024.\nOriginal chart. Source: RSFAs we can see, for scores lower than 40, press freedom is considered a very serious situation; between 40 and 55, difficult; between 56 and 70, problematic; between 70 and 85, satisfactory; and from 85 to 100, good.\nIn the plot, the countries are divided into five zones: Europe - Central Asia, Americas, Africa, Asia - Pacific and Middle East - North Africa. These columns are filled with the percentages of countries in each zone within each situation category. Every category would go with different colors (from very serious situation in dark read to good situation in bright green). For this graph, only 2024 data is needed.\nThe Maghreb and Middle East region registers the most serious situation in the World Press Freedom Index 2024, followed by the Asia-Pacific region, where journalism suffocates under the weight of authoritarian regimes. In Africa, although less than 10% of the region is in a “very serious” situation, almost half of the countries are in a “difficult” situation.\nReplica\nFirst, in order to create our graph, we load the libraries we are going to use throughout this workshop:\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(cowplot)\nlibrary(magick)\nlibrary(grid)\nlibrary(plotly)\n\n\nAnd then, we load our data, downloaded from the RSF website:\n\n\npressfreedom <- read_excel(\"pressfreedom24.xlsx\")\nhead(pressfreedom)\n\n# A tibble: 6 × 7\n  Source.Name `Year (N)` ISO   `Rank N` `Score N` EN_country  Zone    \n  <chr>            <dbl> <chr>    <dbl>     <dbl> <chr>       <chr>   \n1 2024.csv          2024 NOR          1      91.9 Norway      Europe …\n2 2024.csv          2024 DNK          2      89.6 Denmark     Europe …\n3 2024.csv          2024 SWE          3      88.3 Sweden      Europe …\n4 2024.csv          2024 NLD          4      87.7 Netherlands Europe …\n5 2024.csv          2024 FIN          5      86.6 Finland     Europe …\n6 2024.csv          2024 EST          6      86.4 Estonia     Europe …\n\nAnd we format it by assigning the labels we see in the original RSF graph:\n\n\npress_freedom_df <- data.frame(pressfreedom)\n\npress_freedom_df <- press_freedom_df |> \n  mutate(Situation = case_when(\n    Score.N < 40 ~ \"Very serious\",\n    Score.N >= 40 & Score.N < 55 ~ \"Difficult\",\n    Score.N >= 55 & Score.N < 70 ~ \"Problematic\",\n    Score.N >= 70 & Score.N < 85 ~ \"Satisfactory\",\n    Score.N >= 85 ~ \"Good\"\n  ))\n\n# Calculate the percentage of countries in each situation category by zone\npercentage_data <- press_freedom_df |> \n  group_by(Zone, Situation) |> \n  summarise(count = n()) |> \n  ungroup() |> \n  group_by(Zone) |> \n  mutate(percentage = count / sum(count) * 100) |> \n  ungroup()\n\nzone_order <- c(\"Europe - Central Asia\", \"Americas\", \"Africa\", \"Asia - Pacific\", \"Middle East - North Africa\")\n\npercentage_data$Zone <- factor(percentage_data$Zone, levels = zone_order)\n\nsituation_order <- c(\"Good\", \"Satisfactory\", \"Problematic\",\"Difficult\",\"Very serious\")\n\npercentage_data$Situation <- factor(percentage_data$Situation, levels = situation_order)\n\n\nNow that our data is organized, we proceed to create the plot:\n\n\n# Load the logo image\nlogo <- image_read(\"RSFlogo.png\")\n\n# Create the stacked column chart\nreplicaplot <- ggplot(percentage_data, aes(x = Zone, y = percentage, fill = Situation)) +\n  geom_bar(stat = \"identity\", color = \"white\", size = 1.2, width = 0.75) +  # Thicker borders, reduced width\n  geom_text(aes(label = sprintf(\"%.2f%%\", percentage)),\n            position = position_stack(vjust = 0.87),\n            color = \"white\", size= 4.5, fontface = \"bold\") +  # Bold values inside columns\n  \n    # Add labels on top of the columns\n  geom_text(data = percentage_data |> group_by(Zone) |> summarise(y = 105), \n            aes(x = Zone, y = y, label = Zone),\n            inherit.aes = FALSE, hjust = 0.5, size = 3.5, fontface = \"bold\") +\n  \n  scale_y_continuous(breaks = seq(0, 100, 10), limits = c(0, 110),\n                     labels = scales::percent_format(scale = 1, suffix = \"%\")) +\n  \n  scale_fill_manual(values = c(\"Very serious\" = \"#81312F\",\n                               \"Difficult\" = \"#CF4520\",\n                               \"Problematic\" = \"#ECA154\",\n                               \"Satisfactory\" = \"#F3D03E\",\n                               \"Good\" = \"#CDEA80\")) +\n  \nguides(fill = guide_legend(override.aes = list(shape = 15, size = 6, stroke = 0), # Smaller squares (size = 4)\n                             keywidth = 1, keyheight = 0.8, \n                             title.position = \"left\",\n                             label.theme = element_text(size = 14))) +\n  \n  labs(title = \"Press freedom in the world’s five regions in 2024\",\n       x = \"\",\n       y = \"\",\n       fill = \"Situation\") +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 18, margin = margin(b = 10)),  # Bold title, closer\n    plot.title.margin = margin(b = 20),\n    plot.title.position = \"plot\",  # Title aligns with plot area\n    axis.text.x = element_blank(),  # Remove x-axis labels (zones at bottom)\n    axis.ticks.x = element_blank(),\n    axis.title.y = element_text(size = 12),\n    panel.grid.major.x = element_blank(),  # Grid only between axis\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_line(color = \"gray80\", size = 0.5),  # Keep y-grid within axis\n    legend.position = \"top\",  # Move legend to the top\n    legend.justification = \"left\",  # Align legend to the left\n    legend.box.margin = margin(0, 0, -10, 0),  # Remove extra margins in legend\n    legend.title = element_text(face = \"bold\"), \n    legend.margin = margin(t = 10),\n    plot.margin = margin(30, 10, 10, 10)  # Adjust margins to bring elements closer\n  ) +\n  # Add the secondary legend\n  annotation_custom(\n    grob = textGrob(\n      label = \"Source: World Press Freedom Index, Link to share\\n© Reporters Without Borders\",\n      x = 0.85, y = -0.1, hjust = 1, vjust = 1,\n      gp = gpar(fontface = \"italic\", fontsize = 10)\n    )\n  ) \n\nsecondary_legend <- ggdraw() +\n  # Draw the text\n  draw_text(\n    text = \"Source: World Press Freedom Index, Link to share\\n© Reporters Without Borders\",\n    x = 0.87,  # Move the text slightly to the left\n    y = 0.5,   # Center vertically\n    hjust = 1, # Align text to the right\n    size = 12\n  ) +\n  # Draw the logo next to the text\n  draw_image(\n    logo,\n    x = 0.67,    # Align logo just to the right of the text\n    y = 0.27,    # Align with the text\n    width = 0.5,\n    height = 0.5\n  )\n\n# Combine using cowplot's `plot_grid`\nfinal_plot <- plot_grid(\n  replicaplot +\n    theme(plot.margin = margin(0, 30, 0, 5)),  \n  secondary_legend,\n  ncol = 1,\n  rel_heights = c(0.87, 0.13)  # Adjust heights of the main plot and footer\n)\n\nfinal_plot\n\n\n\nNow we can clearly see the press freedom situation in each continent for the year 2024. In the RSF’s website, we can see a dropdown menu to select the year, but when clicking on it we can only see 2023 and 2024, when the study by RSF includes data from the year 2002 onwards.\nThis is due to a change in the methodology of the study; the database is not consistent for every year, so they only showcase this graph for the latest years, in which they use the new one.\nNevertheless, given that the data actually exists and that I find it really interesting to compare a bigger timeframe, I chose to gather more data. And now it’s time for the improvement part!\nImprovement\nThe original graph works completely fine and does its job at showing the different levels of press freedom in 2024. But the RSF study contains so much more information that could be displayed with just a little bit more interactivity that it is worth generating other graphs.\nThe press freedom data from 2002 to 2013 is not complete and hardly any information can be drawn from these files, so we are going to work with data from 2013 onwards, which still gathers some significant insights.\nThe dataset consists of press freedom indexes from 2013 to 2024. For each year, we have the name of the countries, the zone where they are and their rank and score.\nIn order to produce the improvement, we read all the mentioned data:\n\n\npressfreedomall <- read_excel(\"pressfreedom.xlsx\")\npressfreedomall <- as.data.frame(pressfreedomall)\nhead(pressfreedomall)\n\n  Source.Name Year ISO Rank Score  EN_country                  Zone\n1    2013.csv 2013 FIN    1 93.62     Finland Europe - Central Asia\n2    2013.csv 2013 NLD    2 93.52 Netherlands Europe - Central Asia\n3    2013.csv 2013 NOR    3 93.48      Norway Europe - Central Asia\n4    2013.csv 2013 LUX    4 93.32  Luxembourg Europe - Central Asia\n5    2013.csv 2013 AND    5 93.18     Andorra Europe - Central Asia\n6    2013.csv 2013 DNK    6 92.92     Denmark Europe - Central Asia\n       Situation\n1 Good situation\n2 Good situation\n3 Good situation\n4 Good situation\n5 Good situation\n6 Good situation\n\nAs we stated previously, the methodology was different for these years, so we have to structure the data. We compute the percentage data for all years, like we did for the 2024 chart:\n\n\npressfreedomall2 <- pressfreedomall |> \n  mutate(Situation = case_when(\n    Score < 40 ~ \"Very serious\",\n    Score >= 40 & Score < 55 ~ \"Difficult\",\n    Score >= 55 & Score < 70 ~ \"Problematic\",\n    Score >= 70 & Score < 85 ~ \"Satisfactory\",\n    Score >= 85 ~ \"Good\"\n  ))\n\n# Calculate the percentage of countries in each situation category by zone\npercentage_data_all <- pressfreedomall2 |> \n  group_by(Year, Zone, Situation) |> \n  summarise(count = n(), .groups = \"drop\") |> \n  group_by(Year, Zone) |> \n  mutate(percentage = count / sum(count) * 100) |> \n  ungroup()\n\nzone_order <- c(\"Europe - Central Asia\", \"Americas\", \"Africa\", \"Asia - Pacific\", \"Middle East - North Africa\")\n\npercentage_data_all$Zone <- factor(percentage_data_all$Zone, levels = zone_order)\n\nsituation_order <- c(\"Good\", \"Satisfactory\", \"Problematic\",\"Difficult\",\"Very serious\")\n\npercentage_data_all$Situation <- factor(percentage_data_all$Situation, levels = situation_order)\n\n\nNow, we create a stacked area chart for all the timespan in the study, with the option to choose which specific area we want to analyse over the years.\nThis type of chart works for those interested in evaluating not a year in particular but the change in slopes across the years of the study. Here, we can better observe the trends and the up and downs of the different categories, something that cannot be seen with just the original graph.\n\n\nfill_colors <- c(\n  \"Very serious\" = \"#81312F\",\n  \"Difficult\"    = \"#CF4520\",\n  \"Problematic\"  = \"#ECA154\",\n  \"Satisfactory\" = \"#F3D03E\",\n  \"Good\"         = \"#CDEA80\"\n)\n\n\n# Get unique zones, situations, and years\nzones <- levels(percentage_data_all$Zone)\nsituations <- levels(percentage_data_all$Situation)\nyears <- sort(unique(percentage_data_all$Year))\n\n# Build traces for each situation per zone\ntraces <- list()\nfor (z in zones) {\n  df_zone <- filter(percentage_data_all, Zone == z)\n  for (sit in situations) {\n    df_sit <- filter(df_zone, Situation == sit)\n    traces[[length(traces) + 1]] <- list(\n      x = df_sit$Year,\n      y = df_sit$percentage,\n      stackgroup = \"one\",\n      type = \"scatter\",\n      mode = \"none\",\n      fillcolor = fill_colors[sit],\n      name = sit,\n      visible = ifelse(z == zones[1], TRUE, FALSE)  # only first zone visible initially\n    )\n  }\n}\n\n# Create dropdown button\n\nbuttons <- lapply(seq_along(zones), function(i) {\n  visible_vec <- rep(FALSE, length(traces))\n  start_idx <- (i - 1) * length(situations) + 1\n  end_idx <- start_idx + length(situations) - 1\n  visible_vec[start_idx:end_idx] <- TRUE\n  \n  list(\n    method = \"update\",\n    args = list(list(visible = visible_vec),\n                list(title = paste(\"Region:\", zones[i]))),\n    label = zones[i]\n  )\n})\n\n\np <- plot_ly()\n\nfor (trace in traces) {\n  p <- add_trace(p, \n                 x = trace$x, y = trace$y,\n                 type = trace$type,\n                 mode = trace$mode,\n                 stackgroup = trace$stackgroup,\n                 fillcolor = trace$fillcolor,\n                 name = trace$name,\n                 visible = trace$visible)\n}\n\np <- layout(\n  p,\n  title = paste(\"Region:\", zones[1]),\n  yaxis = list(title = \"Percentage of Countries\", range = c(0, 100), ticksuffix = \"%\"),\n  xaxis = list(title = \"Year\", tickvals = years),\n  updatemenus = list(\n    list(\n      y = 1.1,\n      buttons = buttons,\n      direction = \"down\",\n      showactive = TRUE\n    )\n  ),\n  legend = list(orientation = \"h\", y = -0.2)\n)\n\np\n\n\n\nAnother visualization option is to create an animated bar chart, in which by clicking the play button at the bottom right part of the graph, we can travel across the years and see how the bars move as the press freedom situation changes.\nBy doing this -having added the rest of the years of the study into the dataset- we are allowing users to select the year they are interested in and not only the last two.\n\n\n# Prepare traces for each zone and situation with animation frames by Year\ntraces <- list()\nfor (z in zones) {\n  df_zone <- filter(percentage_data_all, Zone == z)\n  \n  # We add one trace per situation, but animation frames will be years\n  for (sit in situations) {\n    df_sit <- filter(df_zone, Situation == sit)\n    \n    traces[[length(traces) + 1]] <- list(\n      x = df_sit$Situation,\n      y = df_sit$percentage,\n      color = fill_colors[sit],\n      type = \"bar\",\n      name = sit,\n      frame = df_sit$Year,\n      visible = z == zones[1] # initially show only first zone\n    )\n  }\n}\n\n# build the plot using plot_ly and filter by zone with buttons\n\n# frames for each year and filter by zone using buttons\nfig <- plot_ly()\n\nfor (z in zones) {\n  df_zone <- filter(percentage_data_all, Zone == z)\n  \n  for (sit in situations) {\n    df_sit <- filter(df_zone, Situation == sit)\n    \n    fig <- add_trace(\n      fig,\n      data = df_sit,\n      x = ~Situation,\n      y = ~percentage,\n      type = \"bar\",\n      name = sit,\n      frame = ~Year,\n      marker = list(color = fill_colors[sit]),\n      visible = z == zones[1]\n    )\n  }\n}\n\n# Build buttons to toggle zone visibility\nbuttons <- lapply(seq_along(zones), function(i) {\n  visible_vec <- rep(FALSE, length(zones) * length(situations))\n  start <- (i - 1) * length(situations) + 1\n  end <- start + length(situations) - 1\n  visible_vec[start:end] <- TRUE\n  \n  list(\n    method = \"update\",\n    args = list(list(visible = visible_vec), list(title = paste(\"Region:\", zones[i]))),\n    label = zones[i]\n  )\n})\n\nfig <- fig %>%\n  layout(\n    barmode = \"stack\",\n    yaxis = list(range = c(0, 100), title = \"Percentage of Countries\", ticksuffix = \"%\"),\n    xaxis = list(title = \"Situation\"),\n    updatemenus = list(\n      list(\n        y = 1.15,\n        buttons = buttons,\n        direction = \"down\",\n        showactive = TRUE\n      )\n    ),\n    title = paste(\"Region:\", zones[1])\n  ) %>%\n  animation_opts(frame = 1000, transition = 500, redraw = FALSE) %>%\n  animation_slider(currentvalue = list(prefix = \"Year: \", font = list(size = 16))) %>%\n  animation_button(label = \"▶ Play\", x = 1.1, xanchor = \"right\", y = 0, yanchor = \"bottom\")\n\nfig\n\n\n\nAdditionally, we can put these two visualization options in a Shiny App with two tabs. At the left of the page, we have the option to choose the zone we want to look at.\n\n\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Press Freedom: Bar vs. Stacked‐Area\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"selected_zone\",\n        \"Choose a region (Zone):\",\n        choices  = zone_levels,\n        selected = zone_levels[1]\n      ),\n      tags$p(\"Toggle between:\"),\n      tags$ul(\n        tags$li(strong(\"Animated Bar:\"), \" vertical stacked bars (Situation on x, % on y), animated over years.\"),\n        tags$li(strong(\"Stacked Area:\"), \" vertical area plot (Year on x, % on y).\")\n      ),\n      width = 3\n    ),\n    mainPanel(\n      tabsetPanel(\n        id = \"which_plot\",\n        tabPanel(\n          \"Animated Bar\",\n          br(),\n          plotlyOutput(\"animated_bar\", height = \"550px\")\n        ),\n        tabPanel(\n          \"Stacked Area\",\n          br(),\n          plotOutput(\"stacked_area\", height = \"550px\")\n        )\n      ),\n      width = 9\n    )\n  )\n)\n\n\nserver <- function(input, output, session) {\n\n  filtered_bar_data <- reactive({\n    percentage_data_all %>%\n      filter(Zone == input$selected_zone) %>%\n      arrange(Year, Situation)\n  })\n\n  output$animated_bar <- renderPlotly({\n    df <- filtered_bar_data()\n    plot_ly(\n      df,\n      x      = ~Situation,\n      y      = ~percentage,\n      color  = ~Situation,\n      colors = fill_colors,\n      type   = \"bar\",\n      frame  = ~Year,\n      hoverinfo    = \"text\",\n      text         = ~paste0(sprintf(\"%.1f\", percentage), \"%\"),\n      textposition = \"inside\"\n    ) %>%\n      layout(\n        barmode = \"stack\",\n        xaxis   = list(title = \"Situation\", tickfont = list(size = 12)),\n        yaxis   = list(\n          title      = \"Percentage of Countries\",\n          range      = c(0, 100),\n          ticksuffix = \"%\",\n          zeroline   = TRUE\n        ),\n        showlegend = FALSE,\n        title      = paste0(\"Region: \", input$selected_zone)\n      ) %>%\n      animation_opts(\n        frame      = 1000,\n        transition = 500,\n        easing     = \"linear\",\n        redraw     = FALSE\n      ) %>%\n      animation_slider(\n        currentvalue = list(\n          prefix = \"Year: \",\n          font   = list(color = \"black\", size = 16)\n        )\n      ) %>%\n      animation_button(\n        label   = \"▶ Play\\n\",\n        x       = 1.05,\n        xanchor = \"right\",\n        y       = 0,\n        yanchor = \"bottom\"\n      )\n  })\n\n\n  filtered_area_data <- reactive({\n    percentage_data_all %>%\n      filter(Zone == input$selected_zone) %>%\n      arrange(Year, Situation)\n  })\n\n  output$stacked_area <- renderPlot({\n    df <- filtered_area_data()\n    ggplot(df, aes(x = Year, y = percentage, fill = Situation)) +\n      geom_area(color = \"white\", size = 0.3) +\n      scale_fill_manual(values = fill_colors) +\n      scale_x_continuous(breaks = year_values) +\n      scale_y_continuous(\n        labels = scales::percent_format(scale = 1, suffix = \"%\"),\n        limits = c(0, 100)\n      ) +\n      labs(\n        title = paste0(\"Region: \", input$selected_zone),\n        x     = \"Year\",\n        y     = \"Percentage of Countries\",\n        fill  = \"Situation\"\n      ) +\n      theme_minimal(base_size = 14) +\n      theme(\n        plot.title        = element_text(face = \"bold\", size = 20, hjust = 0.5),\n        axis.text.x       = element_text(angle = 45, hjust = 1),\n        panel.grid.major.y = element_line(color = \"gray80\", size = 0.5),\n        panel.grid.minor   = element_blank(),\n        legend.position    = \"bottom\",\n        legend.title       = element_text(face = \"bold\"),\n        axis.title.x       = element_text(margin = margin(t = 10)),\n        axis.title.y       = element_text(margin = margin(r = 10))\n      )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\nThe insights we can get from all these graphs are worrying: governments are failing to guarantee an exemplary framework for the practice of journalism and the right of citizens to reliable, independent and pluralistic information.\nJournalists are being threatened by both the wars they’re covering and the political actors playing in the background of these conflicts. Only time will tell how future elections around the globe are going to pressure them even more.\n\n\n\n",
    "preview": "projects/2024/100431024/100431024_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2025-06-10T15:46:06+02:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1920
  },
  {
    "path": "projects/2024/100534723/",
    "title": "The Price of a Longer Life",
    "description": "An exploration of how health spending correlates with life expectancy across\ncountries from 2000 to 2017, recreated and refined from an original New York\nTimes graphic.",
    "author": [
      {
        "name": "Irantzu Lamarca-Flores",
        "url": {}
      }
    ],
    "date": "2025-06-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nOriginal graph\nLibraries\nGetting the data\nData cleaning\nManual labels\n\nSome additional adjustments\nBuilding the graph\nCreating the plot\nBackground Annotations\nMain data lines\nCountry labels\nAxes and scales\nVisual Theme and Styling\nText Annotations\nAdditional note\n\nFinal version\nImproved version\n\nUnderstanding how health spending connects to health outcomes is a big topic in both public policy and global development. Life expectancy at birth is one of the most common ways to measure a country’s healthcare performance, since it gives a general idea of both the quality of medical care and the living conditions in a place.\nThis project looks at a data visualization originally created by The New York Times, which compares health expenditure per person with life expectancy for a range of countries between 2000 and 2017. The chart shows a clear trend where more spending usually goes hand in hand with longer lives.\nThe aim of this project is not merely to replicate the visual appearance of the original chart, but also to improve the original design enhancing clarity, visual storytelling, and overall impact through better annotation, refined aesthetics, and more intuitive labeling.\nOriginal graph\nThe original graph, as mentioned before, displays how life expectancy at birth relates to healthcare spending per capita across different countries between 2000 and 2017. Using data from the World Bank, the graph plots countries’ trajectories over time, with the x-axis representing current health expenditure per capita and the y-axis showing life expectancy in years.\nWhile most countries show a positive relationship as higher spending tends to accompany longer lives, the United States stands out as a notable exception. Despite having by far the highest health expenditure, its life expectancy remains relatively low in comparison. This contrast is visually emphasized through color: the U.S. is shown in gold, key comparison countries are labeled in grey, and the rest appear in light grey to provide context without overwhelming the visual focus.\nOriginal graph.Libraries\nTo begin the replication process, the necessary R libraries were loaded. These packages play different but complementary roles: dplyr is used for cleaning and transforming the data; ggplot2 handles the core visualization; scales helps format numeric labels; and patchwork allows for combining multiple plots into one coherent layout. Additionally, showtext is used to import and apply custom Google Fonts, which is important for matching the original chart’s typographic style. Together, these libraries provide a flexible and powerful foundation for recreating the visual and analytical structure of the original graphic.\n\n\nlibrary(ggplot2)\nlibrary(dplyr)      \nlibrary(patchwork)  \nlibrary(scales)   \nlibrary(showtext)   \n\n\nGetting the data\nThe data consists of country-level information on life expectancy at birth and current health expenditure per capita, provided by the World Bank. The dataset covers multiple countries over a span of years and is structured in a wide format, where each row corresponds to a specific country and year.\n\n\ncsv <- \"life-expectancy-vs-healthcare-expenditure.csv\" # load the dataset\nraw <- read.csv(csv, check.names = FALSE) # read the dataset\nhead(raw) \n\n       Entity Code Year\n1 Afghanistan  AFG 1950\n2 Afghanistan  AFG 1951\n3 Afghanistan  AFG 1952\n4 Afghanistan  AFG 1953\n5 Afghanistan  AFG 1954\n6 Afghanistan  AFG 1955\n  Life expectancy - Sex: all - Age: 0 - Variant: estimates\n1                                                   28.156\n2                                                   28.584\n3                                                   29.014\n4                                                   29.452\n5                                                   29.698\n6                                                   30.366\n  Current health expenditure per capita, PPP (current international $)\n1                                                                   NA\n2                                                                   NA\n3                                                                   NA\n4                                                                   NA\n5                                                                   NA\n6                                                                   NA\n  Population (historical) World regions according to OWID\n1                 7776182                                \n2                 7879343                                \n3                 7987783                                \n4                 8096703                                \n5                 8207953                                \n6                 8326981                                \n\nLet’s look at the summary of the data:\n\n\nsummary(raw)\n\n    Entity              Code                Year       \n Length:59749       Length:59749       Min.   :-10000  \n Class :character   Class :character   1st Qu.:  1834  \n Mode  :character   Mode  :character   Median :  1904  \n                                       Mean   :  1613  \n                                       3rd Qu.:  1969  \n                                       Max.   :  2023  \n                                                       \n Life expectancy - Sex: all - Age: 0 - Variant: estimates\n Min.   :10.99                                           \n 1st Qu.:55.99                                           \n Median :66.43                                           \n Mean   :63.78                                           \n 3rd Qu.:72.83                                           \n Max.   :86.37                                           \n NA's   :41027                                           \n Current health expenditure per capita, PPP (current international $)\n Min.   :    6.717                                                   \n 1st Qu.:  170.687                                                   \n Median :  558.141                                                   \n Mean   : 1176.941                                                   \n 3rd Qu.: 1516.700                                                   \n Max.   :11702.409                                                   \n NA's   :55517                                                       \n Population (historical) World regions according to OWID\n Min.   :1.000e+00       Length:59749                   \n 1st Qu.:1.510e+05       Class :character               \n Median :1.436e+06       Mode  :character               \n Mean   :4.974e+07                                      \n 3rd Qu.:6.947e+06                                      \n Max.   :8.092e+09                                      \n NA's   :572                                            \n\nThe data includes demographic and economic indicators, however, for this project, only a subset of the data will be used. We need to clean the data before moving on to the replication.\nData cleaning\nThe first step in the cleaning process is to identify the relevant columns in the dataset. Since the original column names are long and not always consistent, the grepl() function is used to search for keywords like “life expect”, “health expenditure”, and “entity” or “country”. This makes the code more adaptable, avoiding the need to manually enter column names that could change slightly across versions of the dataset.\n\n\nlife_exp_col <- names(raw)[grepl(\"life.*expect\",  names(raw), TRUE)][1]\n\nhealth_exp_col <- names(raw)[grepl(\"current.*health.*expenditure.*capita\", names(raw), TRUE)][1]\n\nentity_col <- names(raw)[grepl(\"^(Entity|Country)$\", names(raw), TRUE)][1]\n\n\nIt is also necessary to check that the required columns (life expectancy, health expenditure, and country) are correctly identified in the dataset. If any of them are missing, the script stops and returns an error message to avoid issues later in the analysis.\n\n\nif (anyNA(c(life_exp_col, health_exp_col, entity_col)))\n  stop(\"Columns not found; check names(raw)\")\n\n\nOnce the correct columns have been identified, we will rename them to shorter and more manageable names to help simplify the rest of the workflow.\nMoreover, to ensure smooth processing and avoid errors during plotting, both LifeExpectancy and HealthExpenditure will be converted to numeric values. We will also filter the dataset to include only data from the year 2000 onward, as this is the time range shown in the original visualization. Additionally, rows with NA’s in either life expectancy or health expenditure will be removed to ensure the plot would not be distorted by incomplete data.\nLastly, a new variable called Highlight will be created using case_when(). This variable assigns countries to one of three categories: “US” for the United States (which is highlighted in gold in the original graph), “Key” for a selected group of countries (the ones that are in dark grey), and “Rest” for all remaining countries (light grey). This distinction is important later when customizing line colors and label visibility in the plot.\n\n\ndf <- raw %>%\n  rename(Country = all_of(entity_col),\n         LifeExpectancy = all_of(life_exp_col),\n         HealthExpenditure = all_of(health_exp_col)) %>%\n  mutate(across(c(LifeExpectancy, HealthExpenditure), as.numeric)) %>%\n  filter(Year >= 2000, !is.na(LifeExpectancy), !is.na(HealthExpenditure)) %>%\n  mutate(Highlight = case_when(\n    Country == \"United States\" ~ \"US\",\n    Country %in% c(\"Switzerland\",\"Japan\",\"Italy\",\"France\",\"Canada\",\"Germany\",\n                   \"China\",\"Brazil\",\"Saudi Arabia\",\"Ukraine\",\"Russian Federation\",\"India\") ~ \"Key\",\n    TRUE ~ \"Rest\"))\n\n\nManual labels\nWe will manually create a small table to define the positions of specific country labels in the final plot, as, while creating it, we have had some trouble with them. This is necessary because, for some countries, the automatic placement of labels might not be clear or may overlap with others.\n\n\nmanual_labels <- tibble::tribble(\n  ~Country,             ~HealthExpenditure, ~LifeExpectancy,\n  \"United States\",                 8000 ,            79,\n  \"Japan\",                          4000 ,            84,\n  \"Russian Federation\",             1500 ,            72\n)\n\n\nSome additional adjustments\nBefore building the body of the graph, we need to define some aesthetics. In this part of the code, we are setting up a custom font for the plot. The font_add_google() function loads the Source Sans Pro font directly from Google Fonts and assigns it the nickname “ssp” for easy reference in the rest of the code. The showtext_auto() function then activates the showtext package, which ensures that this font is properly rendered in the plots. This helps match the typography of the original graph.\n\n\nfont_add_google(\"Source Sans Pro\", \"ssp\", regular.wt = 400, bold.wt = 700)\nshowtext_auto()\n\n\nWe also need to define the font sizes for the country labels that will appear on the plot. Specifically, size_us sets the label size for the United States (highlighted in gold), while size_key sets the size for the other selected countries.\n\n\nsize_us   <- 6   # United States \nsize_key  <- 6\n\n\nFinally, we will define the custom breaks and labels for the x-axis of the plot. The brks object creates a sequence of values from 0 to 10,000 in increments of 1,000, which will serve as the tick marks. The labels object formats these values using commas, with a custom label for the last value as “$10,000”.\n\n\nbrks   <- c(seq(0, 9000, 1000), 10000)\nlabels <- c(label_comma()(seq(0, 9000, 1000)), \"$10,000\")\n\n\nBuilding the graph\nCreating the plot\nWe will first create the plot using the ggplot2 package. We will display HealthExpenditure on the x-axis and LifeExpectancy on the y-axis. This code does not yet draw anything, it just sets up the coordinate system and mapping.\n\n\nmain <- ggplot(df, aes(HealthExpenditure, LifeExpectancy, group = Country))\n\nmain\n\n\n\nBackground Annotations\nWe will now add a background rectangle behind the data points. Horizontally, it will move from 0 to 10,000 (the full x-range of health expenditure) and vertically from 66 to 84 (the y-range of life expectancy).\n\n\nmain <- main +\n  annotate(\"rect\", xmin = 0, xmax = 10000, ymin = 66, ymax = 84, fill = \"grey95\")\n\nmain\n\n\n\nMain data lines\nIn here, we will draw three different types of lines for three groups of countries:\n“Rest” countries (gray, thin lines): These represent countries not considered key or the US. They are shown in very light gray to provide background context without visual dominance.\n“Key” countries (slightly darker gray): These are important for comparison, with a bit more emphasis than the rest.\nUnited States: This line is highlighted with a dynamic color gradient and alpha transparency based on health expenditure. This makes the US visually pop out as the main subject of the chart.\n\n\nmain <- main +\n  geom_line(data = filter(df, Highlight == \"Rest\"), colour = \"grey90\", linewidth = 0.75, alpha = .6) +\n  geom_line(data = filter(df, Highlight == \"Key\"),  colour = \"grey70\", linewidth = 0.85, alpha = .8) +\n  geom_line(data = filter(df, Highlight == \"US\"),\n            aes(colour = HealthExpenditure, alpha = HealthExpenditure / max(HealthExpenditure)),\n            linewidth = 1.5)\n\n\nCountry labels\nMoving on, we can now add text labels to the lines on the chart. The US label is in bold goldenrod to match its line and highlight it as the focus. Key countries have their names added in gray. For Canada, the label is manually nudged upward (-0.7) to avoid overlapping with the line. This ensures the viewer can quickly identify important countries without needing a legend.\n\n\nmain <- main +\n  geom_text(data = subset(manual_labels, Country == \"United States\"),\n            aes(x = HealthExpenditure, y = LifeExpectancy, label = Country),\n            hjust = 0, vjust = 0, size = size_us, family = \"ssp\", fontface = \"bold\", colour = \"goldenrod\") +\n  \n  geom_text(data = df %>% filter(Highlight == \"Key\", Country != \"United States\") %>%\n              group_by(Country) %>% slice_max(Year) %>%\n              mutate(nudge = ifelse(Country == \"Canada\", -0.7, 0)),\n            aes(label = Country, y = LifeExpectancy + nudge),\n            hjust = 0, vjust = 0, size = size_key,\n            family = \"ssp\", fontface = \"bold\", colour = \"grey70\") +\n  \n  geom_text(data = subset(manual_labels, Country != \"United States\"),\n            aes(x = HealthExpenditure, y = LifeExpectancy, label = Country),\n            hjust = 0, vjust = 0, size = size_key, family = \"ssp\", fontface = \"bold\", colour = \"grey70\")\n\n\nAxes and scales\nIn this section, we define how both axes and visual encodings behave to convey meaning clearly and intuitively. The scale_colour_gradient() function creates a smooth color transition from grey to goldenrod, which is applied only to the United States line. In parallel, the scale_alpha() setting adjusts the transparency of the line based on expenditure, with higher values appearing more solid.\nFor the horizontal axis, the chart displays health expenditure per capita, ranging from 0 to 10,000 dollars. The axis includes custom tick marks and labels that help guide the viewer’s understanding of the scale. On the vertical axis, life expectancy is shown, ranging from 66 to 84 years, with regular intervals every two years.\n\n\nmain <- main +\n  scale_colour_gradient(low = \"grey80\", high = \"goldenrod\", guide = \"none\") +\n  scale_alpha(range = c(.3, 1), guide = \"none\") +\n  scale_x_continuous(breaks = brks, labels = labels, limits = c(0, 10000), expand = expansion(add = c(0, 100))) +\n  scale_y_continuous(breaks = seq(66, 84, 2), limits = c(66, 84), expand = expansion(add = c(0, 1)))\n\nmain\n\n\n\nVisual Theme and Styling\nWe can move on to the definition of the look and feel of the chart. We use theme_void() to remove all gridlines, background, and default axis elements. Custom styling is applied to axis labels and tick marks in a subtle gray. And, plot.margin ensures there’s enough space on the right for labels to fit without being cut off.\n\n\nmain <- main +\n  theme_void(base_family = \"ssp\") +\n  theme(\n    axis.text.x = element_text(color = \"grey70\", size = 16, margin = margin(t = 5)),\n    axis.text.y = element_text(color = \"grey70\", size = 16, margin = margin(r = 5)),\n    axis.ticks.length.x = unit(3, \"pt\"),\n    axis.ticks.length.y = unit(3, \"pt\"),\n    axis.ticks.x = element_line(color = \"grey80\", size = .3),\n    axis.ticks.y = element_line(color = \"grey80\", size = .3),\n    panel.grid = element_blank(),\n    plot.margin = margin(t = 5, r = 35, b = 5, l = 5)\n  )\n\nmain\n\n\n\nText Annotations\nFinal labels are added outside the main plotting area to help guide interpretation.\n\n\nmain <- main +\n  annotate(\"text\", x = 0, y = 64, label = \"0\", family = \"ssp\", colour = \"grey40\") +\n  annotate(\"text\", x = 9900, y = 66.5, label = \"Health expenditure per capita\",\n           hjust = 1, family = \"ssp\", colour = \"grey70\", size = 5.5) +\n  annotate(\"text\", x = 0, y = 84, label = \"Life expectancy at birth\",\n           hjust = 0, vjust = -1, family = \"ssp\", colour = \"grey70\", size = 5.5)\n\n\nAdditional note\nAt the bottom of the visualization, a note is added to provide important context about the data. It is carefully positioned slightly outside the main plotting area, with added margin space to the right to prevent clipping.\n\n\nnote <- ggplot() +\n  annotate(\n    \"text\",\n    x = -0.05, y = .7,\n    label = paste(\n      \"Note: Current health expenditure per capita, purchasing power parity,\",\n      \"reflects current international dollars. Both\\n\",\n      \"measures span 2000–2017. Source: World Bank\"\n    ),\n    hjust = 0, vjust = 1,\n    family = \"ssp\", colour = \"grey50\", size = 6, lineheight = 1.1\n  ) +\n  coord_cartesian(xlim = c(0, 1), clip = \"off\") +\n  theme_void(base_family = \"ssp\") +\n  theme(plot.margin = margin(r = 35))\n\n\nFinal version\nAnd this is how the replication looks like:\n\n\nmain / note + plot_layout(heights = c(10, 1.5))\n\n\n\nImproved version\nWhile the original chart is already effective in communicating the overall trend, there are several ways of improving its clarity and visual impact. We will try to introduce a series of design improvements aimed at making the data more accessible, the message more accurate, and the presentation more visually attractive.\nWe will first need to load some additional libraries\n\n\nlibrary(readr)\nlibrary(countrycode)\nlibrary(ggtext)\n\n\nThe readr package is used to efficiently load the dataset from a CSV file. countrycode simplifies the task of mapping country names to their corresponding continents, enabling regional grouping for analysis and visualization. Finally, ggtext enhances the visual expressiveness of the chart by allowing styled text elements through markdown and HTML rendering directly within the plot.\nWe will also add some specific fonts, as we have done in the previous replication.\n\n\nfont_add_google(\"IBM Plex Sans\", \"plex\")\nshowtext_auto()\n\n\nAs we need to add a new variable and clean the data again, we will upload the data again from 0 in order to avoid any problems with the data.\n\n\ndf <- read_csv(\"life-expectancy-vs-healthcare-expenditure.csv\") # read the data\n\ncolnames(df) <- c(\"country\", \"code\", \"year\", \"life_exp\", \"health_exp\", \"population\", \"region\") # rename columns\n\n\nThe dataset is now refined to prepare it for analysis. The variables for life expectancy and health expenditure are converted to numeric values to ensure consistency. Each country is then assigned to a continent based on its name, with a manual adjustment that separates North and South America (placing the United States, Canada, and Mexico in the former, and all other American countries in the latter) as we want to make 6 small plots to ensure the visual harmony. Finally, the data is filtered to include only the years between 2000 and 2017 and to exclude any rows with missing values in key variables, ensuring that the dataset is clean and complete for visualization.\n\n\ndf <- df %>%\n  mutate(\n    life_exp = as.numeric(life_exp),\n    health_exp = as.numeric(health_exp),\n    continent = countrycode(country, \"country.name\", \"continent\"),\n    continent = case_when(\n      country %in% c(\"United States\", \"Canada\", \"Mexico\") ~ \"North America\",\n      continent == \"Americas\" & !country %in% c(\"United States\", \"Canada\", \"Mexico\") ~ \"South America\",\n      TRUE ~ continent\n    )\n  ) %>%\n  filter(year >= 2000 & year <= 2017, !is.na(life_exp), !is.na(health_exp), !is.na(continent))\n\n\nA specific color is assigned to each continent in order to visually differentiate them in the final plot. We have tried to use colorblind-friendly palette, as all colors have high contrast and are easily distinguishable in most types of colorblindness.\n\n\ncontinent_colors <- c(\n  \"Africa\" = \"#66c2a5\",        # teal\n  \"Asia\" = \"#fc8d62\",          # orange\n  \"Europe\" = \"#8da0cb\",        # light blue\n  \"North America\" = \"#e78ac3\", # pink\n  \"Oceania\" = \"#a6d854\",       # lime green\n  \"South America\" = \"#ffd92f\"  # yellow\n)\n\n\nMoving on, the next step is to identify the top 10 countries in each continent based on their average life expectancy between 2000 and 2017. First, the data is grouped by country and continent, and the mean life expectancy is calculated for each country. Then, within each continent, the ten countries with the highest average life expectancy are selected. The goal of it is to highlight those nations that consistently perform best in terms of health outcomes. Including only the top performers helps reduce visual clutter in the chart, making the trends easier to interpret while still capturing meaningful geographic variation.\n\n\ntop10 <- df %>%\n  group_by(country, continent) %>%\n  summarise(mean_life = mean(life_exp), .groups = \"drop\") %>%\n  group_by(continent) %>%\n  slice_max(mean_life, n = 10) %>%\n  pull(country)\n\n\nWe also want to identify the country in each continent that experienced the largest change in health expenditure per capita between 2000 and 2017.\n\n\ndestacado <- df %>%\n  group_by(country, continent) %>%\n  summarise(variacion = max(health_exp) - min(health_exp), .groups = \"drop\") %>%\n  group_by(continent) %>%\n  slice_max(variacion, n = 1, with_ties = FALSE) %>%\n  pull(country)\n\n\nEach country in the dataset is categorized based on its relevance in the visualization. Countries that experienced the highest change in health expenditure within their continent are labeled as highlighted. Those that belong to the top 10 in average life expectancy per continent are marked as top10. All remaining countries are grouped under the rest category. This classification allows for differentiated styling in the plot, helping to visually emphasize the most significant countries while maintaining context with the rest.\n\n\ndf <- df %>%\n  mutate(categoria = case_when(\n    country %in% destacado ~ \"highlighted\",\n    country %in% top10 ~ \"top10\",\n    TRUE ~ \"rest\"\n  ))\n\n\nWe also need to prepare the position of the country labels that will appear on the plot. It selects only the countries classified as highlightedand filters them for the most recent year available (2017). Then, for each of these countries, custom x and y coordinates are calculated to fine-tune the placement of their labels.These manual adjustments ensure that the labels are clearly visible and do not overlap with data lines, improving the readability of the final visualization.\n\n\nlabels <- df %>%\n  filter(categoria == \"highlighted\", year == 2017) %>%\n  mutate(\n    label_x = case_when(\n      country == \"United States\" ~ health_exp + 600,  # more to the right\n      country == \"Cuba\" ~ health_exp - 300,           # more to the left\n      TRUE ~ health_exp + 150\n    ),\n    label_y = case_when(\n      country == \"United States\" ~ life_exp + 1,      # higher\n      country == \"Cuba\" ~ life_exp + 1.2,             # higher\n      TRUE ~ life_exp\n    )\n  )\n\n\nIt is necessary to calculate the vertical limits for the y-axis by finding the range of life expectancy values and adding some extra space above and below.\n\n\nmin_y <- min(df$life_exp)\nmax_y <- max(df$life_exp)\nrange_y <- max_y - min_y\ny_lim <- c(min_y - 0.2 * range_y, max_y + 0.05 * range_y)\n\n\nIn here, we want to create a custom label style for the facet titles by assigning each continent a specific color and bold text.\n\n\ncolor_labeller <- labeller(\n  continent = function(x) {\n    colors <- c(\n      \"Africa\" = \"#66c2a5\",        # teal\n      \"Asia\" = \"#fc8d62\",          # orange\n      \"Europe\" = \"#8da0cb\",        # light blue\n      \"North America\" = \"#e78ac3\", # pink\n      \"Oceania\" = \"#a6d854\",       # lime green\n      \"South America\" = \"#ffd92f\"  # yellow\n    )\n    paste0(\"<span style='color:\", colors[x], \"'><b>\", x, \"<\/b><\/span>\")\n  }\n)\n\n\nFinally, this section builds the final version of the improved visualization. The plot shows the relationship between health expenditure and life expectancy across countries, grouped by continent. Different line colors and styles are used to distinguish between three categories of countries: “rest” (shown in light gray for context), “top10” (in darker gray to highlight strong performers), and “highlighted” (in color, representing countries with the greatest change in spending). Each line represents the historical evolution of a country from 2000 to 2017. Overall, this block brings together all elements of the improved design, emphasizing key insights while maintaining a visually appealing and accessible presentation.\n\n\nggplot(df, aes(x = health_exp, y = life_exp, group = country)) +\n  geom_line(data = df %>% filter(categoria == \"rest\"),\n            color = \"grey80\", size = 0.4, alpha = 0.3) +\n  geom_line(data = df %>% filter(categoria == \"top10\"),\n            color = \"grey40\", size = 0.5, alpha = 0.7) +\n  geom_line(data = df %>% filter(categoria == \"highlighted\"),\n            aes(color = continent), size = 1.2) +\n  geom_text(data = labels,\n            aes(x = label_x, y = label_y, label = country, color = continent),\n            size = 4, fontface = \"bold\", hjust = 0, family = \"plex\") +\n  scale_color_manual(values = continent_colors) +\n  facet_wrap(~ continent, scales = \"free\", labeller = color_labeller) +\n  coord_cartesian(ylim = c(60, max(df$life_exp, na.rm = TRUE))) +\n  scale_x_continuous(expand = expansion(mult = c(0.02, 0.2))) +\n  theme_minimal(base_family = \"plex\", base_size = 18) +\n  labs(\n    title = \"Evolution of life expectancy vs healthcare expenditure (2000-2017)\",\n    subtitle = \"Light gray: other countries | Dark gray: top 10 life expectancy | Color: most changing country\",\n    x = \"Health expenditure per capita ($)\",\n    y = \"Life expectancy\",\n    caption = \"Source: World Bank | Irantzu Lamarca\"\n  ) +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"#ffffff\", color = NA),\n    panel.background = element_rect(fill = \"#f7f7f7\", color = \"grey85\"),\n    panel.grid.major = element_line(color = \"grey85\", size = 0.3, linetype = \"dashed\"),\n    panel.grid.minor = element_blank(),\n    axis.text = element_text(family = \"plex\", color = \"black\", size = 12),\n    axis.text.x = element_text(margin = margin(t = 5)),\n    axis.text.y = element_text(margin = margin(r = 5)),\n    axis.ticks.length = unit(0.2, \"lines\"),\n    axis.ticks = element_line(color = \"grey60\"),\n    strip.text = element_markdown(size = 16, face = \"bold\", family = \"plex\"),\n    panel.spacing = unit(0.4, \"lines\"),\n    plot.title = element_text(size = 22, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 16, hjust = 0.5),\n    axis.title = element_text(size = 14, family = \"plex\"),\n    plot.caption = element_text(size = 14, hjust = 0.5, face = \"italic\", family = \"plex\")\n  )\n\n\n\nThis final visualization clearly illustrates the relationship between healthcare spending and life expectancy across different world regions from 2000 to 2017. By categorizing countries into three distinct groups the chart effectively highlights both global trends and regional nuances. The use of colorblind-friendly colours and styled facet titles enhances readability and accessibility, while the clean design and thoughtful label positioning ensure that key insights are immediately visible. Overall, the improved chart not only replicates the original graphic’s core message but also elevates it by adding clarity, depth, and inclusivity to the visual storytelling.\n\n\n\n",
    "preview": "projects/2024/100534723/100534723_files/figure-html5/final-plot-1.png",
    "last_modified": "2025-06-10T15:46:09+02:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 1536
  },
  {
    "path": "projects/2024/100540514/",
    "title": "Dispersion patterns of SARS-CoV-2 variants Gamma, Lambda and Mu in Latin America and the Caribbean",
    "description": "The graph illustrates the total number of genomes sequenced alongside the\nproportion of sequenced COVID-19 cases.",
    "author": [
      {
        "name": "Gina Tedesco",
        "url": {}
      }
    ],
    "date": "2025-01-17",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nGetting the Data\nRecreating the Graph\nRequired Libraries\nCountry Order Definition\nData Loading Preparation\nTransformation Function\nPlotting the Graph\n\nAlternative Graph 1\nDefine New Country order\nData Loading Preparation\nTransformation Function\nPlotting the Graph\n\nAlternative Graph 2\nDefine New Country order\nData Loading Preparation\nTransformation Function\nPlotting the Graph\n\nInteractive Graph\nRequired Libraries\nDefine New Country order\nData Loading Preparation\nTransformation Function\nDefine custom colors for bars\nMap colors to data\nPlotting the Graph\n\n\nThe COVID-19 pandemic disproportionately impacted Latin America and the Caribbean (LAC), revealing significant inequalities in health infrastructure and surveillance capacity across the region. In response, the Pan American Health Organization (PAHO) established the COVID-19 Genomic Surveillance Regional Network (COVIGEN) to strengthen genomic sequencing and enable the timely identification of viral variants. From February 2020 to March 2022, this initiative resulted in the sequencing of 126,985 SARS-CoV-2 genomes across 32 LAC countries and territories. Expanding this dataset with genomes from the GISAID database brought the total analyzed to 296,286 genomes from 41 regions, providing a comprehensive view of genomic diversity. The study highlighted disparities in sequencing efforts, ranging from below 0.05% to over 10% of total COVID-19 cases, with countries such as Brazil, Argentina, Colombia, Mexico, and Peru contributing 80% of the sequences. The emergence of regional Variants of Interest (VOIs) like Gamma, Lambda, and Mu emphasized the importance of COVIGEN in tracking viral evolution and guiding public health responses. This analysis further explored the dynamics of variant dissemination by incorporating air traffic data and mobility restrictions to model viral spread patterns, offering insights into the interplay between epidemiology and social behavior during the pandemic.\nOriginal chartGetting the Data\nThe data for this graph was derived from the SARS-CoV-2 genomic surveillance efforts coordinated through the COVID-19 Genomic Surveillance Regional Network (COVIGEN). From its inception in March 2020 to March 2022, COVIGEN supported the sequencing of 126,985 SARS-CoV-2 genomes from 32 countries and territories in Latin America and the Caribbean (LAC). To create a more comprehensive dataset, these genomes were supplemented with additional sequences and metadata obtained from the EpiCoV database hosted on GISAID, covering the same period and geographic region. This aggregation resulted in a dataset of 296,286 genomes from 41 countries and territories, providing a summarized view of genomic diversity and sequencing efforts across the region. The data was further aggregated by combining geographically proximate countries into broader locations, enabling a summarized representation of viral sequencing and lineage diversity. The data specific to this graph was available in the paper’s “Data Availability” section.\nRecreating the Graph\nRequired Libraries\ntidyverse: unifies workflows by integrating ggplot2 for graphics and dplyr for data manipulation, providing a consistent and intuitive grammar for transforming and visualizing data.\ndplyr: allows intuitive manipulation of data, readable operations on datasets through verb-like functions that transform and reshape data in predictable ways.\nggtext: an extension to ggplot2 that enhances text rendering capabilities\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggtext)\n\n\nCountry Order Definition\nThis step defines a custom order for the countries in the visualization. The order is crucial for the graph’s readability\n\n\ncountry_order <- c(\n  \"Argentina\", \"Bolivia\", \"Brazil\", \"Chile\", \"Colombia\", \"Ecuador\", \"Guyana\",\n  \"Paraguay\", \"Peru\", \"Suriname\", \"Uruguay\", \"Venezuela\", \"Honduras\",\n  \"Guatemala\", \"El Salvador\", \"Costa Rica\", \"Panama\", \"Belize\", \"Nicaragua\",\n  \"Mexico\", \"Bahamas\", \"Bermuda\", \"Cuba\", \"Dominican Republic\", \"Haiti\",\n  \"Jamaica\", \"Barbados\", \"Dominica\", \"Saint Barthélemy\", \"Grenada\",\n  \"Saint Lucia\", \"Guadeloupe\", \"Saint Kitts and Nevis\", \"Trinidad and Tobago\",\n  \"Saint Martin\", \"Saint Vincent and the Grenadines\", \"Antigua and Barbuda\",\n  \"Curacao\", \"Aruba\", \"Bonaire\", \"Sint Maarten\"\n)\n\n\nData Loading Preparation\n\n\ncovid_data <- read_csv(\"SARS-CoV-2.csv\") %>%\n  mutate(\n    Country = factor(Country, levels = rev(country_order))\n  )\n\n\nTransformation Function\nThis function transforms genome counts to a percentage scale, using a logarithmic transformation to handle wide ranges of data.\n\n\ngenome_to_pct <- function(x) {\n  x_log <- log10(x)\n  min_log <- log10(2)  # Minimum genome count\n  max_log <- log10(129677)  # Maximum genome count\n  scaled_value <- 2.5 + ((x_log - min_log) / (max_log - min_log)) * 19.5\n  return(scaled_value)\n}\nbreaks<- c(0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000)\n\n\nPlotting the Graph\n\n\nggplot() +\n  geom_col(\n    data = covid_data,\n    aes(x = Prop_sequenced_cases, y = Country, fill = Country),\n    alpha = 0.6,  \n    width = 0.8\n  ) +\n  geom_point(\n    data = covid_data,\n    aes(x = genome_to_pct(Genomes), y = Country, color = Country),\n    size = 1.3\n  ) +\n  scale_x_continuous(\n    name = \"Total COVID-19 cases that have been sequenced (%)\",\n    limits = c(0, 25),\n    breaks = seq(0, 25, 5),\n    expand = c(0, 0),\n    sec.axis = sec_axis(\n      ~10^((. - 2.5) / 19.5 * (log10(129677) - log10(2)) + log10(2)),\n      name = \"Total genomes sequenced (dots)\",\n      breaks = breaks,\n      labels = c(ifelse(breaks %in% c(1, 10, 100, 1000, 10000, 100000),\n                        paste0(\"<span style='color=black;font-weight:900;font-size:7pt'><b>\", ifelse(breaks > 1000, paste0(breaks/1000, 'k'), breaks), \"<\/span>\"),\n                        paste0(\"<span style='font-size:6pt'>\", str_sub(breaks, 1, 1), \"<\/b><\/span>\"))[-1], \"<span style='font-size:6pt'>2<\/b><\/span>\")\n\n    )) +\n  scale_fill_manual(values = c(\n    \"Argentina\" = \"#7F9EB4\", \"Bolivia\" = \"#5aae61\", \"Brazil\" = \"#107c4c\",\n    \"Chile\" = \"#D0E7F1\", \"Colombia\" = \"#fcdca1\", \"Ecuador\" = \"#f7ac91\",\n    \"Guyana\" = \"#CCE6D0\", \"Paraguay\" = \"#5bc686\", \"Peru\" = \"#e22629\",\n    \"Suriname\" = \"#a6e0a6\", \"Uruguay\" = \"#AFC6D0\", \"Venezuela\" = \"#e5c195\",\n    \"Honduras\" = \"#a286c9\", \"Guatemala\" = \"#7447b7\", \"El Salvador\" = \"#7447b7\",\n    \"Costa Rica\" = \"#7447b7\", \"Panama\" = \"#7447b7\", \"Belize\" = \"#7447b7\",\n    \"Nicaragua\" = \"#7447b7\", \"Mexico\" = \"#a3a1ed\", \"Bahamas\" = \"#FECFD5\",\n    \"Bermuda\" = \"#FECFD5\", \"Cuba\" = \"#FECFD5\", \"Dominican Republic\" = \"#f21d92\",\n    \"Haiti\" = \"#f21d92\", \"Jamaica\" = \"#f21d92\", \"Barbados\" = \"#ff69a0\",\n    \"Dominica\" = \"#ff69a0\", \"Saint Barthélemy\" = \"#ff69a0\", \"Grenada\" = \"#ff69a0\",\n    \"Saint Lucia\" = \"#ff69a0\", \"Guadeloupe\" = \"#ff69a0\", \"Saint Kitts and Nevis\" = \"#ff69a0\",\n    \"Trinidad and Tobago\" = \"#ff69a0\", \"Saint Martin\" = \"#ff69a0\",\n    \"Saint Vincent and the Grenadines\" = \"#ff69a0\", \"Antigua and Barbuda\" = \"#ff69a0\",\n    \"Curacao\" = \"#ff69a0\", \"Aruba\" = \"#ff69a0\", \"Bonaire\" = \"#ff69a0\",\n    \"Sint Maarten\" = \"#ff69a0\"\n  )) +\n  scale_color_manual(values = c(\n    \"Argentina\" = \"#176EA9\", \"Bolivia\" = \"#F76F4E\", \"Brazil\" = \"#008C3C\",\n    \"Chile\" = \"#B6D1DA\", \"Colombia\" = \"#F6D98E\", \"Ecuador\" = \"#FEAE92\",\n    \"Guyana\" = \"#A8E3B5\", \"Paraguay\" = \"#46C383\", \"Peru\" = \"#E92721\",\n    \"Suriname\" = \"#A9E7B4\", \"Uruguay\" = \"#3FAFD5\", \"Venezuela\" = \"#FB9E1E\",\n    \"Honduras\" = \"#6E52A8\", \"Guatemala\" = \"#6E52A8\", \"El Salvador\" = \"#6E52A8\",\n    \"Costa Rica\" = \"#6E52A8\", \"Panama\" = \"#6E52A8\", \"Belize\" = \"#6E52A8\",\n    \"Nicaragua\" = \"#6E52A8\", \"Mexico\" = \"#A19AC4\", \"Bahamas\" = \"#FDB6BE\",\n    \"Bermuda\" = \"#FDB6BE\", \"Cuba\" = \"#E7298E\", \"Dominican Republic\" = \"#E7298E\",\n    \"Haiti\" = \"#E7298E\", \"Jamaica\" = \"#E7298E\", \"Barbados\" = \"#FF6CA4\",\n    \"Dominica\" = \"#FF6CA4\", \"Saint Barthélemy\" = \"#FF6CA4\", \"Grenada\" = \"#FF6CA4\",\n    \"Saint Lucia\" = \"#FF6CA4\", \"Guadeloupe\" = \"#FF6CA4\", \"Saint Kitts and Nevis\" = \"#FF6CA4\",\n    \"Trinidad and Tobago\" = \"#FF6CA4\", \"Saint Martin\" = \"#FF6CA4\",\n    \"Saint Vincent and the Grenadines\" = \"#FF6CA4\", \"Antigua and Barbuda\" = \"#FF6CA4\",\n    \"Curacao\" = \"#FF6CA4\", \"Aruba\" = \"#FF6CA4\", \"Bonaire\" = \"#FF6CA4\",\n    \"Sint Maarten\" = \"#FF6CA4\"\n  )) +\n  labs(y = NULL) +\n  theme_minimal() +\n  theme(\n    panel.grid.major.y = element_line(color = \"gray90\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.text.y = element_text(size = 10, hjust = 1),\n    axis.text.x = element_text(size = 10),\n    axis.text.x.sec = element_text(size = 10),\n    axis.text=element_markdown (),\n    axis.title.x = element_text(size = 12),\n    legend.position = \"none\",  # No legend\n    plot.margin = margin(1, 1, 1, 1, \"cm\")\n  )\n\n\n\nWhile this graph is very informative, it is challenging to read. First, there are too many colors associated with the countries that don’t suggest any obvious pattern. Since it is a double x-axis graph it’s hard to understand where one should begin to interpret the graph.\nAlternative Graph 1\nIn this version of the graph, I have regrouped the countries by their respective regions: South America, North and Central America, and the Caribbean. Where there was previously too many colors I have now concentrated it to three colors- one for each region. By restructured the countries in this way and in descending order the readers focus should be pulled towards to the “Total COVID-19 cases that have been sequenced (%)” data. This allows a more organized way of interpreting the graph.\nDefine New Country order\nThis step redefines the countries in descending order by “Total COVID-19 cases that have been sequenced (%)”\n\n\ncountry_order <- c(\n  \"Bolivia\", \"Argentina\", \"Uruguay\", \"Venezuela\", \"Paraguay\", \"Guyana\",\n  \"Colombia\", \"Brazil\", \"Peru\", \"Ecuador\", \"Chile\", \"Suriname\",\n  \"Honduras\", \"Guatemala\", \"El Salvador\", \"Costa Rica\", \"Panama\",\n  \"Mexico\", \"Belize\", \"Nicaragua\", \"Cuba\", \"Dominican Republic\",\n  \"Barbados\", \"Dominica\", \"Grenada\", \"Saint Barthélemy\", \"Guadeloupe\",\n  \"Haiti\", \"Saint Lucia\", \"Bahamas\", \"Jamaica\", \"Bermuda\",\n  \"Saint Kitts and Nevis\", \"Trinidad and Tobago\", \"Saint Martin\",\n  \"Saint Vincent and the Grenadines\", \"Antigua and Barbuda\",\n  \"Curacao\", \"Aruba\", \"Bonaire\", \"Sint Maarten\"\n)\n\n\nData Loading Preparation\n\n\ncovid_data <- read_csv(\"SARS-CoV-2.csv\") %>%\n  mutate(\n    Country = factor(Country, levels = rev(country_order))\n  ) %>%\n  filter(!is.na(Country))  \n\n\nTransformation Function\nThis function transforms genome counts to a percentage scale, using a logarithmic transformation to handle wide ranges of data.\n\n\ngenome_to_pct <- function(x) {\n  x_log <- log10(x)\n  min_log <- log10(2)  \n  max_log <- log10(129677)  \n  scaled_value <- 2.5 + ((x_log - min_log) / (max_log - min_log)) * 19.5\n  return(scaled_value)\n}\n\nbreaks <- c(1, 10, 100, 1000, 10000, 100000)\n\n\nPlotting the Graph\n\n\nggplot() +\n  geom_col(\n    data = covid_data,\n    aes(x = Prop_sequenced_cases, y = Country, fill = Country),\n    alpha = 0.6,\n    width = 0.8\n  ) +\n  geom_point(\n    data = covid_data,\n    aes(x = genome_to_pct(Genomes), y = Country, color = Country),\n    size = 1.3\n  ) +\n  scale_x_continuous(\n    name = \"Total COVID-19 cases that have been sequenced (%)\",\n    limits = c(0, 25),\n    breaks = seq(0, 25, 5),\n    expand = c(0, 0),\n    sec.axis = sec_axis(\n      trans = ~10^((. - 0) / 25 * (log10(129677) - log10(1)) + log10(1)),\n      name = \"Total genomes sequenced (dots)\",\n      breaks = breaks,\n      labels = c(\"1\", \"10\", \"100\", \"1k\", \"10k\", \"100k\")\n    )\n  ) +\n  scale_fill_manual(values = c(\n    \"Argentina\" = \"#ea874b\", \"Bolivia\" = \"#ea874b\", \"Brazil\" = \"#ea874b\",\n    \"Chile\" = \"#ea874b\", \"Colombia\" = \"#ea874b\", \"Ecuador\" = \"#ea874b\",\n    \"Guyana\" = \"#ea874b\", \"Paraguay\" = \"#ea874b\", \"Peru\" = \"#ea874b\",\n    \"Suriname\" = \"#ea874b\", \"Uruguay\" = \"#ea874b\", \"Venezuela\" = \"#ea874b\",\n    \"Honduras\" = \"#a6e0a6\", \"Guatemala\" = \"#a6e0a6\", \"El Salvador\" = \"#a6e0a6\",\n    \"Costa Rica\" = \"#a6e0a6\", \"Panama\" = \"#a6e0a6\", \"Belize\" = \"#a6e0a6\",\n    \"Nicaragua\" = \"#a6e0a6\", \"Mexico\" = \"#a6e0a6\", \"Bahamas\" = \"#4b85ea\",\n    \"Bermuda\" = \"#4b85ea\", \"Cuba\" = \"#4b85ea\", \"Dominican Republic\" = \"#4b85ea\",\n    \"Haiti\" = \"#4b85ea\", \"Jamaica\" = \"#4b85ea\", \"Barbados\" = \"#4b85ea\",\n    \"Dominica\" = \"#4b85ea\", \"Saint Barthélemy\" = \"#4b85ea\", \"Grenada\" = \"#4b85ea\",\n    \"Saint Lucia\" = \"#4b85ea\", \"Guadeloupe\" = \"#4b85ea\", \"Saint Kitts and Nevis\" = \"#4b85ea\",\n    \"Trinidad and Tobago\" = \"#4b85ea\", \"Saint Martin\" = \"#4b85ea\",\n    \"Saint Vincent and the Grenadines\" = \"#4b85ea\", \"Antigua and Barbuda\" = \"#4b85ea\",\n    \"Curacao\" = \"#4b85ea\", \"Aruba\" = \"#4b85ea\", \"Bonaire\" = \"#4b85ea\",\n    \"Sint Maarten\" = \"#4b85ea\"\n  )) +\n  scale_color_manual(values = c(\n    \"Argentina\" = \"#a4501e\", \"Bolivia\" = \"#a4501e\", \"Brazil\" = \"#a4501e\",\n    \"Chile\" = \"#a4501e\", \"Colombia\" = \"#a4501e\", \"Ecuador\" = \"#a4501e\",\n    \"Guyana\" = \"#a4501e\", \"Paraguay\" = \"#a4501e\", \"Peru\" = \"#a4501e\",\n    \"Suriname\" = \"#a4501e\", \"Uruguay\" = \"#a4501e\", \"Venezuela\" = \"#a4501e\",\n    \"Honduras\" = \"#236a42\", \"Guatemala\" = \"#236a42\", \"El Salvador\" = \"#236a42\",\n    \"Costa Rica\" = \"#236a42\", \"Panama\" = \"#236a42\", \"Belize\" = \"#236a42\",\n    \"Nicaragua\" = \"#236a42\", \"Mexico\" = \"#236a42\", \"Bahamas\" = \"#23447a\",\n    \"Bermuda\" = \"#23447a\", \"Cuba\" = \"#23447a\", \"Dominican Republic\" = \"#23447a\",\n    \"Haiti\" = \"#23447a\", \"Jamaica\" = \"#23447a\", \"Barbados\" = \"#23447a\",\n    \"Dominica\" = \"#23447a\", \"Saint Barthélemy\" = \"#23447a\", \"Grenada\" = \"#23447a\",\n    \"Saint Lucia\" = \"#23447a\", \"Guadeloupe\" = \"#23447a\", \"Saint Kitts and Nevis\" = \"#23447a\",\n    \"Trinidad and Tobago\" = \"#23447a\", \"Saint Martin\" = \"#23447a\",\n    \"Saint Vincent and the Grenadines\" = \"#23447a\", \"Antigua and Barbuda\" = \"#23447a\",\n    \"Curacao\" = \"#23447a\", \"Aruba\" = \"#23447a\", \"Bonaire\" = \"#23447a\",\n    \"Sint Maarten\" = \"#23447a\"\n  )) +\n  labs(y = NULL) +\n  theme_minimal() +\n  theme(\n    panel.grid.major.y = element_line(color = \"gray90\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.text.y = element_text(size = 10, hjust = 1),\n    axis.text.x = element_text(size = 10),\n    axis.text.x.sec = element_text(size = 10),\n    axis.text = element_markdown(),\n    axis.title.x = element_text(size = 12),\n    legend.position = \"none\",  # No legend\n    plot.margin = margin(1, 1, 1, 1, \"cm\")\n  )\n\n\n\nAlternative Graph 2\nThis second alternative of the graph keeps the countries grouped by their regions and their respective colors from the first alternative graph. However, they are now instead organized by “Total genomes sequenced (dots)” in ascending order. Again the purpose here is to draw the readers focus to the data provided by one of the x-axis, instead of spending time trying to decipher both x-axis at the same time. This allows a more structured way to understand the information being presented.\nDefine New Country order\nThis step redefines the countries in ascending order by “Total genomes sequenced (dots)”\n\n\ncountry_order <- c(\n  \"Brazil\", \"Chile\", \"Peru\", \"Colombia\", \"Argentina\", \"Ecuador\", \"Paraguay\",\n  \"Suriname\", \"Uruguay\", \"Venezuela\", \"Bolivia\", \"Guyana\", \"Mexico\", \"Panama\",\n  \"Costa Rica\", \"Guatemala\", \"Belize\", \"Nicaragua\", \"El Salvador\", \"Honduras\",\n  \"Aruba\", \"Trinidad and Tobago\", \"Sint Maarten\", \"Curacao\", \"Bonaire\",\n  \"Dominican Republic\", \"Jamaica\", \"Guadeloupe\", \"Bahamas\", \"Saint Martin\",\n  \"Saint Vincent and the Grenadines\", \"Antigua and Barbuda\", \"Haiti\",\n  \"Saint Lucia\", \"Bermuda\", \"Barbados\", \"Saint Kitts and Nevis\", \"Grenada\",\n  \"Dominica\", \"Saint Barthélemy\", \"Cuba\"\n)\n\n\nData Loading Preparation\n\n\ncovid_data <- read_csv(\"SARS-CoV-2.csv\") %>%\n  mutate(\n    Country = factor(Country, levels = rev(country_order))\n  ) %>%\n  filter(!is.na(Country))   \n\n\nTransformation Function\nThis function transforms genome counts to a percentage scale, using a logarithmic transformation to handle wide ranges of data.\n\n\ngenome_to_pct <- function(x) {\n  x_log <- log10(x)\n  min_log <- log10(2)  \n  max_log <- log10(129677)  \n  scaled_value <- 2.5 + ((x_log - min_log) / (max_log - min_log)) * 19.5\n  return(scaled_value)\n}\nbreaks <- c(1, 10, 100, 1000, 10000, 100000)\n\n\nPlotting the Graph\n\n\nggplot() +\n  geom_col(\n    data = covid_data,\n    aes(x = Prop_sequenced_cases, y = Country, fill = Country),\n    alpha = 0.6,  \n    width = 0.8\n  ) +\n  geom_point(\n    data = covid_data,\n    aes(x = genome_to_pct(Genomes), y = Country, color = Country),\n    size = 1.3\n  ) +\n  scale_x_continuous(\n    name = \"Total COVID-19 cases that have been sequenced (%)\",\n    limits = c(0, 25),\n    breaks = seq(0, 25, 5),\n    expand = c(0, 0),\n    sec.axis = sec_axis(\n      trans = ~10^((. - 0) / 25 * (log10(129677) - log10(1)) + log10(1)),\n      name = \"Total genomes sequenced (dots)\",\n      breaks = breaks,\n      labels = c(\"1\", \"10\", \"100\", \"1k\", \"10k\", \"100k\")\n    )\n  ) +\n  scale_fill_manual(values = c(\n    \"Brazil\" = \"#ea874b\", \"Chile\" = \"#ea874b\", \"Peru\" = \"#ea874b\",\n    \"Colombia\" = \"#ea874b\", \"Argentina\" = \"#ea874b\", \"Ecuador\" = \"#ea874b\",\n    \"Paraguay\" = \"#ea874b\", \"Suriname\" = \"#ea874b\", \"Uruguay\" = \"#ea874b\",\n    \"Venezuela\" = \"#ea874b\", \"Bolivia\" = \"#ea874b\", \"Guyana\" = \"#ea874b\",\n    \"Mexico\" = \"#a6e0a6\", \"Panama\" = \"#a6e0a6\", \"Costa Rica\" = \"#a6e0a6\",\n    \"Guatemala\" = \"#a6e0a6\", \"Belize\" = \"#a6e0a6\", \"Nicaragua\" = \"#a6e0a6\",\n    \"El Salvador\" = \"#a6e0a6\", \"Honduras\" = \"#a6e0a6\", \"Aruba\" = \"#4b85ea\",\n    \"Trinidad and Tobago\" = \"#4b85ea\", \"Sint Maarten\" = \"#4b85ea\",\n    \"Curacao\" = \"#4b85ea\", \"Bonaire\" = \"#4b85ea\", \"Dominican Republic\" = \"#4b85ea\",\n    \"Jamaica\" = \"#4b85ea\", \"Guadeloupe\" = \"#4b85ea\", \"Bahamas\" = \"#4b85ea\",\n    \"Saint Martin\" = \"#4b85ea\", \"Saint Vincent and the Grenadines\" = \"#4b85ea\",\n    \"Antigua and Barbuda\" = \"#4b85ea\", \"Haiti\" = \"#4b85ea\", \"Saint Lucia\" = \"#4b85ea\",\n    \"Bermuda\" = \"#4b85ea\", \"Barbados\" = \"#4b85ea\", \"Saint Kitts and Nevis\" = \"#4b85ea\",\n    \"Grenada\" = \"#4b85ea\", \"Dominica\" = \"#4b85ea\", \"Saint Barthélemy\" = \"#4b85ea\",\n    \"Cuba\" = \"#4b85ea\"\n  )) +\n  scale_color_manual(values = c(\n    \"Brazil\" = \"#a4501e\", \"Chile\" = \"#a4501e\", \"Peru\" = \"#a4501e\",\n    \"Colombia\" = \"#a4501e\", \"Argentina\" = \"#a4501e\", \"Ecuador\" = \"#a4501e\",\n    \"Paraguay\" = \"#a4501e\", \"Suriname\" = \"#a4501e\", \"Uruguay\" = \"#a4501e\",\n    \"Venezuela\" = \"#a4501e\", \"Bolivia\" = \"#a4501e\", \"Guyana\" = \"#a4501e\",\n    \"Mexico\" = \"#236a42\", \"Panama\" = \"#236a42\", \"Costa Rica\" = \"#236a42\",\n    \"Guatemala\" = \"#236a42\", \"Belize\" = \"#236a42\", \"Nicaragua\" = \"#236a42\",\n    \"El Salvador\" = \"#236a42\", \"Honduras\" = \"#236a42\", \"Aruba\" = \"#23447a\",\n    \"Trinidad and Tobago\" = \"#23447a\", \"Sint Maarten\" = \"#23447a\",\n    \"Curacao\" = \"#23447a\", \"Bonaire\" = \"#23447a\", \"Dominican Republic\" = \"#23447a\",\n    \"Jamaica\" = \"#23447a\", \"Guadeloupe\" = \"#23447a\", \"Bahamas\" = \"#23447a\",\n    \"Saint Martin\" = \"#23447a\", \"Saint Vincent and the Grenadines\" = \"#23447a\",\n    \"Antigua and Barbuda\" = \"#23447a\", \"Haiti\" = \"#23447a\", \"Saint Lucia\" = \"#23447a\",\n    \"Bermuda\" = \"#23447a\", \"Barbados\" = \"#23447a\", \"Saint Kitts and Nevis\" = \"#23447a\",\n    \"Grenada\" = \"#23447a\", \"Dominica\" = \"#23447a\", \"Saint Barthélemy\" = \"#23447a\",\n    \"Cuba\" = \"#23447a\"\n  )) +\n  labs(y = NULL) +\n  theme_minimal() +\n  theme(\n    panel.grid.major.y = element_line(color = \"gray90\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.text.y = element_text(size = 10, hjust = 1),\n    axis.text.x = element_text(size = 10),\n    axis.text.x.sec = element_text(size = 10),\n    axis.text = element_markdown(),\n    axis.title.x = element_text(size = 12),\n    legend.position = \"none\",  # No legend\n    plot.margin = margin(1, 1, 1, 1, \"cm\")\n  )\n\n\n\nInteractive Graph\nThis interactive version of the graph provides a simpler interpretation of the graph. The list of countries is now on the x-axis and the y-axis scaled the “Number of Genomes Sequenced.” Since the focus of the paper is on genomes sequenced, it made sense to display this information first. Then when you hover over a countries bar, you get the more specific number for genomes sequenced and the proportion of sequenced cases.\nRequired Libraries\n\n\nlibrary(highcharter)\nlibrary(dplyr)\n\n\nDefine New Country order\nThis step defines a custom order for the countries in the visualization. The order is crucial for the graph’s readability\n\n\ncountry_order <- c(\n  \"Brazil\", \"Chile\", \"Peru\", \"Colombia\", \"Argentina\", \"Ecuador\", \"Paraguay\",\n  \"Suriname\", \"Uruguay\", \"Venezuela\", \"Bolivia\", \"Guyana\", \"Mexico\", \"Panama\",\n  \"Costa Rica\", \"Guatemala\", \"Belize\", \"Nicaragua\", \"El Salvador\", \"Honduras\",\n  \"Aruba\", \"Trinidad and Tobago\", \"Sint Maarten\", \"Curacao\", \"Bonaire\",\n  \"Dominican Republic\", \"Jamaica\", \"Guadeloupe\", \"Bahamas\", \"Saint Martin\",\n  \"Saint Vincent and the Grenadines\", \"Antigua and Barbuda\", \"Haiti\",\n  \"Saint Lucia\", \"Bermuda\", \"Barbados\", \"Saint Kitts and Nevis\", \"Grenada\",\n  \"Dominica\", \"Saint Barthélemy\", \"Cuba\"\n)\n\n\nData Loading Preparation\n\n\ncovid_data <- read_csv(\"SARS-CoV-2.csv\") %>%\n  mutate(Country = factor(Country, levels = country_order)) %>%\n  arrange(Country)\n\n\nTransformation Function\nThis function transforms genome counts to a percentage scale, using a logarithmic transformation to handle wide ranges of data.\nDefine custom colors for bars\n\n\nbar_colors <- c(\n  \"Brazil\" = \"#ea874b\", \"Chile\" = \"#ea874b\", \"Peru\" = \"#ea874b\",\n  \"Colombia\" = \"#ea874b\", \"Argentina\" = \"#ea874b\", \"Ecuador\" = \"#ea874b\",\n  \"Paraguay\" = \"#ea874b\", \"Suriname\" = \"#ea874b\", \"Uruguay\" = \"#ea874b\",\n  \"Venezuela\" = \"#ea874b\", \"Bolivia\" = \"#ea874b\", \"Guyana\" = \"#ea874b\",\n  \"Mexico\" = \"#a6e0a6\", \"Panama\" = \"#a6e0a6\", \"Costa Rica\" = \"#a6e0a6\",\n  \"Guatemala\" = \"#a6e0a6\", \"Belize\" = \"#a6e0a6\", \"Nicaragua\" = \"#a6e0a6\",\n  \"El Salvador\" = \"#a6e0a6\", \"Honduras\" = \"#a6e0a6\", \"Aruba\" = \"#4b85ea\",\n  \"Trinidad and Tobago\" = \"#4b85ea\", \"Sint Maarten\" = \"#4b85ea\",\n  \"Curacao\" = \"#4b85ea\", \"Bonaire\" = \"#4b85ea\", \"Dominican Republic\" = \"#4b85ea\",\n  \"Jamaica\" = \"#4b85ea\", \"Guadeloupe\" = \"#4b85ea\", \"Bahamas\" = \"#4b85ea\",\n  \"Saint Martin\" = \"#4b85ea\", \"Saint Vincent and the Grenadines\" = \"#4b85ea\",\n  \"Antigua and Barbuda\" = \"#4b85ea\", \"Haiti\" = \"#4b85ea\", \"Saint Lucia\" = \"#4b85ea\",\n  \"Bermuda\" = \"#4b85ea\", \"Barbados\" = \"#4b85ea\", \"Saint Kitts and Nevis\" = \"#4b85ea\",\n  \"Grenada\" = \"#4b85ea\", \"Dominica\" = \"#4b85ea\", \"Saint Barthélemy\" = \"#4b85ea\",\n  \"Cuba\" = \"#4b85ea\"\n)\n\n\nMap colors to data\n\n\ncovid_data <- covid_data %>%\n  mutate(Color = bar_colors[as.character(Country)])\n\n\nPlotting the Graph\n\n\nhchart(covid_data, \"column\", hcaes(x = Country, y = Genomes, color = Color)) %>%\n  hc_title(text = \"Genomes Sequenced by Country\") %>%\n  hc_xAxis(\n    title = list(text = \"Country\"),\n    categories = country_order,\n    gridLineWidth = 0 \n  ) %>%\n  hc_yAxis(\n    title = list(text = \"Number of Genomes Sequenced\"),\n    type = \"logarithmic\",\n    gridLineWidth = 1,  \n    gridLineDashStyle = \"Solid\"  \n  ) %>%\n  hc_tooltip(\n    pointFormat = paste(\n      \"Genomes sequenced: <b>{point.y}<\/b><br>\",\n      \"Proportion sequenced cases: <b>{point.Prop_sequenced_cases}%<\/b>\"\n    )\n  ) %>%\n  hc_plotOptions(column = list(\n    dataLabels = list(enabled = FALSE),\n    showInLegend = FALSE\n  )) %>%\n  hc_add_theme(hc_theme_flat())\n\n\n\n\n\n\n",
    "preview": "projects/2024/100540514/100540514_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1536,
    "preview_height": 1536
  },
  {
    "path": "projects/2024/100546612/",
    "title": "Behind the numbers: comparing extreme poverty and GDP per capita by world regions",
    "description": "By recreating from group up a OurWorldinData chart about extreme poverty vs\nGDP per capita we look at the foundations of Data Visualisation techniques\nlayer by layer. Further, this project also proposes 2 alternative\nrepresentation for the original data to better understand the story behin\nthe numbers.",
    "author": [
      {
        "name": "Mafalda González-González",
        "url": {}
      }
    ],
    "date": "2025-01-17",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nOn Extreme poverty and GDP\nBefore we start…\nLibrary and fonts\nRetrieving and tidying the data\nCleaning the data\n\nReplicating the original graph\nStarting point: facet_wrap by region and rough approximation\nDimensions: second starting point\nAxes skeleton and custom grid\nTheme\nTitles\nAnnotations and Descriptions\nLogo\n\nComparison\nLimitations\nLessons\n\nImprovement Possibilities\nThe original graph\n\nThe bare naked story\nProcessing of the data\nCreating our graph\n\nBare naked story, but with jewellery\nGG plot it\n\nOn Extreme poverty and GDP\nWhen asked if the world’s population living in extreme poverty has halved, stayed the same, or double in the last 20 years, about two thirds of respondents will say it has doubled – when, in fact, it has more than halved, which only one in in every ten person will guess. The misconception stems out our dichotomous perception of the social classes between rich and poor, all the while an overwhelming majority of people live in between those two extremes. The inaccurate negative understanding of this economic asymmetry brings us to two key points: firstly, we believe that everything everywhere is becoming worse which leads to, secondly, diverting our attention away from the actual trends at hand.\nOurWorldinData takes a closer look at the current developments in poverty. Particularly, they are interested in highlighting the necessity to differentiate between people living in poverty, and people living in extreme poverty, i.e. living on less than 2.15$ a day, as without this distinction we would not understand the crucial differences and trends in living standards within impoverished people. In the graph below we can observe how with this metric relates to the GDP of a country. Tackling out previously mentioned key points, we see the important share of wealth that has propelled many world regions out of extreme poverty in the last 200 years, and at the same time recognize which world regions have disproportionate percentages of extreme poverty in comparison to other regions. While it takes just a bit to understand the underlying relationship that OurWorldinData seeks to visualize, the point is that economic growth implies poverty decline, and stagnated economies imply higher poverty rates.\nOriginal graph sourced from Our World in Data.Hence, to quote Max Roser, the author of this graph and corresponding article, “what needs explanation is not poverty, but prosperity.” I find this point particularly intriguing, and will refer back to it in my proposal for the graph improvement. However, first let us take a look at the replication of the original\nBefore we start…\nLibrary and fonts\nTo replicate the graph, the below packages and font families were used. The fonts were retrieved, for free, from Google Fonts. The libraries are commented within the chunks they started being used.\n\n\nlibrary(tidyverse) # readr, dplyr, ggplot2, forcats\nlibrary(ggtext)\nlibrary(grid)\n\n# dowload fonts\nsysfonts::font_add_google(\"Playfair Display\", family = \"playfair display\")\nsysfonts::font_add_google(\"Lato\", family = \"lato\")\nsysfonts::font_add_google(\"Lato\", family = \"lato_light\", regular.wt=300)\n\n# activate fonts to use them with ggplot \nshowtext::showtext_auto()\n\n\nRetrieving and tidying the data\nWhile OurWorldinData does normally provide a direct link to download the data used in their graphs, this specific one did not have such an option. While there is a newer, updated version of the graph, I decided to email directly the creator, Max Roser, who indicated me to the research done by the Organisation for Economic Co-operation and Development OECD. It used to be that the tables with the information about extreme poverty and GDP trends were easily accessible, but now one has to scan the whole article and find the tables like a needle in a hay stack.\n\n\ngdp <- read_csv(\"gdp_world.csv\")\npoverty <- read_csv(\"poverty_world.csv\")\n\n\nWe have two data sets: gdp, 21 observations (years from 1820-2016 in arbitrary increases) over 10 variables (YEAR + country regions), and poverty, with 13 observations (years from 1820-2016 in arbitrary increases) over 9 variables (YEAR + country regions). We will go over the differences below, when we clean the data. First, we will make it tidy adhering to the idea one variable should be stored in one column. Hence, as the column names represet regions, we pivot_longer to create in both data sets a new columns where the region and the metric (GDP or extreme poverty index) is indicated. Finally, we full_join the data sets together and make GDP a numerical variable without spaces. We obtain a tibble with 221 observations over 4 variables: YEAR, region, GDP and poverty.\n\n\n# library(tidyverse) \n# library(dplyr) \n\n# gdp\ngdp <- gdp |> \n  pivot_longer(\n    cols = -YEAR,        \n    names_to = \"region\",  \n    values_to = \"GDP\"      \n  )\n\n# poverty\npoverty <- poverty |> \n  pivot_longer(\n    cols = -YEAR,          \n    names_to = \"region\",  \n    values_to = \"poverty\"  \n  )\n\n# combine\nworld <- gdp |> \n  full_join(poverty, by = c(\"YEAR\", \"region\")) |> \n  mutate(GDP = str_remove_all(GDP, pattern = \"\\\\s\")) |> \n  mutate(GDP = as.numeric(GDP)) \n\nworld\n\n# A tibble: 221 × 4\n    YEAR region                         GDP poverty\n   <dbl> <chr>                        <dbl>   <dbl>\n 1  1820 Western Europe                2307      73\n 2  1820 Eastern Europe                 818      91\n 3  1820 Western Offshoots             2513      55\n 4  1820 Latin America and Carribean    953      NA\n 5  1820 East Asia                     1089      78\n 6  1820 South and Southeast Asia)      929      NA\n 7  1820 Middle East and North Africa   974      75\n 8  1820 Sub-Saharan Africa             800      91\n 9  1820 World                         1174      NA\n10  1830 Western Europe                2384      NA\n# ℹ 211 more rows\n\nCleaning the data\nCleaning the data posed itself as a tedious task due to various challenges. Firstly, as mentioned, the data sets differentiated each other by 8 observations and 1 variable. This is due to GDP having information (observations) during more years and having an extra region, “World,” that represents the global average.\nThe first, and easier task, was to clean the regions names, as some had been spelled differently in the different data set (“Latin America and Carribean” vs “Latin America and Caribbean” and “South and Southeast Asia” vs “South and Southeast Asia)”).\nIn hindsight, the simplest solution would have been to clean the names before merging the data sets. However, as one does learn from their mistakes, I have left my creative, but extremely unnecessarily complicated approach to the task at hand. The idea was to extract the data that contained the wrong names into a “phantom data set”, clean the names, merge the poverty and GDP information, and the re-join that phantom data set into the original data set.\n\n\n# check name disparities\nunique(world$region)\n\n [1] \"Western Europe\"               \"Eastern Europe\"              \n [3] \"Western Offshoots\"            \"Latin America and Carribean\" \n [5] \"East Asia\"                    \"South and Southeast Asia)\"   \n [7] \"Middle East and North Africa\" \"Sub-Saharan Africa\"          \n [9] \"World\"                        \"Latin America and Caribbean\" \n[11] \"South and Southeast Asia\"    \n\n# clean South and Southeast Asia\n\n# create new data set \nclean_southeast <- world |>\n  filter(region %in% c(\"South and Southeast Asia\", \"South and Southeast Asia)\")) |>\n  mutate(region = \"South and Southeast Asia\") |>\n  group_by(YEAR, region = \"South and Southeast Asia\") |>\n\n  # select the first non-missing GDP or poverty value\n  summarise(\n    GDP = first(na.omit(GDP)),\n    poverty = first(na.omit(poverty)),\n    .groups = \"drop\"\n  )\n\n# remove the region from the original dataset \nworld <- world |> \n  filter(!region %in% c(\"South and Southeast Asia\", \n                          \"South and Southeast Asia)\"))\n\nclean_world <- bind_rows(world, clean_southeast)\n\nworld <- clean_world\n\n# clean Latin America and Caribbean\n\nclean_latin <- world |>\n  filter(region %in% c(\"Latin America and Carribean\", \"Latin America and Caribbean\")) |>\n  mutate(region = \"Latin America and Caribbean\") |>\n  group_by(YEAR, region = \"Latin America and Caribbean\") |>\n  summarise(\n    GDP = first(na.omit(GDP)),\n    poverty = first(na.omit(poverty)),\n    .groups = \"drop\"\n  )\n\nworld <- world |> \n  filter(!region %in% c(\"Latin America and Carribean\", \n                        \"Latin America and Caribbean\"))\n\nclean_world <- bind_rows(world, clean_latin)\nworld <- clean_world\n\n\nThe second, also easy, task was to rename the “Western Offshoots” as our goal regions “Australia, New Zealand, USA and Canada” and World as “Global Average.” This was not strictly necessary as the annotations of the regions in the final graph will be done manually, but it did improve clarity during the replication process.\n\n\n# recode names \n\nworld <- world |> \n  mutate(region = recode(region,\n                         \"Western Offshoots\" = \n                           \"Australia, New Zealand, USA and Canada\"), \n         region = recode(region, \"World\" = \"Global Average\"))\n\n\nFinally, the last, and most time-consuming step in the cleaning process was supplementing the data. The hardship with this step was not its execution per se, but figuring out which data to use for the supplementation. The original article that provided the excel tables about the world GDP and poverty trends also included tables with information about 25 countries in both these metrics. Therefore, different questions arose: does GDP need supplementation, as it already has some information for its “Global Average” region? Is the supplementation done with the means of the observations out of 25 countries? Or with the means of the observations of the countries already grouped in regions? Or maybe a mix of both? These questions were answered by trial and error, as OurWorldinData had given me no information thereof nor was there any to find in the original source. Hence, I tried different approaches and looked at its impact in later stages of the replication process. It seemed to me that the mean of the world regions had been used for supplementing the observations both for poverty and GDP, while excluding the already existing GDP information for the calculation of the average of the regions.\n\n\n# calculate means for GDP and poverty by YEAR, excluding \"World\"\nworld_mean <- world |> \n  filter(region != \"Global Average\") |> \n  group_by(YEAR) |> \n  summarise( # create means in new columns \n    avg_poverty = mean(poverty, na.rm = TRUE), \n    avg_gdp = mean(GDP, na.rm = TRUE), \n    .groups = \"drop\"\n  )\n\n# supplementing \"Global Average\" region\nworld_supplemented <- world |> \n  left_join(world_mean, by = \"YEAR\") |> \n  mutate( # add means if they are missing (important for GDP!)\n    poverty = if_else(\n      region == \"Global Average\" & is.na(poverty), \n      avg_poverty, \n      poverty),\n    GDP = if_else(\n      region == \"Global Average\" & is.na(GDP), \n      avg_gdp, \n      GDP)\n  ) |> \n  select(-avg_poverty, -avg_gdp)  # remove temporary average columns\n\nworld <- world_supplemented\n\nworld |>\n  filter(region == \"Global Average\")\n\n# A tibble: 21 × 4\n    YEAR region           GDP poverty\n   <dbl> <chr>          <dbl>   <dbl>\n 1  1820 Global Average 1174     77.1\n 2  1830 Global Average 1663    NaN  \n 3  1840 Global Average 1744.   NaN  \n 4  1850 Global Average 1225     72  \n 5  1860 Global Average 2548.   NaN  \n 6  1870 Global Average 1498     69.1\n 7  1880 Global Average 3830    NaN  \n 8  1890 Global Average 3078.   NaN  \n 9  1900 Global Average 2212     57.4\n10  1910 Global Average 4022    NaN  \n# ℹ 11 more rows\n\nThere are still some years of the poverty index that have no information, these correspond to the years that existed in the GDP data set but not in the poverty data set.\nReplicating the original graph\nThe replication process consisted in roughly approximating my way towards the indications of the original graph, and then fine tuning details as possible and necessary. It involved:\nBasic starting point: facet_wrap by region and rough approximation\nDimensions: second starting point\nAxes skeleton and custom grid\nTitles\nAnnotations\nLogo\nStarting point: facet_wrap by region and rough approximation\nTo understand how the data behaves the first step is to create simple line graphs with geom_path that are separated by regions through facet_wrap. Even though small, this step was crucial as originally my intention had been to create a graph of one region to understand the dimensions of the individual graphs and then replicate it for all 9 regions in order to have more control over fine details. However, it was more practical to actually create the skeletons of all graphs at the same time, and at the end add the details to the totality of the facet_wrap.\nThis basic graph incorporates GDP in the x axis, poverty in the y axis and region into the colors in the aesthetic options. We use a Log scale for GDP, as in the original the x axis is not divided in equal spaces, and a continuous scale for the y axis, which already incorporates percentages in the labels.\n\n\n# library(ggplot2)\nplot_basic <- ggplot(world) +\n  aes(x = GDP, y = poverty, color = region) + \n  scale_x_log10(labels = scales::comma) +  # log scale for GDP\n  scale_y_continuous(labels = scales::percent_format(scale = 1)) +  # percentage for poverty\n  geom_path() +\n  facet_wrap(~ region)\n\nplot_basic\n\n\n\nFrom this basic facet_wrap we can see that we are not done with the processing of the data.1 The lines of each region do not follow the total pattern of the original graph. After trial and error I found out that the problem was in how geom_path worked with missing values. The solution is to exclude all NAs even though we might be losing information on GDP.\n\n\ndata_filtered <- world |>\n  filter(!is.na(poverty) & !is.na(GDP)) \n\n\nWe also include now the background lines of each of the panels. For this, we duplicate the data set and create a second variable of region, “region2”, deleting the original one.\n\n\ndata_filtered_2 <- data_filtered |> \n  mutate(region2 = region, region = NULL) \n\n\nThe lines will be inserted with geom_path indicating our new data set, its x and y axis, and colours, and including a lower alpha to make them appear in the background.\nIn addition, we can order the regions by factoring them so that they appear as in the original graph, and create a colour scheme data set. The colours were matched by using the colour eyedropper tool of Google docs.\n\n\n# library(forcats)\n\n# order countries\ndata_filtered <- data_filtered |>\n  mutate(region = fct_relevel(region,\n    \"Global Average\",\n    \"Western Europe\",\n    \"Australia, New Zealand, USA and Canada\",\n    \"Middle East and North Africa\",\n    \"Eastern Europe\",\n    \"Sub-Saharan Africa\",\n    \"East Asia\",\n    \"South and Southeast Asia\",\n    \"Latin America and Caribbean\"\n  ))\n\n# create colour scheme\ncolour_scheme <- c(\"Global Average\" = \"#840037\",\n                   \"Western Europe\" = \"#203558\",\n                   \"Australia, New Zealand, USA and Canada\" = \"#3f3386\",\n                   \"Middle East and North Africa\" = \"#845100\",\n                   \"Eastern Europe\" = \"#057ea1\",\n                   \"Sub-Saharan Africa\" = \"#951c73\",\n                   \"East Asia\" = \"#30918d\",\n                   \"South and Southeast Asia\" = \"#e0902f\",\n                   \"Latin America and Caribbean\" = \"#d54c3f\")\n\n\nFinally, we also start to approximate the theme by taking away the legends, labs and individual graph titles as in the original graph, and including a minimal theme to provide us with a background similar to the original one.\n\n\nplot_initial <- ggplot(data_filtered) +\n  aes(x = GDP, y = poverty, color = region) + \n  scale_x_log10(labels = scales::comma) +  \n  scale_y_continuous(labels = scales::percent_format(scale = 1)) +\n  \n  # colour of lines \n  scale_color_manual(values = colour_scheme) + \n  \n  # background lines\n  geom_path(data = data_filtered_2,\n            aes(x = GDP, y = poverty, \n                group = region2, \n                color = region2), \n            alpha = 0.2) +\n  \n  geom_path() +\n  facet_wrap(~ region) +\n  \n  # theme: removing legend, x and y labs, titles\n  theme_minimal() + \n  theme(\n    legend.position = \"none\", \n    strip.text = element_blank(),\n    axis.title = element_blank())\n\nplot_initial\n\n\n\nDimensions: second starting point2\nBefore continuing with the actual replication, it is important that we take a moment to note the importance of dimensions for the final output. For the recreating of this tutorial, now would be a good time to decide your dimensions: the proportional width and height, as well as the quality of the final figure.\nWhen choosing dpi its important to consider that the higher the dpi, the smaller the picture and thus the bigger the sizes for e.g. annotations.\nThe dimensions I originally chose for a full screen presentations included dpi (dots per inch) = 300, but for the purposes of this post dpi = 150 is enough. Still, the changes for higher dpi dimensions are included in the commends of the graph.\nThe dimensions for this post are:\n{r, layout=\"l-body-outset\", fig.width = 8, fig.height = 5.8}\nAxes skeleton and custom grid\nHaving done an initial version of the graph and chosen our dimensions, we set out now to come closer to the details of the original. We adjust the x and y scales to match the original breaks, set the minor_breaks to NULL and adjust the labels of the guides, $ and no decimal mark for the x scale and % for the y scale.\nThe original graph’s x axis limits does not start at 0 or end at the 50000 break, but rather starts and ends a bit later. Thus, we set the scales within facet_wrap free and manually determine the limits within each scale. The x axis limits apparently start at 800 (which is the minimum value of the GDP values) and seem to end at somewhere around 57000 (trial and error considering the logarithmic scale).\n\nExplanation: even though we have set the scales free for all panels as a group in the facet_wrap, we have also pre-defined the scales for all panels individually in scale_x_log10 and scale_y_continuous.\n\n\nplot_axes <- ggplot(data_filtered) +\n  aes(x = GDP, y = poverty, color = region) + \n\n  # x axis: breaks + guide details ($, .) + limits \n  scale_x_log10(breaks = c(1000, 2000, 5000, 10000, 20000, 50000),\n                minor_breaks = NULL,\n                labels = scales::label_number(\n                  big.mark = \".\",prefix = \"$\", decimal.mark = \"none\"),\n                limits = c(800, 57000) \n                ) + \n  \n  # y axis: breaks + guide details (%) + limits \n  scale_y_continuous(breaks = c(0, 25, 50, 75, 100),\n                     minor_breaks = NULL,\n                     labels = scales::percent_format(scale = 1),\n                     limits = c(0, 100)\n                     ) +\n\n  scale_color_manual(values = colour_scheme) + \n  geom_path(data = data_filtered_2,\n            aes(x = GDP, y = poverty, \n                group = region2, \n                color = region2), \n            alpha = 0.2, \n            linewidth = 0.25) + # adjusted for new parameter\n  geom_path(linewidth = 0.35) + # adjusted for new parameter\n  \n  # free scales\n  facet_wrap(~ region, scales = \"free\") +\n  \n  theme_minimal() + \n  theme(\n    legend.position = \"none\", \n    strip.text = element_blank(),\n    axis.title = element_blank(), \n    )\n\nplot_axes\n\n\n\nWith correct axis scales we can now create custom grid lines with geom_segment to recreate the appearance, type and colour of the original ones. It would be an option to instead change the specifications in panel.grid.major within the theme. However geom_segment gives us more flexibility as not all y axis grid lines are of the same type in the original graph. Specifically, we want the first and last line, at 0% and 100%, of the y axis to be solid instead of dashed. Note that we also remove ggplot’s default grid lines in the theme section.\n\nCaution! Because we are currently layering two plots on top of each other, the custom grid lines appear on top of our geom_path lines due to the order of commands.\n\n\nplot_grid <- plot_axes +\n  \n  # x axis grid lines (vertical lines)\n  geom_segment(aes(x = 1000, xend = 1000, y = 0, yend = 100), \n                     linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 2000, xend = 2000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 5000, xend = 5000, y = 0, yend = 100),\n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 10000, xend = 10000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 20000, xend = 20000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 50000, xend = 50000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n\n  # y axis grid lines (horizontal lines): \n  geom_segment(aes(x = 800, xend = 57000, y = 0, yend = 0), \n               linetype = \"solid\", linewidth = 0.22, color = \"#aeaeae\") + \n  geom_segment(aes(x = 800, xend = 57000, y = 25, yend = 25), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 50, yend = 50), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 75, yend = 75), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 100, yend = 100), \n               linetype = \"solid\", linewidth = 0.22, color = \"#aeaeae\") +\n\n  theme(\n    legend.position = \"none\", \n    strip.text = element_blank(),\n    axis.title = element_blank(), \n    \n    # removing ggplot's default grid lines \n    panel.grid.major = element_blank(),\n    )\n\nplot_grid\n\n\n\nTheme\nThe next step is to replicate with exactitude the theme of the panels of the original graph. For this, we change the background of the panels, expand the panels scales so that the have space for the guides’ labels and at the same time move the guides’ labels within the panels, adjust the between-panel spacing and set the family, colour and size of our labels.\nIn this step we set different hjust for the x axis guides as the “50000” in the original graph is slightly to the left. This makes ggplot plot the text bolder, which we take into consideration by setting its colour lighter than from the guides of the y axis.\n\n\nplot_theme <- ggplot(data_filtered) +\n  aes(x = GDP, y = poverty, color = region) +\n  geom_segment(aes(x = 1000, xend = 1000, y = 0, yend = 100), \n                     linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 2000, xend = 2000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 5000, xend = 5000, y = 0, yend = 100),\n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 10000, xend = 10000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 20000, xend = 20000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 50000, xend = 50000, y = 0, yend = 100), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 0, yend = 0), \n               linetype = \"solid\", linewidth = 0.22, color = \"#aeaeae\") + \n  geom_segment(aes(x = 800, xend = 57000, y = 25, yend = 25), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 50, yend = 50), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 75, yend = 75), \n               linetype = \"21\", linewidth = 0.30, color = \"#ebebeb\") +\n  geom_segment(aes(x = 800, xend = 57000, y = 100, yend = 100), \n               linetype = \"solid\", linewidth = 0.22, color = \"#aeaeae\") +\n  \n  \n  scale_x_log10(breaks = c(1000, 2000, 5000, 10000, 20000, 50000),\n                minor_breaks = NULL,\n                labels = scales::label_number(\n                  big.mark = \".\",prefix = \"$\", decimal.mark = \"none\"),\n                limits = c(800, 57000), \n                \n                # expanding panels: width\n                expand = expansion(add = c(0.17, 0.05))\n                ) + \n  \n  scale_y_continuous(breaks = c(0, 25, 50, 75, 100),\n                     minor_breaks = NULL,\n                     labels = scales::percent_format(scale = 1), \n                     limits = c(0, 100),\n                     \n                     # expanding panels: height\n                     expand = expansion(mult = c(0.08, 0.04))\n                     ) +\n\n  scale_color_manual(values = colour_scheme) + \n  geom_path(data = data_filtered_2,\n            aes(x = GDP, y = poverty, \n                group = region2, \n                color = region2), \n            alpha = 0.2, \n            linewidth = 0.20) + \n  geom_path(linewidth = 0.35) + \n  facet_wrap(~ region, scales = \"free\") +\n  theme_minimal() + \n  theme(\n    legend.position = \"none\", \n    strip.text = element_blank(),\n    axis.title = element_blank(), \n    \n    # axes guides theme \n    axis.text.x = element_text(\n      family = \"lato\", colour = \"#939292\", size = 4.5, #dpi= 300 => 26.5 \n      hjust = c(0.4, 0.4, 0.4, 0.4, 0.4, 0.6), margin = margin(t = -9)), #dpi = 300 => 10\n    axis.text.y = element_text(\n      family = \"lato\", colour = \"#676767\", size = 4.5, #dpi = 300 => 26.5\n      vjust = 0.5, margin = margin(r = -17)), #dpi = 300 => 16\n\n    # panel theme \n    panel.background = element_rect(fill = \"#faf9f9\"), \n    panel.border = element_rect(fill = NA, color = \"#efefef\"), \n    \n    # adjust between-panel spacing\n    panel.spacing.x = unit(0.43, \"lines\"), #dpi = 300 => 0.45\n    panel.spacing.y = unit(0.43, \"lines\"), #dpi = 300 => 0.6\n    \n    panel.grid.major = element_blank()\n    ) \n\nplot_theme\n\n\n\nTitles\nFollowingly, we include the title, subtitle, data sources (caption) and the license information, taking into consideration their different fonts, sizes and colours, i.e. their individual themes. Take into consideration that the “-” appear in R as the length -, even when they are actually of length – or —.\n\n\n# library(ggtext)\n\n# text labels\ngraph_title <- \"By world region: Share living in extreme poverty vs. GDP per capita (1820-2017)\"\n\ngraph_subtitle <- paste(c(\n  \"Poverty is measured by the 'cost of basic needs'-approach. It represents the\",\n  \"share which was unable to obtain a bundle of very basic goods and\",\n  \"services.\\nPrice changes over time (inflation) and price differences between\",\n  \"countries are taken into account in both measures.\"\n  ), collapse=\" \")\n\ngraph_caption <- paste(c(\n  \"Data sources:  Michail Moatsos for data on extreme poverty and Jutta Bolt and\",\n  \"Jan Luiten van Zanden for GDP data – both published in How was life? Volume II,\",\n  \"OECD 2021.<br><span style = 'font-family:lato; color:#403c94;'>OurWorldinData.org<\/span>\",\n  \"– Research and data to make progress against the world's largest problems.\"\n  ), collapse=\" \")\n\ngraph_license <- \"Licensed under <span style = 'color:#403c94;'>CC-BY<\/span> by the author Max Roser\"\n\n\nplot_titles <- plot_theme + \n  \n  # labels\n  labs(title = graph_title, \n       subtitle = graph_subtitle,\n       caption = graph_caption,\n       tag = graph_license) +\n  \n  # theme \n  theme(plot.title = element_text(family = \"playfair display\",\n                                  color = \"#191612\",\n                                  size = 14.7, #dpi = 300 => 91.5\n                                  hjust = 0, \n                                  margin= margin(b = 2, l = -4)),\n        plot.title.position = \"plot\",\n        plot.subtitle = element_text(family = \"lato_light\",\n                                     color = \"#515151\",\n                                     size = 8, #8 #dpi = 300 => 51\n                                     hjust = 0, \n                                     lineheight = 0.9, #dpi = 300 => 0.14\n                                     margin= margin(b = 4, l = -1.8)),\n        plot.caption = element_markdown(family = \"lato_light\",\n                                        color = \"#191612\",\n                                        size = 7.7, #dpi = 300 => 48\n                                        hjust = 0, \n                                        lineheight = 1.2, #dpi = 300 => 0.19\n                                        margin= margin(t = 8, l = -1.8)\n                                        ),\n        plot.caption.position = \"plot\",\n        plot.tag = element_markdown(family = \"lato_light\",\n                                color = \"#191612\",\n                                size = 7.8, #dpi = 300 => 49\n                                hjust = 1),\n        plot.tag.position = c(0.993,0.010)) + \n  coord_cartesian(clip = \"off\")\n\nplot_titles\n\n\n\nAnnotations and Descriptions\nFinally, we insert the annotations and descriptions into the individual regions’ panels. This task was a bit tiresome due to the sheer number of individual annotations that needed to be done, and as they are not standardized (e.g. all regions names in one corner), each annotation needed its own coordinates. It is important that this is our last step as it heavily relies on the exact coordinates for each annotation position. We use geom_text and not annotate because annotate does not allow us to filter which panel to annotate in, instead always conducting the command in all faceted graphs.\n\n\nplot_final <- plot_titles +\n  \n  # years by region path \n  geom_text(\n    aes(label = YEAR), \n    color = \"black\", \n    family = \"lato\",\n    size = 1, #dpi = 300 => 6.8\n    hjust = 0,\n    nudge_x = 0.03,\n    check_overlap = TRUE\n    ) +\n  \n  # annotations 3 upper plots \n  geom_text(\n    data = data_filtered |>  filter (region %in% c(\"Global Average\", \"Western Europe\", \n                                                   \"Australia, New Zealand, USA and Canada\")), \n    aes(x = 800, y = 94, \n        label = \"Share living in extreme poverty\"), \n    family = \"lato\", \n    colour = \"#939292\", \n    size = 1.7, #dpi = 300 => 11\n    hjust = 0.19,  \n    vjust = -0.1 #0  \n  ) +\n  \n  # annotations and descriptions by region\n  geom_text(\n    data = data_filtered |> filter(region == \"Global Average\"),\n    aes(x = 5700, y = 53, label = region),\n    family = \"lato\", \n    colour = \"#840037\",\n    size = 2.8, #dpi = 300 => 18.5  \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Global Average\"),\n    aes(x = 1300, y = 88, \n        label = \"1820: Three-quarters of the world \n        lived in extreme poverty\"\n        ),\n    family = \"lato_light\",\n    colour = \"#840037\",\n    size = 1.8,  #dpi = 300 => 11\n    hjust = 0, \n    vjust = 0\n    ) +\n  \n    geom_text(\n    data = data_filtered |> filter(region == \"Global Average\"),\n    aes(x = 1300, y = 78, \n        label = \"Three-quarters of the world \\\"could not affort a tiny space to live, \n        some\\nminimum heating capacity, and food that would not induce malnutrition.\\\"\"\n        ),\n    family = \"lato_light\",\n    colour = \"#840037\",\n    size = 1.6, #dpi = 300 => 10  \n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) +\n  \n      geom_text(\n    data = data_filtered |> filter(region == \"Global Average\"),\n    aes(x = 18000, y = 15, \n        label = \"9% of the world live\\nin extreme poverty\"\n        ),\n    family = \"lato_light\",\n    colour = \"#840037\",\n    size = 1.8, #dpi = 300 => 11  \n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Western Europe\"),\n    aes(x = 2900, y = 68, label = region),\n    family = \"lato\",\n    colour = \"#203558\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Australia, New Zealand, USA and Canada\"),\n    aes(x = 4000, y = 66, label = \"Australia, New Zealand,\\nUSA and Canada\"),\n    family = \"lato\",\n    colour = \"#3f3386\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) +\n  \n    geom_text(\n    data = data_filtered |> filter(region == \"Australia, New Zealand, USA and Canada\"),\n    aes(x = 4000, y = 52, \n        label = \"These four countries had already achieved\\nenough \n        economic growth to reduce extreme\\npoverty to very low levels \n        in the post-war years.\"\n        ),\n    family = \"lato_light\",\n    colour = \"#3f3386\", \n    size = 1.6, #dpi = 300 => 10\n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) +\ngeom_text(\n    data = data_filtered |> filter(region == \"Middle East and North Africa\"),\n    aes(x = 4000, y = 33, label = region),\n    family = \"lato\",\n    colour = \"#845100\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Eastern Europe\"),\n    aes(x = 1230, y = 19, label = region),\n    family = \"lato\",\n    colour = \"#057ea1\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Sub-Saharan Africa\"),\n    aes(x = 3750, y = 66, label = region),\n    family = \"lato\",\n    colour = \"#951c73\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +  \n  \n  geom_text(\n    data = data_filtered |> filter(region == \"Sub-Saharan Africa\"),\n    aes(x = 3800, y = 52, \n        label = \"According to the lastest data 37% of the\\npopulation \n        live in extreme poverty in\\nthe world's poorest region.\"\n        ),\n    family = \"lato_light\",\n    colour = \"#951c73\", \n    size = 1.6, #dpi = 300 => 10\n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"East Asia\"),\n    aes(x = 3900, y = 55, label = region),\n    family = \"lato\",\n    colour = \"#30918d\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(\n    data = data_filtered |> filter(region == \"South and Southeast Asia\"),\n    aes(x = 1850, y = 54, label = region),\n    family = \"lato\",\n    colour = \"#e0902f\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n\n  geom_text(\n    data = data_filtered |> filter(region == \"Latin America and Caribbean\"),\n    aes(x = 3600, y = 68, label = region),\n    family = \"lato\",\n    colour = \"#d54c3f\", \n    size = 2.1, #dpi = 300 => 14 \n    hjust = 0, \n    vjust = 0\n    ) +\n  \n  geom_text(data = data_filtered |> filter(region == \"Latin America and Caribbean\"),\n    aes(x = 3600, y =54, \n        label = \"As a world region with very high inequality\\nthe \n        share in poverty was comparatively high\\nat any given level of \n        average income.\"\n        ),\n    family = \"lato_light\",\n    colour = \"#d54c3f\", \n    size = 1.6, #dpi = 300 => 10\n    hjust = 0, \n    vjust = 0, \n    lineheight = 0.8 #dpi = 300 => 0.14\n    ) \n\nplot_final  \n\n\n\nLogo\nWhile our code for the graph is completed as it is, we can include the OurWorldinData logo with a simple trick. We manually overlay the image of the logo on top of the figure of the replicated graph we have created. We can do this with the grid package by indicating where the logo will appear relative to the final figure, and then drawing the logo on top of the plot.\n\n\n# library(grid)\n\nimage_grob <- rasterGrob(png::readPNG(\"Our_World_in_Data_logo.png\"),\n                         x = 0.997, y = 0.992,  \n                         hjust = 1, vjust = 1, \n                         width = unit(0.082, \"npc\")) \n\n# new plotting canvas\nreplication <- grid.newpage() + # plot graph\n  grid.draw(ggplotGrob(plot_final)) + # overlay logo\n  grid.draw(image_grob)\n\n\n\nComparison\nHere the result of our replication (right) compared to the original graph:\n\n\nOriginal\n\n\n\n\n\nReplication\n\n\n\n\n\nLimitations\nWhile we are able to almost fully replicate the original graph, some small issues escape us:\nThe annotations font is fatter than the original one. I tried with different variations of the font Lato (e.g. lato light), but nothing comes closer to the original.\nThe years annotations following the regions’ line path are not exactly in the same positions as the original.\nThe original graphs’ foreground regions’ line paths are actually small arrows, while the background line paths are normal lines. We could use geom_arrow for the foreground lines, but it does not have the same arguments that geom_path. Due to our dimensions we have to specify some arguments like linewidth for the lines to replicate the original ones, hence, we loose the arrows.\nLessons\nThe most important takeaway’s from this exercise for me are the knowledge I have gained about the expansion and limits arguments, how much the dimensions can affect the final product and to keep that in mind from the beginning, and how the order of commands impact the display of the plot.\nImprovement Possibilities\nThe original graph\n\n\nThe original graph portrays the relationship between the share living in extreme poverty and the GDP per capita in 8 world regions and the global average between the years 1817 and 2017.\n\n\nThe original graphs’ strengths include its clear comparison between the world regions wealth and poverty trends, which highlight the significant variation between regions, and its historical perspective, which provides some context for the global and regional progress. Visually, the regional facets and colouring contribute to their acute distinction and provide clarity and readability.\nStill, we find improvement possibilities.\nFirstly, visually, 9 facets are overstimulating and hard to read all together. Scaling back the information between the graphs can help better understand them. The colours, while pretty, do not actually provide additional help in reading between the graphs. The background lines are faint, so that one can not actually compare a region with a different one, also because one keeps forgetting which colour belongs to which region.\nContent-wise, the graph fails to tell a story, which is the improvement I would like to propose. The original graph displays the decline of extreme poverty oversimplified in relation to GDP per capita, while ignoring a larger issue at stake: how the individual regions, and their economic classifications, play into each others rise and fall. While we can compare world regions, I would like to propose to compare the Global South to the Global North, in order to take a better look at their interplay of GDP per capita and extreme poverty, and augment the historical perspective the original graph hinted on. The power games that we can display reflect the global political dynamics, and might make us come closer to Max Roser’s proposition: “What needs explanation is not poverty, but prosperity”.\nThis change in narrative clarity will allow us to improve visual readability, as grouping by Global South and Global North with distinct colour schemes will allow for clearer comparisons, firstly identifying regional disparities as well as global trends with GDP per capita and extreme poverty, and secondly, between the trends of GDP per capita and extreme poverty themselves.\nThe bare naked story\nTo try to access this side of the story on global economic development and extreme poverty we can create a simple streamgraph that however manages to make strong visual point of the inverse relationship between poverty and GDP.\nFor that, we use the streamgraph package of hrbrmstr’s github, which at the time of the creation of this article is at version 0.9.0 online, but the changes registred in the github are only until 0.8.1 (i.e. I am unsure if there are new functions apart from the ones I use here). Also, not all of the functions work all of the time, as the package is still being worked at.\n\n\nlibrary(streamgraph)\npackageVersion(\"streamgraph\") # use latest version (0.9.0. for this article) \n\n[1] '0.9.0'\n\nFirstly, we create a second data set for our streamgraphs, in which we factor our regions depending on their inclusion of Global North or Global South3, adding as well a prefix and a divided colour-blind friendly colour palette (South = blues/greens, North = reds, Global = white) to sort them visually in the graph.\nProcessing of the data\n\n\ndata_impr_sg <- data_filtered\n\n# update levels to reflect Global South/North distinction\ndata_impr_sg$region_ordered <- \n  factor(data_impr_sg$region,\n  levels = rev(c(\n             # Global North\n             \"Australia, New Zealand, USA and Canada\", \n             \"Western Europe\",\n             \"Eastern Europe\",\n             \n             # Middle\n             \"Global Average\", \n             \n             # Global South\n             \"Middle East and North Africa\",            \n             \"Latin America and Caribbean\", \n             \"East Asia\",\n             \"South and Southeast Asia\",\n             \"Sub-Saharan Africa\"))) \n\n# add prefix for deterministic sorting \ndata_impr_sg$region_prefix <- \n  recode(data_impr_sg$region_ordered,\n             \"Australia, New Zealand, USA and Canada\" = \"1. Australia, New Zealand, USA and Canada\",\n             \"Western Europe\" =                  \"1. Western Europe\",\n             \"Eastern Europe\" =                  \"1. Eastern Europe\",\n             \"Global Average\" =                  \"2. Global Average\",\n             \"Middle East and North Africa\" =    \"3. Middle East and North Africa\",\n             \"Latin America and Caribbean\" =     \"3. Latin America and Caribbean\",\n             \"East Asia\" =                       \"3. East Asia\",\n             \"South and Southeast Asia\" =        \"3. South and Southeast Asia\",\n             \"Sub-Saharan Africa\" =              \"3. Sub-Saharan Africa\"\n)\n\n# update color palette to align with prefixed names: colours to remain distinct but grouped appropriately\ncb_colors <- c(\"dodgerblue4\", \n               \"#E69F00\", \n               \"#56B4E9\", \n               \"#009E73\", \n               \"#F0E442\", \n               \"red\", \n               \"black\", \n               \"#D55E00\", \n               \"#B9E77C\")\n\ncb_colors_ordered <- c(\n  \"1. Australia, New Zealand, USA and Canada\" = \"#D55E00\",\n  \"1. Western Europe\" = \"red\",\n  \"1. Eastern Europe\" = \"#E69F00\",\n  \"2. Global Average\" = \"white\",\n  \"3. Middle East and North Africa\" = \"aquamarine2\",\n  \"3. Latin America and Caribbean\" = \"#B9E77C\",\n  \"3. East Asia\" = \"#56B4E9\",\n  \"3. South and Southeast Asia\" = \"#009E73\",\n  \"3. Sub-Saharan Africa\" = \"dodgerblue4\"\n)\n\n\nCreating our graph\nWith the available arguments of the package, we can generate two streamgraphs for GDP per capita and extreme poverty individually, set as our x variable a timeline, add a title, our set custom colours for Global South and Global North regions with an anchored Global Average in the middle, and make the plot interactive.\n\n\nsg_poverty <- streamgraph(\n  data_impr_sg, \n  key = \"region_prefix\", \n  value = \"poverty\", \n  date = \"YEAR\", \n  interactive=TRUE) %>%\n  sg_axis_x(tick_interval = 50) %>% # simplifying x axis\n  sg_fill_manual(cb_colors_ordered) %>% # new color palette\n  sg_legend(show = TRUE, label = \"Regions\") %>% # legend for regions\n  sg_title(title = \"Extreme Poverty\") # %>% \n  # sg_annotate at time of publishing not working => ads text anotations\n  # sg_annotate(label = \"Global Average\", x = \"\", y = \"460\", \n              # color = \"black\", size = 16) %>% \n  # sg_annotate(label = \"\\\"Global North\\\"\", x = \"0.05\", y = \"600\", \n              # color = \"black\", size = 20) %>% \n  # sg_annotate(label = \"\\\"Global South\\\"\", x = \"0.05\", y = \"100\", \n              # color = \"black\", size = 20) # %>% \n  # sg_add_marker currently not working => ads a vertical line \n  # sg_add_marker(x = 1900, label = \"1900\", stroke_width = 0.5,\n  # stroke = \"#7f7f7f\", space = 5, y = 0, color = \"#7f7f7f\",\n  # size = 12, anchor = \"start\")\n\nsg_gdp <- streamgraph(\n  data_impr_sg, \n  key=\"region_prefix\", \n  value=\"GDP\", \n  date=\"YEAR\", \n  interactive = TRUE) %>%\n  sg_axis_x(tick_interval = 50) %>%\n  sg_fill_manual(cb_colors_ordered) %>%\n  sg_legend(show = TRUE, label = \"GDP\") %>% \n  sg_title(title = \"GDP per capita\") # %>% \n  # sg_annotate(label = \"Global Average\", x = \"1850\", y = \"62000\", \n              # color = \"black\", size = 16) %>%\n  # sg_annotate(label = \"Global North\", x = \"1850\", y = \"160000\", \n              # color = \"black\", size = 20) %>% \n  # sg_annotate(label = \"Global South\", x = \"1850\", y = \"100\", \n              # color = \"black\", size = 20) # %>% \n  # sg_add_marker(x = 1900, label = \"1900\", stroke_width = 0.5,\n  # stroke = \"#7f7f7f\", space = 5, y = 0, color = \"#7f7f7f\",\n  # size = 12, anchor = \"start\")\n\n\n\n\nExtreme Poverty\n\n\n\n\nGDP per capita\n\n\n\n\nWhile simple, the streamgraph allows us to see a story with clarity. While the growth of GDP per capita and the decline of extreme poverty are clearly related, we get to appreciate also the persistence of extreme poverty in the Global South as well as the disproportionate “growth” of GDP per capita in the Global North.\nBare naked story, but with jewellery\nEven though the simplicity of the graph enhances the storytelling aspect, there are some key features that make a graph comprehensible without the need of explanations:\nWe aim to add proper titleling, with subtitles explaining the different regions and indicating their colour and a caption for additional information and source indication.\nWe take away the y axis indications, as it has has different values for each graph and is difficult to read, while not adding clarification to the story.\nWe add vertical date markers, for the milestone years where the Global South’s or the Global North’s extreme poverty line fell below 10%, as well as a marker for the Global Average.\nTo include these features and combine the streamgraphs into a single figure, we modify our plotting approach. First, we continue plotting the streamgraphs with streamgraph, which generates an interactive HTML based visualisation. Then, we layer our desired elements by embedding the visualisation into a custom layout using HTML and CSS. In particular the htmltoolspackage is put into action.\nFirst we find out the milestone years were extreme poverty dropped below 10% on average for the Global South and Global North.\n\n\nlibrary(htmltools)\n\n# grouping by regions \ndata_impr_sg <- data_impr_sg |> \n  mutate(\n    group = case_when(\n      region %in% c(\"Western Europe\", \"Eastern Europe\", \"Australia, New Zealand, USA and Canada\") ~ \"Global North\",\n      region %in% c(\"East Asia\", \"Middle East and North Africa\", \"Sub-Saharan Africa\", \n                    \"South and Southeast Asia\", \"Latin America and Caribbean\") ~ \"Global South\",\n      TRUE ~ \"Global Average\"\n    )\n  )\n\ndata_impr_sg |> \n  filter(poverty < 10) |> \n  group_by(group) |> \n  summarise(earliest_year = min(YEAR),\n            latest_year = max(YEAR), \n            mean_year = mean(YEAR),\n            .groups = \"drop\")\n\n# A tibble: 2 × 4\n  group        earliest_year latest_year mean_year\n  <chr>                <dbl>       <dbl>     <dbl>\n1 Global North          1900        2010     1976.\n2 Global South          1990        2010     2002.\n\nWith this information we create the graph:\n\n\n# streamgraphs \nsg2_poverty <- streamgraph(\n  data_impr_sg, \n  key = \"region_prefix\", \n  value = \"poverty\", \n  date = \"YEAR\") %>%\n  sg_axis_x(tick_interval = 50) %>% \n  sg_axis_y(tick_count = 0) %>%\n  sg_fill_manual(cb_colors_ordered) %>% \n  sg_title(title = \"Extreme Poverty\") \n\nsg2_gdp <- streamgraph(\n  data_impr_sg, \n  key=\"region_prefix\", \n  value=\"GDP\", \n  date=\"YEAR\") %>%\n  sg_axis_x(tick_interval = 50) %>%\n  sg_axis_y(tick_count = 0) %>%\n  sg_fill_manual(cb_colors_ordered) %>%\n  sg_title(title = \"GDP per capita\") \n\n# HTML layering and combination \nstreamgraph_layout <- tags$div(\n  style = \"position: relative; text-align: center; font-family:Arial, sans-serif; margin: 20px;\",\n  \n  # titling \n  tags$h2(\"Extreme Poverty and GDP per capita comparison between Global South and Global North\",\n          style = \"font-size: 24px; font-weight: bold;\"),\n  tags$h3(\n    HTML(\"World region data available for\n          <span style='color:#D55E00;'>Australia, New Zealand, USA and Canada<\/span>, \n          <span style='color:#e69f00;'>Western Europe<\/span>, \n          <span style='color:#ff0000;'>Eastern Europe<\/span>, \n          <span style='color:#000000;'>Global Average<\/span> (in white), \n          <span style='color:#56b4e9;'>Middle East and North Africa<\/span>, \n          <span style='color:#b9e77c;'>Latin America and Caribbean<\/span>, \n          <span style='color:#76eec6;'>East Asia<\/span>, \n          <span style='color:#009e73;'>South and Southeast Asia<\/span>, \n          <span style='color:#104e8b;'>Sub-Saharan Africa<\/span>.\"), \n    style = \"font-size: 14px;\"\n  ),\n  \n  # poverty streamgraph (top)\n  tags$div(\n    style = \"position: relative; width: 100%; margin-bottom: 20px;\",\n    \n    # vertical dashed lines and annotations at 1975 and 2002\n    tags$div(\n      style = \"position: absolute; top: 0; height: 100%; width: 1px; background-color: #eb9797; \n               border-left: 2px dashed #eb9797; left: 78%; z-index: 1;\" # 1975\n    ),\n    tags$div(\n      style = \"position: absolute; top: 0; height: 100%; width: 1px; background-color: #30918d; \n               border-left: 2px dashed #30918d; left: 90%; z-index: 1;\" #2002\n    ),\n    \n    # plot\n    tags$div(\n      sg2_poverty,\n      style = \"position: relative; z-index: 2; width: 100%;\"\n    )\n  ),\n  \n  # GDP streamgraph (bottom)\n  tags$div(\n    style = \"position: relative; width: 100%; margin-top: 20px;\",\n    \n      tags$div(\n      style = \"position: absolute; top: 0; height: 100%; width: 1px; background-color: #eb9797; \n               border-left: 2px dashed #eb9797; left: 78%; z-index: 1;\" # 1975\n    ),\n    tags$div(\n      style = \"position: absolute; top: 0; height: 100%; width: 1px; background-color: #30918d; \n               border-left: 2px dashed #30918d; left: 90%; z-index: 1;\" #2002\n    ),\n    \n    # plot \n    tags$div(\n      sg2_gdp,\n      style = \"position: relative; z-index: 2; width: 100%;\"\n    )\n  ),\n  \n  # line explanations\n  tags$h3(\n    HTML(\"The \n        <span style='color:#eb9797;'>red line<\/span>\n        marks 1975, when the Global North was on average below the 10% extreme poverty line, <br/> the \n        <span style='color:#30918d;'>blue line<\/span>\n        marks 2002, when the Global South was on average below the 10% extreme poverty line.\"),\n    style = \"font-size: 10px;\"\n    ),\n  \n  # caption\n  tags$hr(),\n  tags$p(\n    tags$span(\"Data source: \"),\n    tags$a(\n      \"How was life? Volume II, OECD, 2021\", \n      href = \"https://www.oecd.org/en/publications/how-was-life-volume-ii_3d96efc5-en/full-report/component-14.html#chapter-d1e59754\", \n      target = \"_blank\", # opens the link in a new tab\n      style = \"color: gray; text-decoration: underline;\"\n      ),\n    style = \"font-size: 12px; color: gray;\"\n  )\n)\n\n# rendering\nbrowsable(streamgraph_layout)\n\n\nExtreme Poverty and GDP per capita comparison between Global South and Global North\nWorld region data available for\n          Australia, New Zealand, USA and Canada, \n          Western Europe, \n          Eastern Europe, \n          Global Average (in white), \n          Middle East and North Africa, \n          Latin America and Caribbean, \n          East Asia, \n          South and Southeast Asia, \n          Sub-Saharan Africa.\n\n\n\n\n\nExtreme Poverty\n\n\n\n\n\n\n\n\n\n\nGDP per capita\n\n\n\n\n\nThe \n        red line\n        marks 1975, when the Global North was on average below the 10% extreme poverty line,  the \n        blue line\n        marks 2002, when the Global South was on average below the 10% extreme poverty line.\n\nData source: \nHow was life? Volume II, OECD, 2021\n\n\n\nGG plot it\nFor conveniance, We can do the same work in ggplot. for this, we prepare the data in long format, facet and add our custom features. While we lose the style of the streamgraph, we gain the workability of ggplot.\n\n\n# combine Poverty and GDP into one dataset\ndata_impr_gg <- data_impr_sg |> \n  filter(!is.na(region_ordered)) |> \n  pivot_longer(cols = c(\"poverty\", \"GDP\"), \n               names_to = \"metric\", \n               values_to = \"value\") |> \n  mutate(metric = recode(metric,\n                         \"GDP\" = \"GDP per capita\",\n                         \"poverty\" = \"Extreme Poverty\"))\n\n# titling\ngraph_title <- paste(c(\"Extreme Poverty and GDP per capita,\\ncomparison between\", \n                       \"Global South and Global North\"\n                       ), collapse=\" \")\n\ngraph_subtitle <- paste(c(\n  \"<span style='text-indent: 0; margin-left: 0;'>World region data available for\",\n  \"<span style='color:#D55E00;'>Australia, New Zealand, USA and Canada<\/span>,\",\n  \"<span style='color:#e69f00;'>Western Europe<\/span>,<br>\",\n  \"<span style='text-indent: 0; margin-left: 0;'><span style='color:#ff0000;'>Eastern Europe<\/span>,\",\n  \"<span style='color:#000000;'>Global Average<\/span> (in white),\",\n  \"<span style='color:#56b4e9;'>Middle East and North Africa<\/span>,<br>\", \n  \"<span style='text-indent: 0; margin-left: 0;'><span style='color:#b9e77c;'>Latin America and Caribbean<\/span>,\",\n  \"<span style='color:#76eec6;'>East Asia<\/span>,\", \n  \"<span style='color:#009e73;'>South and Southeast Asia<\/span> and<br>\",\n  \"<span style='text-indent: 0; margin-left: 0; color:#104e8b;'>Sub-Saharan Africa<\/span>.\"\n), collapse = \" \")\n\ngraph_caption <- paste(c(\"<span style='text-indent: 0; margin-left: 0;'>The\",  \n        \"<span style='color:#eb9797;'>pink line<\/span> marks 1975,\", \n        \"when the Global North was on average below the 10% extreme poverty line, <br>\",\n        \"<span style='text-indent: 0; margin-left: 0;'>the <span style='color:#30918d;'>blue line<\/span>\n        marks 2002,\", \n        \"when the Global South was on average below the 10% extreme poverty line.\"), collapse = \" \")\n\ngraph_tag <- paste(\"Data source: How was life? Volume II, OECD, 2021\")\n\n# visuals\nsysfonts::font_add_google(\"Lora\", family = \"lora\")\n\nlegend <- data.frame(\n  region = c(\"Sub-Saharan Africa\",\n             \"South and Southeast Asia\", \n             \"East Asia\", \n             \"Latin America and Caribbean\", \n             \"Middle East and North Africa\", \n             \"Global Average\", \n             \"Eastern Europe\", \n             \"Western Europe\", \n             \"Australia, New Zealand, USA and Canada\"))\n\n# plot\nggplot(data_impr_gg, aes(x = YEAR, y = value, fill = region_prefix)) +\n  geom_area() +\n  facet_wrap(~ metric, ncol = 1, scales = \"free_y\") +\n  geom_vline(xintercept = 1975, linetype = \"dashed\", colour = \"#eb9797\") + \n  geom_vline(xintercept = 2002, linetype = \"dashed\", colour = \"#30918d\") + \n  scale_fill_manual(values = cb_colors_ordered, labels = legend$region) +\n  labs(title = graph_title, \n       subtitle = graph_subtitle,\n       caption = graph_caption,\n       tag = graph_tag,\n       x = \"Year\",\n       y = NULL\n       ) +\n  guides(fill = guide_legend(nrow = 3, ncol = 3)) +\n  theme_minimal() +\n  theme(\n    strip.text = element_text(family = \"lora\", \n                              face = \"italic\", \n                              colour = \"#939292\", \n                              hjust = 0.55, \n                              margin = margin(b = -7)), \n    plot.title = element_text(family = \"playfair display\", \n                              size = 16, \n                              margin = margin(b = 12)), \n    plot.title.position = \"plot\",\n    plot.subtitle = element_markdown(family = \"lora\", \n                                     size = 10,\n                                     lineheight = 1.3,\n                                     margin = margin(b = 12)\n                                     ), \n    plot.caption = element_markdown(family = \"lora\", \n                                    colour = \"black\",\n                                    size = 9.7, \n                                    hjust = 0, \n                                    lineheight = 1.3,\n                                    margin = margin(t = 12)\n                                    ),\n    plot.caption.position = \"panel\",        \n    plot.tag = element_text(family = \"lora\",\n                            colour = \"#939292\",\n                            size = 8, \n                            hjust = 1, \n                            vjust = 1, \n                            margin = margin (t = 12)\n                            ),\n    plot.tag.position = c(1,0), \n    legend.title = element_blank(), \n    legend.text = element_text(family = \"lora\"),\n    legend.background = element_rect(fill = NULL, colour = \"#888888\", linetype = \"dotted\"),\n    legend.key.size = unit(0.5, \"lines\"),\n    legend.spacing.x = unit(0.2, \"cm\"),\n    legend.position = \"bottom\", \n    axis.title = element_blank(),\n    axis.text.x = element_text(family = \"lora\", colour = \"#939292\"),\n    axis.text.y = element_blank(), \n    panel.spacing.y = unit(1, \"lines\"), \n    panel.grid.minor = element_blank(), \n    plot.margin = margin(b = 19)\n  ) +\n  coord_cartesian(clip = \"off\") \n\n\n\nIn summary, this article has delved into the process of replicating and improving a graph which delt with the issues of extreme poverty and income per capita. We have seen that what initially seems like a straightforward chart often demands substantial effort to fine-tune each detail, as well as the critical role of intentional data visualisation. The alternative visualisations have illustrates how refining the graph through iterations can significantly change the narrative portrayed and change the course of focus and interpretation.\n\nReality check! The reason why I decided to include this final processing of the data in the replication process and not the data cleaning process is due to the importance I attribute to the active replication process in showing me, and me figuring out during it, what the problems were with the data. The replication process is not a straightforward task, but it involves a lot of back and forth, which I believe is important to pay attention to.↩︎\nReality check! I call this the second starting point as if it is done nearer the end of the replication, while the code would be correct, the time that will need to be invested in changing the exact coordinates, widths, lengths, etc of the different functions will have the effect of making the replication process seem like going back to square one. Hence, instead of taking double the time, I recommend setting the dimensions early on!↩︎\nBased on Wikipedia’s article on Global South and North, which is based on the UN’s trade and development classification of Groups of economies.↩︎\n",
    "preview": "projects/2024/100546612/100546612_files/figure-html5/final-1.png",
    "last_modified": "2025-01-17T11:48:26+01:00",
    "input_file": {},
    "preview_width": 2400,
    "preview_height": 1740
  },
  {
    "path": "projects/2024/100419840/",
    "title": "How housing is no longer a right",
    "description": "Visualization of the housing crisis in Spain according to official data from\nthe Ministry of Transportation.",
    "author": [
      {
        "name": "Maria Carda-Gargallo",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\nCollecting data\n\nBasic elements\nPackages\nLoading and preparing the data\n\nReplication\nInteractive version\n\nAlternative representation of the graph\nOption 1: Tile graph\nOption 2: Interactive bubble graph\n\nConclusions\n\nIntroduction\nThe original graph is derived from an article published by elDiario.es in October 2024, coinciding with a demonstration in Madrid addressing rising rental prices (“El aumento del precio del alquiler y la especulación avivan las protestas por el derecho a la vivienda”). The article examines various facets of the ongoing housing crisis such as the interplay between speculation and affordability.\nThe original graph\nThe graph shows the Quarterly evolution of the appraised value of free housing per quarter in each Autonomous Community with respect to the quarter where the price of housing peaked in each community- In other words, the variation in the appraised price of housing with respect to the 2008 crisis. It highlights the values of three communities (Madrid, Baleares and Canarias), which are those with the fastest growth trends in recent months.\nOriginal graphCollecting data\nThe data presented in the graph (appraised value of free housing) is publicly accessible online and is published quarterly by the Spanish Ministry of Transportation.\nIt can be easily downloaded here.\nBasic elements\nPackages\nThe first step is to load the necessary libraries for the replication.\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(plotly)\nlibrary(scales)\n\n\nLoading and preparing the data\nAfterwards, the database needs to be loaded and the missing values coded as “NA”.\n\n\ndata <- read_excel(\"BBDD_DATAVIZ.xls\")\ndata[data == \"n.r\"] <- NA\n\n\nOnce loaded, it is necessary to process the data to be able to work with it. First, the variable of the appraised value (“Valor Tasado”) was renamed to eliminate the blank space between words to be more easily manageable.\n\n\ndata <- data %>%\n  mutate(Valor_Tasado = `Valor Tasado`)\n\n\nThen, the data was filtered to only consider the data of the major regions since it is also disaggregated by province. The filter is applied to the province column since the regional data has a missing value for this variable.\n\n\ndata_filtered <- data %>%\n  filter(is.na(Provincia))\n\n\nOnce the data has been filtered, the highlighted regions were renamed to match the original graph’s labels (Baleares, Madrid and Media Nacional). And a vector was created to contain the names of the specific regions to be highlighted in the following steps.\n\n\ndata_filtered <- data_filtered %>%\n  mutate(CCAA = case_when(\n    CCAA == \"Balears (Illes)\" ~ \"Baleares\",\n    CCAA == \"Madrid (Comunidad de)\" ~ \"Madrid\",\n    CCAA == \"Media Nacional\" ~ \"Media\\nNacional\",\n    TRUE ~ CCAA))\n\ncomunidades_destacadas <- c(\"Baleares\", \"Madrid\", \"Canarias\", \"Media\\nNacional\")\n\n\nSince the data is is provided in quarters, a new variable called “Fecha” (Date) has been created to easily represent the evolution of time. In this case, the variable has been coded to represent the last month of each quarter of the year.\n\n\ndata_filtered <- data_filtered %>%\n  mutate(Fecha = as.Date(paste(Año, Trimestre * 3, \"01\", sep = \"-\"), \n                         format = \"%Y-%m-%d\"))\n\n\nFollowing the previous steps, it is needed to calculate the maximum value of the appraised value during the housing crisis. Therefore, the data is filtered before 2009 (according to the period highlighted in the original graph). The, it is grouped by region to get the maximum value for each one of them. After that, if the value is missing it is replaced by 0 and since this calculus has been made in a different data frame, the results are finally joined by region.\n\n\nmax_data <- data_filtered %>%\n  filter(Año < 2009) %>%\n  group_by(CCAA) %>%\n  summarise(\n    Valor_Max = max(Valor_Tasado, na.rm = TRUE),\n    .groups = \"drop\"\n  ) %>%\n  complete(CCAA, fill = list(Valor_Max = 0))  \n\ndata_filtered <- data_filtered %>%\n  left_join(max_data, by = \"CCAA\")\n\n\nFinally, a variable is aggregated to be able to represent the evolution of housing prices according to the maximum value calculated before. This variable contains the porcentual change in housing prices for the maximum value in the crisis period. Moreover, it has been contemplated that if the maximum value is missing (equal to 0), the Evolution (Evolución) value is also 0.\n\n\ndata_filtered <- data_filtered %>%\n  mutate(\n    Evolucion = if_else(\n      Valor_Max != 0,  \n      ((Valor_Tasado - Valor_Max) / Valor_Max) * 100, 0 ))\n\n\nReplication\nOnce the data is prepared, it is time to replicate the graph. The first step is to create a basic graph that includes the data to be represented and the axis variables. In this case, the x-axis represents the date (“Fecha”) and the y-axis the Evolution. The data is grouped by CCAA and the color to represent each line is determined by the CCAA they belong to.\n\n\nmi_grafico_mal <- ggplot(data_filtered, \n                         aes(x = Fecha, y = Evolucion, group = CCAA)) \nmi_grafico_mal \n\n\n\nTo represent the lines, the command geom_step has been used since it represents the data according to the original graph (similar to a stairs/steps). Since there are two groups of CCAA, the first step has been to represent those that are not highlighted/labeled, which are represented in grey.\n\n\nmi_grafico_mal <- mi_grafico_mal + \n    geom_step(data = subset(data_filtered, \n                            !CCAA %in% comunidades_destacadas), \n                            color = \"grey80\")\nmi_grafico_mal\n\n\n\nThe second part is to include the highlighted regions, which are those contained in the vector of the previous steps and they are colored by region.\n\n\nmi_grafico_mal <- mi_grafico_mal + geom_step(data = subset(\n  data_filtered, CCAA %in% comunidades_destacadas), aes(color = CCAA),\n                                             size = 1.2)\nmi_grafico_mal \n\n\n\nThen, the marked line at the y-axis for value 0 is added in black.\n\n\nmi_grafico_mal <- mi_grafico_mal + geom_hline(yintercept = 0, \n              linetype = \"solid\", linewidth = 0.3, color =\"black\")\n\nmi_grafico_mal\n\n\n\nAfterwards, custom text annotations are added by labeling specific regions (CCAA) from the filtered data at their most recent date (maximum date). Plus, their name and the rounded percentage change (Evolucion) are displayed at a specified position with styling adjustments.\n\n\nmi_grafico_mal <- mi_grafico_mal + geom_text(\n  data = subset(data_filtered, CCAA %in% comunidades_destacadas) %>%\n                        group_by(CCAA) %>%\n                        filter(Fecha == max(Fecha, na.rm = TRUE)), \n                        aes(x = as.Date(\"2024-06-30\") - 1, \n                        y = Evolucion, \n                        label = paste(CCAA, \"\\n\", round(Evolucion, 1), \"%\"), \n                        color = CCAA), \n                        hjust = 0, vjust = 0.3, size = 2.8, fontface = \"bold\")\n\nmi_grafico_mal\n\n\n\nTo highlight the period of the economic crisis of 2008, a rectangle is created using annotate using the max and min values for the y-axis and the period between 2006 and 2008 for the x-axis.\n\n\nmi_grafico_mal <- mi_grafico_mal + annotate(\"rect\", \n        xmin = as.Date(\"2006-01-01\"), xmax = as.Date(\"2008-12-31\"), \n        ymin = -Inf, ymax = Inf, fill = \"grey\", alpha = 0.2)\n\nmi_grafico_mal\n\n\n\nHowever, this previous area contains the label “Burbuja Inmobiliaria” (Housing Bubble), which is also added using annotate to the estimated coordinates and style of the original graph.\n\n\nmi_grafico_mal <- mi_grafico_mal + annotate(\"text\", \n      x = as.Date(\"2007-07-01\"), y = 10, label = \"Burbuja\\nInmobiliaria\", \n      color = \"black\", size = 4, fontface = \"bold\", hjust = 0.5, vjust = -0.5)\n\nmi_grafico_mal\n\n\n\nNow that all necessary data representation is prepared, the final steps are related to the theme and adjustments to accurately represent the original graph.\nFirst, the x-axis is adjusted using the scale_x_date command to represent the date variable only for even years. To do so, the limit of the axis is set to the final month of available data (June of 2024, at the time of consultation) and then the breaks are set so that the year represented is divisible by 2 (to ensure even numbers).\n\n\nmi_grafico_mal <- mi_grafico_mal + scale_x_date(\n  limits = c(min(data_filtered$Fecha, na.rm = TRUE), as.Date(\"2024-06-30\")),\n  breaks = seq(\n    from = as.Date(paste0(ifelse(year(min(\n      data_filtered$Fecha, na.rm = TRUE)) %% 2 == 0,\n      year(min(data_filtered$Fecha, na.rm = TRUE)),\n      year(min(data_filtered$Fecha, na.rm = TRUE)) + 1), \"-01-01\")),\n    to = as.Date(\"2024-01-01\"),\n    by = \"2 years\"),\n  date_labels = \"%Y\")\n\nmi_grafico_mal \n\n\n\nSecond, the y-axis is also adjusted so that values are represented by 10% and despite showing values for up to 30% and down to -80%, not show these limit labels.\n\n\nmi_grafico_mal <- mi_grafico_mal + scale_y_continuous(\n  limits = c(-80, 30),  \n  breaks = seq(-70, 20, by = 10),  \n  labels = function(y) ifelse(y == -80, \"\", paste0(y, \"%\")),  \n  expand = expansion(mult = c(0, 0.05))\n)\n\nmi_grafico_mal\n\n\n\nAfterwards, the original colors of the highlighted regions are manually coded.\n\n\nmi_grafico_mal <- mi_grafico_mal + scale_color_manual(values = c(\n  \"Media Nacional\" = \"#5E5E5E\", \"Baleares\" = \"#ECDC49\", \n  \"Madrid\" = \"#2C7BCB\", \"Canarias\" = \"#175695\", \"Otros\" = \"#D9D9D9\")) \n\nmi_grafico_mal\n\n\n\nThen, the title, subtitle and caption are introduced using labs.\n\n\nmi_grafico_mal <- mi_grafico_mal +\n  labs(\n    title = \"En Baleares y Madrid el precio de la vivienda ya está por encima del peor momento de la burbuja\", \n    subtitle = \"Evolución trimestral del valor tasado de la vivienda libre en cada CCAA respecto al trimestre donde el precio de la vivienda tocó techo en cada\\ncomunidad\",\n    caption = \"Fuente: Ministerio de Transportes y Movilidad Sostenible\"\n  )\n\nmi_grafico_mal\n\n\n\nFinally, the theme is established to accurately replicate the graph. Here is necessary to eliminate the legend, both axis labels and the grid lines of the x-axis. Regarding the y-axis, the grid lines are styled according to the original in grey.\n\n\nmi_grafico_mal <- mi_grafico_mal + theme(\n  legend.position = \"none\",               \n  axis.title.y = element_blank(),        \n  axis.title.x = element_blank(),        \n  panel.grid.major.x = element_blank(),   \n  panel.grid.major.y = element_line(color = \"grey80\", size = 0.5), \n  panel.grid.minor = element_blank(),    \n  plot.margin = margin(5, 80, 5, 5),      \n  plot.title = element_text(face = \"bold\"), \n  panel.background  = element_rect(fill = \"white\", color = NA) \n)\n\n\nmi_grafico_mal\n\n\n\nFinally, coord_cartesian is employed to eliminate the limits that do not allow to see the highlighted regions’ labels (concretely, the key command is clip = “off”).\n\n\nmi_grafico_mal <- mi_grafico_mal + coord_cartesian(xlim = \n                    c(as.Date(\"1995-03-01\"), \n                    as.Date(\"2024-06-30\")), clip = \"off\", expand = 0)\n\nmi_grafico_mal\n\n\n\nHowever, this final graph has an issue since Ceuta and Melilla are not represented in the original graph. Therefore, the data is filtered to eliminate this two regions and then the code is executed altogether to represent the graph correctly.\n\n\ndata_limited <- subset(data_filtered, CCAA != \"Ceuta\" & CCAA != \"Melilla\")\n\nmi_grafico <- ggplot(data_limited, \n       aes(x = Fecha, y = Evolucion, group = CCAA, color = CCAA)) + \n  geom_step(data = subset(data_limited, !CCAA %in% comunidades_destacadas), \n            color = \"grey80\") +  \n  geom_step(data = subset(data_limited, CCAA %in% comunidades_destacadas), \n            aes(color = CCAA), size = 1.2) + \n  geom_hline(yintercept = 0, linetype = \"solid\", linewidth = 0.3, \n             color =\"black\") +\n  geom_text(\n  data = subset(data_filtered, CCAA %in% comunidades_destacadas) %>%\n                        group_by(CCAA) %>%\n                        filter(Fecha == max(Fecha, na.rm = TRUE)), \n                        aes(x = as.Date(\"2024-06-30\") - 1, \n                        y = Evolucion, \n                        label = paste(CCAA, \"\\n\", round(Evolucion, 1), \"%\"), \n                        color = CCAA), \n                        hjust = 0, vjust = 0.3, size = 2.8, fontface = \"bold\") +\n  annotate(\"rect\", xmin = as.Date(\"2006-01-01\"), xmax = as.Date(\"2008-12-31\"), \n           ymin = -Inf, ymax = Inf, \n           fill = \"grey\", alpha = 0.2) + # Rectángulo gris\n  annotate(\"text\", x = as.Date(\"2007-07-01\"), y = 10, \n           label = \"Burbuja\\nInmobiliaria\", \n           color = \"black\", size = 3.5, fontface = \"bold\", hjust = 0.5, \n           vjust = -0.5) +\n scale_x_date(\n    limits = c(min(data_filtered$Fecha, na.rm = TRUE), as.Date(\"2024-06-30\")),\n    breaks = seq(\n        from = as.Date(paste0(ifelse(year(min(\n          data_filtered$Fecha, na.rm = TRUE)) %% 2 == 0, \n          year(min(data_filtered$Fecha, na.rm = TRUE)),\n          year(min(data_filtered$Fecha, na.rm = TRUE)) + 1), \"-01-01\")),\n        to = as.Date(\"2024-01-01\"),\n        by = \"2 years\"),\n    date_labels = \"%Y\") + \n  scale_y_continuous(\n  limits = c(-80, 30),  \n  breaks = seq(-70, 20, by = 10),  \n  labels = function(y) ifelse(y == -80, \"\", paste0(y, \"%\")),  \n  expand = expansion(mult = c(0, 0.05))) + \n  scale_color_manual(values = c(\"Media Nacional\" = \"#5E5E5E\", \n                                \"Baleares\" = \"#ECDC49\", \n                                \"Madrid\" = \"#2C7BCB\", \"Canarias\" = \"#175695\", \n                                \"Otros\" = \"#D9D9D9\")) +\n  labs(title = \n\"En Baleares y Madrid el precio de la vivienda ya está por encima del peor momento de la burbuja\",\nsubtitle = \n\"Evolución trimestral del valor tasado de la vivienda libre en cada CCAA respecto al \ntrimestre donde el precio de la vivienda tocó techo en cada\\ncomunidad\",\ncaption = \"Fuente: Ministerio de Transportes y Movilidad Sostenible\")  +\n  theme(\n    legend.position = \"none\", \n    axis.title.y = element_blank(),\n    axis.title.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"grey80\", size = 0.5),\n    panel.grid.minor = element_blank(),\n    plot.margin = margin(5, 60, 5, 5),\n    plot.title = element_text(face = \"bold\"), \n    panel.background = element_rect(fill = \"white\")) + \n    coord_cartesian(xlim = c(as.Date(\"1995-03-01\"), as.Date(\"2024-06-30\")), \n                    clip = \"off\", expand = 0)\n\nmi_grafico\n\n\n\nInteractive version\nIn addition, ggplotly has been used to make the plot interactive, which enables to see the price value, the quarter, the year and the corresponding region when the cursor is moved across the plot.\n\n\ny <- ggplot(data_limited, \n            aes(x = Fecha, y = Evolucion, group = CCAA, color = CCAA, \n                text = paste(\"CCAA:\", CCAA, \"<br>Año:\", format(Fecha, \"%Y\"),\n                             \"<br>Trimestre:\", \n                             Trimestre, \"<br>Evolución:\",\n                             round(Evolucion, 2), \"%\"))) + \n  geom_step(data = subset(data_limited, !CCAA %in% comunidades_destacadas), \n            color = \"grey80\") +  # Comunidades en gris claro\n  geom_step(data = subset(data_limited, CCAA %in% comunidades_destacadas), \n            size = 1.2) +  # Comunidades destacadas\n  geom_hline(yintercept = 0, linetype = \"solid\", linewidth = 0.1, color = \"black\") +\ngeom_text(\n  data = subset(data_filtered, CCAA %in% comunidades_destacadas) %>%\n                        group_by(CCAA) %>%\n                        filter(Fecha == max(Fecha, na.rm = TRUE)), \n                        aes(x = as.Date(\"2024-06-30\") + 60, \n                        y = Evolucion, \n                        label = paste(CCAA, \"\\n\", round(Evolucion, 1), \"%\"), \n                        color = CCAA), \n                        hjust = 0, vjust = 0.3, size = 2.8, fontface = \"bold\")+\n  annotate(\"rect\", xmin = as.Date(\"2006-01-01\"), xmax = as.Date(\"2008-12-31\"),\n           ymin = -Inf, ymax = Inf, \n           fill = \"grey\", alpha = 0.2) +  \n  annotate(\"text\", x = as.Date(\"2007-07-01\"), y = 10, \n           label = \"Burbuja\\nInmobiliaria\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, \n           vjust = -0.5) +\n  scale_x_date(\n    limits = c(min(data_limited$Fecha, na.rm = TRUE), as.Date(\"2024-12-31\")),  \n    date_breaks = \"2 years\",  \n    date_labels = \"%Y\"  \n  ) + \n  scale_y_continuous(\n    limits = c(-80, 30),  \n    breaks = seq(-70, 20, by = 10),  \n    labels = function(y) ifelse(y == -80, \"\", paste0(y, \"%\")),  \n    expand = expansion(mult = c(0, 0.05))  \n  ) + \n  scale_color_manual(values = c(\"Media Nacional\" = \"#5E5E5E\", \n                                \"Baleares\" = \"#ECDC49\", \n                                \"Madrid\" = \"#2C7BCB\", \"Canarias\" = \"#175695\", \n                                \"Otros\" = \"#D9D9D9\")) +\n  labs(\n    title = \"Evolución del precio de la vivienda libre en cada CCAA: \n    Comparación trimestral respecto al valor máximo antes de la burbuja\",\n    caption = \"Fuente: Ministerio de Transportes y Movilidad Sostenible\"\n  )  +\n  theme(\n    legend.position = \"none\",  \n    axis.title.y = element_blank(),\n    axis.title.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"grey80\", size = 0.5),\n    panel.grid.minor = element_blank(),\n    plot.margin = margin(5, 60, 5, 5),\n    panel.background = element_rect(fill = \"white\")\n  ) \n\ninteractive_plot <- ggplotly(y, tooltip = \"text\")\n\ninteractive_plot\n\n\n\nHowever, this function has trade-offs. In this sense, in order to make the chart dynamic, the final labels of the highlighted regions are not represented and it is not possible to include the box displaying the period of the crisis.\nAlternative representation of the graph\nThe original graph from elDiario.es is a good approach to represent the evolution of housing prices in relation to the economic crisis of 2008. Nonetheless, there are some issues that could be improved. For example, the user is not able to see the values for all the regions since only the highlighted ones are easy to identify (which are the ones where prices have been recently growing faster).\nConsequently, two alternatives are proposed to improve the representation of the data.\nOption 1: Tile graph\nThe first improvement option consists of transforming the graph into a tile graph. First, the date variable (Fecha) is ensured to be established as a date. Then, the base graph is created where date, region and evolution are represented in tiles.\n\n\ndata_limited$Fecha <- as.Date(data_limited$Fecha) \n\ntile <- ggplot(data_limited, aes(x = Fecha, y = CCAA, fill = Evolucion)) + \n    geom_tile(color = \"white\", height = 0.5) \ntile\n\n\n\nAfterwards, the highlighted crisis period is represented by a yellow rectangle so it can be easily identified. Plus, the national average is also highlighted in green.\n\n\ntile <- tile + \n  geom_rect(aes(xmin = as.Date(\"2006-01-01\"),\n                xmax = as.Date(\"2008-12-31\"), \n                ymin = -Inf, ymax = Inf, color = \"Burbuja Inmobiliaria\"), \n            fill = NA, linewidth = 1) +\n  geom_rect(aes(xmin = as.Date(\"1995-03-01\"),\n                xmax = as.Date(\"2024-06-30\"),\n                ymin = which(levels(factor(\n                  data_limited$CCAA)) == \"Media\\nNacional\") - 0.5,\n                ymax = which(levels(factor(\n                  data_limited$CCAA)) == \"Media\\nNacional\") + 0.5,\n                color = \"Media Nacional\"),\n            fill = NA, linewidth = 0.4) +\n  scale_color_manual(\n    name = NULL, \n    values = c(\"Burbuja Inmobiliaria\" = \"yellow\", \"Media Nacional\" = \"green\")\n  )\n\n\ntile\n\n\n\nThen, the x-axis is set to represent the date every 2 years (like the original graph).\n\n\ntile <- tile  +\n    scale_x_date(\n        limits = c(min(data_limited$Fecha, na.rm = TRUE), as.Date(\"2024-12-01\")), \n        date_breaks = \"2 years\", \n        date_labels = \"%Y\")\n\ntile\n\n\n\nFor this graph, it is important to determine the colors of the gradient for an easier visualization. Consequently, the gradient has been coded so that values around 0% are white, the values above are orange and the inferior values are blue.\n\n\ntile <- tile +  scale_fill_gradientn(\n  colours = c(\"blue\", \"white\", \"orange\"),\n  values = rescale(c(-75, 0, 30)),\n  name = \"Evolución (%)\")\n\ntile\n\n\n\nThe final steps include determining the title, subtitle and caption according to the original graph.\n\n\ntile <- tile +\n    labs(\n        title = \"En Baleares y Madrid el precio de la vivienda \n        ya está por encima del peor momento de la burbuja\",\n        subtitle = \"Evolución trimestral del valor tasado de la vivienda libre en cada CCAA \n        respecto al trimestre donde el precio de la vivienda tocó techo\\nen cada comunidad\",\n        caption = \"Fuente: Ministerio de Transportes y Movilidad Sostenible\")\n\ntile\n\n\n\nAnd finally, establish the theme of the plot: white background, eliminating the axis labels and the margins of the plot.\n\n\n tile <- tile +\n    theme(\n        legend.position = \"right\", \n        axis.title.y = element_blank(),\n        axis.title.x = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_blank(),\n        panel.grid.minor = element_blank(),\n        plot.margin = margin(5, 60, 5, 5),\n        plot.title = element_text(face = \"bold\"), \n        panel.background = element_rect(fill = \"white\"))\n\ntile\n\n\n\nOption 2: Interactive bubble graph\nThe second option consists of an interactive bubble graph inspired by gapminder. The aim is to represent the evolution of the appraised value of housing in relation with the average wages and the population of each region throughout the years.\nIntroducing new data\nThe first step is to introduce the new data that is needed. Both, the average wages and the population size are available at INE’s webpage.\nRegarding the average wages per region, the data is available from 2008 to 2023 in this database since it is divided into different datasets depending on which year is taken as the baseline to calculate the monetary value.\nAnd regarding the population per region, the data is available from 1996 to 2021 (excluding 1997 in this period) for all Autonomous Communities and including the national average.\n\n\nrenta_CCAA <- read_excel(\"RENTA PER CAPITA CCAA.xlsx\")\n\nPOP <- read_excel(\"POP.xlsx\")\n\n\nHowever, the data is not in a tidy format and it needs to be arranged accordingly to be able to join all databases.\n\n\nrenta_CCAA <- renta_CCAA %>%\n  rename(CCAA = Año) %>%\n  pivot_longer(cols = 2:17, names_to = \"Año\", values_to = \"renta_media\")\n\nPOP <- POP %>%\n  pivot_longer(cols = 2:27, names_to = \"Año\", values_to = \"population\")\n\nmerged_data <- renta_CCAA %>%\n  left_join(POP, by = c(\"CCAA\", \"Año\")) \n\nmerged_data <- merged_data %>%\n  mutate(CCAA = case_when(\n    CCAA == \"Balears, Illes\" ~ \"Baleares\",\n    CCAA == \"Madrid, Comunidad de\" ~ \"Madrid\",\n    CCAA == \"Media Nacional\" ~ \"Media\\nNacional\",\n    CCAA == \"Asturias, Principado de\" ~ \"Asturias (Principado de )\",\n    CCAA == \"Castilla - La Mancha\" ~ \"Castilla-La Mancha\",\n    CCAA == \"Comunitat Valenciana\" ~ \"Comunidad Valenciana\",\n    CCAA == \"Navarra, Comunidad Foral de\" ~ \"Navarra (Comunidad Foral de)\",\n    CCAA == \"Rioja, La\" ~ \"Rioja (La)\",\n    TRUE ~ CCAA\n  ))\n\n\nOnce the new data has been prepared, the original database has to be filtered again since wages and population are not aggregated by quarter. Therefore, the filter is going to be applied so that the year prices are the ones corresponding to the end of each year (fourth quarter). Plus, it ensure that the year is coded as a numeric variable to join the datasets.\n\n\ndata_filtered_filtered <- data_filtered %>%\n  filter(Trimestre == 4)\n\nmerged_data <- merged_data %>%\n  mutate(Año = as.numeric(Año))\n\n\ncombined_data <- merged_data %>%\n  left_join(data_filtered_filtered, by = c(\"CCAA\", \"Año\"))\n\nfiltered_data <- combined_data %>%\n filter(!Año %in% c(2022, 2023)) %>%\n  filter(!CCAA == \"Media\\nNacional\")\n\n\nThe last part of the code filters the combined dataset to exclude rows the years 2022 and 2023 since population and wages data is not included for those years. Additionally, the national average value is also excluded because it disproportionately included data from all the Autonomous Communities and it made visual representation unbalanced.\nAxis range\nThe second step of the second alternative is to set the ranges for the x-axis and y-axis. Here, it takes the minimum and maximum values of wages and appraised value respectively, ignoring any missing values. Each range is then scaled to expand the upper and lower bounds) to ensure the plot includes some extra space around the data points for better visualization.\n\n\nx_range <- range(filtered_data$renta_media, na.rm = TRUE) * c(0.5, 1.3)\ny_range <- range(filtered_data$Valor_Tasado, na.rm = TRUE) * c(0.5, 1.3)\n\n\nVisualization\nIn order to visualize the evolution of salaries (renta_media) and housing prices (Valor_Tasado) across regions (CCAA) over time, the code below uses plotly to build an animated bubble plot. Each bubble represents a territory; the color of the bubble indicates the region (CCAA), and the size of the bubble is proportional to the population. The animation moves through frames corresponding to different years. Details such as the year, region, average salary, and house price are displayed when you click over a bubble.\n\n\nanimated_plot <- plot_ly(data = filtered_data,\n                         x = ~Valor_Tasado,  \n                         y = ~renta_media,  \n                         size = ~population,  \n                         color = ~CCAA,        \n                         frame = ~Año,         \n                         text = ~paste(\"Año: \", Año, \n                                       \"<br>CCAA: \", CCAA, \n                                       \"<br>Renta Media: \", renta_media, \n                                       \"<br>Valor Tasado: \", Valor_Tasado),\n                         hoverinfo = \"text\",   \n                         marker = list(sizemode = 'diameter', opacity = 0.6, \n                                       line = list(width = 0))) %>%\n  layout(title = \"Evolution of housing prices and wages per region\",\n         xaxis = list(title = \"Valor Tasado de la Vivienda\", range = y_range),  \n         yaxis = list(title = \"Renta Media\", range = x_range),                 \n         showlegend = TRUE,\n         hovermode = \"closest\") %>%\n  animation_opts(frame = 300, transition = 0, easing = \"linear\", redraw = FALSE)  \n\n\nanimated_plot\n\n\n\nConclusions\nThe alternative versions of the original graph offer insights that may not have been easily considered in the article in the article published by the online newspaper. For instance, these versions make it easier to distinguish differences between regions. In the tile graph, those that are currently experiencing worse conditions than during the 2008 financial crisis (*highlighted in orange**) clearly stand out from those that have yet to reach their crisis-era price levels. Moreover, the visualization enhances clarity by making it easier to identify individual regions.\nAdditionally, the interactive version of the bubble plot provides a dynamic perspective on housing trends in relation to wages, since they do not follow a parallel trajectory. This approach is key to understanding the magnitude of the housing problem and regional disparities in housing affordability.\nIn conclusion, these alternative visualizations not only provide a clearer understanding of regional disparities but also underscore the complexity of the housing crisis.\n\n\n\n",
    "preview": "projects/2024/100419840/100419840_files/figure-html5/unnamed-chunk-22-1.png",
    "last_modified": "2025-01-17T11:48:22+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 1152
  },
  {
    "path": "projects/2024/100454764/",
    "title": "What Powers France?",
    "description": "A comprehensive visualization of power plants in France.",
    "author": [
      {
        "name": "Estela Moral",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nFrist steps\nPackages\nImport and filter the data\n\nPlotting the maps\nTotal\nCoal\nGas\nHydro\nNuclear\nOil\nSolar\nWind\nBiomass\n\nArrange map & title\nAlternative map\nVersion 2.0.\nVersion 2.1.\n\n\nFor my final project I decided to replicate this map created by the Twitter user @researchremora, known for the amazing maps and visualizations he shares on the platform.\nOriginal map by @researchremoraThe maps shows the different types of power plants located in France based on their primary fuel. The legend also displays the total energetic capacity of each fuel in megawatts (mw). Additionally, this map provides some insightful geographical information about the country. For instance, we can clearly see that the southern region of France is where they enjoy the most hours of sunlight. Similarly, the northern region of the country (specially on the coast) is where the strongest winds are most prevalent. We can even infer where the Pyrenees and the Alps are located just looking at the hydro plants, since most dams are placed in mountainous areas because of their high elevation and narrow valleys.\nThe original author of the map used the rayshader package to create it, but for this project I will attempt to replicate it using only ggplot2 and other related packages.\nFrist steps\nFirst of all, I will load the packages that we will use for this project.\nPackages\n\n\nlibrary(tidyverse) # Includes several packages that we will use, such as \n                   # dyplr (for cleaning and handling the data efficiently), \n                   # readr (import cvs files), and \n                   # ggplot2 (our main data visualization tool)\nlibrary(sf) # Working with coordinates (longitude & latitude)\nlibrary(giscoR) # Retrieve France map\nlibrary(patchwork) # Arranging multiple plots\nlibrary(ggshadow) # Adding glow and other effects to the data points\nlibrary(sysfonts) # Loading Google Fonts into R\nlibrary(showtext) # Managing fonts\nlibrary(ggfx) # Adding shadows and different filters on ggplot2 layers\n\n\nImport and filter the data\nNow I fill read the csv file we will use for our visualization from the Global Power Plant Database.\n\n\npower_plants_df <- read_csv(file = \"global_power_plant_database.csv\")\n\n\nThis database, created by the World Resources Institute (WRI), collects different information about existing power plants around the world.\n\n\nhead(power_plants_df)\n\n# A tibble: 6 × 36\n  country country_long name   gppd_idnr capacity_mw latitude longitude\n  <chr>   <chr>        <chr>  <chr>           <dbl>    <dbl>     <dbl>\n1 AFG     Afghanistan  Kajak… GEODB004…        33       32.3      65.1\n2 AFG     Afghanistan  Kanda… WKS00701…        10       31.7      65.8\n3 AFG     Afghanistan  Kanda… WKS00711…        10       31.6      65.8\n4 AFG     Afghanistan  Mahip… GEODB004…        66       34.6      69.5\n5 AFG     Afghanistan  Naghl… GEODB004…       100       34.6      69.7\n6 AFG     Afghanistan  Nanga… GEODB004…        11.6     34.5      70.4\n# ℹ 29 more variables: primary_fuel <chr>, other_fuel1 <chr>,\n#   other_fuel2 <chr>, other_fuel3 <lgl>, commissioning_year <dbl>,\n#   owner <chr>, source <chr>, url <chr>, geolocation_source <chr>,\n#   wepp_id <chr>, year_of_capacity_data <dbl>,\n#   generation_gwh_2013 <dbl>, generation_gwh_2014 <dbl>,\n#   generation_gwh_2015 <dbl>, generation_gwh_2016 <dbl>,\n#   generation_gwh_2017 <dbl>, generation_gwh_2018 <dbl>, …\n\nSince we are only interested in the power plants of France, we need to filter the data by creating a separate dataframe for each fuel type:\n\n\nfra_total <- power_plants_df |> filter(country == \"FRA\")\nfra_coal <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Coal\")\nfra_gas <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Gas\")\nfra_hydro <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Hydro\")\nfra_nuclear <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Nuclear\")\nfra_oil <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Oil\")\nfra_solar <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Solar\")\nfra_wind <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Wind\")\nfra_bio <- power_plants_df |> filter(country == \"FRA\",\n                                      primary_fuel == \"Biomass\")\n\n\nThe idea is to create a map for each fuel type, as well as a map that includes all the different power plants, so later we can arrange them together using the patchwork package.\nThe next step is retrieving the France map from the giscoR package.\n\n\nFR <- gisco_get_countries(country = \"FRA\")\n\n\nAnd finally, before getting started with our visualization, I will set the color palette for our data points, as well as the font we will use for the title and the legend of our plot, but you can customize it to your liking.\n\n\nfuel_colors <- c(\"Coal\" = \"#FDA5E2\",\n                 \"Gas\" = \"#FDBF63\",\n                 \"Hydro\" = \"#91DAF7\",\n                 \"Nuclear\" = \"#D69FFF\",\n                 \"Oil\" = \"#FF8585\",\n                 \"Solar\" = \"#FFF575\",\n                 \"Wind\" = \"#8AEEBE\",\n                 \"Biomass\" = \"#B7FF81\")\n\n\n\n\nsysfonts::font_add_google(\"Audiowide\", family = \"audiowide\")\nshowtext::showtext_auto()\n\n\nPlotting the maps\nTotal\nTo begin with, I will plot the map that includes all the different types of power plants. First, we need to plot the map of France using the geom_sf function from ggplot2. It is important to adjust the coordinates properly with coord_sf because France has many overseas territories in other continents that we will not include in our visualization for the sake of simplicity. I also added a slight shadow effect to the borders of France using the with_shadow function from the ggshadow package. This way we can distinguish them better from the dark background.\n\n\ntotal_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(),     \n        plot.background = element_rect(fill = \"#1A1E29\", \n                                       color = NA),\n        legend.position = \"none\") +\n   coord_sf(xlim = c(-6, 10), ylim  = c(41, 52))\n\ntotal_plants\n\n\n\nNow we can add the data points using geom_glowpoint from the ggfx package. It works the same as geom_point from ggplot2, but it adds a glow effect that you can adjust with different arguments such as shadowsize or shadowalpha. Considering that we are plotting points into a map, we need to assign our \\(x\\) and \\(y\\) values to longitude and latitude respectively. We will color each point using the primary_fuel color palette we set at the beginning, specifying it in our aesthetics and creating our own color scale with scale_color_manual.\n\n\ntotal_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(),     \n        plot.background = element_rect(fill = \"#1A1E29\", \n                                       color = NA),\n        legend.position = \"none\") +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  geom_glowpoint(data = fra_total, aes(x = longitude, \n                                       y = latitude, \n                                       color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors,\n                     name = NULL)\n  \n\ntotal_plants\n\n\n\nAfter that, we can add our legend with the annotate() function\n\n\ntotal_plants <- total_plants + annotate(\"text\", x = -3.6, y = 41.5, \n           label = \"~64,000 MW\", color = fuel_colors[\"Nuclear\"], \n           size = 4.5, family = \"audiowide\") +\n  annotate(\"text\", x = -3.6, y = 41, \n           label = \"NUCLEAR\", color = fuel_colors[\"Nuclear\"], \n           size = 8.5, family = \"audiowide\") +\n  annotate(\"text\", x = 0.45, y = 41.34, \n           label = \"~20,000 MW\", color = fuel_colors[\"Hydro\"], \n           size = 3.25, family = \"audiowide\") +\n  annotate(\"text\", x = 0.45, y = 40.95, \n           label = \"HYDRO\", color = fuel_colors[\"Hydro\"], \n           size = 6.3, family = \"audiowide\") +\n  annotate(\"text\", x = 3.1, y = 41.2, \n           label = \"~9,000 MW\", color = fuel_colors[\"Wind\"], \n           size = 2.5, family = \"audiowide\") +\n  annotate(\"text\", x = 3.1, y = 40.95, \n           label = \"WIND\", color = fuel_colors[\"Wind\"], \n           size = 4.5, family = \"audiowide\") +\n  annotate(\"text\", x = 4.65, y = 40.92, \n           label = \"GAS\", color = fuel_colors[\"Gas\"], \n           size = 3.2, family = \"audiowide\") +\n  annotate(\"text\", x = 6.1, y = 40.92, \n           label = \"SOLAR\", color = fuel_colors[\"Solar\"], \n           size = 3.19, family = \"audiowide\") +\n   annotate(\"text\", x = 7.5, y = 40.92, \n            label = \"OIL\", color = fuel_colors[\"Oil\"], \n            size = 3.2, family = \"audiowide\") +\n   annotate(\"text\", x = 8.68, y = 40.92, \n            label = \"COAL\", color = fuel_colors[\"Coal\"], \n            size = 3, family = \"audiowide\") + \n   annotate(\"text\", x = 10.25, y = 40.92, \n            label = \"BIOMASS\", color = fuel_colors[\"Biomass\"], \n            size = 2.5, family = \"audiowide\") \n\ntotal_plants\n\n\n\nIn the following code chunks I will repeat the same process to plot a different map for each fuel type.\nCoal\n\n\ncoal_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(),     \n        plot.background = element_rect(fill = \"#1A1E29\", \n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_coal, aes(x = longitude, \n                                      y = latitude, \n                                      color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"COAL\", \n           color = fuel_colors[\"Coal\"], size = 4.7, family = \"audiowide\")\n\ncoal_plants\n\n\n\nGas\n\n\ngas_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(),\n        panel.border = element_blank(),\n        plot.background = element_rect(fill = \"#1A1E29\", \n                                       color = NA),\n        legend.position = \"none\",\n        text = element_text(family = \"audiowide\")) +\n  geom_glowpoint(data = fra_gas, aes(x = longitude, \n                                     y = latitude, \n                                     color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"GAS\", \n           color = fuel_colors[\"Gas\"], size = 4.7, family = \"audiowide\")\n\ngas_plants\n\n\n\nHydro\n\n\nhydro_plants <- ggplot() +\n with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n             sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(),\n        panel.border = element_blank(),\n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_hydro, aes(x = longitude,\n                                       y = latitude,\n                                       color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"HYDRO\", color = fuel_colors[\"Hydro\"], size = 4.7, family = \"audiowide\")\n\nhydro_plants\n\n\n\nNuclear\n\n\nnuclear_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(),\n        panel.border = element_blank(),\n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_nuclear, aes(x = longitude,\n                                         y = latitude,\n                                         color = primary_fuel),\n                 size = 0.25, \n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"NUCLEAR\", \n           color = fuel_colors[\"Nuclear\"], size = 4.7, family = \"audiowide\")\n\nnuclear_plants\n\n\n\nOil\n\n\noil_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(),\n        panel.border = element_blank(),\n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_oil, aes(x = longitude, \n                                     y = latitude, \n                                    color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"OIL\", \n           color = fuel_colors[\"Oil\"], size = 4.7, family = \"audiowide\")\n\noil_plants\n\n\n\nSolar\n\n\nsolar_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(),\n        panel.border = element_blank(),\n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_solar, aes(x = longitude, \n                                       y = latitude, \n                                       color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"SOLAR\", \n           color = fuel_colors[\"Solar\"], size = 4.7, family = \"audiowide\")\n\nsolar_plants\n\n\n\nWind\n\n\nwind_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(),     \n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_wind, aes(x = longitude, \n                                      y = latitude,\n                                      color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"WIND\", \n           color = fuel_colors[\"Wind\"], size = 4.7, family = \"audiowide\")\n\nwind_plants\n\n\n\nBiomass\n\n\nbio_plants <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(),     \n        plot.background = element_rect(fill = \"#1A1E29\",\n                                   color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_bio, aes(x = longitude,\n                                     y = latitude, \n                                     color = primary_fuel),\n                 size = 0.25,\n                 shadowsize = 0.32,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors) +\n  coord_sf(xlim = c(-6, 10), ylim = c(41, 52)) +\n  annotate(\"text\", x = 2, y = 41.25, label = \"BIOMASS\", \n           color = fuel_colors[\"Biomass\"], size = 4.7, family = \"audiowide\")\n\nbio_plants\n\n\n\nArrange map & title\nAs the last step, we can arrange all the maps together using plot_layout()from patchwork package, and finally add the title.\n\n\n# Specify the layout:\nlayout <- \"\nAAB\nAAC\nDEF\nGHI\n\"\n\n# Arrange the maps:\narranged_maps <- total_plants + nuclear_plants + hydro_plants + oil_plants + \n  solar_plants + wind_plants + coal_plants + bio_plants + gas_plants +\n  plot_layout(design = layout)\n\n# Add the title:\nfinal_map <- arranged_maps + plot_annotation(\n  theme = theme(plot.background = element_rect(fill = \"#1A1E29\",\n                                               color = NA),\n                plot.caption = element_text(color = \"white\",\n                                            size = 50,\n                                            hjust = 0.5, vjust = 0.5,\n                                            margin = unit(c(0.3, 0, 0.3, 0), \"cm\"),\n                                            family = \"audiowide\")),\n  caption = \"WHAT POWERS FRANCE?\")\n\nfinal_map\n\n\n\nAlternative map\nThe map we just created shows in a clear and straightforward way the wide variety of power plants that exist in France. However it can be a bit misleading because it does not reflect which are main types of energy that actually fuel the country. Looking solely at the map one might think that sunlight is the main energy source, since solar plants are the most numerous, but if we take a closer look and read the legend, we can see that nuclear power plants are the ones with the highest energy capacity (64,000 MW). To avoid this kind of misunderstandings, I have come up with an alternative way to plot the maps: adjusting the size of each data point to reflect the actual energy capacity of each plant.\nVersion 2.0.\nIn order to do that we just need to adjust the size parameter into the aesthetics, linking it to the capacity_mw variable. We can also add some transparency to see the points better when overplotting happens.\n(It is important to note that the shadowsize parameter cannot be mapped to the capacity_mw variable because of how the geom_glowpoint() function works, so we must adjust it manually).\n\n\ntotal_plants_2.0 <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(), \n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_total, aes(x = longitude, \n                                       y = latitude,\n                                       color = primary_fuel,\n                                       size = capacity_mw, # Adjust the size to capacity_ww\n                                       alpha = 0.3), # Add some transparency to help visualization\n                 shadowsize = 1,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors, name = NULL) +\n  coord_sf(xlim = c(-6, 10), ylim = c (41, 52)) \n\ntotal_plants_2.0\n\n\n\nIf we tweak the same parameters in the rest of the maps the result is as follows:\n\n\n\nVersion 2.1.\nDespite adding the alpha, there is still some overplotting issues, specially in the wind and hydro power plants. For this reason I decided to change the scale that ggplot uses to calculate the size of each data point adding the scale_size_area(max_size = ... ) at the end of the code. This allows me to limit the maximum size of the biggest point, plotting the rest of them accordingly. Changing this parameter I am able to make all of the points look proportionally smaller so they do not overlap as much with eachother.\n\n\ntotal_plants_2.1 <- ggplot() +\n  with_shadow(geom_sf(data = FR, fill = \"black\", color = \"black\"),\n              sigma = 8) +\n  theme_void() + \n  theme(panel.background = element_blank(), \n        panel.border = element_blank(), \n        plot.background = element_rect(fill = \"#1A1E29\",\n                                       color = NA),\n        legend.position = \"none\") +\n  geom_glowpoint(data = fra_total, aes(x = longitude, \n                                       y = latitude,\n                                       color = primary_fuel,\n                                       size = capacity_mw, \n                                       alpha = 0.3), \n                 shadowsize = 1,\n                 shadowalpha = 0.005) +\n  scale_color_manual(values = fuel_colors, name = NULL) +\n  scale_size_area(max_size = 5) + # Limits maximum size of the points\n  coord_sf(xlim = c(-6, 10), ylim = c (41, 52)) \n\ntotal_plants_2.1\n\n\n\nNow I repeat the same in the rest of the maps\n\n\n\nHere is a side by side comparison of the original replication and the alternative version:\n\n\nwrap_plots(final_map, final_map_2.1)\n\n\n\n\n\n\n",
    "preview": "projects/2024/100454764/100454764_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1084,
    "preview_height": 1536
  },
  {
    "path": "projects/2024/100527072/",
    "title": "Gender Participation Across Sports in the Summer Olympic Games",
    "description": "Recreation, improvement and alternative visualizations of gender participation\nin the Olympics plot (1896 – 2024).",
    "author": [
      {
        "name": "Laura Toro-Iglesias",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nData Base\nReplica Plot\nMy version\nInteractive plot\nAlternative visualizations\n\n\nThe graph I chose is the following:\nOriginal graph. Source: Distribution of ThingsIt’s called “Gender Participation Across Sports in the Summer Olympic Games (1896 – 2024)” and it shows how different Olympic sports across the years have allowed or not the participation of men, women or both in each discipline.\nI chose this graph because the topic of the evolution of inclusivity in the Olympics looked interesting to me and it offered room for improvement. Also, I think it’s a pretty graph.\nThe data is from the platform Kaggle, from three different databases: the athlete’s databases from “120 years of Olympic history: athletes and results”, “Paris 2024 Olympic Summer Games” and “Tokyo 2020 Olympic Summer Games”.\nBecause the data was in different sites, I had to make one unique table that combined the data from all the years into one. There was also a lot of information that was unnecessary, like the athletes’ physical characteristics or their medals. The only information I needed was the sport and the gender. Therefore, I selected the variables year and sport and created a new one called gender status to say if the sport was “Male only”, “Female only” or “Male and female”. After doing that, I had to change the name of the sport Equestrianism in the first data base, delete some of the years in that one, and also order the sports in the order of the original graph. I fixed the databases of Tokyo and Paris in the same way.\nData Base\nData base 1:\n\n\nlibrary(tidyverse)\n\ndata1 <- read_csv(\"athlete_events.csv\")\ndata1.df <- data.frame(data1[1:271116,1:15])\n\ndata1 <- data1.df |> \n  group_by(Year, Sport) |>\n  summarise(status = paste0(unique(Sex), collapse=\"\"))\n\ndata1 <- data1 |> \n  mutate(Gender_Status = case_when(\n      status == \"M\" ~ \"Male only\",\n      status == \"F\" ~ \"Female only\",\n      status %in% c(\"MF\", \"FM\") ~ \"Male_and_Female\",\n      TRUE ~ \"Unknown\"))\n\ndata1 <- data1 |> \n  mutate(Sport = factor(Sport, levels = names(sort(table(Sport), decreasing = TRUE)))) |> \n  mutate(Sport = case_when(\n    Sport == \"Equestrianism\" ~ \"Equestrian\",\n    TRUE ~ Sport)) |> \n  filter(!Year %in% c(1994, 1998, 2002, 2006, 2010, 2014))\n\n\n#order sports\ndata1 <- data1 |> \n  mutate(Sport = factor(Sport,\n                        levels = c(\"Swimming\", \"Athletics\", \"Rowing\", \"Fencing\", \"Wrestling\", \"Water Polo\",\n                                   \"Football\", \"Diving\", \"Cycling\", \"Shooting\", \"Sailing\", \"Gymnastics\",\n                                   \"Weightlifting\", \"Equestrian\", \"Boxing\", \"Modern Pentathlon\", \"Hockey\",\n                                   \"Basketball\", \"Canoeing\", \"Archery\", \"Tennis\", \"Volleyball\", \"Judo\", \"Handball\",\n                                   \"Rhythmic Gymnastics\", \"Table Tennis\", \"Synchronized Swimming\", \"Badminton\",\n                                   \"Beach Volleyball\", \"Art Competitions\", \"Taekwondo\", \"Triathlon\", \"Tug-Of-War\",\n                                   \"Baseball\", \"Polo\", \"Trampolining\", \"Golf\", \"Rugby\", \"Softball\", \"Rugby Sevens\",\n                                   \"Alpinism\", \"Lacrosse\", \"Cricket\", \"Croquet\", \"Roque\", \"Racquets\",\n                                   \"Basque Pelota\", \"Aeronautics\", \"Jeu De Paume\", \"Motorboating\"))) |> \n  filter(!is.na(Sport))\n\n\nTokyo database:\n\n\ndata_tokyo <- read_csv(\"athletes_Tokyo.csv\")\ntokyodf <- data.frame(data_tokyo[1:11656,1:14])\n\ntokyo <- tokyodf |> \n  mutate(Year = \"2020\") |> \n  rename(Sex = gender, Sport = discipline) |> \n  mutate(Sex = ifelse(Sex == \"Male\", \"M\", ifelse(Sex == \"Female\", \"F\", Sex))) |> \n  group_by(Year, Sport) |>\n  summarise(status = paste0(unique(Sex), collapse=\"\")) |> \n  mutate(Gender_Status = case_when(\n      status == \"M\" ~ \"Male only\",\n      status == \"F\" ~ \"Female only\",\n      status %in% c(\"MF\", \"FM\") ~ \"Male_and_Female\",\n      TRUE ~ \"Unknown\"))\n\n\nParis database:\n\n\ndata_paris <- read_csv(\"athletes_Paris.csv\")\nparisdf <- data.frame(data_paris[1:11110,1:35])\n\nparis <- parisdf |> \n  mutate(Year = \"2024\") |> \n  rename(Sex = gender, Sport = disciplines) |> \n  mutate(Sex = ifelse(Sex == \"Male\", \"M\",\n                      ifelse(Sex == \"Female\", \"F\", Sex))) |> \n  mutate(Sport = str_remove_all(Sport, \"\\\\['|']\")) |> \n  group_by(Year, Sport) |>\n  summarise(status = paste0(unique(Sex), collapse=\"\")) |> \n  mutate(Gender_Status = case_when(\n      status == \"M\" ~ \"Male only\",\n      status == \"F\" ~ \"Female only\",\n      status %in% c(\"MF\", \"FM\") ~ \"Male_and_Female\",\n      TRUE ~ \"Unknown\"))\n\n\nJoin databases:\n\n\ndata1$Year <- as.factor(data1$Year)\ntokyo$Year <- as.factor(tokyo$Year)\nparis$Year <- as.factor(paris$Year)\n\ndata_final <- bind_rows(data1, tokyo, paris)\n\n\nFinal database, with sports ordered:\n\n\ndata_final <- data_final |> \n  mutate(Sport = factor(Sport,\n                        levels = c(\"Swimming\", \"Athletics\", \"Rowing\", \"Fencing\", \"Wrestling\", \"Water Polo\",\n                                   \"Football\", \"Diving\", \"Cycling\", \"Shooting\", \"Sailing\", \"Gymnastics\",\n                                   \"Weightlifting\", \"Equestrian\", \"Boxing\", \"Modern Pentathlon\", \"Hockey\",\n                                   \"Basketball\", \"Canoeing\", \"Archery\", \"Tennis\", \"Volleyball\", \"Judo\", \"Handball\",\n                                   \"Rhythmic Gymnastics\", \"Table Tennis\", \"Synchronized Swimming\", \"Badminton\",\n                                   \"Beach Volleyball\", \"Art Competitions\", \"Taekwondo\", \"Triathlon\", \"Tug-Of-War\",\n                                   \"Baseball\", \"Polo\", \"Trampolining\", \"Golf\", \"Rugby\", \"Softball\", \"Rugby Sevens\",\n                                   \"Surfing\", \"Skateboarding\", \"Artistic Gymnastics\", \"Trampoline Gymnastics\",\n                                   \"Artistic Swimming\", \"Alpinism\", \"Sport Climbing\", \"Canoe Sprint\",\n                                   \"3x3 Basketball\", \"Cycling Track\", \"Marathon Swimming\", \"Lacrosse\",\n                                   \"Canoe Slalom\", \"Cycling BMX Freestyle\", \"Cycling BMX Racing\",\n                                   \"Cycling Mountain Bike\", \"Cycling Road\", \"Cricket\", \"Croquet\", \"Roque\",\n                                   \"Racquets\", \"Basque Pelota\", \"Baseball/Softball\", \"Aeronautics\",\n                                   \"Jeu De Paume\", \"Karate\", \"Motorboating\", \"Breaking\"))) |> \n  filter(!is.na(Sport))\n\n\nThis fixing of the data base was one of my first issues when it came to replicating the graph. As it can be seen, the variables didn’t have the same names across the different databases, some sports like Equestrianism had different names, and so I had to process the data to change all of that. In order to have a correct replica, I couldn’t change some names, for example, Artistic vs Rythmic gymnastics changed name in Tokyo Olympics, and the people that made the plot didn’t account for that, so some of the sports that only have data for Tokyo and Paris is because of that (or because they separated some sports into their different events).\nReplica Plot\nI did the plot using geom_tile. This creates a rectangular grid of tiles, where each tile represents, for a sport and year, whether just men, women or both were allowed to compete. I had to carefully adjust the sizes to make it as close as possible to the original one, which took a few tries and was one of my main challenges.\n\n\na <- ggplot(data_final, aes(x = factor(Year), y = reorder(Sport, desc(Sport)))) +\n  geom_tile(aes(fill = Gender_Status), color = \"white\", width = 0.65, height = 0.65) +\n  scale_fill_manual(\n    values = c(\n      \"Male_and_Female\" = \"#ed8280\",\n      \"Male only\" = \"#82cfed\",\n      \"Female only\" = \"#870304\"),\n    breaks = c(\"Male_and_Female\", \"Male only\", \"Female only\"),\n    labels = c(\n      \"Male_and_Female\" = \"Male and Female\",\n      \"Male only\" = \"Male Only\",\n      \"Female only\" = \"Female Only\")) +\n  labs(\n    title = \"Gender Participation Across Sports in the Summer Olympic Games (1896 – 2024)\",\n    x = NULL,\n    y = NULL,\n    fill = \"\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_text(size = 10, face = \"bold\", angle = 0, hjust = 1, vjust = 0.5),\n    axis.text.x = element_text(angle = 90, face = \"bold\", hjust = 1, vjust = 0.5),\n    legend.position = \"bottom\",\n    panel.grid.major = element_line(color = \"gray90\", size = 0.5),\n    panel.grid.minor = element_line(color = \"gray95\", size = 0.25),\n    plot.title = element_text(hjust = 1, face = \"bold\", size = 12.5),\n    plot.margin = margin(10, 10, 10, 10)\n  )\n\na\n\n\n\nMy version\nNow it is time to create my version of this graph. I’ve decided to, on one hand, improve the original plot, by making it more readable, and on the other hand, to create an alternative visualization, as I think this one has some problems which I’ll address soon.\nOne of the issues I find with it is that it’s hard to read as there are a lot of sports and it’s difficult to see which years correspond to each sport to see at what point in history it actually changed participation.\nTo improve readability, first of all, I rearranged the data base. To do this, I did two things: first, I combined events that belonged to one sport into said sport, as well as sports that had their name changed in the Tokyo Olympics. We can see this in sports like cycling or synchronized swimming respectively:\n\n\ndata_newversion <- data_final |> \n  mutate(Sport_Grouped = case_when(\n    Sport %in% c(\"Artistic Gymnastics\", \"Trampoline Gymnastics\", \"Gymnastics\") ~ \"Gymnastics\",\n    Sport %in% c(\"Cycling Track\", \"Cycling Road\", \"Cycling Mountain Biking\", \"Cycling BMX Freestyle\",\n                 \"Cycling BMX Racing\") ~ \"Cycling\",\n    Sport %in% c(\"Artistic Swimming\", \"Synchronized Swimming\") ~ \"Synchronized Swimming\",\n    Sport %in% c(\"Canoeing\", \"Canoe Sprint\", \"Canoe Slalom\") ~ \"Canoeing\",\n    Sport %in% c(\"Baseball\", \"Softball\", \"Baseball/Softball\") ~ \"Baseball\",\n    Sport %in% c(\"Basketball\", \"3x3 Basketball\") ~ \"Basketball\",\n    Sport %in% c(\"Volleyball\", \"Beach Volleyball\") ~ \"Volleyball\",\n    Sport %in% c(\"Swimming\", \"Marathon Swimming\") ~ \"Swimming\",\n    Sport %in% c(\"Sport Climbing\", \"Alpinism\") ~ \"Sport Climbing\",\n    TRUE ~ Sport\n  )) |> \n  mutate(Sport_Grouped = factor(Sport_Grouped,\n                                levels = c(\"Swimming\", \"Athletics\", \"Rowing\", \"Fencing\", \"Wrestling\", \"Water Polo\",\n                                           \"Football\", \"Diving\", \"Cycling\", \"Shooting\", \"Sailing\", \"Gymnastics\",\n                                           \"Weightlifting\", \"Equestrian\", \"Boxing\", \"Modern Pentathlon\", \"Hockey\",\n                                           \"Basketball\", \"Canoeing\", \"Archery\", \"Tennis\", \"Volleyball\", \"Judo\",\n                                           \"Handball\", \"Rhythmic Gymnastics\", \"Table Tennis\",\n                                           \"Synchronized Swimming\", \"Badminton\", \"Art Competitions\", \"Taekwondo\",\n                                           \"Triathlon\", \"Tug-Of-War\"))) |> \n  filter(!is.na(Sport_Grouped))\n\n\nI also eliminated some of the sports, mainly the ones that have barely had presence in the Olympics history, like basque pelota, aeronautics, or the recent incorporation of break dance (breaking).\nOnce we’ve rearranged the database, we have a more concise and more readable plot:\n\n\np <- ggplot(data_newversion, aes(x = factor(Year), y = reorder(Sport_Grouped, desc(Sport_Grouped)))) +\n  geom_tile(aes(fill = Gender_Status), color = \"white\", width = 0.7, height = 0.7) +\n  scale_fill_manual(\n    values = c(\n      \"Male_and_Female\" = \"#ed8280\",\n      \"Male only\" = \"#82cfed\",\n      \"Female only\" = \"#870304\"),\n    breaks = c(\"Male_and_Female\", \"Male only\", \"Female only\"),\n    labels = c(\n      \"Male_and_Female\" = \"Male and Female\",\n      \"Male only\" = \"Male Only\",\n      \"Female only\" = \"Female Only\")) +\n  labs(\n    title = \"Gender Participation Across Sports in the Summer Olympic Games (1896 – 2024)\",\n    x = NULL,\n    y = NULL,\n    fill = \"\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_text(size = 10, face = \"bold\", angle = 0, hjust = 1, vjust = 0.5),\n    axis.text.x = element_text(angle = 90, face = \"bold\", hjust = 1, vjust = 0.5),\n    legend.position = \"bottom\",\n    panel.grid.major = element_line(color = \"gray90\", size = 0.5),\n    panel.grid.minor = element_line(color = \"gray95\", size = 0.25),\n    plot.title = element_text(hjust = 1, face = \"bold\", size = 12.5),\n    plot.margin = margin(10, 10, 10, 10)\n  )\n\np\n\n\n\nThis version is shorter, which makes it easier for the eyes to read. It is true, though, that we lose some information, especially for those minoritarian sports. Still, I think that information we lose is more anecdotal, it doesn’t really allow us to see tendencies like the evolution of inclusivity in sports (as they’re sports that have only appeared once or twice in the Olympics).\nInteractive plot\nOnce we have the plot with the new database, we can make it interactive with plotly:\n\n\nlibrary(plotly)\n\n# Convert to interactive plot with plotly\ninteractive_plot <- ggplotly(p, tooltip = c(\"x\", \"y\", \"fill\"), height = 650, width = 950)\n\n# Display the interactive plot\ninteractive_plot\n\n\n\nI find the interactive version of the plot an improvement on the original one, as it allows us to select genders to see only that information in order to have a more clear vision on how inclusivity across sports has changed. We can also use the cursor to select a specific period of time or specific sports.\nAlternative visualizations\nI’ve already improved the original plot by making it more readable, shorter and interactive, but I also wanted to try some alternative visualizations to see if there is a better way to present the plot’s information.\nOne of the difficulties I found doing this, is that the plot’s data is actually very scarce, it doesn’t tell you a lot about the topic at hands. It could be interesting to have the proportion of men and women participating.\nIn the end, I opted to do two barcharts. I chose the barcharts because, with the scarce data the original plot has, what’s interesting about it is that it wants to tell us about the evolution of inclusivity in the sports. I think a barchart is a great way to see this evolution and the changing tendencies, because the data won’t be so stacked as in the original (making it difficult to see which years correspond to each sport to see at what point in history it actually changed participation). For example, we’ll be able to see more clearly how male-only dominated sports become more uncommon and inclusive sports become more common.\nThe first option for a bar chart was a classical one (note that I’m again using the final database I used in the replica instead of the database from the improvement version, as I don’t have the need here to shorten the list of sports in order to make it more readable. The only difference is that we have a higher total count of sports):\n\n\nyearly_gender_counts <- data_final |> \n  group_by(Year, Gender_Status) |> \n  summarise(Count = n(), .groups = 'drop')\n\n#Barchart\nggplot(yearly_gender_counts, aes(x = factor(Year), y = Count, fill = Gender_Status)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  labs(\n    title = \"Gender Participation by Year in the Summer Olympic Games (1896 – 2024)\",\n    x = \"Year\",\n    y = \"Sports Count\",\n    fill = \"Gender Status\"\n  ) +\n  scale_fill_manual(\n    values = c(\"Male_and_Female\" = \"#ed8280\", \"Male only\" = \"#82cfed\", \"Female only\" = \"#870304\"),\n    breaks = c(\"Male_and_Female\", \"Male only\", \"Female only\"),\n    labels = c(\"Male and Female\", \"Male Only\", \"Female Only\")\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1),\n    legend.position = \"bottom\"\n  )\n\n\n\nWe can see with much more clarity the evolution in tendencies, as we see the male only blue bar getting smaller and smaller until it disappears after 2008. We also see how inclusive sports become more popular by the years, with a special rise starting in 1976.\nIn my opinion, this is a better albeit simpler way to see what the original plot wanted us to see: how gender becomes less of a barrier when it comes to participating in Olympic sports.\nAnother way we can see this evolution by paying special attention to changes in specific years, is doing a barchart with proportionally stacked bars:\n\n\nlibrary(forcats)\n\nyearly_gender_proportions <- data_final |> \n  group_by(Year, Gender_Status) |> \n  summarise(Count = n(), .groups = 'drop') |> \n  group_by(Year) |> \n  mutate(Proportion = Count / sum(Count))\n\n\nyearly_gender_proportions <- yearly_gender_proportions |> \n  mutate(Gender_Status = fct_relevel(Gender_Status, \"Female only\", after = Inf))\n\n#Stacked barchart\nggplot(yearly_gender_proportions, aes(x = factor(Year), y = Proportion, fill = Gender_Status)) +\n  geom_bar(stat = \"identity\", position = \"fill\") +\n  labs(\n    title = \"Proportional Gender Participation by Year in the Summer Olympic Games (1896 – 2024)\",\n    x = \"Year\",\n    y = \"Proportion\",\n    fill = \"Gender Status\"\n  ) +\n  scale_fill_manual(\n    values = c(\"Male_and_Female\" = \"#ed8280\", \"Male only\" = \"#82cfed\", \"Female only\" = \"#870304\"),\n    breaks = c(\"Male_and_Female\", \"Male only\", \"Female only\"),\n    labels = c(\"Male and Female\", \"Male Only\", \"Female Only\")\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1),\n    legend.position = \"bottom\"\n  )\n\n\n\nAlthough the previous plot allows us to see the evolution more clearly, this one lets us see tendencies in specific years more clearly. For example, how there was more inclusivity in the period 1920-1928, which allows to ask ourselves questions related to the topic to further a possible investigation, like if it has to do with the aftermath of WWI, and why that changed after, as we see a decrease after 1928. We also see an important increase in inclusivity from 1976 onwards, which again can bring us to ask more questions about that period of time.\nOverall, these improvements entail a better understanding of the evolution of inclusivity in Olympic sports, something that was more difficult in the original plot. Nevertheless, it must also be stated that these improvements also have limitations not previously found in the original plot. For example, since they consider the total number of sports and their proportions, we can’t see which specific sports had more barriers for females inclusion. In the original, we see how sports like swimming, fencing or diving allowed women’s participation quite early on, but others like wrestling, water polo or football took more years to allow women to participate.\nIn conclusion, I think the most important thing to create a plot is to have a clear question to answer. I was interested in the evolution of inclusivity in Olympic sports, for which my improvements may be a better option than the original one, but I’m also losing some information by not taking into consideration the specificities of each particular sport.\n\n\n\n",
    "preview": "projects/2024/100527072/100527072_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 2150
  },
  {
    "path": "projects/2024/100535153/",
    "title": "The Changing Nature of Middle-Class Jobs",
    "description": "The types of jobs that pay middle-class wages — between $40,000 and $80,000\nin 2014 dollars — have shifted since 1980. Fewer of these positions are in\nmale-dominated production occupations, while a greater share are in workplaces\nmore open to women.",
    "author": [
      {
        "name": "Marco Boso",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication work\nLoad the packages\nInsert the data\nLoop for the gradient transition\nFirst graph\nThe others graphs\nFaceting\nFinal adjustments\n\nAlternative graph\nRemodelling the data\nCreating the plot\n\n\nIntroduction\nThe chart from The New York Times examines the shifting landscape of middle-class jobs, defined as positions paying between $40,000 and $80,000 in 2014 dollars, and how these changes have impacted the workforce since 1980. Over a span of 30 years, the analysis by a team of reporters and data journalists revealed a significant transformation in the types of jobs offering middle-class wages. Notably, there has been a decline in male-dominated production occupations, traditionally associated with manufacturing and physical labor. At the same time, a growing share of middle-class positions has emerged in workplaces that are more inclusive and accessible to women, such as healthcare, education, and administrative roles.\nThis shift reflects broader societal changes, including advancements in technology, globalization, and evolving cultural norms about gender roles in the workforce. As part of a comprehensive series on the American middle class, the data highlights that women have been the primary beneficiaries of these shifts, gaining increased access to stable, well-paying jobs that were previously less available to them.\nThe Changing Nature of Middle-Class Jobs - The New York TimesReplication work\nLoad the packages\n\n\nlibrary(tidyverse)   \nlibrary(readxl)     \nlibrary(cowplot)     \nlibrary(scales) \n\n\nThe chart is made up of 10 individual graphs, each illustrating changes in employment within a specific sector over time. To construct the final visualization, I first modeled and created each graph separately, ensuring that each accurately depicted the employment trends for its respective sector. Once the individual graphs were completed, I combined them into a cohesive and comprehensive chart using faceting.\nInsert the data\nI was unable to access an existing online dataset, so I had to recreate the data myself. Fortunately, a detailed description was provided on the same page as the article, and using that information, I was able to create an Excel file containing all the necessary details to produce the chart. To make it easier to manage the data across the corresponding graphs, I decided to organize the Excel file into separate sheets, each dedicated to a specific occupational area.\nHere you can find the link to the page of the article to extract the data: The Changing Nature\nof Middle-Class Jobs - The New York Times\n\n\ndata1 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Professionals and specialists\")\ndata2 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Managers and administrators\")\ndata3 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Service workers and salespeople\")\ndata4 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Technicians\")\ndata5 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Police, fire and military\")\ndata6 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Administrative support workers\")\ndata7 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Transportation workers\")\ndata8 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Construction and agricolture \")\ndata9 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Skilled production workers\")\ndata10 <- read_xlsx(\"middle_class.xlsx\", sheet = \"Machine operators and assembler\")\n\n\nThis is an example of the sheet for ‘Managers and administrators’. The column ‘Jobs’ represents specific occupations or job titles within each sector, while ‘Sector’ groups jobs into broader categories and reflects the division by sheets. ‘Years’ indicates the time frame of the data (1980 and 2012), and ‘Employed’ shows the number of people employed in a specific job, expressed in thousands (e.g., 41 represents 41,000 workers). Finally, ‘Gender’ represents the proportion of workers in a job that are male, expressed as a decimal (e.g., 1.0 means 100% male, 0.0 means 100% female, and intermediate values like 0.5 indicate an equal gender balance).\n\n\nhead(data1)\n\n# A tibble: 6 × 5\n  Jobs                                Sector     Years Employed Gender\n  <chr>                               <chr>      <dbl>    <dbl>  <dbl>\n1 Elementary school teacher           Professio…  1980       41    0.2\n2 Elementary school teacher           Professio…  2012       52    0.2\n3 Registred nurses                    Professio…  1980       19    0  \n4 Registred nurses                    Professio…  2012       39    0  \n5 Mathematical and computer scientist Professio…  1980        6    0.7\n6 Mathematical and computer scientist Professio…  2012       25    0.7\n\nLoop for the gradient transition\nIn my opinion, the most interesting aspect of the chart is the gradient color shift within the lines that make up the visualization. This color change represents the percentage shift in the workforce composition for a specific job by gender-blue indicates 100% male employment, red represents 100% female employment, and intermediate colors reflect varying percentages, culminating in a neutral gray where gender parity is achieved.\nTo implement this effect, it is necessary to create a loop that interpolates the colors along the lines, ensuring a smooth gradient transition between points.\n\n\n# Tranform the data in Gender column in factor to create the interpolation for the color gradient \ndata1$Gender <- as.factor(data1$Gender)\ndata2$Gender <- as.factor(data2$Gender)\ndata3$Gender <- as.factor(data3$Gender)\ndata4$Gender <- as.factor(data4$Gender)\ndata5$Gender <- as.factor(data5$Gender)\ndata6$Gender <- as.factor(data6$Gender)\ndata7$Gender <- as.factor(data7$Gender)\ndata8$Gender <- as.factor(data8$Gender)\ndata9$Gender <- as.factor(data9$Gender)\ndata10$Gender <- as.factor(data10$Gender)\n\n# Loop for the colors of the lines \ninterpolate_lines <- function(data) {\n  data %>%\n    group_by(Jobs) %>%\n    # Ensure there are at least 2 unique points and no missing values\n    filter(n_distinct(Years) > 1 & !is.na(Years) & !is.na(Employed) & !is.na(Gender)) %>%\n    summarise(\n      interpolated_data = list(\n        data.frame(\n          Years = seq(min(Years), max(Years), length.out = 100),  # Smooth grid for Years\n          Employed = approx(Years, Employed, xout = seq(min(Years), max(Years), length.out = 100))$y,\n          Gender = approx(Years, Gender, xout = seq(min(Years), max(Years), length.out = 100))$y\n        )\n      )\n    ) %>%\n    unnest(cols = c(interpolated_data))  # Expand nested data into rows\n}\n\n\nFirst graph\nInitial plot set-up\nIn the initial plot setup, I added light gray horizontal grid lines for reference and used geom_line() to plot smooth gradient lines representing employment trends for each job category, with colors mapped to gender proportions. I overlaid the original data points with geom_point() for clarity and defined a gradient color scale from red (100% female) to blue (100% male), with gray indicating gender parity.\n\n\ninterp_data1 <- interpolate_lines(data1)\n\nplot1_step1 <- ggplot() +\n  geom_hline(yintercept = seq(0, 60, 10), color = \"lightgray\", linewidth = 0.3) +\n  # Add smooth gradient lines for each job\n  geom_line(data = interp_data1, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  # Add original points for reference\n  geom_point(data = data1, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  # Define gradient color scale for Gender\n  scale_color_gradientn(colors = c(\"red\", \"pink\", \"grey\", \"#8cdde3\", \"#2e86c1\"), name = \"Gender\")\n\n\nAxes Customization\nThe axes were adjusted with scale_x_continuous() and scale_y_continuous(). The x-axis was formatted to display the key years 1980 and 2012 with shortened labels (“’80” and “’12”), while the y-axis was set with breaks at intervals of 10 and limited to a range of 0 to 90. The y-axis labels were tailored to show numeric values up to 60, leaving the upper range visually open. At least I added a descriptive label to the x-axis using labs() to provide context.\n\n\nplot1_step2 <- plot1_step1 +\n  # Customize axes\n  scale_x_continuous(breaks = c(1980, 2012), labels = c(\"'80\", \"'12\")) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10), \n    limits = c(0, 90), \n    labels = c(\"0\", \"10\", \"20\", \"30\", \"40\", \"50\", \"60\", \"\", \"\")\n  ) +\n  labs(x = \"+ 80 jobs\\nProfessionals\\nand specialists\\n\")\n\n\nTheme\nI applied a clean and minimal aesthetic to the chart using theme_minimal(). This theme simplifies the overall design by removing unnecessary visual elements, allowing the data to stand out more clearly.\nTo further refine the appearance, I customized specific elements using the theme() function. I removed major grid lines on the x-axis and y-axis, as well as all minor grid lines, to reduce clutter. The legend was hidden with legend.position = “blank” since it was not needed for this chart.\nI adjusted the y-axis text to be clear and legible by setting its size and color, while the x-axis text was styled with a slight margin adjustment for better alignment.\n\n\nplot1_step3 <- plot1_step2 +\n  theme_minimal() +\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    legend.position = \"blank\",\n    axis.text.y = element_text(size = 10, color = \"black\"),\n    axis.text.x = element_text(margin = margin(t = -8), size = 10, color = \"black\"),\n    axis.title.y = element_blank(),\n    axis.title = element_text(size = 12)\n  ) \n\n\nAnnotation\nUsing annotate(“text”), I added a label for “Registered nurses,” positioning it near the corresponding data point to replicate the original annotation. I used annotate(“segment”) to draw a connecting line between the label and the data point, mirroring the style of the original chart.\n\n\nplot1 <- plot1_step3 +\n  annotate(\"text\", x = 1998, y = 40, label = \"Registered\\nnurses\", \n           size = 4, color = \"black\", fontface = \"plain\", hjust = 0.5) +\n  annotate(\"segment\", x = 1998, xend = 1998, y = 30, yend = 38, \n           color = \"black\", linewidth = 0.8) \n\nplot1\n\n\n\n(it looks a little… weird; but don’t worry after the faceting the result will be much better!)\nThe others graphs\nCommon part\nSince the graphs are very similar to each other and differ only in small but significant ways that make each graph unique, I decided to group the shared elements, such as the theme and the color_gradient, into variables. This allows me to reuse these components in each graph, reducing redundancy and shortening the code for each individual plot.\n\n\ngender_color_scale <- scale_color_gradientn(\n  colors = c(\"red\", \"pink\", \"grey\", \"#8cdde3\", \"#2e86c1\"),\n  name = \"Gender\"\n)\n\nbase_theme <- theme_minimal() +\n  theme(\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.y = element_blank(),\n    legend.position = \"none\",\n    axis.title.y = element_blank(),\n    axis.title = element_text(size = 12)\n  )\n\n\n2° Graph\nIn the second plot, the x-axis does not include custom labels, simplifying its appearance, while the y-axis uses scale_y_continuous() with a custom labeling scheme that only displays “70” and “80” at the higher range of values, leaving the lower values blank.\n\n\ninterp_data2 <- interpolate_lines(data2)\n\nplot2 <- ggplot() +\n  geom_line(data = interp_data2, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data2, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90),\n    labels = c(\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"70\", \"80\")\n  ) +\n  labs(x = \"+ 40 jobs\\nManagers and\\nadministrators\\n\") +\n  base_theme +\n  theme(\n    panel.grid.major.y = element_line(color = \"lightgray\", size = 0.3), # Add light gray gridlines\n    axis.text.x = element_blank(),\n    axis.text.y = element_text(size = 10, color = \"black\")\n  )\n\n\nStarting from the 3° until the 9° plot (except for the 8°, see below why) the only differences from the first one consist in omitting both x-axis and y-axis labels entirely. There are some graphs (4°-5°-6°-9°) that have some annotation, like the first one.\n3° Graph\n\n\ninterp_data3 <- interpolate_lines(data3)\n\nplot3 <- ggplot() +\n  geom_hline(yintercept = seq(0, 40, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data3, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data3, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"+ 23 jobs\\nService Workers\\nand salespeople\\n\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n4° Graph\n\n\ninterp_data4 <- interpolate_lines(data4)\n\nplot4 <- ggplot() +\n  geom_hline(yintercept = seq(0, 20, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data4, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data4, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  annotate(\"text\", x = 1998, y = 25, label = \"Health\\ntechnologists and\\ntechnicians\", size = 4, color = \"black\", fontface = \"plain\", hjust = 0.5) +\n  annotate(\"segment\", x = 1998, xend = 1998, y = 15.5, yend = 22, color = \"black\", linewidth = 0.8) +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"+ 13 jobs\\nTechnicians\\n\\n\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n5° Graph\n\n\ninterp_data5 <- interpolate_lines(data5)\n\nplot5 <- ggplot() +\n  geom_hline(yintercept = seq(0, 10, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data5, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data5, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  annotate(\"text\", x = 1998, y = 21, label = \"Police and\\ndetectives\", size = 4, color = \"black\", fontface = \"plain\", hjust = 0.5) +\n  annotate(\"segment\", x = 1998, xend = 1998, y = 16.2, yend = 19, color = \"black\", linewidth = 0.8) +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"+ 3 jobs\\nPolice, fire,\\nand military\\n\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n6° Graph\n\n\ninterp_data6 <- interpolate_lines(data6)\n\nplot6 <- ggplot() +\n  geom_hline(yintercept = seq(0, 20, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data6, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data6, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  annotate(\"text\", x = 1998, y = 28.5, label = \"Secretaries\", size = 4, color = \"black\", fontface = \"plain\", hjust = 0.5) +\n  annotate(\"segment\", x = 1998, xend = 1998, y = 25.7, yend = 27, color = \"black\", linewidth = 0.8) +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"- 3 jobs\\nAdministrative\\nsupport workers\\n\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n7° Graph\n\n\ninterp_data7 <- interpolate_lines(data7)\n\nplot7 <- ggplot() +\n  geom_hline(yintercept = seq(0, 30, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data7, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data7, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"- 26 jobs\\nTransportation\\nworkers\\n\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n8° Graph\nThere was an issue with the interpolation of colors in this graph. In the graph from teh NYT, all points and their respective lines are blue (#2e86c1) because the majority of those jobs were, and still are, predominantly held by men. However, the interpolation process mistakenly assigned shades of pink to the lines, which inaccurately represented the data.\nTo resolve this problem, I explicitly set the color for both geom_line and geom_point to “#2e86c1”. This fixed the color across the entire graph, ensuring consistency with the data and accurately reflecting the predominance of men in these roles. By doing so, I eliminated the unintended color gradient and maintained the graph’s integrity.\n\n\nplot8 <- ggplot(data8, aes(x = Years, y = Employed, group = Jobs)) +\n  geom_hline(yintercept = seq(0, 30, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(color = \"#2e86c1\", linewidth = 1.2) +\n  geom_point(color = \"#2e86c1\", size = 3) +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"- 31 jobs\\nConstruction\\nand agriculture\\nworkers\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n9° Graph\n\n\ninterp_data9 <- interpolate_lines(data9)\n\nplot9 <- ggplot() +\n  geom_hline(yintercept = seq(0, 30, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data9, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data9, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  annotate(\"text\", x = 1998, y = 31, label = \"Production\\nsupervisors or\\nforemen\", size = 4, color = \"black\", fontface = \"plain\", hjust = 0.5) +\n  annotate(\"segment\", x = 1998, xend = 1998, y = 21.1, yend = 28, color = \"black\", linewidth = 0.8) +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90)\n  ) +\n  labs(x = \"- 38 jobs\\nSkilled\\nproduction\\nworkers\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank()\n  )\n\n\n10° Graph\nIn this graph the y-axis labels returns and is being positioned on the right (not on the left like the first one)\n\n\ninterp_data10 <- interpolate_lines(data10)\n\nplot10 <- ggplot() +\n  geom_hline(yintercept = seq(0, 50, 10), color = \"lightgray\", linewidth = 0.3) +\n  geom_line(data = interp_data10, aes(x = Years, y = Employed, group = Jobs, color = as.numeric(Gender)), linewidth = 1.2) +\n  geom_point(data = data10, aes(x = Years, y = Employed, color = as.numeric(Gender)), size = 3) +\n  gender_color_scale +\n  scale_x_continuous(breaks = c(1980, 2012)) +\n  scale_y_continuous(\n    breaks = seq(0, 80, 10),\n    limits = c(0, 90),\n    labels = c(\"0\", \"10\", \"20\", \"30\", \"40\", \"50\", \"\", \"\", \"\"),\n    position = \"right\"\n  ) +\n  labs(x = \"- 62 jobs\\nMachine\\noperators and\\nassemblers\") +\n  base_theme +\n  theme(\n    axis.text.x = element_blank(),\n    axis.text.y = element_text(size = 10, color = \"black\")\n  )\n\n\nFaceting\nNow that the plots are ready, we can align them vertically using align = “v to ensure consistent stacking. To maintain visual coherence, we use scale_y_continuous(limits = c(0, 90)) in all plots, even when geom_hline() marks horizontal reference lines at different heights. This consistent y-axis range ensures that differences in scale do not distort comparisons. Additionally, by setting axis =”tb”, we align the top and bottom axes, creating a seamless flow for the x-axis (years) across all graphs.\n\n\ncombined_plot <- plot_grid( plot1, plot2, plot3, plot4, plot5, plot6, plot7, plot8, plot9, plot10,\n    align = \"v\",             # Align plots vertically\n    axis = \"tb\",             # Align top and bottom axes\n    ncol = 10,               # Arrange in 10 columns\n    rel_widths = c(rep(1, 10)))  # Equal widths for all plots\n\nprint(combined_plot)\n\n\n\nCustom legend plot\nAnother challenging aspect was the creation of the custom legend plot featured in the middle of the original graph. This legend provides a visual tool to understand the gender breakdown of each occupation by displaying the percentage of the dominant gender in that field.\nTo replicate the original design, I first created the data needed for the plot and assigned colors to fill each segment of the bar. Then, I constructed a horizontal segmented bar plot, adding black divider lines between each segment to closely resemble the style of the original graph.\n\n\n# Create the custom legend data\ncustom_legend <- data.frame(\n  x = seq(10, 90, by = 20),  # Midpoints of the segments\n  y = 1,                    # Single row for the bar\n  fill = factor(c(\"1\", \"0.7\", \"0.5\", \"0.2\", \"0\"), levels = c(\"1\", \"0.7\", \"0.5\", \"0.2\", \"0\")) # Segment categories\n)\n\ngender_segmented_colors <- c(\n  \"1\" = \"#2e86c1\",  # 100% MEN\n  \"0.7\" = \"#8cdde3\", # 80%\n  \"0.5\" = \"grey\",   # 60%\n  \"0.2\" = \"pink\",   # 80% (Women side)\n  \"0\" = \"red\"       # 100% WOMEN\n)\n\n# Create the custom legend plot\ncustom_legend <- ggplot() +\n  # Create colored segments\n  geom_tile(data = custom_legend, aes(x = x, y = y, fill = fill), width = 20, height = 0.5) +\n  \n  # Add black divider lines going downward\n  geom_segment(aes(x = 0, xend = 0, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 20, xend = 20, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 40, xend = 40, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 60, xend = 60, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 80, xend = 80, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 100, xend = 100, y = 1.25, yend = 0.75), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 20, xend = 20, y = 1, yend = 0.6), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 40, xend = 40, y = 1, yend = 0.6), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 60, xend = 60, y = 1, yend = 0.6), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 80, xend = 80, y = 1, yend = 0.6), color = \"black\", size = 0.6)+\n  geom_segment(aes(x = 0, xend = 0, y = 1, yend = 0.6), color = \"black\", size = 0.6) +\n  geom_segment(aes(x = 100, xend = 100, y = 1, yend = 0.6), color = \"black\", size = 0.6) +\n \n  scale_fill_manual(\n  \n    values = gender_segmented_colors,\n    guide = \"none\"  # Remove default legend\n  ) +\n  scale_x_continuous(limits = c(-10, 100), expand = c(0, 0)) +\n  scale_y_continuous(limits = c(0, 1.5), expand = c(0, 0)) +\n  \n  theme_minimal() +\n  theme(\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = margin(0, 0, 0, 0)\n  )\n\n\nFinal adjustments\nNow, we can enhance the graph by adding the missing text to the custom legend. This step ensures that the legend is not only visually aligned with the main graph but also provides all the text information that are visible in the original graph.\n\n\nsemi_final_combined_plot <- ggdraw() +\n  draw_plot(combined_plot, x = 0, y = 0, width = 1, height = 1) +  # Main plot\n  draw_plot(custom_legend, x = 0.45, y = 0.55, width = 0.2, height = 0.04) +\n  draw_text(\n    \"Gender breakdown of\\neach occupation\",\n    x = 0.34, y = 0.58,  # Adjust x and y to place text\n    size = 13,          # Font size\n    fontface = \"bold\",  # Bold font\n    hjust = 0        # Center horizontally\n  ) +\n  draw_text(\n    \"MAN\",\n    x = 0.47, y = 0.6,  # Adjust x and y to place text\n    size = 11,  \n    family = \"serif\",\n    fontface = \"plain\",  # Bold font\n    hjust = 0        # Center horizontally\n  ) +\n  draw_text(\n    \"WOMEN\",\n    x = 0.615, y = 0.6,  # Adjust x and y to place text\n    size = 11,     \n    family = \"serif\", \n    fontface = \"plain\",  # Bold font\n    hjust = 0        # Center horizontally\n  ) +\n  draw_text ( \"100%\", \n  x = 0.45, y = 0.56,  # Adjust x and y to place text\n  size = 11.5,     \n  family = \"serif\", \n  fontface = \"plain\",  # Bold font\n  hjust = 0  \n  ) +\n  draw_text ( \"80\", \n              x = 0.5, y = 0.56,  # Adjust x and y to place text\n              size = 11.5,     \n              family = \"serif\", \n              fontface = \"plain\",  # Bold font\n              hjust = 0  \n  )+\n  draw_text ( \"60\", \n              x = 0.537, y = 0.56,  # Adjust x and y to place text\n              size = 11.5,     \n              family = \"serif\", \n              fontface = \"plain\",  # Bold font\n              hjust = 0  \n  )+\n  draw_text ( \"60\", \n              x = 0.575, y = 0.56,  # Adjust x and y to place text\n              size = 11.5,     \n              family = \"serif\", \n              fontface = \"plain\",  # Bold font\n              hjust = 0  \n  )+\n  draw_text ( \"80\", \n              x = 0.61, y = 0.56,  # Adjust x and y to place text\n              size = 11.5,     \n              family = \"serif\", \n              fontface = \"plain\",  # Bold font\n              hjust = 0  \n  ) +\n  draw_text ( \"100\", \n              x = 0.645, y = 0.56,  # Adjust x and y to place text\n              size = 11.5,     \n              family = \"serif\", \n              fontface = \"plain\",  # Bold font\n              hjust = 0  \n  ) \n\n\nFinally, we can add the title and the subtitle to the graph.\n\n\n final_combined_plot <- semi_final_combined_plot +\n  draw_text(\"The types of jobs that pay middle-class wages — between $40,000\\n and $80,000 in 2014 dollars — have shifted since 1980. Fewer of\\n these positions are in male-dominated production occupations,\\n while a greater share are in workplaces more open to women.\",\n            x = 0.505, y = 0.70,  # Adjust x and y to place text\n            size = 19,     \n            family = \"serif\", \n            fontface = \"plain\",  # Bold font\n            hjust = 0.5 ) +\n  draw_text ( \"The Changing Nature\\nof Middle-Class Jobs\", \n              x = 0.371, y = 0.88,  # Adjust x and y to place text\n              size = 40,     \n              family = \"serif\", \n              fontface = \"bold\", \n              hjust = 0,\n              lineheight = 0.9\n  ) + \n  draw_text ( \"By GREGOR AISCH and ROBERT GEBELOFF FEB. 22, 2015\", \n              x = 0.38, y = 0.79,  # Adjust x and y to place text\n              size = 13,     \n              family = \"serif\", \n              hjust = 0  \n  ) +\n  draw_text ( \"jobs per 1,000\\nmiddle-class\\njobs\", \n              x = 0.013, y = 0.655,  # Adjust x and y to place text\n              size = 11,     \n              fontface = \"plain\",\n              hjust = 0  \n  ) \n\nfinal_combined_plot\n\n\n\nAlternative graph\nUsing the same data as before, I propose an alternative visualization to provide a different perspective on the previous graph. Specifically, I aim to highlight the percentage growth for each job, allowing readers to easily identify which jobs experienced the highest growth.\nTo achieve this, I will create a Horizontal lollipop chart with the percentage growth on the y-axis and the various jobs ordered by growth on the x-axis. This approach will make it simpler to compare growth rates across different occupations.\nRemodelling the data\nI started by retrieving all the sheet names and created a function called process_sheet to read each sheet and add a Sector column, which identifies the occupational category of the data in that sheet. Then, I combined all the sheets into a single dataframe called all_data.\nTo analyze the data in the best way, I calculated the percentage growth for each job between 1980 and 2012. This involved grouping the data by job titles and sectors, allowing me to compute how employment levels changed over time.\nSince some job names were too long and cluttered the visualizations, I used case_when() to shorten them. For example, “Elementary school teachers, except special education” became “Elem. school teachers,” making the names more concise and easier to read. If a name didn’t need changes, I left it as is.\nBy the end, I had a clean and well-organized dataset called data_growth with shortened job names, their sectors, and their percentage growth rates.\n\n\n# Define the file path\nfile <- \"middle_class.xlsx\"\n\n# Get all sheet names\nsheet_names <- excel_sheets(file)\n\n# Function to read and process each sheet\nprocess_sheet <- function(sheet_name) {\n  read_excel(file, sheet = sheet_name) |> \n    mutate(Sector = sheet_name)  # Add a column for the sector (sheet name)\n}\n\n# Read and combine all sheets\nall_data <- bind_rows(lapply(sheet_names, process_sheet))\n\n# Calculate percentage growth\ndata_growth <- all_data |> \n  group_by(Jobs, Sector) |> \n  summarize(\n    Growth_Percentage = ((Employed[Years == 2012] - Employed[Years == 1980]) / Employed[Years == 1980]) * 100,\n    .groups = \"drop\"\n  )\n\n# Shorten long job names\ndata_growth <- data_growth |> \n  mutate(Jobs = case_when(\n    Jobs == \"Elementary school teachers, except special education\" ~ \"Elem. school teachers\",\n    Jobs == \"Secondary school teachers, except special and career/technical education\" ~ \"Secondary teachers\",\n    Jobs == \"Registered nurses\" ~ \"Reg. nurses\",\n    Jobs == \"Secretaries and administrative assistants, except legal, medical, and executive\" ~ \"Secretaries/admin asst.\",\n    Jobs == \"Police and sheriff's patrol officers\" ~ \"Police officers\",\n    Jobs == \"Construction laborers\" ~ \"Constr. laborers\",\n    Jobs == \"Transportation and material moving workers\" ~ \"Trans. & material movers\",\n    Jobs == \"Billing clerks and related financial records processing\" ~ \"Billing clerks\",\n    Jobs == \"Bookkeepers and accounting and auditing clerks\" ~ \"Bookkeepers\",\n    Jobs == \"Engineering and related technologists and technicians\" ~ \"Eng. technologists\",\n    Jobs == \"Farming, forestry, and fishing occupations\" ~ \"Farming/forestry/fishing\",\n    Jobs == \"Information clerks and records processing occupations, except financial\" ~ \"Info clerks\",\n    Jobs == \"Janitors and other commercial building services\" ~ \"Janitors\",\n    Jobs == \"Machine operators and tenders, except precision\" ~ \"Mach. operators\",\n    Jobs == \"Managers and specialists in marketing, advertising and public relations\" ~ \"Marketing managers\",\n    Jobs == \"Material recording, scheduling and distributing clerks\" ~ \"Material clerks\",\n    Jobs == \"Physicians, dentists, and other health diagnosing\" ~ \"Physicians & dentists\",\n    Jobs == \"Plant and system operators, stationary engineers\" ~ \"Plant operators\",\n    Jobs == \"Purchasing agents and buyers, of farm products\" ~ \"Purchasing agents\",\n    Jobs == \"Sales representatives, finance and business services\" ~ \"Sales reps (finance)\",\n    Jobs == \"Software developers and numerical programmers\" ~ \"Software devs\",\n    Jobs == \"Textile, apparel, and furnishings machine operators\" ~ \"Textile operators\",\n    Jobs == \"Vehicle and mobile equipment mechanics and repairers\" ~ \"Vehicle mechanics\",\n    Jobs == \"Electrical and electronic equipment repairers\" ~ \"Electrical repairers\",\n    TRUE ~ Jobs \n  ))\n\n\nCreating the plot\nI’ve started with a basic horizontal lollipop chart, representing the percentage growth for each job from 1980 to 2012. For each job, I drew a line connecting the baseline (0%) to its growth percentage. The job names are displayed along the x-axis, rotated vertically for better readability. I have added the color to the line and to the points of the chart to show the growth or the decrease of the number of jobs in that field.\n\n\nlollipop_base <- ggplot(data_growth) +\n  geom_segment(aes(x = reorder(Jobs, -Growth_Percentage),  \n                   xend = reorder(Jobs, -Growth_Percentage),\n                   y = 0, \n                   yend = Growth_Percentage,\n                   colour = ifelse(Growth_Percentage < 0, \"#D22B2B\", \"#50C878\")),\n               linewidth = 1.2) +\n  geom_point(aes(x = reorder(Jobs, -Growth_Percentage), \n                 y = Growth_Percentage,\n                 colour = ifelse(Growth_Percentage < 0, \"#D22B2B\", \"#50C878\")),  \n             size = 3) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), \n    axis.text.y = element_text(size = 10)\n  ) +\n  scale_colour_identity()  \n\n\nlollipop_base\n\n\n\nImprovements\nI have redifine a little the chart. Now the y-axis gridlines are displayed at 50% intervals, ranging from -100% to 500%, to improve clarity and allow viewers to easily interpret the data. Unnecessary x-axis gridlines have been removed to minimize distractions, ensuring the focus remains on the job growth trends and their respective percentages.\n\n\nlollipop_improvement1 <- lollipop_base +\n  theme(\n    panel.grid.major.x = element_blank(),  \n    panel.grid.minor.x = element_blank(),  \n    panel.grid.major.y = element_line(color = \"gray\", size = 0.5),  \n    panel.grid.minor.y = element_blank()   \n  ) +\n  scale_y_continuous(\n    breaks = seq(-100, 500, by = 50),  \n    labels = paste0(seq(-100, 500, by = 50), \"%\") \n  )\n\n\nlollipop_improvement1\n\n\n\nAnd for last i added the original title to the alternative graph.\n\n\nlollipop_final <- ggdraw() +\n  draw_plot(lollipop_improvement1, x = 0, y = 0, width = 1, height = 0.8) +\n  draw_text(\"The Changing Nature\\nof Middle-Class Jobs\", \n            x = 0.5, y = 0.95,  \n            size = 40,     \n            family = \"serif\", \n            fontface = \"bold\", \n            hjust = 0.5,        \n            lineheight = 0.9) + \n  draw_text(\"By MARCO BOSO. 01, 2025\", \n            x = 0.5, y = 0.88,  \n            size = 13,     \n            family = \"serif\", \n            hjust = 0.5) +      \n  draw_text(\"The percentage growth of jobs that pay middle-class wages has varied significantly since 1980.\\nThis chart highlights the jobs that have grown the most and those that have faced the greatest decline over this period.\",\n            x = 0.5, y = 0.83,  \n            size = 18,     \n            family = \"serif\", \n            fontface = \"plain\",  \n            hjust = 0.5)        \n\nlollipop_final\n\n\n\nEven though this chart does not delve into the detailed dynamics of occupational changes within middle-class jobs, I believe it offers a fresh perspective on the issue. By focusing on the overall percentage growth or decline of individual jobs, it highlights the broader shifts in employment patterns over time.\n\n\n\n",
    "preview": "projects/2024/100535153/100535153_files/figure-html5/replica-of-the-original-graph-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 3686,
    "preview_height": 2035
  },
  {
    "path": "projects/2024/100535241/",
    "title": "Winners and losers of tax legislation changes",
    "description": "Recreating the ABC news article Graph for MCSS Data Viz 24/25",
    "author": [
      {
        "name": "Brad McKenzie",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nAbout the graph\nSetup\nLoad required packages\nLoad data\nSet parameters\n\nData cleaning\nBasic plotting to check variable functionality\n\nReplication\nCreate male plot\nCreate basic female plot\nInitial combining of plots\nCreate the legend for the plot\n\nFinal replication\nCompare to the original\n\nAlternative plots\nViolin plot\nBeeswarm graph\nAdditional option - using percentile data\n\n\nAbout the graph\nI have recreated the following graph from this February 2024 article by ABC news Australia.\n\n\n\nFigure 1: Original graph from ABC article\n\n\n\nThe graph shows the median income of Australians by occupation compared to who would benefit from proposed tax changes. The graph highlights those who will benefit under the changes and those who will be worse off. To distinguish the two groups, the authors use a horizontal line from the y-axis at the benefit cutoff point, $146,486, and background shading.\nThe purpose of the graph is to highlight that most people are expected to be better off under the changes. Instead of estimating the number of people in raw terms that would benefit, the plot uses disagregated tax data by occupation and gender to display which groups are better and worse off.\nThe graph is effective because you can easily conclude that the majority of people will be better off under the changes, regardless of sex or occupation. The use of a linear y-axis to show income is effective in isolating the very high income occupations which are outliers to the data. It creates a white space which contrasts against the concentrated grouping of occupations below the cutoff point.\nSetup\nLoad packages, set global and local parameters, and read in our dataset.\nLoad required packages\nThe packages are for data cleaning, graph generation, adding themes and organising subplots into the final graph.\n\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(patchwork)\nlibrary(grid)\nlibrary(magick)\nlibrary(ggbeeswarm)\nlibrary(cowplot)\nlibrary(showtext) # most similar font found but couldn't match exact\nsysfonts::font_add_google(\"Hind\", family=\"hind\")\nshowtext_auto()\nlibrary(geomtextpath)\n\n\nLoad data\nNow we load the data from the data.gov.au page. The data comes from Table 15B of the 2020-21 Australian Tax Office individual statistics.\nThis is some of the most granular tax data available. This choice of data allows the authors to create a graph with these dimensions:\nOccupation\nNumber of employees in the occupation (shown as % of total employees on the x-axis)\nMedian income of each occupation\nSplits by gender\n\n\n## if reading from web\n# library(httr)\n# url <- \"https://data.gov.au/data/dataset/07b51b39-254a-4177-8b4c-497f17eddb80/resource/1535c9eb-8385-41af-ae65-f71b2be77d6d/download/ts21individual15occupationsex.xlsx\"\n# response <- GET(url)\n# file_path <- tempfile(fileext = \".xlsx\")\n# writeBin(content(response, \"raw\"), file_path)\n# \n# data <- read_excel(file_path,\n#                    sheet=\"Table 15B\",\n#                    skip=1) # Initial clean step to remove unused row\n\n\ndata <- read_excel(\"ts21individual15occupationsex.xlsx\",\n                   sheet = \"Table 15B\",\n                   skip = 1)\nhead(data, 5)\n\n# A tibble: 5 × 10\n  `Occupation - sub-major group1`         Occupation - unit gr…¹ Sex4 \n  <chr>                                   <chr>                  <chr>\n1 00 Occupation blank                     0000 Occupation blank  Fema…\n2 00 Occupation blank                     0000 Occupation blank  Male \n3 00 Occupation blank                     0000 Occupation blank  Total\n4 11 Chief executives, general managers … 1100 Manager or direc… Male \n5 11 Chief executives, general managers … 1100 Manager or direc… Total\n# ℹ abbreviated name: ¹​`Occupation - unit group1`\n# ℹ 7 more variables: `Individuals\\r\\nno.` <dbl>,\n#   `Average taxable income2,5\\r\\n$` <dbl>,\n#   `Median taxable income2,5\\r\\n$` <dbl>,\n#   `Average salary or wage income5 \\r\\n$` <dbl>,\n#   `Median salary or wage income5\\r\\n$` <dbl>,\n#   `Average total income2,5\\r\\n$` <dbl>, …\n\nImportant data consideration: The original graph was published in February 2024, the ATO then revised the data in March 2024 (as seen on the data updated row of the metadata online). This has led to some variation between figures in our graph and in the actual graph I will recreate. So I am not able to create a 100% like for like replication. Spot checks have been completed and the occupation and number of employee figures appear the same. There appears to be more revisions to some median income figures however the changes are minor overall.\nSet parameters\nDefine parameters that are used multiple times through the recreation. This saves us writing them out multiple times, including the income cutoff point and colours.\n\n\nbenefit_cut <- 146486 # Those below $146,486 benefit from the redesigned plan\noptions(scipen = 999) \n\n\n# colour for female purple; HEX = #a175b4 or RGB rgba(161,117,180,255)\ncolour_fem <- \"#a175b4\"\n# colour for male blue; HEX = #ca555d or RGB rgba(202,85,93,255)\ncolour_male <- \"#ca555d\"\n\n\nData cleaning\nFirst, remove unused columns, clean column names and also filter rows to only have the groups by gender we are interested in (remove totals).\n\n\nclean_data <- data |>\n  rename(\"occupation\" = \"Occupation - unit group1\",\n         \"sex\" = \"Sex4\",\n         \"count\" = \"Individuals\\r\\nno.\",\n         \"income\" = \"Median taxable income2,5\\r\\n$\") |>\n  select(occupation, sex, count, income) |>\n  filter(sex %in% c(\"Female\", \"Male\"))\n\n\nSecond, create the additional variable required, which is % of total workers in that occupation. I also create a negative income % variable for females, this is used to create the mirrored graphs by gender in later stages.\n\n\nclean_data <- clean_data |>\n  group_by(sex) |>\n  mutate(prop_workers_sex = count/sum(count), # create proportion of workers variable\n         income_display = ifelse(sex==\"Female\", -prop_workers_sex, prop_workers_sex))|> # create negative female proportion variable\n  ungroup() |> \n  filter(occupation != \"0000 Occupation blank\") # remove unused occupation\n\n\nThe authors make their calculations of total % of workers including the “0000 Occupation blank” variable, but then remove it from all of the visualisations.\nBasic plotting to check variable functionality\nNow, to check all the required variables are available, I create a very basic version of the graph to check our data completeness. Some parameters for axis are included for comparison purposes.\n\n\nbasic_test_plot <- clean_data |>\n  filter(occupation != \"0000 Occupation blank\") |>\n  ggplot(aes(x=income_display, y=income, size=count ,color=sex))+\n  geom_point(alpha=0.8)+\n  \n  # now add split around the y axis and change the x axis to be equal, plus change the axix units\n  scale_x_continuous(name = \"Percentage of workers\",\n                     breaks= c(-0.04, -0.035, -0.03, -0.025, -0.02, -0.015, -0.01, -0.005,\n                               0,\n                               0.005, 0.01, 0.015, 0.02, 0.025, 0.03, 0.035, 0.04),\n                     minor_breaks = NULL,\n                     limits = c(-0.04, 0.04),\n                     labels = function(x) abs(x) %>% scales::percent())+ # apply absolute vals\n  \n  scale_y_continuous(name = \"Median taxable income ($)\",\n                     breaks = c(0, 50000, 100000, 150000, 200000, 250000,\n                                300000, 350000, 400000, 450000, 500000),\n                     minor_breaks = NULL,\n                     limits = c(0,500000),\n                     labels = scales::label_number(suffix=\"k\", scale = 1e-3)) +\n  theme_minimal()\n\nbasic_test_plot\n\n\n\nThe initial plotting shows that I have all required variables for our graph.\nChallenge detected:\nThere is one one major problem in the basic replication. There are two X=0 values on the original graph with a gap without data to divide the male and female data.  I need to replicate this gap and double y-axis aesthetic for the replication too.\nThere is no option to do this manually within one ggplot. Instead, I will create two separate graphs (for male and female) that are manually positioned together with patchwork to create the mirrored effect. This mirrored presentation also means we have to create two positive X-axis graphs, however the X-axis are going in opposite directions.\nThis is a source of repetition in the next few steps to create almost identical but symmetrical plots.\nReplication\nPrimarily because I cannot impute the gap around x=0, individual graphs by gender are created. To start, I split the data by gender to work with on each graph.\n\n\ndata_male <- clean_data |> filter(sex == \"Male\")\ndata_female <- clean_data |> filter(sex == \"Female\")\n\n\nCreate male plot\nFirst, create the basic male plot, these are all positive values and easier to work with.\n\n\nplot_male <- data_male |>\n  filter(occupation != \"0000 Occupation blank\") |>\n  arrange(occupation) |> # this matches the layering of plot points \n  ggplot(aes(x=income_display, y=income, size = prop_workers_sex))+\n  \n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = benefit_cut,\n           fill = \"grey\", alpha = 0.5) +  # add a background box for the benefit area\n  geom_point(color = \"white\", \n             fill = colour_male, \n             shape = 21, # circle with different fill and border\n             alpha = 0.85,\n             position = \"identity\")+\n\n  geom_hline(yintercept = benefit_cut, linetype = 'dashed')+ # add cutoff line \n\n  annotate(\"text\", x=0.04, y=135000, # add label for cutoff line\n           label = \"Bigger tax cut\",\n           size = 3.3,\n           hjust = 0.85,\n           family = \"hind\")+\n  \n  labs(y=\"Median taxable income $\",\n       x=\"Percentage of workers\") # include both of these so the labels combine with female site in patchwork join. \n\nplot_male\n\n\n\nSpecify male plot axis and theme settings\nNow, I update some of the presentation and layout of the male graph. This includes things such as updating the x and y axis scales, manipulating the size of the plot points, setting limits and updating different theme settings.\n\n\nplot_male2 <- plot_male +\n  \n  # set x-axis, percentages will only show decimil point if non-zero. \n  scale_x_continuous(n.breaks= 9,\n                     minor_breaks = NULL,\n                     limits = c(0, 0.04),\n                #     labels = function(x) abs(x) %>% scales::percent()+\n                     labels = function(x) {paste0((x) * 100, \"%\")})+ \n  \n    # specify y-axis conditions \n  scale_y_continuous(n.breaks = 11,\n                     minor_breaks = NULL,\n                     limits = c(0,500000),\n                     labels = scales::label_number(suffix=\"k\", scale = 1e-3))+\n\n  # set scale size for plot points (manual for consistency with female plot)\n  scale_size(range = c(1,10),\n             breaks=c(1000, 290000),\n             labels = c(\"<1000 individuals\", \"290k individuals\"))+\n\n  labs(title = \"Male\") + # add title, then add details below for title colour and position\n  \n  theme(\n    # update title, position and color\n    plot.title = element_text(hjust = 0.5,\n                                  color = colour_male,\n                                  size = 14,\n                                  family = \"sans\", # closest font but not perfect\n                                  face = \"bold\"), \n    \n    # update x axis positions and conditions\n      axis.ticks.x = element_blank(),\n      axis.title.x = element_text(size = 12, family = \"hind\", \n                                  margin = margin(t = 10)), # no X-axis label \n      axis.text.x = element_text(size = 10, family = \"hind\",\n                                 margin = margin(t = 10)), # X-axis values, move values off axis a little\n\n    # y axis conditions\n    axis.ticks.y = element_blank(), #remove the x and y axis labels and tick marks\n    axis.title.y = element_blank(),\n    axis.text.y = element_blank(), # remove y axis labels to join upto female graph\n        \n    # general conditions \n    plot.margin = unit(c(0.5, 0.5, 0.5, -0.1), \"cm\"),   #move the graph -0.1cm to the left so it is touching the female graph when they combine in grid.arrange\n    legend.position = \"none\", # remove legend\n\n\n    # Other visualisation conditions\n    panel.background = element_rect(fill = \"white\"),\n    panel.border = element_rect(color = \"grey\",\n                                fill = NA,\n                                size = 0.5),\n    panel.grid = element_line(color = \"grey\",\n                              size = 0.2,\n                              linetype = 1),\n    axis.line.y.left = element_blank()) # Ensure left border removed to match up with Female graph\n\n\nplot_male2\n\n\n\nCreate basic female plot\nThis is similar to the initial male plot development. All of the conditions around borders, shading and axis have to be identical, so the two plots can be combined and give the impression of being a single plot.\n\n\n### now replicate with female, minor changes\nplot_female <- data_female |>\n  filter(occupation != \"0000 Occupation blank\") |>\n  arrange(occupation) |> #same as male, order appearance of plots \n  ggplot(aes(x=income_display, y=income, size=prop_workers_sex))+\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = benefit_cut,\n           fill = \"grey\", alpha = 0.5) +  # add a background box in for colouring the line under cutoff\n  geom_point(color = \"white\", fill = colour_fem, shape = 21, alpha = 0.85)+\n  geom_hline(yintercept = benefit_cut, linetype = 'dashed') +\n  \n    annotate(\"text\", x=-0.04, y=135000, \n         label = \"Bigger tax cut\",\n         size = 3.3,\n         hjust = 0.15,\n         family = \"hind\")+\n  \n  labs(y=\"Median taxable income $\",\n       x=\"Percentage of workers\")\n\nplot_female\n\n\n\nSpecify female plot axis and theme settings\nNow I refine the left hand side plot. It is very similar to the male updates, where we add in the scale and conditions. This plot is a positive axis left of the y-axis. To create this effect, negative values are used, but their absolute values are displayed on the x-axis.\n\n\nplot_female2 <- plot_female +\n  \n  # update labels to percentage, but this will only show the decimal point if it is non-zero\n  # need to apply absolute vals first for label, otherwise it gives an error as the scales function returns a vector of characters for the label\n  scale_x_continuous(n.breaks= 9,\n                     minor_breaks = NULL,\n                     limits = c(-0.04, 0), \n                     labels = function(x) {paste0(abs(x) * 100, \"%\")})+ \n  \n  scale_y_continuous(n.breaks = 11,\n                     minor_breaks = NULL,\n                     limits = c(0,500000),\n                     labels = scales::label_number(suffix=\"k\", scale = 1e-3)) +\n  \n  labs(title = \"Female\") + # add title, then add details below for title colour and posiiton\n  \n  scale_size(breaks=c(1000, 290000),\n             labels = c(\"<1000 individuals\", \"290k individuals\"),\n             range = c(1, 14))+\n  \n  theme(\n        # title conditions, colour\n        plot.title = element_text(hjust = 0.5,\n                                  color = colour_fem,\n                                  size = 14,\n                                  family = \"sans\",\n                                  face = \"bold\"), \n        \n        # update x axis positions and conditions\n      axis.ticks.x = element_blank(),\n      axis.title.x = element_text(size = 12, family = \"hind\", \n                                  margin = margin(t = 10)), # move X-axis label \n      axis.text.x = element_text(size = 10, family = \"hind\",\n                                 margin = margin(t = 10)), # X-axis values, move values off axis a little\n\n\n        # y-axis conditions and position, incl move further away from axis with margin\n        axis.title.y = element_text(size = 12, family = \"hind\", \n                                    margin = margin(r=10)), # Y-axis label\n        axis.text.y = element_text(size = 10, family = \"hind\", \n                                   margin = margin(r=10)), # Y-axis values \n        axis.ticks.y = element_blank(), #remove the x and y axis labels and tick marks\n\n        \n        # general conditions\n        plot.margin = unit(c(0.5, 0, 0.5, 0.5), \"cm\"),\n        legend.position = \"none\", # Adjust left margin to overlap slightly\n\n\n        # create border and update function for female graph - remov the right border\n        panel.background = element_rect(fill = \"white\"),\n        panel.border = element_rect(color = \"grey\",\n                                    fill = NA,\n                                    size = 0.5),\n        panel.grid = element_line(color = \"grey\",\n                                  size = 0.2,\n                                  linetype = 1),\n        \n        axis.line.y.right = element_blank()) # Ensure right border is removed\n          \n\nplot_female2\n\n\n\nInitial combining of plots\nHere, I test the join of the plots using patchwork. As our plot axis and design are built to be very similar, they do join together well. The key settings that create the impression of a single plot are:\nUse plot margin to remove gaps where the graphs will be joined (i.e. right y-axis for female graph and left hand y-axis for male plot)\nFor the female plot, we adjust the plot margin to be zero on the right hand side plot_margin = unit(c(0.5, 0, 0.5, 0.5), \"cm\")\nFor males, we remove the left margin and actually make it negative to allow for the overlapping, plot.margin = unit(c(0.5, 0.5, 0.5, -0.1), \"cm\")\nThe final gap removal is through setting the right hand axis tick marks to zero. Even though there is no data on the male y axis, R still leaves space for the tick marks. We remove this gap too with axis.ticks.length.y = unit(0, \"pt\")) in our combination.\n\n\n# First test -Combine the plots without space between them and with one legend\ncombined_plot <- plot_female2 + plot_male2 +\n  plot_layout(ncol = 2, widths = c(6,6), \n              guides = \"collect\",\n              axis_titles = \"collect\") + # to join the two x-axis labels into one\n  theme(panel.background = element_rect(fill = \"white\"),\n        panel.border = element_rect(color = \"grey\",\n                                fill = NA,\n                                size = 0.5),\n        panel.grid = element_line(color = \"grey\",\n                                  size = 0.2,\n                                  linetype = 1),\n        #axis.title.x = element_text(size = 16, family = \"roboto\", margin = margin(t = 10)),\n        axis.ticks.length.y = unit(0, \"pt\")) # to remove the axis gaps on the Male y-axis\n\n\ncombined_plot\n\n\n\nThis is getting closer to a nice replication of the original. There is one major piece missing however, the legend.\nCreate the legend for the plot\nOne of the biggest challenges for the replication has been the legend. The legend uses concentric circles that are outside of the plot area, have different colours to the actual plot and use specific call out labels.\nBecause of these issues, I have built the legend manually then used inset_element to position it with the other plots. The legend is created as a grob, saved as an image and then called back and sized and positioned. Sizing and positioning within the two other plots has been a big challenge.\n\n\n# Create data for concentric circles\ncircle_data <- function(radius, npoints=100) {\n  angles <- seq(0, 2*pi, length.out = npoints)\n  data.frame(\n    x = radius * cos(angles),\n    y = radius * sin(angles)\n  )\n}\n\n# Create concentric circles data\ncirclesmall <- circle_data(0.7)\ncirclebig <- circle_data(3)\n\n# Plot concentric circles with grey fill\nconcentric_plot <- ggplot() +\n  geom_polygon(data = circlebig, aes(x = x, y = y), fill = \"grey90\", color = \"black\", linewidth=0.3) +\n  geom_polygon(data = circlesmall, aes(x = x, y = y - 2.3), fill = \"grey90\", color = \"black\", linewidth=0.3)+\n  lims(x=c(-3,21))+\n  \n  annotate(\"segment\", # line for <1k label\n           x=0, xend = 6,\n           y=-2.3, yend = -2.3,\n           size=0.3)+\n  annotate(\"segment\", \n           x = 0, xend = 6, \n         y = 0, yend = 0,\n         size=0.3)+\n  annotate(\"text\", x = 6.5, y = -2.3, label = \"<1k individuals\", size = 3, hjust = 0)+\n  annotate(\"text\", x = 6.5, y = 0, label = \"290k individuals\", size = 3, hjust = 0)+\n  coord_fixed()+\n  theme_void()\n\nconcentric_plot\n\n\n\nFinal replication\nTo include the legend, I re-build our combined plot with the order of 1) set female plot, 2) join on legend and position, and 3) join onto the male plot as above. The plot is layered in this way because of issues when trying to combined the to initial plots then add on the legend. When creating the combined plot first, the legend would obscure parts of the female plot. With this layering, the inset_element does not disturb the female plot.\nThis is the final version of the replication!\n\n\nfinal_plot <- \n  # first layer of female plot\n  plot_female2 +\n  \n  # use inset_element to include our legend and position appropriately \n  inset_element(concentric_plot,\n                              left=0.01,\n                              bottom=0.955,\n                              right=0.4,\n                              top=1.01,\n                              align_to=\"full\",\n                              on_top = FALSE,\n                              clip=FALSE) +\n  \n  # add in our male plot with patchwork too\n  plot_male2 +\n  \n  # set the join conditions for patchwork again. These are the same as our first combined plot attempt\n  plot_layout(ncol = 2, widths = c(6,6),\n              guides = \"collect\",\n              axis_titles = \"collect\") + # to join the two x-axis labels into one\n  theme(panel.background = element_rect(fill = \"white\"),\n        panel.border = element_rect(color = \"lightgrey\",\n                                fill = NA,\n                                size = 0.5),\n        panel.grid = element_line(color = \"lightgrey\",\n                                  size = 0.2,\n                                  linetype = 1),\n        axis.ticks.length.y = unit(0, \"pt\")) # to remove the axis gaps on the Male y-axis\n\nfinal_plot\n\n\n\nCompare to the original\n\n\n\nAlternative plots\nHere I have created alternatives of the original plot. The focus of the alternatives is conveying the message that most people will be better off under the tax changes. To do this, I attempted to make more simple plots with fewer dimensions. Three alternative plots have been created:\nA violin plot, to better represent the volume of occupations that will benefit at their medium income level\nA beeswarm plot, to show a plot that still uses bubbles for occupation data, but is more clean with less overlap and a categorical x-axis (sex) instead of the initial continuous X-axis (% of workers).\nA line plot using information on taxable income percentiles to estimate the proportion of people that will benefit rather than occupation numbers.\nWith each, I have tried to include different presentation characteristics such as relabeling the text to help the reader take away key messages, however I tried to include elements from the initital plot I liked, such as the shading and colouring.\nOne of the changes I use in the alternatives is having income on a log scale. Even though the original plot uses white space effectively to show the disparity of incomes by occupation, we will use the log scale to highlight the majority of occupations are in the benefit area.\n\n\n# create a new data to work with for improvements\nimprov <- clean_data\n\nimprov <- improv |>\n  mutate(benefit = ifelse(income <= benefit_cut, TRUE, FALSE))\n\n\nViolin plot\nIn this plot, we will only drop one dimension; number of workers by occupation. In the original plot, this % of workers shown twice, as the size of circles and the x-axis. However, neither add much value because the overall message is that most occupations are better off.\nIn this violin plot, the volume of occupations is still represented by the width of the violin. It could be considered a limitation that each occupation is weighted equally here, but individual occupations are hard to distinguish in the original, so we don’t lose any meaning here.\n\n\n# Create the violin plot\nimprov |>\n  filter(occupation != \"0000 Occupation blank\") |>\n  ggplot(aes(x=sex, y=income, fill = sex))+\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = 0, ymax = benefit_cut,\n           fill = \"green\", alpha = 0.1)+  # add a background box in for colouring the pos area\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = benefit_cut, ymax = Inf,\n           fill = \"red\", alpha = 0.1)+  # add a background box in for colouring the neg area\n  geom_violin(trim=TRUE)+\n  scale_fill_manual(values = c(\"Female\" = colour_fem, \"Male\" = colour_male), name = \"sex\") +\n  labs(title = \"Will you be better off under the new tax changes?\",\n       caption = \"Each occupation weighted equally, number of employees is not factored in.\\n Log scale for income used.\",\n       y = \"Median income ($)\",\n       x = \"\") +\n  theme_minimal()+ \n  geom_hline(yintercept = benefit_cut, color = \"black\", linetype = \"dashed\") + # Cutoff line\n  annotate(\"text\", \n           x = c(0.65,0.65), \n           y = c(125000,170000),\n           label = c(\"Better off\", \"Worse off\") ,\n           color=\"black\",\n           size=4,\n           face = \"sans\",\n           fontface=\"bold\")+\n  \n    ## adding label with annotate and geom_label to point to plots\n  annotate(\"segment\", y = 20000, yend = 50000,\n           x = 1.5, xend = 1,\n           colour = \"black\", size=0.75, alpha=0.5,\n           linetype = \"dotted\")+\n    annotate(\"segment\", y = 20000, yend = 50000,\n           x = 1.5, xend = 2,\n           colour = \"black\", size=0.75, alpha=0.5,\n           linetype = \"dotted\")+\n\n  geom_label(aes(x = 1.5, y = 20000, \n                 label = \"Nearly every occupation will benefit\\n at the median income level \"), fill = \"lightyellow\", \n             color = \"black\", size = 3, fontface = \"bold\")+\n\n  \n#  scale_y_continuous(labels = scales::label_number(suffix=\"k\", scale = 1e-3))+\n  scale_y_log10(labels = scales::label_number(suffix=\"k\", scale = 1e-3),\n                n.breaks=6)+\n  theme(legend.position = \"none\")\n\n\n\nBeeswarm graph\nTo try and update the individual to a plot that also uses one individual plot point for each occupation, I have created a beeswarm graph. I have also re-included the number of workers as the size of the plot points here. This is to try and reduce data loss from the original plot. However only those with over 1000 workers are included to reduce clutter and overlapping, which I don’t like in the original plot around the two y-axes.\nFurther, I have updated the labels with arrows to draw the readers attention and added in other potentially relevant information.\nFinally, I have included the overall median income by gender (male = $59,415 female = $44,547). Overlaying aggregate statistics allows the reader to compare between groups. While it is clear that both male and female median incomes are well under the cutoff, trends by sex are hard to identify in the original plot. This provides an easy overall comparion.\n\n\nimprov_small <- improv |>\n  filter(occupation != \"0000 Occupation blank\",\n         count > 1000)\nmale_med <- 59415\nfem_med <- 44547\n####### BEESWARM GRAPH\n\n# Basic beeswarm plot in ggplot2\nggplot(improv_small, aes(x = sex,\n                         y = income,\n                         colour = sex,\n                         size=prop_workers_sex,\n                         )) +\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = 0, ymax = benefit_cut,\n           fill = \"grey\", alpha = 0.2)+  # add a background box in for colouring the pos area\n\n  geom_quasirandom()+\n  labs(title = \"Most people will be better off under the tax bracket changes\",\n       caption = \"Only includes occupations with over 1000 workers by gender\",\n       x = element_blank(),\n       y = \"Median income $\")+\n  scale_color_manual(values = c(\"Female\" = colour_fem, \"Male\" = colour_male), name = \"sex\") +\n  theme_minimal()+ \n  theme(axis.text.x = element_text(size = 14))+\n  \n  # add cutoff line and label\n  geom_hline(yintercept = benefit_cut, color = \"black\", linetype = \"dashed\") + # Cutoff line\n  annotate(\"text\", x=0.6, y=135000, # add label for cutoff line\n           label = paste0(\"Cutoff: $\",benefit_cut),\n           size = 3.3,\n           hjust = 0.35,\n           family = \"sans\")+\n  \n  # add labels for the median income by gender\n  geom_labelsegment(aes(x=0.6, xend=1.4, y=fem_med, yend=fem_med,\n                    label = \"Median = $44,547\"), fill = \"lightyellow\", size=3,\n                    inherit.aes = FALSE)+\n\n  geom_labelsegment(aes(x=1.6, xend=2.4, y=male_med, yend=male_med,\n                    label = \"Median = $59,415\"), fill = \"lightyellow\",size = 3,\n                    inherit.aes = FALSE)+\n  \n  # add directional arrows and labels for axis\n    annotate(\n    \"textsegment\",\n    x = 0.5, xend = 0.5, yend = benefit_cut-25000, y = 25000,\n    label = \"Better off\", size=3, \n    angle = 180,\n    arrow = arrow(length = unit(0.05, \"inches\"), type=\"closed\", \n                  ends = \"first\"))+ \n  \n    annotate(\n    \"textsegment\",\n    x = 0.5, xend = 0.5, y = benefit_cut + 20000, yend = 480000,\n    label = \"Worse off\", size=3, \n    arrow = arrow(length = unit(0.05, \"inches\"), type=\"closed\"))+\n\n  scale_y_log10(labels = scales::label_number(suffix=\"k\", scale = 1e-3))+\n  theme(legend.position = \"none\")\n\n\n\nAdditional option - using percentile data\nThe primary purpose of this data is to show that most people are better off under the changes rather than worse off. The ideal plot to convey the message would be showing a ridge or density plot of each individual’s income level and have that compared to the benefit cutoff line. We cannot access data this granular. But using slightly different data, we can try to convey this message more clearly.\nBy incorporating slightly different tax data, we can view individual tax data by median taxable income, gender and percentile of income. This data is available in table 16B of the individual tax statistics, where our original data is from 15B.\nFirst, we read in the new data table and do basic cleaning:\n\n\n### read in table 16B first\n    # url <- \"https://data.gov.au/data/dataset/07b51b39-254a-4177-8b4c-497f17eddb80/resource/d902104e-a9c1-4d14-8d21-f4538bda037a/download/ts21individual16percentiledistributionontaxableincomebysex.xlsx\"\n    # response <- GET(url)\n    # file_path <- tempfile(fileext = \".xlsx\")\n    # writeBin(content(response, \"raw\"), file_path)\n    # \n    # data <- read_excel(file_path,\n    #                    sheet=\"Table 16B\",\n    #                    skip=1)\n    # \n    # percentile_counts <- read_excel(file_path,\n    #            sheet=\"Table 16A\",\n    #            skip=1)\n\n#read from file:\ndata <- read_excel(\"ts21individual16percentiledistributionontaxableincomebysex.xlsx\",\n                   sheet=\"Table 16B\",\n                   skip=1)\n\npercentile_counts <- read_excel(\"ts21individual16percentiledistributionontaxableincomebysex.xlsx\",\n           sheet=\"Table 16A\",\n           skip=1)\n\ndata <- data |>\n  filter(Statistic3 == \"Median\") |>\n  rename(\"Range\" = \"Ranged Taxable Income\",\n         \"Income\" = \"Taxable income or loss \\r\\n$\") |>\n  select(Percentile, Sex, Range, Income)\n\npercentile_counts <- percentile_counts |>\n  rename(\"Count\" = \"Individuals \\r\\nno.\",\n         \"Range\" = \"Ranged Taxable Income\") |>\n  select(Percentile, Range, Sex, Count)\n\n# join on the number of workers\ndata <- data |>\n  left_join(percentile_counts, by = c(\"Percentile\", \"Range\", \"Sex\"))\n\ndata$benefit <- ifelse(data$Income<benefit_cut, TRUE, FALSE)\n\n# create actual % value to show the distribution of male and female\ndata <- data |>\n  group_by(Sex) |>\n  arrange(Percentile) |>\n  mutate(prop_Sex = Count/sum(Count)*100,\n         cumul_count = cumsum(Count),\n         total = sum(Count),\n         new_ntile = cumul_count / total * 100)\nhead(data)\n\n# A tibble: 6 × 10\n# Groups:   Sex [2]\n  Percentile Sex    Range    Income Count benefit prop_Sex cumul_count\n       <dbl> <chr>  <chr>     <dbl> <dbl> <lgl>      <dbl>       <dbl>\n1          1 Female $23,629…  22887 60650 TRUE       1.10        60650\n2          1 Male   $23,629…  18164 56406 TRUE       0.911       56406\n3          2 Female $23,630…  24089 65518 TRUE       1.19       126168\n4          2 Male   $23,630…  24090 51508 TRUE       0.832      107914\n5          3 Female $24,557…  25011 65241 TRUE       1.18       191409\n6          3 Male   $24,557…  25012 51748 TRUE       0.836      159662\n# ℹ 2 more variables: total <dbl>, new_ntile <dbl>\n\nWe then create a graph of log income compared to the median income at each percentile\n\n\ndata |>\n  ggplot(aes(y=Income, x=new_ntile, colour = Sex))+\n  \n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = 0, ymax = benefit_cut,\n         fill = \"grey\", alpha = 0.5) +  # add a background box in for colouring the\n\n  geom_line(size=2, show.legend = FALSE) +\n  \n  labs(title = \"Most people benefit from the income tax changes\",\n       caption = \"Note: Log scale used for income\",\n       y = \"Median income ($)\",\n       x = \"Proportion of workers (%)\")+\n  \n  theme_minimal_grid()+\n  theme(axis.ticks.x=element_blank(),\n      axis.ticks.y=element_blank(),\n      axis.title.x = element_text(size = 12), # reduce y and x axis label size \n      axis.title.y = element_text(size = 12)) + # Adjust y-axis label \n\n  # create a log scale on the y-axis\n  scale_y_log10(n.breaks =5, \n                labels = scales::label_number(suffix=\"k\", scale = 1e-3))+\n  \n  scale_x_continuous(breaks = c(50,100), \n                     expand = c(0,0.5))+ #to avoid x-axis label cutoff\n  \n  scale_colour_manual(values = c(\"Female\" = colour_fem, \"Male\" = colour_male), name = \"Sex\") +\n\n  geom_hline(yintercept = benefit_cut, colour=\"black\", linetype=\"dashed\")+\n  \n  ## adding female labels with geom_curve and geom_label\n  annotate(\"segment\", y = 40000, yend = benefit_cut,\n           x = 85, xend = 95,\n           colour = colour_fem, size=0.75, alpha=1,\n           linetype = \"dotted\")+\n\n  geom_label(aes(x = 80, y = 42000, \n                 label = \"Better for 95% \\n of females\"), fill = \"lightyellow\", \n             color = colour_fem, size = 3, fontface = \"bold\")+\n\n  \n  ## adding male labels with annotate and geom_label\n  annotate(\"segment\", y = 300000, yend = benefit_cut,\n           x = 75, xend = 88,\n           colour = colour_male, size=0.75, alpha=1,\n           linetype = \"dotted\")+\n\n  geom_label(aes(x = 70, y = 320000, \n                 label = \"Better for 88% \\n of males\"), fill = \"lightyellow\", \n             color = colour_male, size = 3, fontface = \"bold\")+\n\n  # create manual coloured text labels for clea\n  annotate(\"text\",\n           y=75000, x= 40,\n           label = \"Male\",\n           color=colour_male,\n           face = \"sans\", fontface = \"bold\",\n           size = 4)+\n  annotate(\"text\",\n           y=40000, x= 41,\n           label = \"Female\",\n           color=colour_fem,\n           face = \"sans\", fontface = \"bold\",\n           size = 4)+\n  \n  # create label for cutoff point and arrow \n  annotate(\"text\",\n           y=300000, x= 30,\n           label = \"Everyone earning under $146,486\\n per year will be better off\",\n           color=\"black\",\n           size = 4)+\n   geom_curve(aes(x = 15, y = 270000, xend = 13, yend = benefit_cut),\n                  colour = \"black\",\n              arrow = arrow(length = unit(0.03, \"npc\")))\n\n\n\nFrom this graph, a better estimate of the impacted population can be made. This proportion of people measure is more tangible than the count of occupations by size. I have included this as the final option as it is the one that allows the reader most quickly realise they are likely to benefit.\n\n\n\n",
    "preview": "projects/2024/100535241/100535241_files/figure-html5/final-legend-joinplot-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 1536
  },
  {
    "path": "projects/2024/100541120/",
    "title": "Cocaine consumption",
    "description": "This project aims to provide insights into the principal consumers of cocaine\nthrough a bar plot. I chose this topic because I find it interesting and\nrelevant, especially in relation to the global issues surrounding drug trafficking. \nThe bar plot serves as an effective tool to visually compare the data,\nmaking complex information more accessible and understandable. I was particularly\ninspired by the work of El Orden Mundial, which I consider they do a great job\nof visualizing data.",
    "author": [
      {
        "name": "Jorge Ramos",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nFirst Steps\nData\n\nReplica\n1. Bar plot\n2. Flags\n3. Logos\nCritique of the original chart\n\nImprovements\n1. Bar plot\n2. Flags\n3. Logos\n\nAlternative\nFirst Attempt\nSecond Attempt\nThird Attempt\nFourth Attempt\nFifth Attempt\n\n\nThis is a chart created by the team at El Orden Mundial, the original plot that I want to reproduce:\nOriginal PlotFirst Steps\nFirst I load the libraries that I will need to make the plot:\n\n\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(tibble)\nlibrary(grid)\nlibrary(png)\nlibrary(ggtext)\nlibrary(tidyverse)\nlibrary(showtext)\nlibrary(extrafont)\nlibrary(flagon)\nlibrary(ggrepel)\nlibrary(patchwork)\nlibrary(magick)\nlibrary(ggstream)\nlibrary(scales)  \n\n\nNow, I can start with the data I need to make the graph. In the original plot from El Orden Mundial there is one papers where they extract the information. These are: UNODC (2018): World Drug Report 2018: opioid crisis, prescription drug abuse expands; cocaine and opium hit record highs.\nData\nUnfortunately, I couldn’t find an available database with this data. I found in UNODC page other databases with the information of cocaine use, but none of them coincide with the consumption percentage of 2018 presented in the plot.\nDue to this, I will try to make my own database with the information in order to make the representation later.\n\n\n# Data I need: Country, Position, and Consume Percentage.\n\ncocaine_data <- tibble(\n  Posición = c(1, 1, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13, 14, 15),\n  País = c(\"Australia\", \"Albania\", \"Estados Unidos\", \"Escocia (R.U.)\", \"Inglaterra y Gales (R.U.)\",\n              \"España\", \"Países Bajos\", \"Irlanda del Norte (R.U.)\", \"Uruguay\", \"Argentina\",\n              \"Irlanda\", \"Canadá\", \"Polonia\", \"Chile\", \"Costa Rica\"),\n  `Porcentaje de consumo (%)` = c(2.5, 2.5, 2.4, 2.34, 2.3, 2.0, 1.9, 1.8, 1.8, 1.67, \n                                   1.5, 1.47, 1.4, 1.38, 1.33)\n)\n\n\n#I do this to order the countries in the graph\ncocaine_data$País <- factor(cocaine_data$País, levels = rev(cocaine_data$País))\n\n\nNow, I am going to choose the font I am going to use for the text in the plot.\n\n\nfont_add_google(\"Mulish\", \"mulish\")\n\nshowtext_auto()\n\n\nI needed to change the original font as it wasn’t open-source. I selected a font from Google Fonts that is slightly similar, ensuring the visual appearance aligns with the authentic bar plot.\nReplica\n1. Bar plot\nNow, I can start with the plot. I am going to do this by layers, I consider it will make the code more readable and organized, ensuring each part of the plot is built in a modular way.\nThe first step regarding to the graph creation is to restrict the length and height of the graph, for this I introduce <```{r, fig.width= 8.5, fig.height= 6}>\n\n\nbarchart_coc1 <- ggplot(cocaine_data, aes(x = País, \n                                         y = `Porcentaje de consumo (%)`,\n                                         fill = `Porcentaje de consumo (%)`), \n                        family = \"mulish\", font.main = 2) +\n  # Create bar chart with identity stat (values directly from data)\n  geom_bar(stat = \"identity\", width = 0.7) +\n  # Flip to make a horizontal bar chart\n  coord_flip() +  \n  # Add a vertical line on the axis Y \n  geom_segment(aes(x = 0.65, xend = 15.35, y = 0, yend = 0), \n               color = \"#498f3d\", \n               linewidth = 0.8) +\n  # Add positions of the countries next to the  Y axis\n  geom_text(aes(label = Posición, y = -0.12), \n            hjust = 1, \n            color = \"#0A0A0A\", \n            size = 4.3, family = \"mulish\", font.main = 2) +\n  # Add consumption percentages at the end of each bar\n  geom_text(aes(label = paste0(gsub(\"\\\\.\", \",\", \n                                    formatC(`Porcentaje de consumo (%)`, \n                                            format = \"f\", digits = 2, drop0trailing = TRUE)), \"%\"), \n                y = `Porcentaje de consumo (%)`), \n            hjust = -0.4, \n            vjust = 0.38,\n            color = \"#0A0A0A\", \n            size = 4.25, \n            family = \"mulish\", font.main = 2) +\n  # Adjust the expansion of the y-axis to give more space at the edges\n  scale_y_continuous(expand = expansion(add = c(0.6, 1.5))) +\n  # Extend the x-axis limits slightly to make space for annotations\n  expand_limits(x = 16.4) +\n  # Add a label for the \"Position\" column\n  annotate(geom = \"text\", label = \"Position\",\n           x = 15.85, y = -0.15, size = 4.4, vjust = 0, \n           color = \"#353939\", family = \"mulish\") + \n  # Use a color gradient to fill the bars (low to high values)\n  scale_fill_gradient(low = \"#c0cd94\", high = \"#84a528\") +\n  # Add titles, subtitles, and captions\n  labs(title = \"Principales consumidores de cocaína\", \n       subtitle = \"Porcentaje de adultos que han consumido en el último año*\", \n       caption = paste0(\n         \"Último año con datos disponibles*<br>\",\n         \"**Cartografía:**<br>\",\n         \"Abel Gil Lobo (2019)<br>\", \n         \"**Fuente:**<br>\",\n         \"UNODC (2018)\"),\n       y = \"Consumption Percentage (%)\", \n       x = NULL) +\n  # Apply a minimal theme for the plot\n  theme_minimal() +\n  theme(\n    # Remove x-axis title, text, and ticks\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    panel.grid = element_blank(),\n    axis.text.y = element_text(size = 13, family = \"mulish\", color = \"#0A0A0A\"), \n    # Remove the grid lines\n    panel.grid.major = element_blank(),\n    # Hide the legend\n    legend.position = \"none\",\n    # Adjust plot margins\n    plot.margin = margin(t = 0, r = 5, b = 1, l= 2), \n    # Remove panel and plot backgrounds\n    panel.background = element_blank(), \n    plot.background = element_blank(),\n    # Style the caption with markdown support\n    plot.caption = element_markdown(hjust = 0, vjust = 1, face = \"plain\", \n                                    size = 8, family = \"mulish\", margin = margin(t = 0, r = 0, b = 0, l = 11)),\n    # Style the title and subtitle with specific positions and sizes\n    plot.title = element_text(hjust = 0.07, vjust = 0, \n                              size = 29, family = \"mulish\"),# Adjust bottom margin for title\n    plot.subtitle = element_text(hjust = 0.12, vjust = 0, \n                                 size = 22, color = \"#353939\", family = \"mulish\"),# Adjust bottom margin for subtitle\n    # Position title and subtitle within the plot panel\n    plot.title.position = \"plot\",\n    plot.subtitle.position = \"plot\"\n  )\n\nbarchart_coc1\n\n\n\n2. Flags\nNow I can continue with the flags, which have been one of the main challenges. First, it was difficult to find the right package for this task. Second, the issue was with the images themselves, as I initially had to download them, which added to the complexity.\nFinally, I decided to use a package that I have downloaded from Github, called flagon.\nBut there is also a particularity, some of the flags of the original plot are not in this package (because these are from regions inside a country), so I needed to download in the project file.\n\n\n# Read PNG images for flags\nAustralia <- readPNG(flagon::flags(\"au\"))\nAlbania <- readPNG(flagon::flags(\"al\"))\nEstados_Unidos <- readPNG(flagon::flags(\"us\"))\nEscocia <- readPNG(flagon::flags(\"gb-sct\"))\nInglaterra <- readPNG(\"wls_eng.png\")\nEspaña <-  readPNG(flagon::flags(\"es\"))\nPaises_Bajos <- readPNG(flagon::flags(\"nl\"))\nIrlanda_norte <- readPNG(flagon::flags(\"gb-nir\"))\nUruguay <- readPNG(flagon::flags(\"uy\"))\nArgentina <- readPNG(flagon::flags(\"ar\"))\nIrlanda <- readPNG(flagon::flags(\"ie\"))\nCanada <- readPNG(flagon::flags(\"ca\"))\nPolonia <- readPNG(flagon::flags(\"pl\"))\nChile <- readPNG(flagon::flags(\"cl\"))\nCostaRica <- readPNG(flagon::flags(\"cr\"))\n\n#Add flags to the bar chart using `annotation_raster`\nflag_plot <- barchart_coc1 +\n  annotation_raster(CostaRica, xmin = 0.6, xmax = 1.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Chile, xmin = 1.6, xmax = 2.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Polonia, xmin = 2.6, xmax = 3.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Canada, xmin = 3.6, xmax = 4.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Argentina, xmin = 5.6, xmax = 6.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Irlanda, xmin = 4.6, xmax = 5.3, ymin = -0.62, ymax = -0.34) + \n  annotation_raster(Irlanda_norte, xmin = 7.6, xmax = 8.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Uruguay, xmin = 6.6, xmax = 7.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Paises_Bajos, xmin = 8.6, xmax = 9.3, ymin = -0.62, ymax = -0.34) + \n  annotation_raster(España, xmin = 9.6, xmax = 10.3, ymin = -0.62, ymax = -0.34) + \n  annotation_raster(Inglaterra, xmin = 10.6, xmax = 11.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Escocia, xmin = 11.6, xmax = 12.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Estados_Unidos, xmin = 12.6, xmax = 13.3, ymin = -0.62, ymax = -0.34) +  \n  annotation_raster(Albania, xmin = 13.6, xmax = 14.3, ymin = -0.62, ymax = -0.34) + \n  annotation_raster(Australia, xmin = 14.6, xmax = 15.3, ymin = -0.62, ymax = -0.34)  \n\n\n#Now, we can display the final plot with flags\nflag_plot\n\n\n\nAs we can see, one problem I encountered was with the quality of the flags in the graph. Despite using the annotation_raster() function to add them, the quality of the flags appeared quite poor.\nFor the shades that has the authentic graph, I tried to introduce grey rectangles on the back of the flags but it wasn’t a good option. Also I tried to edit the images of the packages but then when I tried to introduce those flags in the graph they disappeared.\n3. Logos\nThe next step is to introduce the logos. These original figures were difficult to find, so I decided to made a screenshot of the original plot and introduce the pictures with patchwork package.\n\n\n# Read the PNG images for the logos\nlogo1 <- readPNG(\"eom.png\")\nlogo2 <- readPNG(\"cuch.png\")  \n\n#Convert images into raster objects to be used in the plot\nlogo1_grob <- rasterGrob(logo1, interpolate = TRUE)  #Convert the first logo into a graphical object\nlogo2_grob <- rasterGrob(logo2, interpolate = TRUE)  #Convert the second logo into a graphical object\n\n#Combine the bar chart with flags and logos\nplot_logo <- flag_plot + \n  # Add Logo 1 in the topright corner\n  inset_element(\n    logo1_grob,\n    left = 0.62, bottom = -0.12, right = 1.02, top = 0.17,  #Position for top-right corner\n    align_to = \"panel\",  # Align the position to the panel dimensions\n    on_top = TRUE  # Ensure the logo appears on top of the plot\n  ) +\n  # Add Logo 2 in the bottomright corner\n  inset_element(\n    logo2_grob,\n    left = 0.62, bottom = 0.12, right = 1.02, top = 0.56,  #Position for bottom-right corner\n    align_to = \"panel\",  \n    on_top = FALSE  \n  )\n\n#The final plot\nplot_logo\n\n\n\nCritique of the original chart\nAlthough it is titled Main Cocaine Consumers, all the observations are countries except for Scotland, England and Wales, and Northern Ireland. Two issues can be identified here: first, while these territories are divided, England and Wales are kept together, meaning these observations do not correspond to an administrative area of the United Kingdom. Second, I believe these observations should have been grouped into a single one, United Kingdom, to allow for a better comparison.\nIt’s important to acknowledge that this is a sensitive topic, as it touches on drug consumption, which involves complex social, economic, and cultural factors. Additionally, gathering reliable data on cocaine use poses significant challenges. Drug use is often under reported due to stigma, illegality, and variations in how surveys or studies are conducted across different regions or countries.\nThis previous part have been my replica to the graph. As you can see, there are some differences. First, there are some adjustment issues, such as with the size of the figures, text, and positioning. I’ve tried to make it as similar as possible, but there are still some aspects that could be improved. Second, the flag images, as in the original, the quality of these is much higher than what I’ve managed to achieve, as well as the shading behind them.\nImprovements\nConsidering the points mentioned, I can now move forward with improving the graph. Despite the challenges, I believe the original graph is a strong representation of the data. It effectively conveys the information in a clear and straightforward manner. The simplicity of the design makes it easy to understand, and the choice of a bar plot is particularly appropriate for visualizing this type of comparative data.\n1. Bar plot\nAesthetics\nFirst, I will proceed to address some aesthetic aspects that, in my opinion, will improve the overall quality of the graphic:\n1.Aligning positions: Adjusting the positioning number to ensure they are visually balanced and aligned properly.\n2.Axis line: Modifying the line on the axis to make it more distinct will help to clarify the data’s structure and improve the overall clarity of the graph.\n\n\n# Create the bar chart with reordered countries and custom aesthetics\n# Reorder countries by consumption percentage\nupgrade <- ggplot(cocaine_data, aes(x = reorder(País, `Porcentaje de consumo (%)`),\n                                    y = `Porcentaje de consumo (%)`,\n                                    fill = `Porcentaje de consumo (%)`), \n                  family = \"mulish\", font.main = 2) +\n  # Add horizontal bars for each country\n  geom_bar(stat = \"identity\", width = 0.7) +\n  # Flip the axes for a horizontal bar chart\n  coord_flip() +  \n  # Add a horizontal line at y = 0 to connect the starting points of the bars\n  geom_segment(aes(x = 0.6, xend = 15.4, y = 0, yend = 0), \n               color = \"black\", #Change the color from the original one\n               linewidth = 0.8) +\n  # Add the ranking positions to the left of the y-axis\n  geom_text(aes(label = Posición, y = -0.2), \n            hjust = 0.5,  #Adjust text horizontally\n            color = \"#0A0A0A\",  #Text color\n            size = 4.3, family = \"mulish\", font.main = 2) +\n  # Add the percentage of consumption at the end of each bar\n  geom_text(aes(label = paste0(gsub(\"\\\\.\", \",\", formatC(\n    `Porcentaje de consumo (%)`, format = \"f\", digits = 2, drop0trailing = TRUE)), \"%\"), \n                y = `Porcentaje de consumo (%)`), \n            hjust = -0.4,  #Adjust the text placement horizontally\n            vjust = 0.38,  #Adjust the text placement vertically\n            color = \"#0A0A0A\", \n            size = 4, \n            family = \"mulish\", font.main = 2) +\n  # Adjust the expansion of the y-axis\n  scale_y_continuous(expand = expansion(add = c(0.6, 1.5))) +\n  # Add additional space for the x-axis limits\n  expand_limits(x = 17) +\n  # Add a label for the \"Position\" column\n  annotate(geom = \"text\", label = \"Posición\",\n           x = 15.8, y = -0.2, size = 4, vjust = 0, \n           color = \"#353939\", family = \"mulish\") + \n  # Set a gradient color scale for the bars\n  scale_fill_gradient(low = \"#c0cd94\", high = \"#84a528\") +\n  # Add plot labels\n  labs(title = \"Principales consumidores de cocaína\",  \n       subtitle = \"Porcentaje de adultos que han consumido en el último año*\", \n       caption = paste0(  \n         \"Último  año con datos disponibles*<br>\",\n         \"**Cartografía:**<br>\",\n         \"Abel Gil Lobo (2019)<br>\", \n         \"**Fuente:**<br>\",\n         \"UNODC (2018)\"),\n       y = \"Porcentaje de consumo (%)\",  # Y-axis label\n       x = NULL) +  # No label for the x-axis\n  # Customize the overall theme\n  theme_minimal() +\n  theme(\n    axis.title.x = element_blank(),  # Remove x-axis title\n    axis.title.y = element_blank(),  # Remove y-axis title\n    axis.text.x = element_blank(),  # Remove x-axis text\n    axis.ticks.x = element_blank(),  # Remove x-axis ticks\n    panel.grid = element_blank(),  #Remove grid lines\n    axis.text.y = element_text(size = 13, family = \"mulish\", color = \"#0A0A0A\"), \n    panel.grid.major = element_blank(),  # Remove major grid lines\n    legend.position = \"none\",  #Hide legend\n    plot.margin = margin(t = 0, r = 5, b = 1, l= 2),  # Adjust plot margins\n    panel.background = element_blank(),  # Set panel background to blank\n    plot.background = element_blank(),  #Set overall plot background to blank\n    # Style for the plot caption\n    plot.caption = element_markdown(hjust = 0, vjust = 1, face = \"plain\", \n                                    size = 8, family = \"mulish\",\n                                    margin = margin(t = 0, r = 0, b = 0, l = 11)),\n    #Style for the main title\n    plot.title = element_text(hjust = 0.07, vjust = 0, size = 29, \n                              family = \"mulish\"),  \n    #Style for the subtitle\n    plot.subtitle = element_text(hjust = 0.12, vjust = 0, size = 22, \n                                 color = \"#353939\", family = \"mulish\"),\n    # Position the title and subtitle within the panel\n    plot.title.position = \"plot\",\n    plot.subtitle.position = \"plot\"\n  )\n\n# Display the improvements\nupgrade\n\n\n\nNew info\nMy aim is to make the graph more informative, so I decided to introduce the continent information in the graph.Therefore, I introduce the Continent values in a new variable.\n\n\n#Introduce the variable\ncocaine_data$Continente <- c(\"Oceanía\",\"Europa\",\"América\",\"Europa\",\"Europa\",\n                             \"Europa\",\"Europa\",\"Europa\",\"América\",\"América\",\n                             \"Europa\",\"América\",\"Europa\",\"América\",\"América\")\n\n#I convert it to a factor for the legend:\ncocaine_data$Continente <- factor(cocaine_data$Continente, \n                                  levels = c(\"Oceanía\", \"Europa\", \"América\")) \n\n\n# Create the bar chart with countries and color by continent\nupgrade_color <- ggplot(cocaine_data, aes(x = País, \n                                   y = `Porcentaje de consumo (%)`,\n                                   fill = Continente), family = \"mulish\", font.main = 2) +\n  geom_bar(stat = \"identity\", width = 0.7) +\n  coord_flip() +  # To rotate the chart\n  # Vertical line on the y-axis, connecting the start of the bars\n  geom_segment(aes(x = 0.6, xend = 15.4, y = 0, yend = 0), \n               color = \"black\", \n               linewidth = 0.8) +\n  # Add positions next to the Y axis\n  geom_text(aes(label = Posición, y = -0.2), \n            hjust = 0.5, \n            color = \"#0A0A0A\", \n            size = 4.3, family = \"mulish\", font.main = 2) +\n  # Add consumption percentages at the end of each bar\n  geom_text(aes(label = paste0(gsub(\"\\\\.\", \",\", formatC(\n    `Porcentaje de consumo (%)`, format = \"f\", digits = 2, drop0trailing = TRUE)), \"%\"), \n                y = `Porcentaje de consumo (%)`), \n            hjust = -0.4, \n            vjust = 0.38,\n            color = \"#0A0A0A\", \n            size = 4.25, \n            family = \"mulish\", font.main = 2) +\n    # Adjust the expansion of the Y axis\n scale_y_continuous(expand = expansion(add = c(0.6, 1.5))) +\n  expand_limits(x = 16.4)  +\n  annotate(geom = \"text\", label = \"Position\",\n           x = 15.85, y = -0.2, size = 4.4, vjust = 0, color = \"#353939\", family = \"mulish\") + \n   # Add a manual color palette for the variable Continent\n  scale_fill_manual(values = c(\"Oceanía\" = \"#2C3E50\", \n                               \"Europa\" = \"#FFA500\", \n                               \"América\" = \"#84a528\")) +\n  labs(title = \"Top Cocaine Consumers\", \n       subtitle = \"Percentage of adults who have consumed in the last year*\", \n       caption = paste0(\n         \"Latest available year*<br>\",\n         \"**Cartography:**<br>\",\n         \"Abel Gil Lobo (2019)<br>\", \n         \"**Source:**<br>\",\n         \"UNODC (2018)\"),\n       y = \"Percentage of consumption (%)\", \n       x = NULL) +\n  theme_minimal() +\n  theme(\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    panel.grid = element_blank(),\n    axis.text.y = element_text(margin = margin(r = 1.7), size = 12.8, family = \"mulish\", color = \"#0A0A0A\"), \n    panel.grid.major = element_blank(),\n    legend.position = c(0.9, 0.88),\n    plot.margin = margin(t = 0, r = 5, b = 1, l= 2), \n    panel.background = element_blank(), \n    plot.background = element_blank(),\n    plot.caption = element_markdown(hjust = 0, vjust = 1, face = \"plain\", size = 8, family = \"mulish\", margin = margin(t = 0, r = 0, b = 0, l = 11)),\n    plot.title = element_text(hjust = 0.07, vjust = 0, size = 29, family = \"mulish\"),  # Adjust bottom margin of the title\n    plot.subtitle = element_text(hjust = 0.12, vjust = 0, size = 22, color = \"#353939\", family = \"mulish\"),  # Adjust bottom margin of the subtitle\n    plot.title.position = \"plot\",  # Title inside the panel\n    plot.subtitle.position = \"plot\"  # Subtitle inside the panel\n  )\n\n\nupgrade_color\n\n\n\nWith these aesthetic improvements, the graph now allows us to visually capture more information. Each bar is assigned a different color representing a continent: blue for Oceania, yellow for Europe, and green for the Americas, as indicated in the legend at the top right.\nThis color coding reveals that, while the top consumer is from Oceania, the majority of the remaining consumers are from Europe and America. Notably, most of these countries and regions are developed nations.\n2. Flags\nNow that I have modified the aesthetics of the graph, I can proceed with the steps I followed in the replication process.\n\n\n#Add flags to the bar chart:\nupgrade_flag <- upgrade_color +\n  # I Position the flags on the chart maintaining original coordinates\n  annotation_raster(CostaRica, xmin = 0.6, xmax = 1.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Chile, xmin = 1.6, xmax = 2.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Polonia, xmin = 2.6, xmax = 3.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Canada, xmin = 3.6, xmax = 4.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Argentina, xmin = 5.6, xmax = 6.3, ymin = -0.66, ymax = -0.38) + \n  annotation_raster(Irlanda, xmin = 4.6, xmax = 5.3, ymin = -0.66, ymax = -0.38) + \n  annotation_raster(Irlanda_norte, xmin = 7.6, xmax = 8.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Uruguay, xmin = 6.6, xmax = 7.3, ymin = -0.646, ymax = -0.38) +  \n  annotation_raster(Paises_Bajos, xmin = 8.6, xmax = 9.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(España, xmin = 9.6, xmax = 10.3, ymin = -0.66, ymax = -0.38) + \n  annotation_raster(Inglaterra, xmin = 10.6, xmax = 11.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Escocia, xmin = 11.6, xmax = 12.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Estados_Unidos, xmin = 12.6, xmax = 13.3, ymin = -0.66, ymax = -0.38) +  \n  annotation_raster(Albania, xmin = 13.6, xmax = 14.3, ymin = -0.66, ymax = -0.38) + \n  annotation_raster(Australia, xmin = 14.6, xmax = 15.3, ymin = -0.66, ymax = -0.38)  \n\n#Display the chart with flags positioned\nupgrade_flag\n\n\n\nI followed the previous steps, so the problems of quality remain here.\n3. Logos\nFinally, I reintroduce the logos as in the original graph:\n\n\n#Combine the flag chart with logos\nfinal_upgrade <- upgrade_flag + \n  #Add Logo 1 (top-right position)\n  inset_element(\n    logo1_grob,\n    left = 0.62, bottom = -0.12, right = 1.02, top = 0.17, # Top-right corner position\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  #Add Logo 2 (bottom-right position)\n  inset_element(\n    logo2_grob,\n    left = 0.62, bottom = 0.12, right = 1.02, top = 0.56, # Bottom-right corner position\n    align_to = \"panel\",\n    on_top = FALSE\n  )\n\n\nfinal_upgrade\n\n\n\nThis has been the improvement to my graph. With enhancements in its visual appearance and the inclusion of data from the continents, I believe the graph now provides more information. However, the issue is that, given the quality of the original graph and the available data, the scope for improvement was limited.\nAlternative\nTherefore, I believe two approaches could be considered with this type of data. First, creating a graph that reflects the evolution of cocaine consumption, and second, categorizing countries based on their status. I have decided on three categories: producer, transition, and consumer countries.\nFor the purpose of creating an alternative visualization, I am going to invent some data about the evolution of cocaine consumption in these countries. My aim is to group the countries into three categories: producer, transition, and consumer countries.\n\n\n# I am going to generate random values for with the range of [0.92, 3.5]\nset.seed(123)  \nserie_1 <- runif(15, min = 0.92, max = 3.5)  \nserie_2 <- runif(15, min = 0.92, max = 3.5)\nserie_3 <- runif(15, min = 0.92, max = 3.5)\n\n# Now I need to unify:\nserie_completa <- c(serie_1, serie_2, serie_3,\n                    2.5, 2.5, 2.4, 2.34, 2.3, 2.0, 1.9, 1.8, 1.8, 1.67, \n                    1.5, 1.47, 1.4, 1.38, 1.33)\n\n\n\n\n#Create a tibble with the previous information\ndata_countries <- tibble::tibble(\n  País = c(\"Australia\", \"Albania\", \"Estados Unidos\", \"Escocia (R.U.)\", \"Inglaterra y Gales (R.U.)\", \"España\", \n           \"Países Bajos\", \"Irlanda del Norte (R.U.)\", \"Uruguay\", \"Argentina\", \"Irlanda\", \"Canadá\", \"Polonia\", \n           \"Chile\", \"Costa Rica\", \"Australia\", \"Albania\", \"Estados Unidos\", \"Escocia (R.U.)\", \n           \"Inglaterra y Gales (R.U.)\", \"España\", \"Países Bajos\", \"Irlanda del Norte (R.U.)\", \"Uruguay\", \n           \"Argentina\", \"Irlanda\", \"Canadá\", \"Polonia\", \"Chile\", \"Costa Rica\", \"Australia\", \"Albania\", \n           \"Estados Unidos\", \"Escocia (R.U.)\", \"Inglaterra y Gales (R.U.)\", \"España\", \"Países Bajos\", \n           \"Irlanda del Norte (R.U.)\", \"Uruguay\", \"Argentina\", \"Irlanda\", \"Canadá\", \"Polonia\", \"Chile\", \n           \"Costa Rica\", \"Australia\", \"Albania\", \"Estados Unidos\", \"Escocia (R.U.)\", \"Inglaterra y Gales (R.U.)\", \n           \"España\", \"Países Bajos\", \"Irlanda del Norte (R.U.)\", \"Uruguay\", \"Argentina\", \"Irlanda\", \"Canadá\", \n           \"Polonia\", \"Chile\", \"Costa Rica\"),\n  `Porcentaje de consumo` = serie_completa,\n  Año = rep(c(1988, 1998, 2008, 2018), each = 15)  \n)\n\n# Now, I create the varibale status:\ndata_countries <- data_countries %>%\n  mutate(País = case_when(\n    País %in% c(\"Escocia (R.U.)\", \"Inglaterra y Gales (R.U.)\", \"Irlanda del Norte (R.U.)\") ~ \"Reino Unido\",\n    TRUE ~ País\n  )) %>%\n  group_by(País, Año) %>%\n  summarise(`Porcentaje de consumo` = mean(`Porcentaje de consumo`), .groups = 'drop') %>%\n  ungroup() %>% \n  mutate(estatus = case_when(\n    País %in% c(\"Albania\", \"Argentina\", \"Costa Rica\") ~ \"Productor\",\n    País %in% c(\"España\", \"Uruguay\", \"Países Bajos\") ~ \"Transición\",\n    TRUE ~ \"Consumidor\"\n  )) \n#Join the values of Escocia, Inglaterra, Gales e Irlanda del Norte to create Reino Unido, and I have calculated the mean.\n\ndata_countries\n\n# A tibble: 52 × 4\n   País        Año `Porcentaje de consumo` estatus   \n   <chr>     <dbl>                   <dbl> <chr>     \n 1 Albania    1988                    2.95 Productor \n 2 Albania    1998                    1.55 Productor \n 3 Albania    2008                    3.25 Productor \n 4 Albania    2018                    2.5  Productor \n 5 Argentina  1988                    2.10 Productor \n 6 Argentina  1998                    2.61 Productor \n 7 Argentina  2008                    1.52 Productor \n 8 Argentina  2018                    1.67 Productor \n 9 Australia  1988                    1.66 Consumidor\n10 Australia  1998                    3.24 Consumidor\n# ℹ 42 more rows\n\nI must mention that since the consumption data has been generated randomly, the evolution may seem strange. However, I preferred to do it this way to represent the variations, without considering how it might turn out.\nFirst, I will also maintain the size of the graph to ensure consistency and comparability with the previous one. Similarly, I will keep the font used in the replica because it is similar and I believe it enhances readability. I will also include the images of the tubes and lines.\nTo complete this exercise, I will present different visualization styles or attempts I have made:\nFirst Attempt\nIn the first attempt, I aim to represent the evolution by country.\n\n\n# Plot showing the trend of cocaine consumption by country over time\nggplot(data_countries) +\n  aes(x = Año, \n      y = `Porcentaje de consumo`, \n      color = País) +  #Color by country\n  geom_line(linewidth = 0.75) +  #Thicker lines for clarity\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == max(Año)),  # Labels only for the most recent year\n    aes(label = País), \n    hjust = -0.1,\n    size = 3.5,\n    direction = \"y\",  #Avoid label overlaps\n    nudge_x = 1.5,  #Move labels to the right\n    segment.color = \"grey70\", \n    segment.size = 0.3\n  ) +\n  scale_x_continuous(\n    breaks = c(1988, 1998, 2008, 2018),  # Set x axis breaks\n    labels = c(\"1988\", \"1998\", \"2008\", \"2018\")  #x axis labels\n  ) +\n  scale_y_continuous(\n    breaks = c(0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4),  #Set y axis breaks\n    labels = c(0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4)  # y axis labels\n  ) +\n  expand_limits(x = 2022, y = 4) +  #Expand axis limits\n  labs(\n    title = \"Evolución del Consumo de Cocaína\",\n    subtitle = \"Porcentaje de adultos que han consumido cocaína\",\n    caption = \"*¡Los datos han sido generados de forma aleatoria!*\"\n  ) +\n  theme_minimal() +  # Minimal theme\n  theme(\n    legend.position = \"none\",  # Hide legend\n    axis.title.x = element_text(size = 14, family = \"mulish\"), \n    axis.title.y = element_text(size = 14, family = \"mulish\"),\n    plot.title = element_text(hjust = 0, vjust = 1, size = 27, family = \"mulish\"),\n    plot.subtitle = element_text(hjust = 0, vjust = 0, size = 24, family = \"mulish\", colour = \"#4D5154\"),\n    plot.caption = element_markdown(size = 9, family = \"mulish\"),\n    plot.margin = unit(c(1, 2, 1, 1), \"cm\")  \n  )\n\n\n\nAs we can see, although the graph represents our objective, it is somewhat difficult to read. Adding the grey lines for annotating the country names has made it slightly easier to follow. However, despite the graph conveying the idea I want to express, I believe the visualization is not very clear.\nTherefore, I consider it important to explore other ways of visualizing the data to make it more readable and visually appealing.\nSecond Attempt\nNow, I will try placing the country labels at the beginning as well, to see if this approach makes the graph easier to read. Another idea that occurred to me is to include the country names both at the beginning, next to the y-axis, and at the end.\nIn this attempt, I will also add the logos to simulate a finalized graph.\n\n\n#First I am going to charge the logos\nlogo3 <- readPNG(\"tur.png\")\nlogo3_grob <- rasterGrob(logo3, interpolate = TRUE)\nlogo4 <- readPNG(\"tur1.png\")\nlogo4_grob <- rasterGrob(logo4, interpolate = TRUE)\nlogo5 <- readPNG(\"ray.png\")\nlogo5_grob <- rasterGrob(logo5, interpolate = TRUE)\n\n# Updating the country name \"Estados Unidos\" to \"EEUU\" for better fit on the plot\ndata_countries <- data_countries %>%\n  mutate(etiqueta = if_else(País == \"Estados Unidos\", \"EEUU\", País))\n\n#Plot:\nggplot(data_countries) +\n  aes(x = Año, \n      y = `Porcentaje de consumo`, \n      color = País) +  #Plot by country\n  geom_line(linewidth = 0.75) +  # Increase the line width\n  # Labels at the beginning of the line (first year)\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == min(Año)),  # Filter data for labels at the start\n    aes(label = etiqueta), \n    size = 3.5,\n    direction = \"y\",  #Adjust direction to avoid overlap\n    nudge_x = -1.9,   #Move labels to the left\n    segment.color = \"grey70\",  #Line color connecting the labels\n    segment.size = 0.3\n  ) +\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == max(Año)),  #Filter only the last year\n    aes(label = etiqueta), \n    hjust = -0.1,\n    size = 3.5,\n    direction = \"y\",  #Adjust direction to avoid overlap\n    nudge_x = 1.5,      #Move labels to the right\n    segment.color = \"grey70\",  #  Add lines connecting the labels to the points\n    segment.size = 0.3\n  ) +\n  scale_x_continuous(\n    breaks = c(1988, 1998, 2008, 2018),  #Set breaks at specific years\n    labels = c(\"1988\", \"1998\", \"2008\", \"2018\")  #Labels for the years\n  ) +\n  scale_y_continuous(breaks = c(0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4),\n                     labels = c(0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4)) +\n  expand_limits(x = 2022, y = 4) +\n  labs(title = \"Evolución del Consumo de Cocaína\",\n       subtitle = \"Porcentaje adultos consumidores\",\n       caption = \"*¡Los datos han sido generados de forma aleatoria!*\") +\n  theme_minimal() +  \n  theme(legend.position = \"none\",\n        axis.title.x = element_text(size = 14, family = \"mulish\"),  # Set the x-axis title size\n        axis.title.y = element_text(size = 14, family = \"mulish\"),\n        axis.text.y = element_text(size = 12, face = \"bold\"),\n        plot.title = element_text(hjust = 0, vjust = 1, size = 27, family = \"mulish\"),\n        plot.subtitle = element_text(hjust = 0, vjust = 0, size = 24, family = \"mulish\", colour = \"#4D5154\"),\n        plot.caption = element_markdown(size = 9, family = \"mulish\"),\n        plot.margin = unit(c(1, 2, 1, 1), \"cm\")) +\n  #Adding logos to the plot\n  inset_element(\n    logo3_grob,\n    left = 0.82, bottom = 1, right = 1.35, top = 1.25,  #Position at the upper right\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo4_grob,\n    left = -0.16, bottom = 1, right = 0, top = 1.25, #Position at the upper-left\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo5_grob,\n    left = 0.79, bottom = 1, right = 0.95, top = 1.25, #Another position at the upper-right\n    align_to = \"panel\",\n    on_top = TRUE)\n\n\n\nIn this way, the evolution of consumption can be followed much more clearly, although the presence of 13 countries still makes the graph somewhat difficult to read, as there are many lines crossing each other.\nThird Attempt\nNext, I will attempt the same representation as before but grouping the countries based on their status values: producers, consumers, and transition countries.\n\n\n#Colors for each status (Producer, Consumer, Transition)\ncolor_palette <- c(\n  \"Productor\" = \"#0072B2\",  #Strong blue for Producer\n  \"Consumidor\" = \"#D55E00\",  #Strong red for Consumer\n  \"Transición\" = \"#009E73\"   #Bright green for Transition\n)\n\nggplot(data_countries) +\n  aes(x = Año, \n      y = `Porcentaje de consumo`, \n      group = País, \n      color = estatus) +  # Use 'estatus' for coloring based on category\n  geom_line(linewidth = 0.75) +  #Lines for each country\n  #Labels at the start of the line (first year)\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == min(Año)),  #Filter data for labels at the start\n    aes(label = etiqueta), \n    size = 3.5,\n    direction = \"y\",  #Adjust direction to avoid overlap\n    nudge_x = -1.9,   #ove labels to the left\n    segment.color = \"grey70\",  # Line color connecting the labels\n    segment.size = 0.3\n  ) +\n  # Labels at the end of the line (last year)\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == max(Año)),  #Filter only the last year\n    aes(label = etiqueta), \n    hjust = -0.1,\n    size = 3.5,\n    direction = \"y\",  # Adjust direction to avoid overlap\n    nudge_x = 1.5,    #Move labels to the right\n    segment.color = \"grey70\",  #Add lines connecting the labels to the points\n    segment.size = 0.3\n  ) +\n  scale_x_continuous(\n    breaks = c(1988, 1998, 2008, 2018),\n    labels = c(\"1988\", \"1998\", \"2008\", \"2018\")\n  ) +\n  scale_y_continuous(breaks = seq(0.5, 4, 0.5)) +\n  expand_limits(x = 2022, y = 4) +\n  labs(\n    title = \"Evolución del Consumo de Cocaína\",\n    subtitle = \"Porcentaje de adultos consumidores\",\n    caption = \"*¡Los datos han sido generados de forma aleatoria!*\",\n    color = \"ESTATUS\"\n  ) +\n  scale_color_manual(values = color_palette) +  #assign colors\n  theme_minimal() +\n  theme(\n    legend.position = c(0.85, 0.85),  # Legend position within the plot (relative coordinates)\n    legend.title = element_text(size = 12),  # Size of the legend title\n    legend.text = element_text(size = 10),  # Size of the legend text\n    axis.title.x = element_text(size = 14, family = \"mulish\"),\n    axis.title.y = element_text(size = 14, family = \"mulish\"),\n    axis.text.y = element_text(size = 12, face = \"bold\"),  # Y-axis values in bold and size 12\n    plot.title = element_text(hjust = 0, vjust = 1, size = 27, family = \"mulish\"),\n    plot.subtitle = element_text(hjust = 0, vjust = 0, size = 24, family = \"mulish\", colour = \"#4D5154\"),\n    plot.caption = element_markdown(size = 9, family = \"mulish\"),\n    plot.margin = unit(c(1, 2, 1, 1), \"cm\")  # Add margins (top, right, bottom, left)\n  ) +\n  # Adding logos to the plot\ninset_element(\n    logo3_grob,\n    left = 0.82, bottom = 1, right = 1.35, top = 1.25,  #Position at the upper right\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo4_grob,\n    left = -0.16, bottom = 1, right = 0, top = 1.25, #Position at the upper-left\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo5_grob,\n    left = 0.79, bottom = 1, right = 0.95, top = 1.25, #Another position at the upper-right\n    align_to = \"panel\",\n    on_top = TRUE)\n\n\n\nRegarding this graph, although I have represented the information I initially wanted, I believe that reducing 13 countries to 3 colors still hinders clear readability.\nFourth Attempt\nTherefore, a solution to the problem could be to create 3 separate graphs using facet wrap, as this would help avoid having too many countries in a single grid.\n\n\n# Crear el gráfico con facet_wrap y colores según estatus\nggplot(data_countries) +\n  aes(x = Año, \n      y = `Porcentaje de consumo`, \n      group = País,\n      color = estatus) +  \n  geom_line(linewidth = 0.75) +  \n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País, estatus) %>%\n      filter(Año == max(Año)),  \n    aes(label = País), \n    size = 3.5,\n    nudge_x = 1.5,  \n    segment.color = \"grey70\",\n    segment.size = 0.3\n  ) +\n  scale_x_continuous(\n    breaks = c(1988, 1998, 2008, 2018),\n    labels = c(\"1988\", \"1998\", \"2008\", \"2018\")\n  ) +\n  scale_y_continuous(\n    breaks = seq(0.5, 4, 0.5),\n    labels = seq(0.5, 4, 0.5)\n  ) +\n  scale_color_manual(values = color_palette) +  \n  expand_limits(x = 2022, y = 4) +\n  facet_wrap(~estatus, ncol = 1, scales = \"free_y\") +  \n  theme_minimal() +\n  theme(\n    legend.position = \"none\",  \n    axis.title.x = element_text(size = 14, family = \"mulish\"),\n    axis.title.y = element_text(size = 14, family = \"mulish\"),\n    plot.title = element_text(hjust = 0, vjust = 1, size = 27, family = \"mulish\"),\n    plot.subtitle = element_text(hjust = 0, vjust = 0, size = 24, family = \"mulish\", colour = \"#4D5154\"),\n    plot.caption = element_markdown(size = 9, family = \"mulish\"),\n    strip.text = element_text(size = 15, family = \"mulish\", face = \"bold\"),\n    plot.margin = unit(c(1, 2, 1, 1), \"cm\")\n  )\n\n\n\nSince the Consumer category contains the most countries, this could make the graph less readable. To address this issue, I will split this category into two: European Consumers and Non-European Consumers. This way, the data will be more organized and easier to interpret, ensuring clearer visibility for each group.\nFifth Attempt\n\n\n#First, odify the data:\ndata_countries <- data_countries %>%\n  mutate(estatus_modificado = case_when(\n    estatus == \"Consumidor\" & País %in% c(\"Reino Unido\", \"Irlanda\", \"Polonia\") ~ \"Consumidores Europeos\",\n    estatus == \"Consumidor\" & País %in% c(\"Estados Unidos\", \"Australia\", \"Canadá\", \"Chile\") ~ \"Consumidores No Europeos\",\n    estatus == \"Productor\" ~ \"Países Productores\",\n    estatus == \"Transición\" ~ \"Países Transitorios\",\n    TRUE ~ estatus  \n  ))\n\n#Colors for each estatus:\ncolor_palette <- c(\n  \"Países Productores\" = \"#0072B2\",       \n  \"Países Transitorios\" = \"#009E73\",      \n  \"Consumidores Europeos\" = \"#D55E00\",  \n  \"Consumidores No Europeos\" = \"#CC79A7\"   \n)\n\n\n#PLOT\ngrafico_facet <- ggplot(data_countries) +\n  aes(x = Año, \n      y = `Porcentaje de consumo`, \n      group = País,\n      color = estatus_modificado) + \n  geom_line(linewidth = 0.75) + \n    ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País) %>%\n      filter(Año == min(Año)),  \n    aes(label = etiqueta), \n    size = 3.5,\n    direction = \"y\",  \n    nudge_x = -2.1,   \n    segment.color = \"grey70\",  \n    segment.size = 0.3\n  ) + # Líneas de los países\n  ggrepel::geom_text_repel(\n    data = data_countries %>%\n      group_by(País, estatus_modificado) %>%\n      filter(Año == max(Año)),  \n    aes(label = etiqueta), \n    hjust = -0.1,\n    size = 3.5,\n    direction = \"y\",  \n    nudge_x = 0.7,      \n    segment.color = \"grey70\",  \n    segment.size = 0.3\n  ) +\n  scale_x_continuous(\n    breaks = c(1988, 1998, 2008, 2018),\n    labels = c(\"1988\", \"1998\", \"2008\", \"2018\")\n  ) +\n  scale_y_continuous(\n    breaks = seq(0.5, 4, 1),\n    labels = seq(0.5, 4, 1)\n  ) +\n  scale_color_manual(values = color_palette) +  # Assign colors by estatus modificado\n  expand_limits(x = 2022, y = 4) +\n  facet_wrap(~estatus_modificado, ncol = 1, scales = \"free_y\") +  #New panel for estatus modificado\n  labs(\n    title = \"Evolución del Consumo de Cocaína\",\n    subtitle = \"Porcentaje de adultos consumidores según el estatus\",\n    caption = \"*¡Los datos han sido generados de forma aleatoria!*\"\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",  \n    axis.title.x = element_text(size = 14, family = \"mulish\"),\n    axis.title.y = element_text(size = 14, family = \"mulish\"),\n    plot.title = element_text(hjust = 0, vjust = 1, size = 27, family = \"mulish\"),\n    plot.subtitle = element_text(hjust = 0, vjust = 0, size = 24, family = \"mulish\", colour = \"#4D5154\"),\n    plot.caption = element_markdown(size = 9, family = \"mulish\"),\n    strip.text = element_text(size = 15, family = \"mulish\", face = \"bold\"),  \n    plot.margin = unit(c(1, 2, 1, 1), \"cm\")\n  ) +\ninset_element(\n    logo3_grob,\n    left = 0.82, bottom = 1, right = 1.35, top = 1.25,  #Position at the upper right\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo4_grob,\n    left = -0.16, bottom = 1, right = 0, top = 1.25, #Position at the upper-left\n    align_to = \"panel\",\n    on_top = TRUE\n  ) +\n  inset_element(\n    logo5_grob,\n    left = 0.79, bottom = 1, right = 0.95, top = 1.25, #Another position at the upper-right\n    align_to = \"panel\",\n    on_top = TRUE)\n\n\ngrafico_facet    \n\n\n\nI believe this graph is much more readable and makes it easier to compare the patterns across the different categories. By separating the countries into smaller, more focused groups, the data becomes less cluttered and more accessible, allowing for clearer insights.\nTo conclude, I would like to reflect on the graphs I have created. From my point of view, if I could only choose one, my choice would be the second graph, as I believe it is the most aesthetically pleasing. Its design stands out and conveys the intended message effectively.\nHowever, I also recognize that this graph may be challenging to read, as it requires focus to follow the progression of the lines accurately. This could make it less accessible for some viewers, especially when attempting to interpret complex patterns quickly.\nOn the other hand, the final graph allows for a clearer comparison of countries within the same category. It simplifies the visualization by grouping similar nations, making trends within each group more evident. However, comparing countries across different categories becomes more challenging with this layout. This trade-off highlights the difficulty of balancing clarity and comparability in visualizations, as the ideal choice often depends on the specific context and the audience’s needs.\n\n\n\n",
    "preview": "projects/2024/100541120/100541120_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2025-01-17T11:48:24+01:00",
    "input_file": {},
    "preview_width": 1632,
    "preview_height": 1152
  },
  {
    "path": "projects/2024/100542532/",
    "title": "Exploring Where Americans Can Afford to Live Alone",
    "description": "Rising rents and stagnant wages make even modest apartments unaffordable in many U.S. cities",
    "author": [
      {
        "name": "Isabel Monge",
        "url": {}
      }
    ],
    "date": "2025-01-16",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nReplication\nData\nBasic plot structure\nLegend and labels\nTheme\nAnnotations\n\nInteraction\nShiny app framework\nTooltips\nDropdown selector rules\n\nAlternative vizualization\nData joining\nData cleaning\nBasic map structure\nLegend and labels\nCity markers\n\n\nThis double lollipop graph below, originally published by The Economist in 2023, compares the median wage to the affordable studio wage across cities in the United States. It highlights the growing housing affordability crisis and reveals where single renters face the greatest financial challenges. My objective is to recreate this graph as closely as possible using R, and then to propose an alternative visualization.\n\n\n\nFigure 1: The Economist, 2023\n\n\n\nReplication\n\n\nlibrary(ggplot2)   # Create plots\nlibrary(showtext)  # Custom fonts\nlibrary(sysfonts)  # Manage fonts\nlibrary(readr)     # Read data\nlibrary(ggiraph)   # Add tooltips\nlibrary(shiny)     # Build interactive web applications (used for dropdown list)\nlibrary(rvest)     # Web scraping and extracting data from HTML\nlibrary(dplyr)     # General data manipulation\nlibrary(stringr)   # String manipulation and cleaning\nlibrary(maps)      # Plot basic map outlines\nlibrary(sf)        # Handle spatial data (maps)\nlibrary(leaflet)   # Create interactive maps\nlibrary(scales)    # Format tooltips with commas for better readability\n\n\nData\nThe data to create this graph is not publicly available for download, but I was able to recreate the dataset from the information included in the original graph. Since I recreated the dataset to include the exact information in the original graph, I did not need to clean the data.\n\n\ndata <- read_csv(\"wage_vs_housing_econ.csv\")\n\n\nBasic plot structure\nTo begin, I created the lollipops for each city, and a black, horizontal line where the y-intercept = 0.\n\n\nmy_graph <- ggplot(data, aes(x = reorder(City, -Affordable_Rent_Wage))) +\n  geom_segment(aes(xend = City, \n                   y = Affordable_Rent_Wage / 1000, \n                   yend = Average_Wage / 1000),\n               color = \"#5e5e5e\", linewidth = 0.2) +\n  geom_point(aes(y = Average_Wage / 1000, color = \"Median wage\"), size = 1.3) +\n  geom_point(aes(y = Affordable_Rent_Wage / 1000, color = \"Affordable-studio wage*\"), size = 1.3) +\n  geom_hline(yintercept = 0, color = \"black\", linewidth = 0.25) \nmy_graph\n\n\n\nLegend and labels\nNext, I manually defined the y-axis labels. Formatting the y-axis labels to match the original graph was particularly challenging, as they needed to sit above the axis lines while remaining right-justified. To achieve this, I first created custom labels with precise spacing to ensure proper right alignment. Adjusting the label position over the bars will be addressed later as part of the theme customization.\n\n\nmy_graph <- my_graph +\n  scale_y_continuous(\n    name = NULL, \n    position = \"right\", \n    limits = c(0, 150), \n    expand = expansion(mult = c(0.02, 0.025)),\n    breaks = seq(0, 150, by = 25),\n    labels = c(\"    0\", \"  25\", \"  50\", \"  75\", \"100\", \"125\", \"150\")) + \n  scale_x_discrete(\n      expand = expansion(mult = c(0.01, 0.05)\n    )\n  )\nmy_graph\n\n\n\nNext, I modified the legend. This included defining custom dot sizes and colors and ensuring labels were in the correct order to replicate the original graph.\n\n\nmy_graph <- my_graph +\n  scale_color_manual(\n    name = NULL, \n    values = c(\"Median wage\" = \"#1b2b73\", \"Affordable-studio wage*\" = \"#e3130b\"),\n    breaks = c(\"Median wage\", \"Affordable-studio wage*\"), \n    guide = guide_legend(\n      override.aes = list(size = 1.3), \n      direction = \"horizontal\", \n      title.position = \"top\", \n      label.position = \"right\" \n    )\n  ) \nmy_graph\n\n\n\nThen I added a title, subtitle, and footer to my graph. At this stage, my graph contained all the essential elements. The next step was refining the theme to closely match the original.\n\n\nmy_graph <- my_graph +\n  labs(\n    title = \"Median wage v affordable-studio wage*\",\n    subtitle = \"United States, selected cities, 2022, $'000\",\n    x = NULL, # Remove x-axis label for cities\n    caption = \"*Where rental costs make up 30% of annual wage. Based on median studio rental prices, July 2023\\nSources: Bureau of Labour Statistics; Zumper\"\n  )\nmy_graph\n\n\n\nTheme\nThe Economist has their own proprietary font that I could not access, so I instead chose to use a Google font that would allow others to replicate my graph. I opted for “Roboto Condensed,” a similar sans-serif font with a range of weights. My original graph uses three different font weights for the title, subtitle, and legend. Since font_add_google only provides plain and bold styles by default, I loaded the font three times, specifying a different weight each time. This allowed me to call the appropriate font weight in my theme for each element.\n\n\nfont_add_google(name = \"Roboto Condensed\", family = \"Roboto Condensed Regular\", regular.wt = 400)\nfont_add_google(name = \"Roboto Condensed\", family = \"Roboto Condensed Bold\", regular.wt = 700)\nfont_add_google(name = \"Roboto Condensed\", family = \"Roboto Condensed Light\", regular.wt = 300)\nshowtext_auto()\n\n\nI customized my graph’s theme by removing unnecessary elements like x-axis text and grid lines. As I mentioned earlier, I also adjusted the y-axis text for size and alignment. I then specified font weights, sizes, and spacing for the title, subtitle, and caption. Finally, I positioned the legend at the top in a horizontal layout and fine-tuned the margins to closely replicate the overall design and layout.\n\n\nmy_graph <- my_graph +\n  theme_minimal(base_family = \"Roboto Condensed Regular\") +  \n  theme(\n    axis.text.x = element_blank(),  \n    axis.ticks.x = element_blank(), \n    panel.grid.major.x = element_blank(), \n    panel.grid.minor = element_blank(),   \n    axis.text.y.right = element_text(size = 7, vjust = -0.5, hjust = -5.5), \n    plot.title = element_text(size = 9.5, family = \"Roboto Condensed Bold\", margin = margin(b = 3)), \n    plot.subtitle = element_text(size = 8.5, family = \"Roboto Condensed Light\", margin = margin(b = 10)), \n    plot.caption = element_text(hjust = 0, size = 6, color = \"#808080\", margin = margin(b = -10)), \n    plot.caption.position = \"plot\", \n    plot.margin = margin(t = 17, r = -5, b = 10, l= 10), \n    legend.position = \"top\", \n    legend.direction = \"horizontal\", \n    legend.justification = \"left\", \n    legend.margin = margin(-5, 0, 0, 0), \n    legend.text = element_text(size = 7), \n    legend.key.size = unit(0, 'cm') \n  )\nmy_graph\n\n\n\nAnnotations\nThe last step was to add in the annotations using annotate(). I started by adding the annotations for the five selected cities in the original graph.\n\n\nmy_graph <- my_graph +\n annotate(\"text\", x = which(data$City == \"New York, NY\"), y = 144, label = \"New York, NY\", \n           size = 2.2, hjust = 0, family = \"Roboto Condensed Regular\") +\n  annotate(\"text\", x = which(data$City == \"Miami, FL\"), y = 94, label = \"Miami, FL\", \n           size = 2.2, hjust = -0.1, vjust = 1, family = \"Roboto Condensed Regular\") +\n  annotate(\"text\", x = which(data$City == \"Charleston, SC\"), y = 38, label = \"Charleston, SC\", \n           size = 2.2, hjust = 0.9, family = \"Roboto Condensed Regular\") +\n  annotate(\"text\", x = which(data$City == \"Seattle, WA\"), y = 66, label = \"Seattle, WA\", \n           size = 2.2, hjust = 0, family = \"Roboto Condensed Regular\") +\n  annotate(\"text\", x = which(data$City == \"El Paso, TX\"), y = 28, label = \"El Paso, TX\", \n           size = 2.2, hjust = 0.95, family = \"Roboto Condensed Regular\") \nmy_graph\n\n\n\nFinally, I added the fork structure connecting Los Angeles and Chicago, as well as the annotation text to complete my static replication.\n\n\nmy_graph <- my_graph +\n# Fine-tuned annotation for accurate spacing and alignment\n  annotate(\"text\", x = which(data$City == \"Los Angeles, CA\"), y = 102, \n           label = \"Los Angeles and Chicago are among the\\ncities where the affordable-studio wage is\\nhigher than the median wage\", \n           hjust = 0, size = 2.5, family = \"Roboto Condensed Regular\") +\n  \n  # Top line of fork\n  annotate(\"segment\", x = which(data$City == \"Nashville, TN\") + 0.5, \n           xend = which(data$City == \"Nashville, TN\") + 0.5, \n           y = 82, yend = 91, color = \"black\", linewidth = 0.2) +  \n  \n  # Horizontal fork line\n  annotate(\"segment\", x = which(data$City == \"Los Angeles, CA\"), \n           xend = which(data$City == \"Chicago, IL\"), \n           y = 82, yend = 82, color = \"black\", linewidth = 0.2) +\n  \n  # Vertical lines of the fork\n  annotate(\"segment\", x = which(data$City == \"Los Angeles, CA\"), \n           xend = which(data$City == \"Los Angeles, CA\"), \n           y = 73, yend = 82, color = \"black\", linewidth = 0.25) +  \n  annotate(\"segment\", x = which(data$City == \"Chicago, IL\"), \n           xend = which(data$City == \"Chicago, IL\"), \n           y = 65, yend = 82, color = \"black\", linewidth = 0.2)\nmy_graph\n\n\n\nInteraction\nThe original graph from The Economist had two interactive elements: a dropdown selector and hover-over tooltips. I believe both are essential to my graph, as the tooltips are useful for exploration, while the dropdown selector is quicker for users who have a specific city in mind. Therefore, I aimed to replicate both.\nI chose to use ggiraph for the tooltips because it allowed me to match the format and styling of The Economist’s original tooltips and integrates seamlessly with my existing ggplot. Since I wanted to use ggiraph, I also needed Shiny to implement the dropdown selector and bring both interactive elements together in the graph.\nI was able to keep the titles, legend, axis labels, and theme from the original graph, but needed to make a few changes as shown below.\nShiny app framework\nFirst, I needed to set up the app’s layout with a dropdown menu to select a city, space to display the interactive chart, and the basic setup needed to make the chart update based on user choices.\n\n\nui <- fluidPage(\n  tags$head(\n    # Add Roboto Condensed from Google Fonts\n    tags$link(rel = \"stylesheet\", \n         href = \"https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700\")\n  ),\n  div(selectInput(\n    \"selected_city\", \n    \"Choose a city:\", \n    choices = c(\"All\", sort(unique(data$City))), \n    selected = \"All\", \n    width = \"600px\")\n  ),\n  girafeOutput(\"interactive_plot\", height = \"500px\")\n)\n\nserver <- function(input, output, session) {\n  output$interactive_plot <- renderGirafe({\n\n# All the code for my graph will go in here\n  })\n}\n\n# This line will run the app\nshinyApp(ui = ui, server = server)\n\n\nTooltips\nThen I used ggiraph to create tooltips that show details about each city. I used CSS styling to ensure the colors and bolding replicated the tooltips in The Economist’s version of the graph.\n\n\n# Add tooltip text\ndata$tooltip <- with(data, paste0(\n   \"<b>\", City, \"<\/b><br>\",\n   \"The <b><span style='color:#e3130b;'>affordable rent wage<\/span><\/b> is $\",\n   Affordable_Rent_Wage, \",<br>\",\n   \"which is <b>$\", abs(Difference), \" \",\n    ifelse(Difference < 0, \"more than\", \"less than\"),\n    \"<\/b> the <b><span style='color:#1b2b73;'>median wage<\/span><\/b>.\"\n))\n\n# Render the interactive plot with tooltips\ngirafe(\n  ggobj = interactive_plot,\n  options = list(\n    opts_hover(css = \"opacity: 1; stroke-width: 2px;\"),\n    opts_selection(css = \"opacity: 0.2;\"),\n    opts_tooltip(css = \"background-color: white; color: black; border: 1px solid black; \npadding: 5px; border-radius: 5px; font-family: 'Roboto Condensed', sans-serif; font-size: 14px;\")\n  )\n)\n\n\nDropdown selector rules\nI also created a dropdown selection rule that uses two sets of colors—bold colors to highlight the selected city and lighter colors to dim unselected cities. The geom_segment_interactive function draws lines connecting the affordable rent wage and median wage for each city, while geom_point_interactive plots individual data points with the assigned colors and tooltips that appear on hover.\n\n\n# Define colors\ndark_blue <- \"#1b2b73\"\ndark_red <- \"#e3130b\"\ndark_gray <- \"#808080\"\nlighter_blue <- \"#c7d2f1\"\nlighter_red <- \"#fdd4d2\"\nlight_gray <- \"#d3d3d3\"\n\n# Adjust colors based on selection\ndata$dot_color_median <- ifelse(\n  input$selected_city == \"All\" | data$City == input$selected_city, dark_blue, lighter_blue\n)\ndata$dot_color_affordable <- ifelse(\n  input$selected_city == \"All\" | data$City == input$selected_city, dark_red, lighter_red\n)\ndata$line_color <- ifelse(\n  input$selected_city == \"All\" | data$City == input$selected_city, dark_gray, light_gray\n)\n\n# Build the interactive plot\ninteractive_plot <- ggplot(data, aes(x = reorder(City, -Affordable_Rent_Wage))) +\n  geom_segment_interactive(aes(\n    xend = City, \n    y = Affordable_Rent_Wage / 1000, \n    yend = Average_Wage / 1000,\n    tooltip = tooltip,\n    data_id = City\n  ), color = data$line_color, linewidth = 0.2) +\n  \n  geom_point_interactive(aes(\n    y = Average_Wage / 1000,\n    tooltip = tooltip,\n    data_id = City\n  ), color = data$dot_color_median, size = 1.3) +\n  \n  geom_point_interactive(aes(\n    y = Affordable_Rent_Wage / 1000,\n    tooltip = tooltip,\n    data_id = City\n  ), color = data$dot_color_affordable, size = 1.3)\n\n\nAlthough the Shiny App altered the original formatting slightly, we are left with an interactive graph that closely replicated the functionality of The Economist’s version.\nAlternative vizualization\nFor my alternative visualization, I wanted to add to the story of my original graph by showing trends in rent affordability based on city size and location. For this reason, I chose to create an interactive map.\nWhen creating my interactive map, I first considered using ggplotly or ggiraph because they both integrate well with ggplot2. However, ggplotly didn’t allow multiple legends, which I needed, and I wasn’t able to customize the tooltips the way I wanted. ggiraph had good tooltip options but wasn’t built for maps, so its zoom feature didn’t work well, which was an essential functionality given that I have overlapping cities in multiple regions.\nTherefore, I chose leaflet to create my map. It has smooth zooming, supports multiple legends, and makes tooltips easy to customize. Since I had already started learning some basic CSS for my Shiny app, leaflet was simple to use and was the best choice for my project.\nData joining\nI started by joining the preexisting dataset from the Economist with a new dataset that included population data and geographic coordinates for each city.\n\n\n# Download the population and coordinates data, and clean text strings\npop_and_coordinates <- read_html(\"https://en.wikipedia.org/wiki/List_of_United_States_cities_by_population\") |>\n  html_node(\"table.wikitable.sortable.static-row-numbers.sticky-header-multi\") |>\n  html_table() |>\n  select(City = `City`, State = `ST`, Population = `2023estimate`, Coordinates = `Location`) |> \n  mutate(\n    City = str_remove_all(City, \"\\\\[.*?\\\\]\"),\n    City = paste(City, State, sep = \", \"),                  \n    Population = as.numeric(str_remove_all(Population, \",\")),\n    Coordinates = str_extract(Coordinates, \"^[^/]+\"\n  )\n)\n\n# Merge the datasets\nmerged_data <- left_join(data, pop_and_coordinates, by = \"City\")\n\n# There were a few cities missing, so I will add them manually\nmerged_data <- merged_data |>\n  mutate(\n    Population = case_when(\n      City == \"Arlington, VA\" ~ 238643,\n      City == \"Asheville, NC\" ~ 94589,\n      City == \"Phoenix, AZ\" ~ 1608139,\n      City == \"Winston Salem, NC\" ~ 249545,\n      City == \"New York, NY\" ~ 8467513,\n      TRUE ~ Population \n    ),\n    Coordinates = case_when(\n      City == \"Arlington, VA\" ~ \"38.8797°N 77.1075°W\",\n      City == \"Asheville, NC\" ~ \"35.5951°N 82.5515°W\",\n      City == \"Phoenix, AZ\" ~ \"33.4484°N 112.0740°W\",\n      City == \"Winston Salem, NC\" ~ \"36.0999°N 80.2442°W\",\n      City == \"New York, NY\" ~ \"40.7128°N 74.0060°W\",\n      TRUE ~ Coordinates \n  )\n)\n\n\nData cleaning\nNext, I cleaned the data by converting the latitude and longitude data to numeric and eliminating unnecessary character strings. I then capped “Difference” values at ±$50k because a few cities had extremely high values, which made the colors of all other cities less prominent when plotting. Finally, I created the tooltip as a new column in my dataset, so I could call it later when building the graph.\n\n\n# Clean latitude and longitude data to prepare for plotting\nmerged_data <- merged_data |>\n  mutate(\n    Latitude = as.numeric(sub(\"°.*\", \"\", Coordinates)),\n    Longitude = as.numeric(sub(\".*[°N|°S|°E|°W]\\\\s(-?\\\\d+\\\\.?\\\\d*).*\", \"\\\\1\", Coordinates)),\n    Alpha = pmin(1, abs(Difference) / max(abs(Difference), na.rm = TRUE\n    )\n  )\n)\n\n# Apply capping for cities exceeding ±$50k\nmerged_data <- merged_data |>\n  mutate(\n    CappedDifference = ifelse(Difference > 50000, 50000, ifelse(Difference < -50000, -50000, Difference)) \n  )\n\n#Adding the tooltip to the dataset\nmerged_data <- merged_data |>\n  mutate(\n    Tooltip = paste0(\n      \"<div style='font-family: Arial, sans-serif; font-size: 12px;'>\",\n      \"<b style='color:black;'>\", City, \"<\/b><br>\",\n      \"Population: \", comma(Population), \"<br>\",\n      \"The affordable rent wage is $\", comma(Affordable_Rent_Wage), \",<br>\",\n      \"which is <b style='color:black;'>$\", comma(abs(Difference)), \" \",\n      ifelse(Difference < 0, \"<b style='color:#e3130b;'>more than <\/b>\", \n      \"<b style='color:#1b2b73;'>less than <\/b>\"),\n      \"<\/b>the median wage.\",\n      \"<\/div>\"\n    )\n  )\n\n\nBasic map structure\nTo begin creating my new graph, I first used the maps() and sf() packages to load a US Map, and then added state boundaries.\n\n\n# Load US Map with Accurate Projection\nus_map_sf <- st_as_sf(map(\"state\", plot = FALSE, fill = TRUE))\n\n# Initialize Map with Basic Settings\nmy_map <- leaflet(merged_data) |>\n  setView(\n    lng = -96.5,    \n    lat = 37.8,     \n    zoom = 3        \n  ) |>\n  addProviderTiles(providers$CartoDB.PositronNoLabels)\n\n# Add State Boundaries\nmy_map <- my_map |>\n  addPolygons(\n    data = us_map_sf,\n    fillColor = \"gray90\",  \n    color = \"black\",       \n    weight = 0.5\n  )\nmy_map\n\n\n\nLegend and labels\nI added a title, subtitle, and two legends - one for the size and another for the color of each city. I used addLegend() for the affordability gap because leaflet supports color scale legends, but I used addLegendCustom() for population size since leaflet doesn’t support custom marker shapes or sizes.\n\n\n# Add title and subtitle\nmy_map <- my_map |>\n  addControl(\n    \"<div style='font-family: Arial, sans-serif; text-align: center;'>\n      <h3 style='margin: 0;'>Where Housing Costs Outpace Wages<\/h3>\n      <p style='margin: 0; font-size: 12px;'>U.S. Cities by Affordability and Size, 2022<\/p>\n    <\/div>\",\n    position = \"topright\"\n  )\n\n# Define color palette\ncolor_palette <- colorNumeric(\n  palette = c(\"#e3130b\", \"#FFFFFF\", \"#1b2b73\"), \n  domain = c(-50000, 50000)\n)\n\n# Add affordability gap legend\nmy_map <- my_map |>\n  addLegend(\n    position = \"bottomright\",\n    pal = color_palette,\n    values = c(-50000, 50000), \n    title = \"Affordability<br>Gap (USD)\",\n    labFormat = function(type, cuts, p) {\n      labels <- c(\"-50k\", \"\", \"0k\", \"\", \"+50k\")\n      return(labels)\n    },\n    opacity = 1\n  )\n\n# Add custom population legend\naddLegendCustom <- function(map, title, labels, sizes, position) {\n  legendHTML <- paste0(\n    \"<div style='font-family: Arial, sans-serif; text-align: center;'>\",\n    \"<b>\", title, \"<\/b><br>\",\n    paste0(\n      \"<div style='display: inline-block; width: \", sizes, \"px; height: \", sizes, \n      \"px; border-radius: 50%; border: 1px solid black; background-color: gray; margin: 5px;'><\/div>\",\n      labels, \"<br>\", collapse = \"\"\n    ),\n    \"<\/div>\"\n  )\n  my_map |> addControl(html = legendHTML, position = position)\n}\n\nmy_map <- addLegendCustom(\n  map = map,\n  title = \"Population<br>(Millions)\",\n  labels = c(\"1M\", \"2M\", \"3M+\"),\n  sizes = c(15, 25, 35), \n  position = \"bottomleft\"\n)\nmy_map\n\n\n\nCity markers\nFinally, I defined the sizes for each city, plotted them on the map using their geographic coordinates, and incorporated the previously specified colors and tooltips to complete the map.\n\n\n# Add city circles\nmy_map <- my_map |>\n  addCircleMarkers(\n    lng = ~jitter(-merged_data$Longitude, factor = 5),  \n    lat = ~jitter(merged_data$Latitude, factor = 15), \n    # Jitter points slightly to minimize overlap\n    radius = ~pmin((Population / 1e6 * 4) + 6, 25),         \n    color = \"black\",                                        \n    weight = 1,                                            \n    fillColor = ~color_palette(CappedDifference),           \n    fillOpacity = 1,                                        \n    popup = ~Tooltip                                        \n  )\nmy_map\n\n\n\n\n\n\n",
    "preview": "projects/2024/100542532/100542532_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2025-01-17T11:48:24+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100431421/",
    "title": "Global Map of Migration",
    "description": "Recreation and improvement of a migration plot",
    "author": [
      {
        "name": "Mencía Gómez-Luna",
        "url": {}
      }
    ],
    "date": "2025-01-15",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nWhy did I choose this plot\nPreparation of the data\nRecreation of the original plot\nWe create the original map\nWe create the original barplot\nFinal replication\n\nImprovements of the plot\nLimitations\nImprovements\n\nFinal plot with improvements\n\nWhy did I choose this plot\nI wanted to replicate and improve this EOM plot where there’s represented the percentage of migrant population that each country has:\nInmigrantes en el mundo. Source: El Orden Mundial.I chose this graph since I had never recreated a map before (unlike other types of plots such as barplots, boxplots, histograms, etc.). In addition, it also caught my attention because it’s not only a single type of plot, but within one plot it includes another; in this case, within the map there’s a barplot. Likewise, among the improvements I also wanted to add other types of visual representation forms such as flows.\nAs it’s a migration map, we can visualize which areas have the most migrations and -with the improvements I make- how and why people move between regions, revealing historical, political social or economic patterns. It is therefore a key type of plot to understand population dynamics.\nTo recreate and improve this plot, this document contains the following parts:\nPreparation of the data\nRecreation of the original plot\nImprovement of the plot\nFinal plot\nPreparation of the data\nFirst, we open the libraries and fonts that we’ll use:\n\n\n#Libraries\nlibrary(openxlsx)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(rworldmap)\nlibrary(sf)\nlibrary(ggforce)\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(showtext)\nlibrary(png)\nlibrary(cowplot)\n\n#Fonts\nfont_add_google(\"Lato\", family = \"lato\")\nfont_add_google(\"Raleway\", family = \"raleway\")\nshowtext_auto()\n\n\nNow we load the data and the base map. Migration data were obtained from the Pew Research Center and population data from the World Bank for the year 2017.\nFor the base map, I chose a low resolution because we don’t need very precise details as in other types of more specific maps (for example province maps)\n\n\n# DATA\ndatos <- read.xlsx(\"migraciones_final.xlsx\", sheet = 1)\n\n# BASE MAP\nmapa_mundial <- st_as_sf(getMap(resolution = \"low\")) \nmapa_mundial <- mapa_mundial |>\n  rename(Country = ADMIN)\n\n\nThen we join our data and change some country names to shorten them\n\n\ndatos_mapa <- mapa_mundial |>\n  left_join(datos, by = \"Country\")\n\ndatos_mapa <- datos_mapa |>\n  mutate(Country = recode(Country, \"United Arab Emirates\" = \"UAE\"),\n         Country = recode(Country, \"British Virgin Islands\" = \"BVI\"))\n\n\nWe create the brackets for the “% of immigrants” as in the original plot\n\n\ndatos_mapa$Percent_Migration <- datos_mapa$Percent_Migration * 100 # to make it percentage (%)\n\ndatos_mapa$Percent_Migration_category <- cut(\n  datos_mapa$Percent_Migration,\n  breaks = c(-Inf, 1, 3, 10, 25, Inf),\n  labels = c(\"< 1%\", \"1% - 3%\", \"3% - 10%\", \"10% - 25%\", \">25%\"),\n  right = FALSE\n)\n\n\nRecreation of the original plot\nWe create the original map\n\n\noriginal_map <- ggplot(datos_mapa) +\n  geom_sf(aes(fill = Percent_Migration_category), color = \"white\", linewidth = 0.25) +\n  scale_fill_manual(\n    values = c(\"< 1%\" = \"#ebc657\", \"1% - 3%\" = \"#aac25c\",\"3% - 10%\" = \"#72b56e\", \n               \"10% - 25%\" = \"#388f8d\", \">25%\" = \"#286b80\"),\n    name = \"% de población migrante\",\n    na.value = \"#e1e1e1\",\n    na.translate = FALSE,\n    guide = guide_legend(\n      keywidth = 0.7,  # Legend width\n      keyheight = 0.7, # Legend height\n    )\n  ) +\n  theme_void() +\n  theme(\n    legend.position = c(0.17, 0.28),  # Legend position\n    legend.justification = c(0, 0), \n    legend.title = element_blank(), \n    legend.text = element_text(size = 8 , family = \"raleway\"))+\n  coord_sf()+\n  theme(aspect.ratio = 0.6) # More compressed\n\noriginal_map\n\n\n\nWe create the original barplot\n\n\nbarplot <- datos_mapa |>\n  arrange(desc(Percent_Migration)) |>\n  head(8) |> #we need 8 countries as in the original plot\n  ggplot(aes(x = reorder(Country, Percent_Migration), y = Percent_Migration, fill = Percent_Migration)) +\n  geom_bar(stat = \"identity\", fill=\"#8aa526\",  width = 0.7) + #width of the bars\n  geom_text(\n    aes(label = paste0(round(Percent_Migration), \"%\")),\n    hjust = 0,  # Text position\n    nudge_y = 4, #Space between bars and percentage\n    size = 2, # Size of numbers in percentages\n    family = \"raleway\"\n  )+\n  coord_flip() +  # Horizontal\n  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05)))+ #Space between bars\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),  # Eliminate text in axis X\n    axis.text.y = element_text(size = 6,  margin = margin(r = 6)), \n    axis.title.x = element_blank(),  # Eliminate the title in axis X\n    axis.title.y = element_blank(),  # Eliminate the title in axis X\n    panel.grid = element_blank(),\n    axis.line = element_blank(),\n    legend.position = \"none\",\n    aspect.ratio = 1.8 # More or less compressed\n  )\nbarplot\n\n\n\nClarification: The letters are small so that, in the final merge with the map, they appear at the correct size (it adjusts automatically). And the margin between the Y axis and the bars is a bit wide to add the flag images.\nNext, we want to add the flags, so we load them and add them\n\n\nflag_eau <- readPNG(flagon::flags(\"ae\"))\nflag_kuwait <- readPNG(flagon::flags(\"kw\"))\nflag_bvi <- readPNG(flagon::flags(\"vg\"))\nflag_qatar <- readPNG(flagon::flags(\"qa\"))\nflag_isleofman <- readPNG(flagon::flags(\"im\"))\nflag_andorra <- readPNG(flagon::flags(\"ad\"))\nflag_liecht <- readPNG(flagon::flags(\"li\"))\nflag_bahrain <- readPNG(flagon::flags(\"bh\"))\n\n\nFinal bar plot with the flags:\n\n\ngraph <- barplot +\n  annotation_raster(flag_eau, xmin = 7.65, xmax = 8.35, ymin = -32, ymax = -6)+\n  annotation_raster(flag_kuwait, xmin = 6.65, xmax = 7.35, ymin = -32, ymax = -6)+\n  annotation_raster(flag_bvi, xmin = 5.65, xmax = 6.35, ymin = -32, ymax = -6) +\n  annotation_raster(flag_qatar, xmin = 4.65, xmax = 5.35, ymin = -32, ymax = -6) +\n  annotation_raster(flag_isleofman, xmin = 3.65, xmax = 4.35, ymin = -32, ymax = -6) + \n  annotation_raster(flag_andorra, xmin = 2.65, xmax = 3.35, ymin = -32, ymax = -6) +\n  annotation_raster(flag_liecht, xmin = 1.65, xmax = 2.35, ymin = -32, ymax = -6) +\n  annotation_raster(flag_bahrain, xmin = 0.65, xmax = 1.35, ymin = -32, ymax = -6) +\n  coord_flip(clip = \"off\")\n\ngraph\n\n\n\nClarification: The reason why I didn’t correct the superimposition of maps on the letters and graphics is because in the final join it reajusts automatically and fits good.\nFinal replication\nNow we want to join the map with the barplot and add the logo, title and sources. So first we load the images for the logo and image and transform the map and barplot into a grob plot. The grob command allows us to directly manipulate graphical elements so it’s useful for combining complex plots outside of standard ggplot2 capabilities:\n\n\n# We load the logo and image to add\nlogo <- readPNG(\"EOM.png\")\nimage <- readPNG(\"familia2.png\")\n\n# Transform into grob\nmap_grob <- ggplotGrob(original_map)\ngraph_grob <- ggplotGrob(graph)\n\n\nWe combine the map, barplot, source, images, and title:\n\n\nplot <- ggdraw() +\n  draw_grob(map_grob) +  \n  draw_grob(graph_grob, x = 0.43, y = 0.14, width = 0.35, height = 0.25) + \n  draw_image(logo, x = 0.77, y = 0.08, width = 0.12, height = 0.14) + \n  draw_image(image, x = 0.77, y = 0.97, width = 0.12, height = 0.11) +\n  draw_grob(\n    textGrob(\n      \"Cartografía:\", \n      x = 0.15, y = 0.19, \n      gp = gpar(fontface = \"bold\", fontsize = 8, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  ) +\n  draw_grob(\n    textGrob(\n      \"Mencía Gómez (2024)\", \n      x = 0.15, y = 0.16, \n      gp = gpar(fontsize = 8, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  ) +\n  draw_grob(\n    textGrob(\n      \"Fuente:\", \n      x = 0.15, y = 0.13, \n      gp = gpar(fontface = \"bold\", fontsize = 8, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  ) +\n  draw_grob(\n    textGrob(\n      \"Pew Research Center (2017)\", \n      x = 0.15, y = 0.1, \n      gp = gpar(fontsize = 8, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  )\n\n# We add the title\n\nfinal_plot <- plot_grid(\n  ggdraw() + \n    draw_text(\"Un mundo de migrantes\", size = 24, x = 0.15, y = 0.32, hjust = 0,\n              fontface = \"bold\", family= \"lato\") +\n    draw_text(\"% de la población que ha nacido en otro país\", size = 12, x = 0.15,\n              y = 0.05, hjust = 0, fontface = \"bold\", family= \"lato\", color = \"#444444\"),\n  plot,\n  ncol = 1,\n  rel_heights = c(0.2, 0.8)\n)\n\nfinal_plot\n\n\n\nImprovements of the plot\nOnce we have done the entire replication, we are going to improve this map, although there were some limitations and doubts that we had to resolve:\nLimitations\nOne option for improvement was to change the scale from categorical/discrete to continuous, since we have data for this. The problem with using a continuous scale in this case is that, because most countries have low percentages of immigrants (less than 20%), the colors assigned to these countries would be very similar, since they fall in a narrow range of the scale, which would make most of the map a uniform color. Only areas with very high percentages, such as the Arab region, would be highlighted with a different color, but this would make the map monotonous and uninformative for most countries.\n(Additionally, we use the Viridis color scale correctly where blues are associated with low values and yellows with the highest values, which are the ones that stand out.)\n\n\n# Map with continuous scale\nmap_cont <- ggplot() +\n  geom_sf(data = datos_mapa, aes(fill = Percent_Migration), color = \"white\", linewidth = 0.2) +\n  theme_void() +\n  scale_fill_viridis_c(name = \"% of immigrants\") +\n  theme(\n    legend.position = c(0.2, 0.4),\n    legend.title = element_text(size = 10, face = \"bold\"),\n    legend.key.size = unit(0.15, \"cm\"),\n    legend.key.height = unit(0.25, \"cm\"),\n    legend.key.width = unit(0.25, \"cm\"),\n    legend.text = element_text(size = 8),\n    aspect.ratio = 0.6\n  ) +\n  coord_sf()\n\nmap_cont\n\n\n\nSeeing this results and how uninformative the map is with a continuous scale, I thought about the option of converting the continuous scale to logarithmic since this type of transformation allows the highest values to be compressed and the lowest values to be expanded, which helps to improve the visualization of countries with low immigration percentages without losing the distinction from those with higher percentages. When applying a logarithmic scale, the colors of countries with low immigration diversify slightly, while areas with high percentages continue to stand out, but without the map appearing uniformly tinted with a single color.\nHowever, the problem with this comes from the interpretation and the legend: it appears in logarithmic notation or, if converted to a percentage, they appear as multiples of 10 raised to powers, which makes interpretation completely difficult. In addition, another problem arises: since in the logarithmic scale the values are not distributed linearly, there is confusion when interpreting percentages. It’s better understood with an example: if Libya and Canada are colored green on a map, this indicates that they both have more than 10% migration, but we don’t know how much more. The difference could be anywhere from, maybe, 5% to 40% or more, but the logarithmic scale does not clearly show these variations, making it difficult to know whether Canada’s migration is just a little higher than Libya’s or much higher, creating confusion when comparing these countries. In addition, we wouldn’t even be able to know Libya’s percentage of immigration: will it be 12% or will it be 45%, for example? We can see these limitations in the map below:\n\n\n# Logaritmic scale into percentage scale\nlog_percent_scale_colors <- scale_fill_viridis_c(\n  trans = \"log10\",  \n  na.value = \"gray80\",\n  name = \"% of immigrants\",\n  labels = function(x) scales::percent(x / max(x))  \n)\n\n# Map wit logaritmic scale\nmap_log_percent <- ggplot() +\n  geom_sf(data = datos_mapa, aes(fill = Percent_Migration), color = \"white\", linewidth = 0.2) +\n  log_percent_scale_colors +  \n  theme_void() +\n  theme(\n    legend.position = c(0.2, 0.4),\n    legend.title = element_text(size = 8, face = \"bold\"),\n    legend.key.size = unit(0.15, \"cm\"),\n    legend.key.height = unit(0.25, \"cm\"),\n    legend.key.width = unit(0.25, \"cm\"),\n    legend.text = element_text(size = 6),\n    aspect.ratio = 0.6\n  ) +\n  coord_sf()\n\nmap_log_percent\n\n\n\nThe solution to all this: a discreet scale. After several tests and attempts I realized that the original map is correct in making this decision. Discrete scaling, by dividing data into fixed categories (such as “< 1%”, “1% - 3%”, etc.), allows both low and high values to be represented with different colors and more accurately interpret the percentages and the differences between them, making differences between countries to be more visible and preventing the map from looking mostly uniform, with only some areas highlighted.\nImprovements\nAfter seeing the possible limitations of the improvement attempts, these are my final proposals for the plot improvements:\nSince we have justified the use of the discrete scale, all we will do is add a new category, splitting the numerical scale of migration in other categories. Specifically, I split the “10-25%” category into two categories: “10-15%” and “15-25%”. I did it since the 10-25% range is still very large and contains many countries between which there are differences that should be highlighted. This allows us to see that there are notable differences between immigration in central Europe and the north, between the US and Canada, among others.\nAdd another barplot for the countries with less immigrants. This would be a good idea because there is already one barplot for those with a higher percentage of migration, so it would be interesting and would give a more balanced image if we showed the same information but for countries with less migration. In this case, we are going to focus only on the first 5 countries of each category not to overload the map.\nAdd migratory flows (differenciating flows depending on the reason of migration). I used the “Migration Report 2017” and the information of the Mexican Government (2017-2024) to choose the most important migratory flows in 2017 on the political, social and economic sphere.\nWe create the flows for the map\nI did it manually. First we define the flows by origin and destination.\nThis information was extracted from a literature review of relevant documents and reports on migratory flows in 2017, especially the Migration Report (2017).\n\n\nflows <- data.frame(\n  Origin = c(\"Libya\",\"Marruecos\", \"Argelia\", \"El Salvador\", \n             \"Honduras\", \"Mexico\", \"Ethiopia\", \"Venezuela\", \n             \"Siria\",  \"Siria\", \"Siria\", \"India\", \"India\", \"Egypt\", \n             \"Australia\", \"Venezuela\", \"Venezuela\", \"China\"),\n  Destination = c(\"Italy\", \"Spain\", \"France\", \"United States\", \n                  \"United States1\", \"United States2\", \"Saudi Arabia\", \n                  \"Colombia\", \"Turkey\",  \"Jordan\", \"Iraq\", \"Saudi Arabia1\",\n                  \"Oman\", \"Saudi Arabia2\", \"Europe\", \"Brasil\", \"Peru\", \"Europe1\")\n)\n\n\nI set the coordinates manually to specify the exact area where I wanted the arrow to reach (for some countries there are more than one pair of coordinates so that the ends of the arrows do not overlap each other)\n\n\ncountry_coords <- data.frame(\n  country = c(\"Libya\", \"Marruecos\", \"Argelia\", \"El Salvador\", \"Honduras\", \n              \"Mexico\", \"Ethiopia\", \"Venezuela\", \"Siria\", \"Italy\", \"Spain\", \n              \"France\", \"United States\", \"Saudi Arabia\", \"Colombia\", \"Turkey\", \n             \"Jordan\", \"Iraq\", \"India\", \"Oman\", \"Egypt\", \"Australia\", \"Europe\",\n              \"Brasil\", \"Peru\", \"United States2\", \"United States1\", \"Saudi Arabia2\",\n             \"Saudi Arabia1\", \"China\", \"Europe1\"),\n  lon = c(17.228, -7.092, 1.659, -88.896, -86.241,-102.5528, 40.48, -65.589, \n          38.996, 12.567, -3.749, 2.2137, -95.712, 45.0792, -74.2973, 35.2433, \n          30.5851, 43.6792, 78.96288, 55.9232, 30.8024, 133.775, 6.129,\n          -51.925, -75.015152, -110, -85, 43, 42.5, 104.19, 19.129),  # Longitudes\n  lat = c(26.3351, 31.7917, 28.0339, 13.7942, 15.199,  23.6345, 9.145, 7.4238, \n          32.0, 41.8719, 40.463, 46.2276, 37.090, 22.8859, 4.5709, 38.9637, \n           36.2384,  33.2231, 20.5936, 21.5125, 26.8205, -25.2743, 49.8152,\n          -14.235004, -9.189967, 39.090, 40, 27, 24, 35.86, 51.8152)    # Latitudes\n)\n\n\nThen I added the coordinates (latitude and longitude) of the origin and destination countries to the flows\n\n\nflows <- flows |>\n  left_join(country_coords, by = c(\"Origin\" = \"country\")) |>\n  rename(origin_lon = lon, origin_lat = lat) |>\n  left_join(country_coords, by = c(\"Destination\" = \"country\"))|>\n  rename(dest_lon = lon, dest_lat = lat)\n\n\nFinally I set the reason of migration, highlighting the most mentioned in the Migration Report (2017)\n\n\nflows <- flows |>\n  mutate(\n    reason = case_when(\n      Origin %in% c(\"Libya\", \"El Salvador\", \"Honduras\", \"Venezuela\", \"Siria\") ~ \"Violence / War\",\n      TRUE ~ \"Economic Reasons\"\n    )\n  )\n\n\nWe create the map with flows\nWe create the new categories and we add the flows over the map with the new categories. For the colors of the arrows, I chose those that could stand out and, at the same time, would not cause problems to the color blind people.\nHaving included colors in the arrows for different migrations reasons, forced me to change the base colors of the map. Why? For the colors of the map I didn’t use de Viridis scale as the original because those colors prevented us from seeing the arrows of migrations. That is, given that the Viridis scale models from yellow to blue through greens and this is a great variety of colors, then when adding more colors with the migration arrows it looked overloaded and confusing with so many colors. In other words: the Viridis scale would have been perfect for the simple map, as in the original map but when adding another layer of colors, it isn’t such an appropriate scale\nThat’s why I chose only one color for the base colors of the map: blue, which graduated in greater or lesser intensity depending on the percentage of migration. Dark blues are for low migration rates, while light blues are for high rates as it stands out more.\n\n\n#New categories\ndatos_mapa$Percent_Migration_category <- cut(\n datos_mapa$Percent_Migration,\n breaks = c(-Inf, 1, 3, 10, 15, 25, Inf),\n labels = c(\"< 1%\", \"1% - 3%\", \"3% - 10%\", \"10% - 15%\", \"15% - 25%\", \">25%\"),\n right = FALSE)\n\nmap_2 <- ggplot() +\n  geom_sf(data = datos_mapa, \n          aes(fill = Percent_Migration_category), \n          color = \"white\", linewidth = 0.2) +\n  scale_fill_manual(\n    values = c(\n      \"< 1%\" = \"#1a5276\", #e0f7fa,\n      \"1% - 3%\" = \"#1d62ad\", #80deea\n      \"3% - 10%\" = \"#3498db\", #26c6da\n      \"10% - 15%\" = \"#26c6da\", #3498db\n      \"15% - 25%\" = \"#80deea\", #1d62ad\n      \">25%\" = \"#e0f7fa\" #1a5276\n    ),\n    name = \"% of immigrants\",\n    na.translate = FALSE,\n    na.value = \"gray80\" \n  ) +\n  \n  # Arrows\n  geom_curve(data = flows, \n             aes(x = origin_lon, y = origin_lat, \n                 xend = dest_lon, yend = dest_lat, \n                 color = reason), \n             curvature = 0.3,  # Arrow curvature\n             arrow = arrow(length = unit(0.03, \"inches\"), type = \"open\"), \n             linewidth = 0.6,  #Arrow line width\n             lineend = \"round\") +\n  geom_curve(data = flows, \n             aes(x = origin_lon, y = origin_lat, \n                 xend = dest_lon, yend = dest_lat, \n                 color = reason), \n             curvature = 0.3,  \n             arrow = arrow(length = unit(0.03, \"inches\"), type = \"open\"), \n             linewidth = 1,  #Effect line width\n             alpha = 0.3,   \n             lineend = \"round\") +\n  \n  # Reasons of migration\n  scale_color_manual(\n    values = c(\"Violence / War\" = \"#f77d00\", \n               \"Economic Reasons\" = \"#9800f7\"),\n    name = \"Reason of migration\"\n  ) +\n  \n  # Theme and legends\n  theme_void() +\n  theme(\n    legend.position = c(0.16, 0.4),\n    legend.title = element_text(size = 6, face = \"bold\", family = \"raleway\"),\n    legend.key.size = unit(0.04, \"cm\"),\n    legend.key.height = unit(0.13, \"cm\"),\n    legend.key.width = unit(0.13, \"cm\"),\n    legend.box.spacing = unit(0.04, \"cm\"),\n    legend.text = element_text(size = 6, family = \"raleway\"),\n    aspect.ratio = 0.6\n  ) +\n  coord_sf()\n\nmap_2\n\n\n\nAs we see, having used only 1 base grading color on the map, we can see the migration arrows more clearly. With the Viridis scale, on the contrary, was very confusing\nWe create the barplots\nWe do the same as before with the original barplot, but now for countries with less immigrants, and just taking into account 5 countries and not 8. First, we load the flag’s images.\n\n\n# We load the flags\nflag_china <- readPNG(flagon::flags(\"cn\"))\nflag_vietnam <- readPNG(flagon::flags(\"vn\"))\nflag_cuba <- readPNG(flagon::flags(\"cu\"))\nflag_madagascar <- readPNG(flagon::flags(\"mg\"))\nflag_indonesia <- readPNG(flagon::flags(\"id\"))\n\n\nWe do again the barplots\n\n\nbar_plot1 <- datos_mapa |>\n  arrange(desc(Percent_Migration)) |>\n  head(5) |>\n  ggplot(aes(x = reorder(Country, Percent_Migration), y = Percent_Migration, fill = Percent_Migration)) +\n  geom_bar(stat = \"identity\", fill=\"#3498db\",  width = 0.7) +\n  geom_text(\n    aes(label = paste0(format(round(Percent_Migration, 2), nsmall = 2), \"%\")),\n    hjust = 0,  # Text position\n    nudge_y = 2, #Space between bars and percentage\n    size = 1.5\n  )+\n  coord_flip() +  # Horizontal \n  labs(\n    title = \"Countries with more immigrants\",\n  ) +\n  scale_y_continuous(expand = expansion(mult = c(0.1, 0.1)))+ #Space between bars\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),  # Eliminate text in axis X\n    axis.text.y = element_text(size = 5,  margin = margin(r = 5), family = \"raleway\"),  \n    axis.title.x = element_blank(),  # Eliminate the title in axis X\n    axis.title.y = element_blank(),  # Eliminate the title in axis X\n    panel.grid = element_blank(),\n    axis.line = element_blank(),\n    legend.position = \"none\",\n    aspect.ratio = 1.8, #More or less compressed\n    plot.title = element_text(\n      size = 4.5,        \n      face = \"bold\",\n      family = \"raleway\",\n      hjust = 0.5       \n    ))\n\n# With the flags:\ngraph_1 <- bar_plot1 +\n  annotation_raster(flag_eau, xmin = 4.6, xmax = 5.35, ymin = -38, ymax = -7)+\n  annotation_raster(flag_kuwait, xmin = 3.6, xmax = 4.35, ymin = -38, ymax = -4)+\n  annotation_raster(flag_bvi, xmin = 2.6, xmax = 3.35, ymin = -38, ymax = -7) +\n  annotation_raster(flag_qatar, xmin = 1.6, xmax = 2.35, ymin = -38, ymax = -7) +\n  annotation_raster(flag_isleofman, xmin = 0.6, xmax = 1.35, ymin = -38, ymax = -7) +\n  coord_flip(clip = \"off\")\n\ngraph_1\n\n\n\nNow for the countries with less immigrants:\n\n\nbar_plot2 <- datos_mapa |>\n  arrange(Percent_Migration) |>\n  head(5) |>\n  ggplot(aes(x = reorder(Country, -Percent_Migration), y = Percent_Migration, fill = Percent_Migration)) +\n  geom_bar(stat = \"identity\", fill=\"#3498db\",  width = 0.7) +\n  geom_text(\n    aes(label = if_else(Percent_Migration < 0.01, \n                        \"<0.01%\", \n                        paste0(format(round(Percent_Migration, 2), nsmall = 2), \"%\"))),\n    hjust = 0,  # Text position\n    nudge_y = 2, #Space between bars and percentage\n    size = 1.5\n  )+\n  coord_flip() +  # Horizontal \n  labs(\n    title = \"Countries with less immigrants\",\n  ) +\n  scale_y_continuous(expand = expansion(mult = c(0.1, 0.1)))+ #Space between bars\n  theme_minimal() +\n  theme(\n    axis.text.x = element_blank(),  # Eliminate text in axis X\n    axis.text.y = element_text(size = 5,  margin = margin(r = 5), family = \"raleway\"),   \n    axis.title.x = element_blank(),  # Eliminate the title in axis X\n    axis.title.y = element_blank(),  # Eliminate the title in axis X\n    panel.grid = element_blank(),\n    axis.line = element_blank(),\n    legend.position = \"none\",\n    aspect.ratio = 1.8,# More or less compressed\n    plot.title = element_text(\n      size = 4.5,        \n      face = \"bold\",\n      family = \"raleway\",\n      hjust = 0.5       \n    )\n  )\n\n# With the flags\ngraph_2 <- bar_plot2 +\n  annotation_raster(flag_china, xmin = 4.7, xmax = 5.35, ymin = -0.9, ymax = -0.2)+\n  annotation_raster(flag_vietnam, xmin = 3.7, xmax = 4.35, ymin = -0.9, ymax = -0.2)+\n  annotation_raster(flag_cuba, xmin = 2.7, xmax = 3.35, ymin = -0.9, ymax = -0.2) +\n  annotation_raster(flag_madagascar, xmin = 1.7, xmax = 2.35, ymin = -0.9, ymax = -0.2) +\n  annotation_raster(flag_indonesia, xmin = 0.7, xmax = 1.35, ymin = -0.9, ymax = -0.2) +\n  coord_flip(clip = \"off\")\n\ngraph_2\n\n\n\nClarification: Just as before the barplots look a bit “ugly” because the flags appear on top of the text blocking it and also because the letters and numbers look tiny, but in the final plot the bar plots appear adjusted.\nFinal plot with improvements\nNow we want to join the map with both barplots. We do the same as before:\n\n\npreview= TRUE\n# We load the images and create grobs\nmap_grob <- ggplotGrob(map_2)\ngraph_grob <- ggplotGrob(graph_1)\ngraph2_grob <- ggplotGrob(graph_2)\n\n# We bind map + barplot1 + barplot2 + image\nfinal_plot <- ggdraw() +\n  draw_grob(map_grob) +  \n  draw_grob(graph_grob, x = 0.55, y = 0.05, width = 0.28, height = 0.28) +\n  draw_grob(graph2_grob, x = 0.38, y = 0.05, width = 0.28, height = 0.28) +\n  draw_grob(\n    textGrob(\n      \"Source:\", \n      x = 0.1, y = 0.125, \n      gp = gpar(fontface = \"bold\", fontsize = 6, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  ) +\n  draw_grob(\n    textGrob(\n      \"Pew Research Center (2017) / World Bank (2017) /\", \n      x = 0.1, y = 0.1, \n      gp = gpar(fontsize = 6, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  )+\n  draw_grob(\n    textGrob(\n      \"Migration Report (2017) / GbMx (2017)\", \n      x = 0.1, y = 0.075, \n      gp = gpar(fontsize = 6, fontfamily = \"raleway\"),\n      hjust = 0\n    )\n  ) \n\n\n# We add the title\nplot <- plot_grid(\n  ggdraw() + \n    draw_text(\"Global Map of Migration\", size = 22, x = 0.08, y = 0.3,\n              hjust = 0, fontface = \"bold\") +\n    draw_text(\"% of immigrants and flows of migration (2017)\", size = 14,\n              x = 0.08, y = 0.0, hjust = 0, fontface = \"bold\", color = \"#444444\"),\n  final_plot,\n  ncol = 1,\n  rel_heights = c(0.2, 0.8)\n)\nplot\n\n\n\n\n\n\n",
    "preview": "projects/2024/100431421/100431421_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 873
  },
  {
    "path": "projects/2024/100432719/",
    "title": "Where do 8 billion people live?",
    "description": "Replica and improvement of a map to show how the world population is distributed among different countries",
    "author": [
      {
        "name": "Alba García-Vega",
        "url": {}
      }
    ],
    "date": "2025-01-15",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nReplica\nImprovement\n\nIntroduction\nWhen I was thinking about this project, I ran directly into this map:\nThe first thing I thought was: wow! A graph were my 3 disciplines merge together: sociology, international relations and, now, programming!. So I decided to use it for this project, replicate it and then improve it. This is a map that was published in the social media Reddit, where we can see how the world population is distributed by countries: those with the bigger circles represent a bigger proportion of the world population and vice versa.\nOriginal graph.Replica\nFirst of all, I have created the data base “population_data”, where I have recorded every single country in the world, their respective populations, continents, latitude, longitude and the percentage of the world population their own population represents. This has been a key part of the project not only because it made it easier to fit the circles later on, but because there were no data bases online with all these data, and also because in the original map, some countries were not shown or taken into consideration. Even in my replica, I have wanted to show as many countries as possible as an initial improvement.\n\n\npopulation_data <- read.csv(\"population_data.csv\")\n\n\n\n\nhead(population_data)\n\n  X        country population     continent    lat    long\n1 1          Aruba     106277 South America  12.50  -69.97\n2 2    Afghanistan   42239854          Asia  33.00   65.00\n3 3        Albania    2745972        Europe  41.00   20.00\n4 4        Algeria   45606480        Africa  28.00    3.00\n5 5 American Samoa      43914       Oceania -14.33 -170.00\n6 6        Andorra      80088        Europe  42.50    1.50\n    percentage    text_size  circle_size population_percentage\n1 0.0013295966 0.0007091182 0.0010636773          0.0013295966\n2 0.5284489166 0.2818394222 0.4227591333          0.5284489166\n3 0.0343539523 0.0183221079 0.0274831618          0.0343539523\n4 0.5705676669 0.3043027557 0.4564541335          0.5705676669\n5 0.0005493936 0.0002930099 0.0004395149          0.0005493936\n6 0.0010019546 0.0005343758 0.0008015637          0.0010019546\n  population_millions adjusted_long adjusted_lat\n1            0.106277        -69.97        12.50\n2           42.239854         65.00        33.00\n3            2.745972         20.00        41.00\n4           45.606480          3.00        28.00\n5            0.043914       -170.00       -14.33\n6            0.080088          1.50        42.50\n\nI also had to create a new data base, a very simple one, called population_by_continent. In this data base, I have only the name of the continent and the percentage (normal and scaled) that each continent´s population represent worldly.\n\n\nlibrary(xfun)\nlibrary(dplyr)\nlibrary(forcats)\npopulation_by_continent <- population_data |> group_by(continent) |> \n  summarize(total_population = sum(circle_size)) |> \n  mutate(percentage = total_population / sum(total_population)*100,\n         continent = fct_reorder(continent, -percentage))\n\n\n\n\nhead(population_by_continent)\n\n# A tibble: 6 × 3\n  continent       total_population percentage\n  <fct>                      <dbl>      <dbl>\n1 Africa                    16.4       15.1  \n2 Asia                      71.6       65.8  \n3 Central America            1.76       1.62 \n4 Europe                     7.95       7.31 \n5 North America              4.14       3.81 \n6 Oceania                    0.455      0.419\n\nLet´s go with the replica itself! Now that I have all the data I may need, I will explain step by step how I have created the map.\nFirst of all, let´s load all the packages I needed:\n\n\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(ggrepel)\nlibrary(cowplot)\nlibrary(permute)\nlibrary(plotly)\nlibrary(patchwork)\nlibrary(extrafont)\n\n\nNow, I changed some of the data in population_data. Originally I had thought that the best option was to divide America in 3 parts, instead of the 2 proposed by the original map: North America, Central America and South America. Nevertheless, Central America represented a very small percentage of the population as was barely visible. Also, it induced some problems in order to create the replica. Finally, I decided to change all Central America countries to South America ones because Central America is not considered a continent, while some authors say that South America is itself a continent.\n\n\npopulation_data <- population_data |> \n  mutate(continent = case_when(\n    continent == \"Central America\" ~ \"South America\",\n    TRUE ~ continent\n  ))\n\n\nI had written incorrectly South America in some of the countries, because I created the data base manually, so I had to fix it:\n\n\npopulation_data <- population_data |> \n  mutate(continent = case_when(continent == \"South Amrica\" ~ \"South America\", TRUE ~ continent))\n\npopulation_by_continent <- population_by_continent |> \n  mutate(continent = case_when(continent == \"Central America\" ~ \"South America\", TRUE ~ continent))\n\n\nHere, I started to design the map itself, not only the data that was going to be shown in it. First of all, I created a new variable inside of population_data, circle_size and circle_sized_adjusted, where I designed the desirable size of the circles in general, but also of the “big 5” specifically. These 5 countries, China, India, USA, Brazil and Nigeria, were not proportional in the original map. They were much bigger than other countries´ circles, even when those countries´ percentage of the world population was not that much smaller. Because of this, I designed these circles as circle_size_adjusted, so that every circle is bigger than in the original variable, circle_size (where every size was directly proportional to the percentage of the population), so that every country´s circle was augmented 60 times, while the big 5 had their circles augmented 150 times.\n\n\npopulation_data <- population_data |> \n  mutate(circle_size = as.numeric(circle_size))\n\npopulation_data <- population_data |> \n  mutate(circle_size_adjusted = case_when(\n    country %in% c(\"China\", \"India\", \"USA\", \"Brazil\", \"Nigeria\") ~ circle_size * 150,\n    TRUE ~ circle_size * 60\n  ))\n\n\nAfter a couple of first trials, I decided that not every country should be included as a label in the map. In the original map they were not, and this makes sense in order to keep some… Well, some order :). So I chose the most visible countries from the original map and created the vector countries_labelled, which collects the countries that would get a label. It is important to note that every country has a different circle, but not all of them are labelled.\n\n\ncountries_labelled <- c(\n  \"Canada\", \"United States\", \"Mexico\", \"Cuba\", \"Guatemala\", \"Haiti\", \"Dominican Republic\", \n  \"Colombia\", \"Venezuela\", \"Ecuador\", \"Peru\", \"Bolivia\", \"Brazil\", \"Uruguay\", \n  \"Paraguay\", \"Argentina\", \"Chile\", \"United Kingdom\", \"Greenland\", \"Spain\", \n  \"Portugal\", \"France\", \"Italy\", \"Germany\", \"Poland\", \"Ukraine\", \"Turkey\", \n  \"Iraq\", \"Syria\", \"Pakistan\", \"Iran\", \"Russia\", \"China\", \"India\", \"Bangladesh\", \n  \"Vietnam\", \"Indonesia\", \"Philippines\", \"Japan\", \"Australia\", \"Nigeria\", \n  \"Morocco\", \"Algeria\", \"Congo, Dem. Rep.\", \"Ethiopia\", \"Egypt\", \n  \"Tanzania\", \"Kenya\", \"South Africa\", \"Russian Federation\")\n\n\nI faced some problems with Kenya, that was not considered as Africa in the original data base; and also with the new variable, circle_size_adjusted, that was not considered as numeric data. I fixed both problems in this chunk:\n\n\npopulation_data <- population_data |>\n  mutate(circle_size_adjusted = as.numeric(circle_size_adjusted))\npopulation_data <- population_data |>\n  mutate(continent = ifelse(country == \"Kenya\", \"Africa\", continent))\n\n\nThen I grouped the data by continent and created the variable of percentage_scaled. This would be used in order to create the legend bar.\n\n\npopulation_by_continent <- population_data |>\n  group_by(continent) |>\n  summarize(percentage = sum(percentage)) |>\n  mutate(percentage_scaled = percentage * 1.5)\n\n\nAlso in order to create the legend bar, I created the data base population_by_continent_summarized. I built this new data base by using population_by_continent and its new variable, percentage_scaled. What I did here was to create two variables inside population_by_continent_summmarized: cumulative and label_position. The most important one out of these two is label_position, which has allowed me to situate the labels in the legend bar correctly. The idea is that the whole bar is a vector, and each label must be situated in position that results from substracting from the whole vector (cumulative, that represents all the continent data) half of the value of percentage_scaled.\n\n\npopulation_by_continent_summarized <- population_by_continent |>\n  arrange(percentage_scaled) |>\n  mutate(\n    cumulative = cumsum(percentage_scaled),\n    label_position = cumulative - percentage_scaled / 2\n  ) |> mutate(continent = factor(continent, levels = continent))\n\n\nNow, I could finally create the legend_bar, which is the first step in the creation of the replica. And, once I had the legend bar, I could create the replica map itself:\n\n\n# Creation of the legend bar:\n\nlegend_bar <- ggplot(population_by_continent_summarized) +\n  aes(x = 1, y = percentage_scaled, fill = reorder(continent, -percentage_scaled)) +\n  geom_bar(stat = \"identity\", width = 2, color = \"black\") +\n  geom_text(\n    aes(\n      label = ifelse(continent == \"Oceania\", \"\",\n                     paste0(continent, \":\", round(percentage_scaled, 1), \"%\")),\n      size = percentage_scaled\n    ),\n    color = \"white\",\n    fontface = \"bold\",\n    family = \"Arial\",\n    position = position_stack(vjust = 0.5)\n  ) +\n  scale_size_continuous(range = c(0.5, 20)) +\n  coord_flip() +\n  scale_fill_manual(\n    values = c( \n      \"Asia\" = \"#00a3e0\", \"Africa\" = \"#009639\", \"Europe\" = \"#FF9E1B\",\n      \"North America\" = \"#aa0061\", \"South America\" = \"#F7EA48\", \n      \"Oceania\" = \"pink\"\n    ),\n    name = \"Continent\"\n  ) +\n  labs(x = NULL, y = NULL) +\n  theme_minimal() +\n  theme(\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    panel.grid = element_blank(),\n    legend.position = \"none\",\n    plot.margin = margin(0, 0, 0, 0),\n    legend.title = element_text(family = \"Arial\", face = \"bold\", size = 16),\n    legend.text = element_text(family = \"Arial\", size = 12)\n  )\n\n# Creation of the replica\n\n\nmap <- ggplot() +\n  borders(\"world\", colour = \"gray95\", fill = \"gray95\") +\n  geom_sf(fill = \"white\", color = \"gray80\") +\n      coord_sf(crs = \"+proj=robin\") +\n  geom_point(\n    data = population_data,\n    aes(x = adjusted_long, y = adjusted_lat,\n        size = circle_size_adjusted, fill = continent),\n    alpha = 1,\n    shape = 21,\n    color = \"black\",\n    stroke = 1.2\n  ) +\n  geom_label(\n    data = population_data |> filter(country %in% countries_labelled),\n    aes(x = adjusted_long, y = adjusted_lat,\n        label = paste0(country, \"\\n\", round(percentage, 1), \"%\"),\n        size = ifelse(country %in% c(\"India\", \"China\"), 20, 6)),\n    fontface = \"bold\", family = \"Arial\", color = \"black\", fill = NA, label.size = 0) +\n  scale_size_identity() +\n  scale_size_continuous(range = c(5, 95), name = \"Population(%)\") +\n  scale_fill_manual(\n    values = c( \"Asia\" = \"#00a3e0\", \"Africa\" = \"#009639\", \"Europe\" = \"#FF9E1B\",\n      \"North America\" = \"#aa0061\", \"South America\" = \"#F7EA48\", \"Oceania\" = \"pink\"),\n    name = \"Continent\"\n  ) +\n  labs(\n    title = \"Where do 8 billion people live?\",\n    x = NULL,\n    y = NULL\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 80, face = \"bold\", hjust = 0.5),\n    legend.position = \"none\",\n    legend.title = element_text(size = 50, face = \"bold\", family = \"Arial\"),\n    legend.text = element_text(size = 15, family = \"Arial\")\n  )\n\nfinal_plot <- map / legend_bar + plot_layout(heights = c(0.85, 0.15))\n\nfinal_plot\n\n\n\nImprovement\nNow, which were the main problems in the original map? In my opinion, the main problem was that the information gets diluted in the whole map. If the idea is to inform people of which countries represent the biggest percentages of population in the world, it is not important to know where the country is, mainly what´s its population, how big their proportion of the world population is compared to that of other countries, and in which continent they can be found (so we can know which continent is the most populated). So I have decided to create a treemap where you will be able to see all of this information. In this case you will be able to see the total population of each country, not the proportion of the world population they represent, since that information is already provided by the size of their square in the treemap.\n\n\nlibrary(ggplot2)\nlibrary(treemapify)\nlibrary(treemapify)\nlibrary(extrafont)\n\npopulation_data$continent[population_data$continent == \"Central America\"] <- \"South America\"\n\ntreemap <- ggplot(data = population_data,\n       aes(area = population, fill = continent,\n           label = paste0(country, \"\\n\", round(population / 1e6, 1), \"M\"))) +\n  geom_treemap(color = \"black\", size = 1) +\n  geom_treemap_text(fontface = \"bold\", color = \"white\", place = \"center\", grow = TRUE) +\n  scale_fill_manual(values = c(\n    \"Africa\" = \"#FF5733\",\n    \"Asia\" = \"#3498DB\",\n    \"Europe\" = \"#2ECC71\",\n    \"North America\" = \"#9B59B6\",\n    \"South America\" = \"#F1C40F\",\n    \"Oceania\" = \"pink\"\n  )) +\n  theme_minimal() +\n  labs(title = \"Where do 8 billion people live?\",\n       subtitle = \"Population distribution by country and continent\",\n       fill = \"Continent\") +\n  theme(plot.title = element_text(size = 50, face = \"bold\", hjust = 0.5),\n        plot.subtitle = element_text(size = 30, hjust = 0.5),\n        legend.title = element_text(size = 35),\n        legend.text = element_text(size = 35))\n\ntreemap\n\n\n\n\n\n\n",
    "preview": "projects/2024/100432719/100432719_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 9000,
    "preview_height": 6000
  },
  {
    "path": "projects/2024/100535296/",
    "title": "Age Distribution of Athletes by Sport since 1896",
    "description": "This project focuses on recreating a The Washington Post graph showing the olympic athlete distribution by sport and age since the inception of the modern games in 1896.",
    "author": [
      {
        "name": "Irene Bosque-Gala",
        "url": {}
      }
    ],
    "date": "2025-01-15",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nOriginal Graph\nGraph Replication\nDownloading libraries\nCleaning data\nBuilding the Graph\n\nAlternative Graph\n\nOriginal Graph\nThe graph titled “Olympians” was published in 2012 by The Washington Post as part of an interactive feature exploring the history of Summer Olympic athletes since the first modern Games in 1896. The visualization aims to break down athlete participation by sport and age group, offering a comprehensive view of how athlete demographics vary across different disciplines, highlighting patterns and outliers in Olympic history.\nThe visualization organizes sports along the vertical axis, ranging from Archery to Wrestling, while the horizontal axis represents age groups, starting from 10–15 years and increasing gradually. The color gradient is used to indicate the density of athletes within each age group for a specific sport: darker blue shades represent higher participation, while lighter shades indicate smaller numbers.\n\n\n\nFigure 1: Original Graph\n\n\n\nOne of the most notable strengths of the graph is its ability to present a large amount of information in a really compact space, as we can observe up to 32 sports in this relatively small plot. It also gives us a clear and comprehensive view of how age range varies across different disciplines, making it an excellent tool for spotting patterns at a glance. For example, we can quickly identify that sports like Gymnastics and Swimming are dominated by younger athletes, with the majority falling into the 10–20 age range, while sports like Equestrian and Shooting feature older competitors, often in their 40s or beyond.\nWhile the graph effectively captures the overall age range of athletes across different sports, it presents several limitations. For instance, the visualization does not include key statistical measures, such as means or medians, which would provide a clearer understanding of central tendencies within each discipline. Moreover, identifying where the majority of athletes are clustered is not straightforward. This issue is particularly evident in sports with smaller datasets, such as taekwondo, triathlon, and rhythmic gymnastics, and even in sports with larger datasets, trends are difficult to discern, reducing the graph’s ability to highlight meaningful patterns.\nGraph Replication\nDownloading libraries\nThe first step in replicating the graphic was to load the required libraries. These libraries provide essential tools for our data manipulation and visualization.\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(gplots)\nlibrary(ggtext)\nlibrary(ggdist)\nlibrary(glue)\nlibrary(patchwork)\nlibrary(paletteer)\nlibrary(showtext)\nlibrary(extrafont)\n\n\nCleaning data\nThe original dataset, sourced from Kaggle, contains a wealth of detailed information about Olympic athletes, including their names, sports, birth years, ages, genders, nationalities, weights, and heights among others. This extensive dataset encompasses all athletes who have competed in the Olympic Games from 1896 to 2016. For the replication, we began by uploading the dataset, removing unnecessary columns and handling missing values from the main variable:\n\n\nolympics3 <- read_csv(\"athlete_events1.csv\")\n\n\n\n\ndata <- olympics3 |> \n  select(Age, Sport) |> \n  drop_na(Age)\n\n\nOnce the dataset was loaded, we observed that it contained a significantly larger number of sports than those present in the original graph. To address this, we applied a filter using the filter function from the tidyverse package, ensuring that only the sports featured in the original graph were retained in the dataset.\n\n\ndata_filtered <- data |> \n  filter(Sport==\"Archery\" | Sport==\"Athletics\" | Sport==\"Badminton\" | Sport==\"Basketball\" |\n           Sport==\"Beach Volleyball\"| Sport==\"Boxing\"|Sport==\"Canooing\"|\n           Sport==\"Cycling\"|Sport==\"Diving\"|Sport==\"Equestrianism\"|\n           Sport==\"Fencing\"|Sport==\"Football\"|Sport==\"Artistic Gymnsatics\"|\n           Sport==\"Handball\"|Sport==\"Hockey\"|Sport==\"Judo\"|\n           Sport==\"Modern Pentathlon\"|Sport==\"Rhythmic Gymnastics\"|Sport==\"Rowing\"|\n           Sport==\"Sailing\"|Sport==\"Shooting\"|Sport==\"Swimming\"|\n           Sport==\"Table Tenis\"|Sport==\"Taekwondo\"|Sport==\"Tennis\"|Sport==\"Trampoling\"|\n           Sport==\"Triathlon\"|Sport==\"Volleyball\"|Sport==\"Water Polo\"|Sport==\"Weightlifting\"|\n           Sport==\"Wrestling\"|Sport==\"Table Tennis\"|Sport==\"Canoeing\"|Sport==\"Volleyball\"|\n           Sport==\"Gymnastics\"|Sport==\"Synchronized Swimming\"| Sport==\"Trampolining\")\n\n\nTo analyze the distribution of athletes by age and sport, we first needed to count how many athletes of each age participated in each sport. To do this, we used the count() function, which allowed us to create a dataset showing the count of athletes of a specific age in each sport. After obtaining these counts, we then categorized the data. This was accomplished using the case_when() function, which allowed us to group the results into the same categories as those in the original visualization.\n\n\ndata_counts <- data_filtered |> \n  count(Sport, Age) |>         \n  rename(Count = n) \n\ndata_counts <- data_counts %>%\n  mutate(grouped_count = case_when((Count>=1) & (Count<5) ~ \"1-5\",\n         (Count>=5) & (Count<30) ~ \"<30\",\n         (Count>=30) & (Count<60) ~ \"<60\",\n         (Count>=60) & (Count<90) ~ \"<90\",\n         (Count>=90) & (Count<120) ~ \"<120\", \n         (Count>=120) & (Count<150) ~ \"<150\",\n         (Count>=150) & (Count<400) ~ \"<400\",\n         (Count>=400) ~ \"400 or higher\"))\n\ndata_counts$Age <- as.numeric (data_counts$Age)\n\n\nNext, we renamed the sports to match the terminology used in the original graph, as “Rhythmic Gymnastics” and “Synchronized Swimming” were written differently. Following this, we ordered the sports alphabetically, from A to Z, in accordance with the structure of the original graph.\n\n\n#Rythmic gymnastics into Rythimc Gym.\n\ndata_counts <- data_counts |> \n  mutate(Sport = ifelse(Sport == \"Rhythmic Gymnastics\", \"Rhythmic Gym.\", Sport))\n\n# Synchronized Swimming into Sync. Swimming\n\ndata_counts <- data_counts |> \n  mutate(Sport = ifelse(Sport == \"Synchronized Swimming\", \"Sync. Swimming\", Sport))\n\n#Ordering sports alphabetically\n\ndata_counts <- data_counts |> \n  arrange(Sport) |> \n  mutate(Sport = factor(Sport, levels = rev(sort(unique(Sport)))))\n\n\nFinally, we create a new table using summarise to calculate the minimum and maximum ages for each sport in order to be able to add this information more easily to the graph later. Afterward, we merged this table with the original one using left_join.\n\n\nage_extremes <- data_counts |> \n  group_by(Sport) |> \n  summarise(min_age = min(Age, na.rm = TRUE), \n            max_age = max(Age, na.rm = TRUE)) |> \n  ungroup() \n\ndata_counts <- data_counts |> \n  left_join(age_extremes, by = \"Sport\")\n\n\nBuilding the Graph\nOnce the dataset was cleaned and prepared, we moved on to the process of replicating the graph. To ensure the final output closely resembled the original, we began by downloading the necessary resources, particularly the fonts used in the visualization.\nFonts\nIn order to replicate the font styles of the original graph, we focused on matching all the fonts displayed, which we identified through The Washington Post’s design system page. This resource provides details on the fonts they use, including their size, weight, and height specifications for articles: https://build.washingtonpost.com/foundations/typography.\nWe were able to recover all the required fonts, except for the title font, Postoni, which is a paid font. As an alternative, we chose Playfair Display, a similar font.\nTo implement these fonts in the graph, we used the showtext package, which allows for text rendering using fonts downloaded from Google Fonts, such as Libre Franklin, the font selected for annotations. We used Playfair Display for the title, subtitle, and caption, while Roboto was chosen for the numbers indicating the maximum and minimum ages of athletes in each sport.\n\n\nfont_add_google(\"Libre Franklin\", \"franklin\")\nshowtext_auto() \nfont_add_google(\"Roboto\", \"roboto\")      \nfont_add_google(\"Playfair Display\", \"playfair\")\n\n\nTheme\nI believe that the most important and complex part of creating the graph was defining the theme. This particular graph is highly intricate, containing numerous elements and details that must be precisely arranged. As a result, I had to carefully adjust not only the annotations but also the axis titles, legend titles, legend colors, spacing between the elements, text sizes, and more. Once the theme was successfully applied, it immediately brought the graph closer to its final design, demonstrating just how crucial the theme is in shaping its overall aesthetic and coherence. This is why the graph appears so similar to the original from the very beginning, as in this final version the theme is applied since the first steps.\nSome of the functions that help achieve this level of precision include starting with theme_minimal(base_size = 7) to establish a minimalist base with small text. The primary and secondary grids are removed using element_blank(), and panel.background sets a light gray background (gray97) with no borders (color = NA). The axis texts are customized in black, with adjusted sizes and very specific margins to replicate the original design. The legend is configured with legend.position to place it at the top of the graph, and legend.justification to fine-tune its exact position. The legend texts are personalized using legend.title and legend.text, with small sizes and precise margins. Additionally, legend.key.size reduces the size of the legend keys to 0.1 cm, creating a more compact design.\nProportions also played a crucial role in accurately representing this graph. For every version of the graph, the specification {r, fig.width=4, fig.height=6, out.width=“100%”} was added to each chunk, ensuring consistent sizing across all iterations. Additionally, coord_fixed(ratio=1.5) was used to adjust the aspect ratio between the X and Y axes. This ratio means that 1 unit on the Y-axis corresponds to 1.5 units on the X-axis, resulting in a Y-axis that appears more elongated and less compact than the X-axis. This adjustments were crucial for achieving the correct visual proportions and ensuring that the graph closely aligned with the original design.\n\n\ntheme <- theme_minimal(base_size = 7) +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"gray97\", color = NA),\n    axis.text.x = element_text(color = \"black\", angle = 0, hjust = 0.7, size = 7),\n    axis.text.y = element_text(color = \"black\", size = 7.3, margin = margin(r = 3)),\n    plot.title = element_text(family = \"playfair\", size = 25, face = \"bold\", hjust = 0.05, vjust = 0, color = \"black\"),\n    plot.subtitle = element_text(family = \"roboto\", size = 8, face = \"bold\", color = \"gray60\", hjust = 0.05, vjust = -5, margin = margin(b = 15)),\n    plot.caption = element_text(\n      family = \"playfair\", size = 7.5, hjust = 0, vjust = 285, margin = margin(t = 0, l= 100), color = \"gray60\", lineheight = 0.5\n    ),\n    legend.position = \"top\",\n    legend.justification = c(0,1.2),\n    legend.title = element_text(size = 7.5, face = \"bold\"),\n    legend.text = element_text(size = 7, margin = margin(l = 1, r = 0)),\n    plot.caption.position = \"panel\",\n    legend.key.size = unit(0.1, \"cm\"),\n    axis.title.x = element_blank(),\n    axis.title.y = element_text(\n      size = 6.5,\n      angle = 0,\n      hjust = -24,\n      vjust = 1.035,\n      face = \"bold\"),\n    plot.margin = margin(t = 20, r = 20, b = 20, l = 0))\n\n\nGraph\nOnce the theme was defined, we proceeded to create the base of the graph using the geom_tile function, which generates a mosaic plot. The aes(x = Age, y = Sport, fill = grouped_count) function maps ages to the X-axis, sports to the Y-axis, and the group size to the color of the tiles. To refine the color palette, we applied the scale_fill_manual function, carefully selecting the colors using the online tool imagecolorpicker.com.\nThe limits argument ensures that the legend displays the categories in a specific order, from “1-5” to “400 or higher”, while the labels argument customizes the labels in the legend to clearly describe the range of athletes in each group. Additionally, we set a clear title for the legend using the name parameter and arranged the legend in a single row with guide_legend(nrow = 1).\n\n\np <- ggplot(data_counts, aes(x = Age, y = Sport, fill = grouped_count)) + \n  geom_tile(size = 0) +\n  scale_fill_manual(\n    values = c(\n      \"1-5\" = \"#ddeaf9\",\n      \"<30\" = \"#c4dbf1\",\n      \"<60\" = \"#9fcae2\",\n      \"<90\" = \"#6cadd4\",\n      \"<120\" = \"#4193c3\",\n      \"<150\" = \"#2372b5\",\n      \"<400\" = \"#08519d\",\n      \"400 or higher\" = \"#083069\"\n    ), \n    labels = c(\n      \"1-5\" = \"1-5 athletes\",\n      \"<30\" = \"<30\",\n      \"<60\" = \"<60\",\n      \"<90\" = \"<90\",\n      \"<120\" = \"<120\",\n      \"<150\" = \"<150\",\n      \"<400\" = \"<400\",\n      \"400 or higher\" = \"400 or higher\"\n    ),\n    limits = c(\"1-5\", \"<30\", \"<60\", \"<90\", \"<120\", \"<150\", \"<400\", \"400 or higher\"),\n    name = \"Total athletes in each age group:\",\n    guide = guide_legend(nrow = 1)\n  ) + theme +\n  coord_fixed(ratio = 1.5)\n\np\n\n\n\nNext, we customized the graph’s axes. For the X-axis, we used scale_x_continuous to position it at the top of the graph. This function also defines a range between 10 and 73, sets tick marks at intervals of 5, and customizes the labels to display “10YRS” only for the value 10, while showing the other values as standard numbers. For the Y-axis, we applied scale_y_discrete to remove unnecessary space before and after the categories (using expand = c(0, 0)), ensuring that the graph elements fit directly within the drawing area. After adjusting the axes, we added the title, subtitle, and caption (which will appear as the description in the top-right corner of the graph) using the labs function.\n\n\np <- p + \n  scale_x_continuous(\n    position = \"top\",\n    limits = c(10, 73),\n    breaks = seq(10, 70, by = 5),\n    labels = function(x) ifelse(x == 10, \"10YRS\", as.character(x))\n  ) +\n  scale_y_discrete(expand = c(0, 0)) +\n  labs(\n    title = \"Olympians\",\n    subtitle = \"By age, sport, country, and sex\",\n    y = \"BY SPORT\",\n    caption = \"Explore a Washington Post breakdown of all Summer Olympics\\n athletes who have competed since the first modern Games in 1896.\\n See the expansive rang in age of the competitors, and when men\\n and women first competed in each sport.\"\n    )  \n  \n\np\n\n\n\nIn the next step, we used the geom_hline() function to add a white line to the graph, separating the sport categories. We position the line just below each category by converting the values of the Sport variable to numeric format and adjusting them by 0.5.\n\n\np <- p +\n  geom_hline(\n    aes(yintercept = as.numeric(Sport) - 0.5),\n    color = \"white\",\n    size = 0.3\n  )\n\np\n\n\n\nNext, we added the maximum and minimum age for each sport by using the variables max_age and min_age, which we created earlier. These values are then displayed on the graph using geom_text(), positioning the text labels accordingly.\n\n\np <- p + geom_text(\n    aes(x = min_age, y = Sport, label = min_age),\n    size = 2.5,\n    hjust = 1.1,\n    color = \"gray40\",\n    family = \"roboto\"\n  ) +\n  geom_text(\n    aes(x = max_age, y = Sport, label = max_age),\n    size = 2.5,\n    hjust = -0.1,\n    color = \"gray40\",\n    family = \"roboto\")\n\np\n\n\n\nFinally, we add the annotations and the lines that connect the data points to these annotations. To create the L-shaped arrows, we combine two geom_segment() functions, one vertical and one horizontal, and position them on the plot to form this shape. Next, we add the three annotations visible in the graph using annotate(), specifying the exact location within the plot, as well as the size, color, font, and line spacing (with lineheight).\n\n\np <- p + \n  geom_segment(\n    aes(x = 72.5, xend = 73, y = 29 , yend = 29),  \n    color = \"gray60\", size = 0.04\n  ) +\n  geom_segment(\n    aes(x = 73, xend = 73, y = 24, yend = 29),  \n    color = \"gray60\", size = 0.04\n  ) +\nannotate(\n  \"text\",\n  x = 62, y = 28,\n  label = \"Arthur von Pongracz\\nof Austria, competed in\\nindividual and team\\ndressage. At 72\\nPongracz placed fourth\\nin team and 16th in\\nindividual.\",\n  hjust = 0,\n  size = 2.1,\n  color = \"gray30\", \n  family = \"franklin\",\n  lineheight = 0.5) +\n  geom_segment(\n    aes(x = 50, xend = 59, y = 20.5, yend = 20.5),\n    color = \"gray60\", size = 0.04\n  ) +\n  annotate(\n    \"text\",\n    x = 60, y = 18.5, \n    label = \"At age 10, Dimitrios \\nLoundras of Greece, won\\nbronze in the 1896 men's\\nteam parallel bars. Jan de\\nBoer of Netherlands, then 49\\nyears old, competed in the\\n1908 men's team all-around.\",\n    hjust = 0,\n    size = 2.1,\n    color = \"gray30\",\n    family = \"franklin\",\n    lineheight = 0.5) +\n  geom_segment(\n    aes(x = 72.5, xend = 73, y = 6, yend = 6),  \n    color = \"gray60\", size = 0.04\n  ) +\n  geom_segment(\n    aes(x = 73, xend = 73, y = 6, yend = 11),  \n    color = \"gray60\", size = 0.04\n  ) +\n  annotate(\n    \"text\",\n    x = 62, y = 6,  \n    label = \"Oscar Swahn of\\nSweden, set the first\\nOlympic record in\\nmen's single shot\\nrunning target in 1908,\\nat age 60. He is also\\nthe oldest gold\\nmedalist in an\\nindividual Olympic\\nevent.\",\n    hjust = 0,\n    size = 2.1,\n    color = \"gray30\",\n    family = \"franklin\",\n    lineheight = 0.5\n  ) \n\np\n\n\n\nWith all adjustments and customizations in place, we now have the final version of the replicated graph, which closely mirrors the original in both design and structure. While this concludes the replication process, the next step will involve creating an alternative graph that enhances the original design and offers new insights.\nAlternative Graph\nBuilding on the replication, the alternative version was developed to address some of the limitations of the original visualization. This new graph aims to provide a more detailed and accurate representation of the data by including important statistical measures, such as the mean and median, and enhancing the depiction of distributions. To achieve this, we decided to create a ridgeline plot with an additional inner plot as a legend to improve interpretability and clarity.\nWe began by cleaning the data once again, with some adjustments to the order of sports based on more meaningful criteria. We decided to arrange the sports according to the median age of athletes in each sport. This approach allowed us to clearly identify which sports accommodate a broader range of ages and which are more concentrated with younger athletes. To achieve this, we used the reorder() function, specifying FUN = median to sort the sports by median age, and -Age to ensure they were ordered from the youngest to the oldest.\n\n\nolympics3 <- read_csv(\"athlete_events1.csv\")\n\nolympics <- olympics3 |> \n  select(Age, Sport) |> \n  drop_na(Age, Sport)\n\nolympics <- olympics |> \n  filter(Sport==\"Archery\" | Sport==\"Athletics\" | Sport==\"Badminton\" | Sport==\"Basketball\" |\n           Sport==\"Beach Volleyball\"| Sport==\"Boxing\"|Sport==\"Canooing\"|\n           Sport==\"Cycling\"|Sport==\"Diving\"|Sport==\"Equestrianism\"|\n           Sport==\"Fencing\"|Sport==\"Football\"|Sport==\"Artistic Gymnsatics\"|\n           Sport==\"Handball\"|Sport==\"Hockey\"|Sport==\"Judo\"|\n           Sport==\"Modern Pentathlon\"|Sport==\"Rhythmic Gymnastics\"|Sport==\"Rowing\"|\n           Sport==\"Sailing\"|Sport==\"Shooting\"|Sport==\"Swimming\"|\n           Sport==\"Table Tenis\"|Sport==\"Taekwondo\"|Sport==\"Tennis\"|Sport==\"Trampoling\"|\n           Sport==\"Triathlon\"|Sport==\"Volleyball\"|Sport==\"Water Polo\"|Sport==\"Weightlifting\"|\n           Sport==\"Wrestling\"|Sport==\"Table Tennis\"|Sport==\"Canoeing\"|Sport==\"Volleyball\"|\n           Sport==\"Gymnastics\"|Sport==\"Synchronized Swimming\"| Sport==\"Trampolining\")\n\nolympics$Age <- as.numeric (olympics$Age)\n\n#Rythmic gymnastics into Rythimc Gym.\n\nolympics <- olympics|> \n  mutate(Sport = ifelse(Sport == \"Rhythmic Gymnastics\", \"Rhythmic Gym.\", Sport))\n\n# Synchronized Swimming into Sync. Swimming\n\nolympics <- olympics |> \n  mutate(Sport = ifelse(Sport == \"Synchronized Swimming\", \"Sync. Swimming\", Sport))\n\n#To order the y axes by the median\n\nolympics <- olympics |> \n  mutate(Sport = reorder(Sport, -Age, FUN = median, na.rm = TRUE))\n\n\nNext, and continuing with the data preparation for the alternative graph, we generated additional variables that will be useful for creating the graph. To identify outliers, we calculated the IQR for each sport to determine the lower and upper boundaries. We then filtered out any values falling outside these limits and merged this information back into the main dataset. This step will be useful when overlaying the outliers on the main plot using geom_point(). Additionally, we calculated and stored the median age for each sport within the dataset, which allowed us to add a dashed line to the plot, facilitating easier comparisons between sports.\n\n\n#Calculate the outliers\noutliers <- olympics |> \n  group_by(Sport) |> \n  summarise(\n    Q1 = quantile(Age, 0.25, na.rm = TRUE),\n    Q3 = quantile(Age, 0.75, na.rm = TRUE),\n    IQR = Q3 - Q1\n  ) |> \n  mutate(\n    lower_limit = Q1 - 3 * IQR,\n    upper_limit = Q3 + 3 * IQR\n  ) |> \n  select(Sport, lower_limit, upper_limit)\n\n# Join the outliers to the dataset\nolympics_outliers <- olympics |> \n  left_join(outliers, by = \"Sport\") |> \n  mutate(is_outlier = Age < lower_limit | Age > upper_limit) |> \n  filter(is_outlier)  \n\n#Create the median age\n\nmedian_age <- median(olympics3$Age, na.rm = TRUE)\n\n\nAfter reprocessing the data, we moved on to creating the graph, starting with the base without the legend. To achieve this, we designed a ridgeline plot using stat_halfeye() and stat_interval() from the ggdist package, which provided a clear view of the distribution of ages across sports. The median age was marked with stat_summary(), and the average age was indicated through an annotation. Additionally, we added a dashed line to mark the median age and used geom_point() to highlight the outliers with the new variables created earlier. Customizations like flipping the coordinates, adjusting axis breaks, and using a similar color scheme as the original graphic helped refine the presentation, making it visually appealing and easy to interpret.\n\n\np <- ggplot(olympics, aes(Sport, Age)) +\n  stat_halfeye(fill_type = \"segments\", alpha = 0.8, scale = 0.9) +\n  stat_interval() +\n  stat_summary(geom = \"point\", fun = median, color = \"black\", size = 3) +\n  annotate(\"text\", x = 33, y = 0, label = \"(\\U00F8 age)\",\n           family = \"franklin\", size = 6.5, hjust = 0.5) +\n  stat_summary(\n    aes(y = Age),\n    geom = \"text\",\n    fun.data = function(x) {\n      data.frame(\n        y = 0,\n        label = sprintf(\"(%s)\", scales::number(mean(ifelse(x > 0, x, NA), na.rm = TRUE), accuracy = 0.1)))},\n    family = \"franklin\", size = 6\n  ) +\n  geom_hline(yintercept = median_age, col = \"black\", lty = \"dashed\") +\n  annotate(\"text\", x = 33.3, y = 25, label = \"Median age\",\n           family = \"franklin\", size = 8, hjust = 0) +\n  geom_point(data = olympics_outliers, aes(x = Sport, y = Age),\n             size = 1, shape = 19) + \n  scale_y_continuous(breaks = seq(10, 70, by = 10)) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_color_manual(values = c(\"#e7e5cc\", \"#9fcae2\", \"#08519d\")) +\n  coord_flip(ylim = c(0, 80), xlim = c(0, 33.5), expand = TRUE) +\n  guides(col = \"none\") +\n  labs(\n    title = \"OLYMPICS\",\n    subtitle = \"by age and sport\",\n    x = NULL,\n    y = NULL) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    panel.grid.major.x = element_line(linewidth = 0.1, color = \"grey75\"),\n    plot.title = element_text(family = \"Georgia\", size = 45, margin = margin (b = 5)),\n    plot.title.position = \"plot\",\n    plot.subtitle = element_textbox_simple(size = 40, family = \"Georgia\", color = \"gray40\", margin = margin (b = 20)),\n    plot.caption.position = \"plot\",\n    axis.text.y = element_text(hjust = 1, family = \"franklin\", size = 25, color = \"black\", face = \"bold\"),\n    axis.text.x = element_text(size = 25, family = \"franklin\", margin = margin(r = 0), color = \"black\"),\n    plot.margin = margin(4, 17, 4, 4))\n\np\n\n\n\nTo create the legend, we constructed a separate plot focused on a specific sport—volleyball in this case. In this plot, we used annotate() to label specific age ranges, such as the 50%, 80%, and 95% percentiles of ages, as well as to highlight the median and overall age distribution. To make the annotations more intuitive and visually connected to the relevant features on the plot, we employed geom_curve(), which draws curved arrows pointing directly to each annotation.\n\n\ndf_for_legend <- olympics |>  \n  filter(Sport == \"Volleyball\") \n\np_legend <- df_for_legend |>  \n  ggplot(aes(Sport, Age)) +\n  stat_halfeye(fill_type = \"segments\", alpha = 0.8, scale = 0.6) +  \n  stat_interval() +\n  stat_summary(geom = \"point\", fun = median, size = 3) +\n  annotate(\n    \"text\",\n    x = c(0.65, 0.65, 0.65, 1.34, 1.6),\n    y = c(21 , 29, 36, 27, 33),\n    label = c(\"50% of ages\\nfall within this range\", \"80% of ages\", \n              \"95% of ages\", \"Median\", \"Distribution\\n of ages\"),\n    fill = NA, family = \"Arial\", size = 5.8, vjust = 1, lineheight = 0.5  \n  ) +\n  geom_curve(\n    data = data.frame(\n      x = c(0.7, 0.7, 0.7, 1.225, 1.4),\n      xend = c(0.98, 0.98, 0.98, 1.02, 1.5),\n      y = c(24, 30, 33, 26, 28),\n      yend = c(24, 30, 33, 25, 30)),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    stat = \"unique\", curvature = 0.2, size = 0.6, color = \"grey12\",\n    arrow = arrow(angle = 20, length = unit(1, \"mm\"))\n  ) +\n  scale_color_manual(values = c(\"#e7e5cc\", \"#9fcae2\", \"#08519d\")) +\n  coord_flip(expand = TRUE) +\n  guides(color = \"none\") +\n    theme_void() +\n  theme(plot.background = element_rect(color = \"black\", fill = \"grey95\"),\n        plot.margin = margin(t = -0.5, r = 0, b = 0, l = 0, unit = \"cm\"))\n\np_legend\n\n\n\nFinally, we combined the original plot with the plot legend by using inset_element():\n\n\np + \n  inset_element(p_legend, \n                left = 0.58, \n                right = 1, \n                top = 0.95, \n                bottom = 0.85)\n\n\n\nThis alternative graph provides a more detailed and clearer view of where most athletes are concentrated, thanks to the enhanced distribution representation. By highlighting key statistical measures, such as the mean and median, and comparing them to the overall mean across all Olympic disciplines, it provides a deeper understanding of how each sport deviates from the general trend.\nIn conclusion, this article has walked through the process of replicating and then improving an Olympic athletes’ age distribution graph. This exercise highlights not only the importance of thoughtful data visualization but also the intrinsic complexity of the process. What might seem like a simple graph often requires significant effort to align every element precisely as intended. This process also demonstrates how iterative improvements not only refine the visual representation but can greatly enhance both interpretability and usefulness.\n\n\n\n",
    "preview": "projects/2024/100535296/100535296_files/figure-html5/unnamed-chunk-15-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 768,
    "preview_height": 710
  },
  {
    "path": "projects/2024/100535255/",
    "title": "Degrees and Nobels: A non-essential link",
    "description": "A comprehensive look at Nobel Prizes from 1901 to 2012, uncovering patterns \nin laureates ages, trends across categories, educational qualifications, academic \naffiliations and hometown demographics.",
    "author": [
      {
        "name": "Andrea Rivera-Mateos",
        "url": {}
      }
    ],
    "date": "2025-01-14",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nSetting the stage\nGetting started\nLibraries\nSome aesthetics\nData reconstruction\n\nReverse engineering\nShifting ages | Connected scatter plot\nFrom dropouts to Phd | Barplot\nBack to the roots | Stacked barplot\nHubs of excellence | Sankey diagram\nGraphical Symbiosis - final result\n\nBeyond the mirror\nVisual Glossary\nHeadline\nStrengthening Women’s Presence\nChronicle of data - final plot\n\n\nSetting the stage\nThe Nobel Prizes, awarded annually since 1901, honor extraordinary achievements in various fields, including Physics, Chemistry, Medicine, Literature, Peace, and Economic Sciences. These prestigious awards not only celebrate groundbreaking contributions but also reveal fascinating patterns and stories about the individuals who have shaped human progress.\nThis visualization delves into the journey of Nobel laureates over time, capturing the diversity of achievements and backgrounds that define these awards. It highlights trends in age at the time of recognition, the global origins and affiliations of the winners, and how different categories have evolved through the years. By examining these elements, the visualization provides a deeper understanding of the context in which these honors were awarded, the historical moments they reflect, and the enduring impact of the laureates’ work.\nThe decision to explore this graph was inspired by the intricate narratives it weaves, capturing the interplay of time, remarkable achievements, and the diverse tapestry of humanity. Through its depiction of Nobel laureates, the visualization illuminates the historical and personal contexts behind these prestigious awards, offering a window into the evolving legacy of innovation and excellence. It invites reflection on the profound stories hidden within the data, highlighting how visual exploration can bring to life the enduring impact of these extraordinary individuals.\nFor this visualization, Georgia Lupi, author of the original graph, took her inspiration from musical scores and their elegant aesthetics, especially John Cage’s source of fascinating contemporary scores. She visualized the evolution over time of the 6 prize categories, as colored musical scores along a skewed timeline.\nNobels, no degrees by Georgia Lupi for La Lettura, Corriere della Sera. (Nov 25, 2012)Getting started\nLibraries\nThis project utilizes a suite of libraries in R Studio to enable effective data manipulation and the creation of visually compelling graphs. These tools, including core visualization and supplementary packages, streamline workflows and enhance graphical outputs. Combining these libraries ensures a powerful and flexible approach to data visualization.\n\n\npackages = c(\"tidyverse\", \"readr\",\"dplyr\", \"ggplot2\", \"ggthemes\", \"ggforce\", \n             \"forcats\", \"ggtext\", \"patchwork\", \"ggalluvial\")\n\npackage.check <- lapply(packages,\n                        FUN = function(x){\n                          if (!require(x,character.only = TRUE)){\n                            install.packages(x,dependencies = TRUE)\n                            library(x, character.only = TRUE)}})\n\n\nSome aesthetics\nAdditionally, the project incorporates carefully chosen fonts to complement the visualizations and enhance their aesthetic appeal. The selection of fonts ensures readability, consistency, and a professional finish, aligning with the overall design of the original graph.\n\n\nsysfonts::font_add_google(\"Tinos\", family=\"tinos\") # for text\nsysfonts::font_add_google(\"Gelasio\", family=\"gl\") #for numbers\nsysfonts::font_add_google(\"EB Garamond\", family=\"ebg\") #for the final title\nshowtext::showtext_auto()\n\n\nFurthermore, we defined a vector (colors) mapping each category to a unique hex color code to differentiate the categories visually.\n\n\ncolors <- c (\n  \"Chemistry\" = \"#C04C3D\", \n  \"Economic Sciences\" = \"#3F7383\", \n  \"Physics\" = \"#84AC6A\", \n  \"Literature\" = \"#B8963F\", \n  \"Physiology or Medicine\" = \"#7F3E48\", \n  \"Peace\" = \"#D47156\")\n\n\nData reconstruction\nObtaining the necessary data for this project posed significant challenges, as the original graph was published in a print newspaper and the sources employed in its creation were unknown. This lack of accessible and verifiable data required extensive effort to approximate and reconstruct the visualizations accurately. Nevertheless, we were able to identify a data set on Kaggle, a platform for data science and machine learning, containing most of the information needed.\nThe data set primarily consists of the years since the first Prize was awarded, the names of the laureates, their birth dates, hometowns, university affiliations, and other relevant information. However, it lacked information regarding the academic backgrounds of the laureates. This was subsequently obtained through a manual search, primarily referencing the biographies available on the official Nobel Prize website. In instances where such information was unavailable, alternative sources, including Wikipedia and the official websites of the relevant universities, were consulted.\nOnce the data was gathered, we moved forward with its processing. Given that the chart spans from 1901 to 2012, we focused on the data for these years. Although some laureates have been organizations, we decided to exclude these entries, as their inclusion would result in outlier values. We then selected the necessary variables to reproduce the graph accurately.\n\n\nnobels <- read_delim(\"nobel_laureates.csv\", delim = \";\")\n\ntidy_nobels <- nobels |> \n  filter(awardYear >= 1901 & awardYear <= 2012) |> \n  filter(ind_or_org == \"Individual\") |> \n  select(awardYear,category,dateAwarded,name ,gender, birth_date, birth_cityNow, \n         academic_degree, affiliation_1_bis, affiliation_1)\n\n\nOnce the data is selected, we will create a vector (cat) listing the six Nobel Prize categories. These will serve as a reference throughout the code. Then, using the factor category_labels we defined the same categories with their order explicitly specified. The tidy_nobels data frame’s category column is then coerced into a factor using the predefined cat vector. This ensures that the column values are treated as ordered categories, allowing logical sequencing in any resulting output.\n\n\ncat <- c (\"Chemistry\", \"Economic Sciences\", \"Physics\", \"Literature\",\n          \"Physiology or Medicine\", \"Peace\") \n\ncategory_labels <- factor(\n  c(\"Chemistry\", \"Economic Sciences\", \"Physics\", \"Literature\", \n    \"Physiology or Medicine\", \"Peace\"),\n  levels = c(\"Chemistry\", \"Economic Sciences\", \"Physics\", \"Literature\", \n             \"Physiology or Medicine\", \"Peace\"))\n\ntidy_nobels$category <- factor(tidy_nobels$category, levels = cat)\n\n\nReverse engineering\nShifting ages | Connected scatter plot\nThis initial representation is the most significant in the graph, showcasing a connected scatter plot where each dot represents a Nobel Laureate, positioned based on the year the prize was awarded and the Laureate’s age at the time. In other words, the display identifies the year of the prize on the x-axis, the winners’ ages on the y-axis.\nThe visualization highlights age trends within each category, offering a clear perspective on how these patterns evolve. Additionally, the plot provides indicators for the average age within each discipline and across all Laureates. Double-rounded dots are used to distinctly represent women, adding another layer of meaningful insight to the data.\nTo replicate this plot, we will need to, first, compute the age of each Laureate at the time of their award. For this action, we ensure that the birth_date variable is a date object for date-based calculations. Then, we create a new variable (age) by calculating the difference between the year the prize was awarded (awardYear) and the Laureate’s year of birth, extracted from the birth_date column.\n\n\ntidy_nobels <- tidy_nobels |>\n  mutate(birth_date = as.Date(birth_date, format = \"%Y-%m-%d\")) |> \n  mutate(age = awardYear - as.numeric(format(birth_date, \"%Y\")))\n\n\nNext, we calculate the average age of Laureates for each category. The data is grouped by category, and the mean age is calculated within each group, ignoring any missing values. The resulting average age is rounded to the nearest whole number, and the grouping structure is removed to produce a simplified data frame.\n\n\navg_age <- tidy_nobels |> \n  group_by(category) |> \n  summarise(avg_age = round(mean(age, na.rm = TRUE))) |>\n  ungroup()\n\n\nAs mention before, for each Nobel Prize category, the average age of the Laureates is visually represented with a horizontal line. The individual ages of the Laureates are shown as scatter points, connected by lines within each category to highlight trends over time. Female Laureates are specifically highlighted with distinct double-rounded markers, making them easy to identify within the plot.\nTo replicate this graph, we need to divide it into six distinct subplots, each corresponding to a specific category. This can be achieved using the facet_grid function, which enables the visualization of subsets of data within a single graph. By organizing the data in this way, we can facilitate a clearer and more effective comparison between categories.\nMoreover, to have complete control over each of the elements of the graph, we will draw each of the components of the image: vertical reference lines in a 5-year interval helping the viewer navigate through time; horizontal grid lines at y-values representing different age benchmarks; dashed black line indicating the overall average age of all Laureates, etc. For this, we will combine geom_vline - for those vertical lines drawn at specific x-axis values- and annotate -to draw horizontal custom lines allowing us to specify the dimension of our lines- functions.\nAs mentioned earlier, the plot is created entirely from scratch.\nBy default, panel.grid.major.x allows us to differentiate between major and minor breaks within the plot. However, when adding the correspondent label to these breaks, it is not possible to add them to minor breaks. To achieve this, we construct different data frames each containing a set of years along with corresponding y-values. These years represent key milestones that will be annotated on the plot. Since the plot is divided into six subsets, we set “Chemistry” as the reference category to avoid duplicating annotations across the facets. This ensures that the annotations will only appear for the “Chemistry” category, which is positioned at the top of the plot. Additionally, we convert the category variable into a factor with defined levels to ensure the data is treated as a categorical variable with a consistent order.\n\n\n#annotations: minor years\nmin.years_label <- data.frame(\n  x = c(1911, 1921, 1941, 1951, 1971, 1981, 2001),\n  y = 100,\n  label = c(\"1911\", \"1921\", \"1941\", \"1951\", \"1971\", \"1981\", \"2001\"),\n  category = \"Chemistry\")\nmin.years_label$category <- factor(min.years_label$category, \n                                   levels = c(\"Chemistry\", \"Economic Science\", \n                                              \"Physics\", \"Literature\", \n                                              \"Physiology or Medicine\", \"Peace\"))\n\n#annotations: major years\nmaj.years_label <- data.frame(\n  x = c(1901, 1931, 1961, 1991, 2012),\n  y = 100,\n  label = c(\"1901\", \"1931\", \"1961\",\"1991\", \"2012\"),\n  category = \"Chemistry\")\nmaj.years_label$category <- factor(maj.years_label$category, \n                                   levels = c(\"Chemistry\", \"Economic Science\", \n                                              \"Physics\", \"Literature\", \n                                              \"Physiology or Medicine\", \"Peace\"))\n\n\nOn the other hand, similar problems arise with all the labels annotated at the y-axis of the plot. By default, when applying facet_grid , ggplot2 does not allow us to move independently each of the labels. Therefore, we create individual data frames for each of the three components needed on the y-axis: name of the category, average age within each category, and average among all the categories. This customization will allow us to determine manually each of the positions of the labels. We then combine this new information to the avg_age data by category .\n\n\n#annotations: average age among all noble laureates\nlabel_avg_laureate <- data.frame(\n  category = category_labels,\n  label_y = c(69, 56, 69, 59, 64, 60), \n  label_text = c(\"(59 years)\", \"(59 years)\", \"(59 years)\", \"(59 years)\", \n                 \"(59 years)\", \"(59 years)\"))\nlabels_avg_facets <- left_join(avg_age, label_avg_laureate, by = \"category\")\n\n#annotations: average age per category\nlabel_avg_cat <- data.frame(\n  category = category_labels,\n  label_y = c(45, 55, 45, 60, 42, 60), \n  label_text = c(\"57 years\", \"67 years\", \"55 years\", \"64 years\", \"57 years\", \"62 years\"))\nlabels_avg_cat_facets <- left_join(avg_age, label_avg_cat, by = \"category\")\n\n#annotation: name each category\nlabel_cat <- data.frame(\n  category = category_labels,\n  label_y = c(70, 55, 70, 70, 55, 70), \n  label_text = c(\"CHEMISTRY\", \"ECONOMIC\\nSCIENCES\", \"PHYSICS\", \"LITERATURE\", \n                 \"PHYSIOLOGY\\nOR MEDICINE\", \"PEACE\"))\n\n\nFor warranting a clear and focused visualization, the plot is designed with specific axis limits and annotation handling. This will help us to highlight the most relevant data points and trends, ensuring that the viewer’s attention is directed where it is most needed. By restricting both axis with coord_cartesian, we ensure that the data points are effectively displayed within a relevant context, without any unnecessary outliers. Additionally, all the text annotations previously created that appear outside the plot area are deliberately not clipped (clip = \"off\"). This design choice ensures that all labels are fully visible even if they extend beyond the plot boundaries. This helps to avoid any truncation or loss of important information,\nHaving built and settled all the essential components, the final code to generate the plot is as follows:\n\n\ngp1 <- ggplot(tidy_nobels,aes(color = category)) +\n  \n  #facet grid: divided plot into facets\n  facet_grid(category ~ ., switch = \"y\") +\n  \n  #grid: minor vertical lines   \n  geom_vline(xintercept = seq(1906, 2010, by = 5), linetype = \"solid\", \n             color = \"#A6A9AC\", linewidth = 0.4,  alpha = 0.5) + \n  \n  #grid: major vertical lines \n  geom_vline(xintercept = 1931, linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.5) +\n  geom_vline(xintercept = 1961, linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.5) +\n  geom_vline(xintercept = 1991, linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.5) +\n  geom_vline(xintercept = 2012, linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.5) +\n  \n  #initial vertical color category line\n  geom_segment(aes(x = 1901, xend = 1901, y = 40, yend = 80, color = category), \n               linewidth =  0.8) +\n  \n  #grid: horizontal lines\n  annotate(\"segment\", x = 1901, xend = 2012, y = 40, yend = 40, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 50, yend = 50, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 60, yend = 60, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 70, yend = 70, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 80, yend = 80, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) +\n  \n  #average lines by category\n  annotate(\"segment\", x = 1901, xend = 2012, \n           y = mean(tidy_nobels$age, na.rm = TRUE), \n           yend = mean(tidy_nobels$age, na.rm = TRUE),\n           color = \"black\", linewidth = 0.3, linetype = \"dashed\") +\n  geom_segment(data = avg_age, aes(x = 1901, xend = 2012, \n                                   y = avg_age, yend = avg_age, \n                                   color = category), linewidth = 0.5) + \n  \n  #scatter points for each age and connections over time\n  geom_point(aes(awardYear, age, color = category), size = 1.5, alpha = 0.8) +\n  geom_line(aes(awardYear, age, color = category), lwd = .2) + \n  \n  #highlighting female laureates\n  geom_point(data = filter(tidy_nobels, gender == \"female\"), \n             aes(x = awardYear, y = age), color = \"#B55F94\", \n             shape = 21, size = 3, stroke = 0.8) +\n  \n  #custom colors\n  scale_color_manual(values = colors) +\n  \n  #text annotations: years\n  geom_text(data = min.years_label, aes(x = x, y = y, label = label), \n            color = \"#7F8082\", size = 3, family = \"gl\", vjust = -1) +\n  geom_text(data = maj.years_label, aes(x = x, y = y, label = label), \n            color = \"#707070\", size = 3, fontface = \"bold\", family = \"gl\", \n            vjust = -1) +\n  \n  #text annotations: average ages per category\n  geom_text(data = labels_avg_facets,\n            aes(x = 1898, y = label_y, label = label_text),\n            hjust = 1, vjust = 1, size = 2.5, color = \"black\", alpha= 0.8, \n            fontface = \"bold\",family = \"gl\") +\n  geom_text(data = labels_avg_cat_facets,\n            aes(x = 1898, y = label_y, label = label_text,fontface = \"bold\", \n                family = \"gl\"), hjust = 1, vjust = -0.8, size = 2.5, color = colors) +\n  \n  #text annotations: category name\n  geom_text(data = label_cat,\n            aes(x = 1898, y = label_y, label = label_text,fontface = \"bold\", \n                family = \"tinos\"), hjust = 1, vjust = -0.8, size = 3, \n            color = colors, lineheight = 0.8) +\n  \n  #styling and theme\n  theme_void() + \n  theme(\n    legend.position = \"none\", \n    panel.grid.major.x = element_blank(), \n    axis.text.y = element_blank(), \n    axis.text.x = element_blank(),\n    strip.text.y = element_blank(),\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA),\n    panel.spacing = unit(0, \"lines\"),\n    plot.margin = margin(10,5,0,0, \"mm\")) + \n  labs(y = \"\", x = \"\") +\n  \n  #axis and plot limits\n  coord_cartesian(xlim = c(1900, 2012), ylim = c(23, 92), \n                  clip = \"off\", expand = 0)\n\ngp1\n\n\n\nFrom dropouts to Phd | Barplot\nThe bars represent the relative percentage of each level of formal education each winner in that category obtained (from Phd to no degrees at all) highlighting how Laureates in Medicine, Physics, or Economic most of the time have a Phd, while the opposite is true for Literature and Peace where most of them don’t even have a degree.\nTo analyze this, we select both categoryand academic_degree variables, isolating missing values for this second one. Data is then grouped by both variables and computed the number of Laureates for each combination. To facilitate meaningful interpretation, the academic_degree variable is transformed into an ordered factor, with levels arranged from “no degree” to “PhD,” reflecting a logical progression of educational attainment.\n\n\neducation <- tidy_nobels |>\n  select(category, academic_degree) |> \n  filter(academic_degree != \"NA\") |> \n  group_by(category, academic_degree) |> \n  summarise(count = n(), .groups = \"drop\") |>  \n  mutate(academic_degree = factor(academic_degree,\n                                  levels = c(\"no degree\", \"bachelor\", \"master\", \n                                             \"PhD\"), ordered = TRUE))\n\n\nAs we did before, we divided the plot into facets, with each category displayed in its own horizontal bar chart. Horizontal grid lines are annotated for each academic level, aiding readability. The bars representing the counts of Laureates are styled with distinct colors corresponding to their categories, using the custom color palette per category previously established. Also, we remove unnecessary elements with a void theme and create custom annotation frames with clasps on either side to add structure. Finally, ggplot2 expects a continuous variable for the y-axis by default, but we are supplying a discrete factor, therefore we add scale_y_discrete to specify that the y-axis uses discrete values.\n\n\ngp2 <- ggplot(education) + \n  \n  #facet grid: divided plot into facets\n  facet_wrap(~category, ncol = 1) + \n  \n  #grid: horizontal lines\n  annotate(\"segment\", x = 0, xend = 140, y = 1, yend = 1, color = \"black\", \n           linewidth = 0.2, alpha = 0.8) +\n  annotate(\"segment\", x = 0, xend = 140, y = 2, yend = 2, color = \"black\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 0, xend = 140, y = 3, yend = 3, color = \"black\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 0, xend = 140, y = 4, yend = 4, color = \"black\", \n           linewidth = 0.2, alpha = 0.8) +\n  \n  #bars for each academic level\n  geom_col(aes(x = count, y = academic_degree, fill = category), alpha = 0.7) +\n  \n  #custom colors\n  scale_fill_manual(values = colors) + \n  \n  #styling and theme\n  theme_void() +\n  labs() + \n  theme(legend.position = \"none\", \n        panel.grid = element_blank(),  \n        axis.text.x = element_blank(), \n        axis.title = element_blank(), \n        plot.background = element_rect(fill = \"#f2ebde\", color = NA),\n        strip.text = element_blank(),\n        panel.spacing = unit(1, \"lines\"),) +\n  \n  #left clasp\n  annotate(\"segment\", x = -5, xend = 5, y = -2, yend = -2, color = \"black\", \n           linewidth = 0.5) +\n  annotate(\"segment\", x = -5, xend = 5, y = 7, yend = 7, color = \"black\", \n           linewidth = 0.5) +\n  annotate(\"segment\", x = -5, xend = -5, y = -2, yend = 7, color = \"black\", \n           linewidth = 0.5) +  \n  \n  #right clasp\n  annotate(\"segment\", x = 140, xend = 145, y = -2, yend = -2, color = \"black\", \n           linewidth = 0.5) +\n  annotate(\"segment\", x = 140, xend = 145, y = 7, yend = 7, color = \"black\", \n           linewidth = 0.5) +\n  annotate(\"segment\", x = 145, xend = 145, y = -2, yend = 7, color = \"black\", \n           linewidth = 0.5) +\n\n  #discrete values in y-axis\n  scale_y_discrete()\n\ngp2\n\n\n\nBack to the roots | Stacked barplot\nThe chart below the main plot represent the most frequent hometowns out of the total, colored by category and aggregated per 30-years period eras. The color within each one corresponds to the prize category. Before plotting, we need to aggregate the data by era and filter the data to the specific cities.\nFirst, we standardize the names of Nobel Laureates’ hometowns that will be part of the final plot for eliminating inconsistencies in the data set that might arise due to minor variations in how city names are recorded. Then, we customize the city order, stored in the city_order vector, to ensure consistent presentation in the visualization.\n\n\ntidy_nobels <- tidy_nobels |> \n  mutate(\n    birth_cityNow = recode(birth_cityNow,\n                           \"Chicago, IL\" = \"Chicago\",\n                           \"Washington, DC\" = \"Washington\",\n                           \"New York\" = \"New York\",\n                           \"Boston, MA\" = \"Boston\",\n                           \"London\" = \"London\",\n                           \"Paris\" = \"Paris\",\n                           \"Munich\" = \"Munich\",\n                           \"Vienna\" = \"Wien\",\n                           \"Budapest\" = \"Budapest\",\n                           \"Moscow\" = \"Moscow\"))\n\n\ncity_order <- c(\"Washington\", \"Munich\", \"Moscow\",\"Budapest\", \"Boston\", \"Berlin\",\n                \"Chicago\", \"Wien\",\"London\",\"Paris\",\"New York\")\n\n\nWhen observing the data in tidy_nobels, we see that New York is divided into two separate observations. For that reason, we combine entries into a unique value using the ifelse function. Then, we count the number of occurrences of each unique birth_cityNow which are sorted in descending order by frequency. Finally, as we only need the top 11 cities, we use the slice_head() function to just keep those unique values.\n\n\ntopcities <- tidy_nobels |> \n  mutate(birth_cityNow = ifelse(birth_cityNow %in% c(\"Brooklyn, NY\", \"New York, NY\"), \n                                \"New York\", birth_cityNow)) |>\n  count(birth_cityNow) |> \n  arrange(desc(n)) |> \n  slice_head(n = 11)  \n\n\nNext, we converted birth_cityNow into a factor with a defined order. This ordering ensures that the cities will be displayed in a predefined sequence (from “Washington” to “New York”) when used in any plots or analyses. The same is done in the dataset for ensuring the correct sequence.\n\n\ntopcities$birth_cityNow <- factor(topcities$birth_cityNow, \n                                  levels = c(\"Washington\", \"Munich\", \"Moscow\",\n                                             \"Budapest\", \"Boston\", \"Berlin\",\n                                             \"Chicago\", \"Wien\",\"London\",\"Paris\",\n                                             \"New York\"))\n\ntopcities <- topcities[order(topcities$birth_cityNow), ]\n\n\nOnce we have the total number of laureates in each city, we will focus on how many there are in each era. For this, we select our original data frame and, as we did before, consolidate the city of New York. The dataset is then filtered to include only the cities from the topcities dataset, ensuring that only the most frequent cities, as identified earlier, are included in the analysis. We then create a new variable (era) containing the four different periods. By grouping the data by birth_cityNow, era, and category, we calculate the number of Nobel Laureates (people_count) for each city within each era and category using the summarise() function. Finally, we order the cities according to the previously defined distribution.\n\n\ntopcities_era <- tidy_nobels |> \n  mutate(birth_cityNow = ifelse(birth_cityNow %in% c(\"Brooklyn, NY\", \"New York, NY\"), \n                                \"New York\", birth_cityNow)) |>\n  filter(birth_cityNow %in% topcities$birth_cityNow) |> \n  mutate(era = case_when(awardYear < 1930 ~ 1901,\n                         awardYear < 1961 ~ 1931,\n                         awardYear < 1991 ~ 1961,\n                         TRUE ~ 1991)) |> \n  group_by(birth_cityNow, era, category) |> \n  summarise(people_count = n(), .groups = \"drop\")\n\ntopcities_era <- topcities_era |> \n  mutate(birth_cityNow = factor(birth_cityNow, levels = city_order))\n\n\nFor creating the stacked barplot, we will need to first determine the specific intervals that we are going to be using. These eras are structured by specifying both the starting and ending years for each period. The era column marks the year the era begins, while the start_year and end_year columns indicate the specific years that define each era’s range. Incrementing the start_year by a couple of years will allow us to create this separated visual effect needed for the replication.\n\n\nera_intervals <- data.frame(\n  era = c(1901, 1931, 1961, 1991),\n  start_year = c(1904, 1934, 1964, 1994),\n  end_year = c(1930, 1960, 1990, 2012))\n\n\nWe now need to join our topcities_era data set with the era_intervals in order to merges the era duration data. To obtaining this duration, we subtract start_year from end_year for each era, providing the length of each historical period in years.\nNext, by grouping the data by each city and the different eras we will create two new variables: one for the total number of Nobel Laureates for each era across all cities, and another that scales the duration of each era computing how much of the era’s total duration should be allocated to each one\n\n\ntopcities_era <- topcities_era |> \n  left_join(era_intervals, by = \"era\") |> \n  mutate(era_duration = end_year - start_year)  \n\ntopcities_era <- topcities_era |> \n  group_by(birth_cityNow, era) |> \n  mutate(\n    total_people_era = sum(people_count), \n    scaled_duration = (people_count / total_people_era) * era_duration)\n\n\nHaving the start and end year, we can define the length of each category for each era and city. In order to do this, we establish a scaling factor (cm_per_unit), corresponding to one unit, that we multiplied for the total count of Laureates. This will indicate how much each city contributes to each era. With this new length, we compute the start position -subtracting the scaled_duration from the cumulative sum to avoiding overlapping- and the end position of each category in the visualization.\n\n\ncm_per_unit <- 0.5\n\ntopcities_era <- topcities_era |> \n  group_by(birth_cityNow, era) |> \n  mutate(\n    scaled_duration = people_count * cm_per_unit,\n    start_year_scaled = start_year + (cumsum(scaled_duration) - scaled_duration),\n    end_year_scaled = start_year_scaled + scaled_duration) |> \n  ungroup()\n\n\nUp to now, we have calculated the total number of Laureates for each city and era, established their scaled duration, and computed their adjusted start and end years. With these processed data, we can start plotting our visualization.\n\n\ngp3 <- ggplot(topcities_era, aes(y = birth_cityNow, color = category)) +\n  \n  #grid: horizontal lines\n  annotate(\"segment\", x = 1901, xend = 2015, y = topcities_era$birth_cityNow, \n           yend = topcities_era$birth_cityNow, \n           color = \"#B5B2AC\" , linewidth = 0.2, alpha = 0.05, linetype = \"dotdash\") +\n  \n  #grid: eras vertical lines \n  geom_vline(xintercept = 1901, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 1931, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 1961, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 1991, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 2012, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n \n  #text annotations: years\n  annotate(\"text\", x = 1901, y = 11, label = \"1901\", size = 3.5, color = \"#707070\", \n           vjust = -4, family = \"gl\", fontface = \"bold\") +\n  annotate(\"text\", x = 1931, y = 11, label = \"1931\", size = 3.5, color = \"#707070\", \n           vjust = -4, family = \"gl\", fontface = \"bold\") +\n  annotate(\"text\", x = 1961, y = 11, label = \"1961\", size = 3.5, color = \"#707070\", \n           vjust = -4, family = \"gl\", fontface = \"bold\") +\n  annotate(\"text\", x = 1991, y = 11, label = \"1991\", size = 3.5, color = \"#707070\", \n           vjust = -4, family = \"gl\", fontface = \"bold\") +\n  annotate(\"text\", x = 2012, y = 11, label = \"2012\", size = 3.5, color = \"#707070\", \n           vjust = -4, family = \"gl\", fontface = \"bold\") +\n  \n  #category segment for each city and era\n  geom_segment(aes(x = start_year_scaled, xend = end_year_scaled, \n                   yend = birth_cityNow), size = 3) +  \n  \n  #styling and theme\n  scale_color_manual(values = colors) +  \n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA)) +\n  \n  #text annotations: total laureates per city in each era\n  geom_text(\n    data = topcities_era |> \n      group_by(birth_cityNow, era) |> \n      filter(end_year_scaled == max(end_year_scaled)) |>  \n      ungroup(),\n    aes(x = end_year_scaled, y = birth_cityNow, label = total_people_era), \n    color = \"#7F8082\", size = 2.5, fontface = \"bold\", hjust = -2,  family = \"gl\", \n    inherit.aes = FALSE) +\n  \n  #text annotations: total laureates per city\n  annotate(\"text\", x = 2012 + 5, y = topcities$birth_cityNow, \n           label =  topcities$n, size = 3, \n           color = \"#7F8082\", vjust = 0.5, hjust = 0,family = \"gl\", fontface = \"bold\") +\n  \n  #text annotations: cities\n  annotate(\"text\", x = 1899, y =  topcities$birth_cityNow,\n           label = city_order, \n           size = 2.5, color = \"black\", alpha = 0.7, vjust = 0.5, hjust = 1, \n           family = \"ebg\", fontface = \"bold.italic\") +\n  \n  #text annotations: legend\n  annotate(\"text\", x = 2012 + 10, y =  10,\n           label =  \"total of \\nlaureate \\nfor each city\", \n           size = 2.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"gl\", fontface = \"bold\") +\n  annotate(\"text\", x = 1888, y =  11,\n           label =  \"principal \\nhometowns \\nof laureates\",\n           size = 2.5, color = \"black\",alpha = 0.8, vjust = 1, hjust = 1, \n           family = \"gl\", fontface = \"bold\") +\n  \n  #axis and plot limits\n  coord_cartesian(xlim = c(1900, 2012), ylim=c(12, 0), clip=\"off\", expand = 0 )\n\n\ngp3\n\n\n\nHubs of excellence | Sankey diagram\nThroughout this Sankey diagram, each of the arcs represents the Laureates’ principal affiliations for each category and their distributions. The visualization shows how Chemistry (red), Physics (green), and Medicine (purple) are spread among the top 7 universities, while Literature and Peace Nobel Laureates (yellow and orange) clearly did not attend those schools.\nThis Sankey diagram was constructed by categorizing Nobel Laureates based on their principal affiliations and grouping the data to highlight the top seven universities: Harvard, MIT, Stanford, Caltech, Columbia, Cambridge, and Berkeley. Since affiliations often appear in varied forms, a crucial step is taken to standardize names. For instance, “Massachusetts Institute of Technology (MIT)” is simplified to “MIT,” and “University of California” becomes “Berkeley,” making the data consistent and easier to interpret. Moreover, to ensure accuracy, we filter out cases where an affiliation is labeled “Berkeley” but doesn’t explicitly mention the institution in its original text. This step ensures that only genuine connections to Berkeley are retained.\nOnce the data is refined, the prize categories and the standardized affiliations are reordered to create the desired structure. Finally, we count the frequency of laureates for each combination of affiliation and prize category removing any incomplete entry leaving a clean dataset.\n\n\nuniv <- tidy_nobels  |> \n  select(category, affiliation_1_bis, affiliation_1) |>\n  \n  #clean and standardized universities names\n  mutate(affiliation_1_bis = case_match(\n    affiliation_1_bis,\n    \"University of California\" ~ \"Berkeley\",\n    \"Harvard University\" ~ \"Harvard\",\n    \"Massachusetts Institute of Technology (MIT)\" ~ \"MIT\",\n    \"Stanford University\" ~ \"Stanford\",\n    \"University of Cambridge\" ~ \"Cambridge\",\n    \"California Institute of Technology (Caltech)\" ~ \"Caltech\",\n    \"Columbia University\" ~ \"Columbia\")) |>\n  \n  #filter California that are not Berkeley\n  filter(!(affiliation_1_bis == \"Berkeley\" & !grepl(\"Berkeley\", affiliation_1))) |>\n  \n  #reorder categories and affiliations\n  mutate(category = fct_relevel(category, \"Chemistry\", \"Economic Sciences\", \n                                \"Physics\", \"Literature\", \"Physiology or Medicine\", \n                                \"Peace\"),\n         affiliation_1_bis = fct_relevel(affiliation_1_bis, \"Harvard\", \"MIT\", \n                                         \"Stanford\", \"Caltech\", \"Columbia\", \n                                         \"Cambridge\", \"Berkeley\")) |>\n  #count frequencies\n  count(category, affiliation_1_bis) |>\n  \n  #remove missing values\n  drop_na()\n\n\nFirst approach - parallel set\nOnce we have the clean data, we need to transform it into a format suitable for creating parallel sets plots. The first step involves reshaping the data with the gather_set_data function. The process takes each observation and organizes the combinations into individual rows representing combinations of categories and affiliations, making it possible to visualize the relationships between these levels. It creates new columns that represent the axis and a unique ID for each flow.\n\n\nuniv_data <- gather_set_data(univ, 1:2) \n\n\nThe reshaped dataset is then used to create the plot with the gplot function, which positions the axes and specifies how to split the data and visualize the flows. Each flow’s width is proportional to the number of laureates in each category-affiliation combination. The geom_parallel_sets function draws the parallel sets on the plot, with the category aesthetic used to color the flows based on the Nobel prize category.\n\n\nggplot(univ_data, \n       aes(x = x, id = id, split = y, value = n)) +\n  geom_parallel_sets(aes(fill = category),\n                    axis.width = 0.05, sep = 0.1) +\n  geom_parallel_sets_axes(axis.width = 0.001, fill = \"black\" , sep = 0.1) +\n  scale_fill_manual(values = colors) +\n  theme_void() +\n  theme(legend.position = \"none\",\n        plot.background = element_rect(fill = \"#f2ebde\", color = NA)) \n\n\n\nHowever, while geom_parallel_sets is useful, it offers limited flexibility for our specific needs: the separation parameter affects all categories equally, and it doesn’t handle missing values well, making it difficult to include categories like “Literature” with NA value. It also does not allow us to manipulate the distribution of the flows making it nearly impossible for further alignment.\nSecond aproach - geom_flow. + NAs\nTo replicate the gaps observed in the original graph, the ggalluvial package in R is utilized to create alluvial diagrams, which are ideal for visualizing the flow of categorical data across multiple stages or variables. By representing the relationships and transitions between categories, alluvial plots provide a clear view of how data “flows” over time or between different groups. It also provides a more manageable format, allowing us to work directly with our dataset offering greater flexibility. In particular, it handles missing values (NAs) that don’t get plotted but create space in the visualization. This feature will allow us to properly include categories like “Literature” and adjust padding as needed.\nIn order to be able to replicate the gaps observed in the original graph, we need to introduce artificial entries with missing values. This will be performed in two steps, first adding rows with missing affiliations and second, by adding rows to missing categories (bind_rows).\nFor this, we create a new row where the affiliation information is missing (NA) for selected prize categories. We only select a subset of categories, all except Chemistry - as is the top visualized category not needing extra values- and Literature - since it has no data at all, there is no need to artificially add gaps for this. We will then manually establish the number of laureates in each row to emulate the specific gaps in the original plot.\nThe same is done for the universities but, in this case, we just exclude the first university (Harvard) and the specific gaps are the same across all universities creating a clean alienation of the flows.\n\n\nuniv <- univ |>\n  \n  #NAs to emulate the gaps in the categories (left side)\n  bind_rows(data.frame(\n    category = factor(levels(univ$category)[-c(1, 4)], \n                      levels = levels(univ$category)),\n    affiliation_1_bis = NA,\n    n = c(27, 30, 77, 22) # different for each one (manually adjusted)\n  )) |>\n  \n  # NAs to emulate the gaps in the universities (right side)\n  bind_rows(data.frame(\n    category = NA,\n    affiliation_1_bis = factor(levels(univ$affiliation_1_bis)[-1], \n                               levels = levels(univ$affiliation_1_bis)), \n                                n = 12 )) # same space for each one (manually adjusted)\n\n\nOnce we have the required gaps created, we then focus on setting up and positioning the visual elements that connect Nobel Prize categories on the left side of the graph with the affiliations of laureates on the right side. The goal is to create segments that accurately reflect the number of laureates from each affiliation, while also ensuring the layout remains clean and visually balanced.\nTo begin, we defined the position of each category’s line on the left (lines_cat). For each one, we assign a position along the vertical axis ensuring they are evenly spaced. The (x) position is fixed, while the (y) position is calculated to place each category in an orderly sequence. This sequence of y values verifies that the categories are spaced out evenly (by=58) along the six distinct categories (length.out=6). Universities are presented in reverse ensuring that they are displayed in the correct order. We then set the end position of the segments (xend, yend), slightly extending the line vertically.\nNext, we extract the lengths for the university segments on the right side based on the frequency of laureates for each affiliation (length_af). By grouping the data by affiliation and summing the number of laureates per institution, we generate a list of values that determine the length of each segment. The segments are then positioned at the right side of the graph connecting affiliations to the categories (lines_af). As before, the horizontal axis is fixed, while the vertical axis position is calculated similarly to the left side, but with slight adjustments to ensure that the affiliations don’t overlap.\nWith the aim of preventing visual clutter while maintaining consistency and maintaining balance in the graph, we create a “fake” affiliation (ZZZ) to the dataset. This placeholder does not represent any real institution but is used solely for layout purposes. It introduces a gap at the bottom of the affiliations section, preventing overcrowding and ensuring that the graph maintains a neat structure. The “fake” affiliation is added with a manually adjusted count of 20 laureates.\n\n\n#category lines (left side)\nlines_cat <- data.frame(\n  x = 0.98, y = seq(-37, by=58, length.out=6),\n  category = factor(rev(levels(univ$category)), levels(univ$category))) |> \n  mutate(xend = x, yend = y + 40)\n\n#length of the university affiliations (right side)\nlength_af <- univ |> drop_na() |>\n  group_by(affiliation_1_bis) |>\n  summarise(n = sum(n)) |>\n  pull(n) |>\n  rev()\n\n#affiliation lines (right side)\nlines_af <- data.frame(\n  x = 2.02, y = seq(20, by=29, length.out=7) + \n    c(0, -1, -1, -2, -3, -2, -1), # base adjustment\n  affiliation_1_bis = factor(rev(levels(univ$affiliation_1_bis)), \n                             levels(univ$affiliation_1_bis))) |> \n  mutate(xend = x, yend = y + length_af)\n\n#\"fake\" affiliation to create space at the end\nlevels(univ$affiliation_1_bis) <- c(levels(univ$affiliation_1_bis), \"ZZZ\")\nuniv <- bind_rows(univ, data.frame(\n  category = NA,\n  affiliation_1_bis = factor(\"ZZZ\", levels=levels(univ$affiliation_1_bis)),\n  n = 20)) # manually adjusted \n\n\nAfter having all the calculations and positions of each element of the graph, we proceed to make the plot.\nBy using ggalluvial::geom_flowfunction we create flows between the categories (on the left) and affiliations (on the right). These flows are colored according to the Nobel categories color palette. Then, with thegeom_segment function we draw the vertical segments on the left, connecting each Nobel Prize category to the flow lines. Similarly, right-side segments are created to link affiliations to the flow lines. We also add the affiliation names next to each segment.\nFinally, as done before, to ensure a correct alignment with the other graphs once we combined them all, we settle the plot limits as the previous graphs.\n\n\ngp4 <- ggplot(univ) +\n  \n  #flow between categories\n  geom_flow(aes(axis1 = category, axis2 = affiliation_1_bis, y = n, \n                fill = category), width = 0, alpha=1) + #warnings can be ignored\n  scale_fill_manual(values = colors) +\n  \n  #left segments\n  geom_segment(aes(x=x, xend=xend, y=y, yend=yend, color=category), lines_cat, \n               size=0.8) +\n  scale_color_manual(values = colors) +\n  \n  #right segments\n  geom_segment(aes(x=x, xend=xend, y=y, yend=yend), color=\"#555\", lines_af, size=0.8) +\n  geom_text(aes(x = x + 0.08, y = y, label = affiliation_1_bis), lines_af, hjust=0, \n            vjust=0, size=3, family = \"ebg\", fontface = \"bold.italic\", alpha = 0.8) +\n  \n  #styling and theme \n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA),\n    strip.text.y = ggtext::element_markdown(size = 8, face = \"bold\", hjust = 1, \n                                            vjust = 0.8)) +\n\n  #axis and plot limits\n  coord_cartesian(xlim=c(1, 2.5), ylim=c(-25, 280))\n\ngp4\n\n\n\nGraphical Symbiosis - final result\nHaving all our graphs individually created, it’s time to assemble all the parts. In this process, first, we create a colored_spacer, which serves as a visual separator between the plots. Then, we arrange the individual plots (gp1, gp2, gp3, and gp4) along with the spacers into different rows, adjusting their widths and margins to ensure everything is properly spaced and aligned. Finally, we combine all the rows into a single layout, adjusting their heights to create the desired proportions and visual flow.\n\n\ncolored_spacer <- plot_spacer() + \n  theme(plot.background = element_rect(fill = \"#f2ebde\", color = NA))\n\nrow1 <- (colored_spacer + gp1 + gp2 + gp4 + colored_spacer) + \n  plot_layout(widths = c(4, 20, 1.5, 4.5, 0.5)) +\n  theme(plot.margin = margin(20, 0, 30, 0))\n\nrow2 <- (colored_spacer + gp3 + colored_spacer)  + \n  plot_layout(widths = c(1.02, 5, 1.71)) +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\nrow3 <- colored_spacer\n\nfinal_plot <- (row3 / row1 / row2 / row3) + \n  plot_layout(heights = c(0.05, 1, 0.5, 0.05)) + \n  theme(\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA))\n\nfinal_plot\n\n\n\nBeyond the mirror\nTo optimize the current visualization for better clarity and user engagement, several modifications can be considered. These adjustments would not only enhance the overall aesthetic appeal but also improve how the data is presented and understood by the audience.\nVisual Glossary\nAs you can see, the original plot presents a legend, which plays a crucial role in helping viewers understand the different categories, variables, or groups represented in the visualization. The legend serves as a guide, ensuring that the meaning of each color, shape, or size used in the plot is clear and easily interpreted.\nHowever, while the legend is helpful, there may be opportunities to refine its design or placement to improve its clarity and integration with the overall plot. Therefore, we have created a minimalist legend showing all the necessary elements to read and understand the visualization.\n\n\nlegend <- ggplot(tidy_nobels) +\n\n  #fake vertical grid lines\n  geom_vline(xintercept = seq(1906, 1910, by = 5), linetype = \"solid\", \n             color = \"#A6A9AC\", linewidth = 0.4,  alpha = 0.01) +\n  \n  #fake horizontal grid lines\n  annotate(\"segment\", x = 1901, xend = 1910, y = 60, yend = 60, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  annotate(\"segment\", x = 1901, xend = 1910, y = 70, yend = 70, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  annotate(\"segment\", x = 1901, xend = 1910, y = 80, yend = 80, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) +\n\n  \n  #gender points\n  annotate(\"point\", x = 1901.5, y = 74.75, color = \"#C04C3D\", size = 2) + \n  #woman\n  annotate(\"point\", x = 1901.5, y = 70, color = \"#C04C3D\", size = 2) +\n  annotate(\"point\", x = 1901.5, y =  70, color = \"#B55F94\", size = 4, shape = 23, \n           stroke = 1) +\n  \n  #gender labels\n  annotate(\"text\", x = 1901.75, y =  74.75, label =  \"man\", \n         size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n         family = \"tinos\", fontface = \"italic\") + \n  annotate(\"text\", x = 1901.75, y =  70, label =  \"woman\", \n         size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n         family = \"tinos\", fontface = \"italic\") +\n  \n  #double points\n  annotate(\"point\", x = 1901.5, y = 65, color = \"#C04C3D\", size = 2) + \n  annotate(\"point\", x = 1901.5, y = 62, color = \"#C04C3D\", size = 2) +\n  annotate(\"segment\", x = 1901.5, xend = 1901.5, y = 62, yend = 65, \n           color = \"#C04C3D\", linewidth = 0.2, alpha = 0.8)+\n  annotate(\"text\", x = 1901.75, y =  63.5,\n           label =  \"Nobel awarded to \\nmore than one person\", \n           size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"tinos\", fontface = \"italic\") + \n  \n  #10 years lines\n  annotate(\"segment\", x = 1903.5, xend = 1904, y = 75, yend = 75, \n           color = \"#B5B2AC\", linewidth = 0.2, alpha = 0.8) +\n  annotate(\"segment\", x = 1903.5, xend = 1904, y = 73, yend = 73, \n           color = \"#B5B2AC\", linewidth = 0.2, alpha = 0.8) +\n  annotate(\"segment\", x = 1903.5, xend = 1903.5, y = 75, yend = 73, \n           color = \"#B5B2AC\", inewidth = 0.2, alpha = 0.8) +\n  annotate(\"text\", x = 1904.25, y =  74,\n         label =  \"10 years\", \n         size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n         family = \"tinos\", fontface = \"italic\") +\n \n  #avg dash line\n  annotate(\"segment\",  x = 1903.5, xend = 1904, y = 69, yend = 69, color = \"black\", \n           linewidth = 0.5, alpha = 0.8, linetype = \"dashed\") +\n  annotate(\"text\", x = 1904.25, y =  69,\n           label =  \"average age of Nobel laureate\", \n           size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"tinos\", fontface = \"italic\") +\n\n  #avg line\n  annotate(\"segment\",  x = 1903.5, xend = 1904, y = 63.5, yend = 63.5, \n           color = \"#C04C3D\", linewidth = 0.8, alpha = 0.8) +\n  annotate(\"text\", x = 1904.25, y =  63.5,\n           label =  \"average age for each CATEGORY\", \n           size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"tinos\", fontface = \"italic\") +\n  \n  #academic degree\n  annotate(\"segment\", x = 1906.5, xend = 1906.7, y = 75, yend = 75, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"segment\", x = 1906.5, xend = 1906.7, y = 62, yend = 62, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"segment\", x = 1906.5, xend = 1906.5, y = 62, yend = 75, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"text\", x = 1906.85, y =  68.5,\n           label =  \"PhD \\nmaster \\nbachelor \\nno degree\", \n           size = 3, color = \"#C04C3D\", alpha = 0.8, vjust = 0.5, hjust = 0.5, \n           family = \"tinos\", fontface = \"bold.italic\") +\n  annotate(\"segment\", x = 1907, xend = 1907.2, y = 75, yend = 75, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"segment\", x = 1907, xend = 1907.2, y = 62, yend = 62, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"segment\", x = 1907.2, xend = 1907.2, y = 62, yend = 75, color = \"black\", \n           linewidth = 0.5, alpha = 0.8) +\n  annotate(\"text\", x = 1906.85, y =  78,\n           label =  \"grade level\", \n           size = 3.5, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0.5, \n           family = \"tinos\", fontface = \"italic\") +\n  \n  #universities\n  annotate(\"segment\", x = 1907.3, xend = 1907.3, y = 74, yend = 72, color = \"#C04C3D\", \n           linewidth = 2, alpha = 0.8) +\n  annotate(\"segment\", x = 1907.3, xend = 1907.3, y = 71.9, yend = 68, color = \"#C04C3D\", \n           linewidth = 2, alpha = 0.8) +\n  annotate(\"segment\", x = 1907.3, xend = 1907.3, y = 67.9, yend = 65, color = \"#C04C3D\", \n           linewidth = 2, alpha = 0.8) +\n  annotate(\"segment\", x = 1907.3, xend = 1907.3, y = 64.9, yend = 64, color = \"#C04C3D\", \n           linewidth = 2, alpha = 0.8) +\n  annotate(\"segment\", x = 1907.3, xend = 1907.3, y = 63.5, yend = 63, color = \"#C04C3D\", \n           linewidth = 2, alpha = 0.8) +\n  annotate(\"text\", x = 1907.5, y =  69,\n         label =  \"Principal univerisity affiliattions \\nof Nobel laureates at \n         the moment \\nthe Prize was awarded (by category).\", \n         size = 3.5, color = \"#C04C3D\", alpha = 0.8, vjust = 0.5, hjust = 0, \n         family = \"tinos\", fontface = \"bold.italic\") +\n  \n  #styling and theme\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_blank(),\n    strip.text.y = element_blank(),\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA)) +\n  labs(y = \"\", x = \"\")\n  \nlegend\n\n\n\nHeadline\nAlso, having a title in visualization is important because it provides immediate context and orientation to the viewer. It helps set the tone and clarifies the purpose of the plot, allowing the audience to quickly grasp the topic or focus of the data. The author attribution is also included in this step.\n\n\ngraph_title <- ggplot(tidy_nobels) +\n  \n  #fake vertical grid lines\n  geom_vline(xintercept = seq(1906, 1908, by = 5), linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.4,  alpha = 0.01) +\n  \n  ##fake horizontal grid lines\n  annotate(\"segment\", x = 1906, xend = 1908, y = 50, yend = 50, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  annotate(\"segment\", x = 1906, xend = 1908, y = 60, yend = 60, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  annotate(\"segment\", x = 1906, xend = 1908, y = 70, yend = 70, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  annotate(\"segment\", x = 1906, xend = 1908, y = 80, yend = 80, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.01) + \n  \n  #title label\n  annotate(\"text\", x = 1906.4, y =  65,\n           label =  \"Nobels, no degrees\", \n           size = 11, color = \"#4e0041\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"ebg\", fontface = \"italic\") +\n  \n  #author label\n  annotate(\"text\", x = 1906.4, y =  45,\n           label =  \"Author: Andrea Rivera Mateos (2025) \\nSource: Source: Nobel Prize Official Website and own eleaboration\", \n           size = 3, color = \"black\", alpha = 0.8, vjust = 0.5, hjust = 0, \n           family = \"ebg\", fontface = \"italic\") +\n  \n  #styling and theme\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_blank(),\n    strip.text.y = element_blank(),\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA)) +\n  labs(y = \"\", x = \"\") +\n  coord_cartesian(clip=\"off\", expand = 0 )\n\ngraph_title\n\n\n\nStrengthening Women’s Presence\nFinally, upon examining the data, it is evident that only 44 Laureates are women. In the original graph, this distinction is marked by a double-rounded dot. However, since ages are also represented using points regardless of gender, we believe that adopting a more distinctive shape, such as a diamond, better highlights and draws attention to the significant role of women in the history of the awards. To implement this change, we reused the existing code but modified the `geom_point shape to 23, which corresponds to a diamond.\n\n\ngp1 <- ggplot(tidy_nobels,aes(color = category)) +\n  \n  geom_vline(xintercept = seq(1906, 2010, by = 5), linetype = \"solid\", color = \"#A6A9AC\", \n             linewidth = 0.4,  alpha = 0.5) + \n  geom_vline(xintercept = 1931, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 1961, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 1991, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  geom_vline(xintercept = 2012, linetype = \"solid\", color = \"#A6A9AC\", linewidth = 0.5) +\n  \n  geom_segment(aes(x = 1901, xend = 1901, y = 40, yend = 80, color = category), linewidth =  0.8) +\n  annotate(\"segment\", x = 1901, xend = 2012, y = 40, yend = 40, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 50, yend = 50, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 60, yend = 60, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 70, yend = 70, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) + \n  annotate(\"segment\", x = 1901, xend = 2012, y = 80, yend = 80, color = \"#B5B2AC\", \n           linewidth = 0.2, alpha = 0.8) +\n  \n  annotate(\"segment\", x = 1901, xend = 2012, \n           y = mean(tidy_nobels$age, na.rm = TRUE), yend = mean(tidy_nobels$age, na.rm = TRUE),\n           color = \"black\", linewidth = 0.3, linetype = \"dashed\") +\n  geom_segment(data = avg_age, aes(x = 1901, xend = 2012, \n                                   y = avg_age, yend = avg_age, \n                                   color = category), linewidth = 0.5) + \n  \n  geom_point(aes(awardYear, age, color = category), size = 1.5, alpha = 0.8) +\n  geom_line(aes(awardYear, age, color = category), lwd = .2) + \n  \n  #new shape for women (diamond shape = 23)\n  geom_point(data = filter(tidy_nobels, gender == \"female\"), \n             aes(x = awardYear, y = age), color = \"#B55F94\", \n             shape = 23, size = 3, stroke = 0.8) +\n  facet_grid(category ~ ., switch = \"y\") +\n  scale_color_manual(values = colors) +\n  \n  \n  geom_text(data = min.years_label, aes(x = x, y = y, label = label), color = \"#7F8082\", \n            size = 3.5, family = \"gl\", vjust = -1) +\n  geom_text(data = maj.years_label, aes(x = x, y = y, label = label), color = \"#707070\", \n            size = 3.5, fontface = \"bold\", family = \"gl\", vjust = -1) +\n  \n  geom_text(data = labels_avg_facets, #avg_cat (59)\n            aes(x = 1898, y = label_y, label = label_text),\n            hjust = 1, vjust = 1, size = 2.5, color = \"black\", alpha= 0.8, \n            fontface = \"bold\",family = \"gl\") +\n  \n  geom_text(data = labels_avg_cat_facets,\n            aes(x = 1898, y = label_y, label = label_text,fontface = \"bold\", family = \"gl\"),\n            hjust = 1, vjust = -0.8, size = 2.5, color = colors) +\n  \n  geom_text(data = label_cat,\n            aes(x = 1898, y = label_y, label = label_text,fontface = \"bold\", family = \"tinos\"),\n            hjust = 1, vjust = -0.8, size = 3, color = colors, lineheight = 0.8) +\n  \n  \n  theme_void() + \n  theme(\n    legend.position = \"none\", \n    panel.grid.major.x = element_blank(), \n    axis.text.y = element_blank(), \n    axis.text.x = element_blank(),\n    strip.text.y = element_blank(),\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA),\n    panel.spacing = unit(0, \"lines\"),\n    plot.margin = margin(10,5,0,0, \"mm\")) + \n  labs(y = \"\", x = \"\") +\n  \n  coord_cartesian(xlim = c(1900, 2012), ylim = c(23, 92), clip = \"off\", expand = 0)\n\ngp1\n\n\n\nChronicle of data - final plot\nIncluded all the improvements, the final graph will be as follow:\n\n\ncolored_spacer <- plot_spacer() + \n  theme(plot.background = element_rect(fill = \"#f2ebde\", color = NA))\n\nrow1 <- (colored_spacer + gp1 + gp2 + gp4 + colored_spacer) + \n  plot_layout(widths = c(3.5, 15, 1, 4.5, 0.5)) +\n  theme(plot.margin = margin(10, 0, 30, 0))\n\nrow2 <- (colored_spacer + gp3 + colored_spacer)  + \n  plot_layout(widths = c(1.03, 4.41, 1.85)) +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\nrow3 <- (graph_title + legend) +\n  plot_layout(widths = c(3, 4)) +\n  theme(plot.margin = margin(25, 0, 15, 0))\n\nfinal_plot <- (colored_spacer / row1 / row2 /row3 ) + \n  plot_layout(heights = c(0.05, 1, 0.5, 0.25)) &\n  theme(\n    plot.background = element_rect(fill = \"#f2ebde\", color = NA))\n\nfinal_plot\n\n\n\n\n\n\n",
    "preview": "projects/2024/100535255/100535255_files/figure-html5/joint-plot-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 3072,
    "preview_height": 1920
  },
  {
    "path": "projects/2024/100437701/",
    "title": "Abortion Access and Sex Education Policies in the United States",
    "description": "Below is an analysis and replication of the graph by Sara Chodosh, originally\npublished in The New York Times, which examines the relationship between\nabstinence-focused sex education requirements and abortion access restrictions\nacross U.S. states.",
    "author": [
      {
        "name": "Julia Martyniewicz",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nData\nBuilding the chart\nFinal result\nAlternative graph\n\nIntroduction\nThe graph done by Sara Chodosh was published in The New York Times and its objective is to analyze if there is any relationship between states requiring that abstinence is stressed in sex education and states restricting access to abortion. Two weeks before the verdict for Roe v. Wade that eliminated the constitutional right to an abortion, The Times Opinion section published the graph. The graph uses a Demers cartogram to size each state based on the number of women of reproductive age, offering a visual representation of the relationship between the two variables.\nOriginal graph from the NYT.Data\nThe data for this reproduction comes from:\nSex Education Policy and Abortion Accessibility: Guttmacher Institute.\nNumber of Women in Reproductive Age: Centers for Disease Control and Prevention (CDC).\nThe variables in the dataset include:\nState Name: Names of U.S. states.\nWomen Reproductive Age: Number of women aged 15–44.\nAbortion Accessibility: Categorical variable - “Available” or “Restricted”.\nAbstinence Required: Boolean variable - TRUE or FALSE.\nX, Y Coordinates: Placement of each state on the graph - coordinates for the centers of the squares, calculated using mobilefish.com, an online application for precise layout positioning.\nSquare Side Length: Derived from the number of reproductive-age women to scale state sizes.\nBorder Color: Indicates whether abstinence is required in sex education.\nBuilding the chart\nTo create the graph, the R programming language was used, with the ggplot2 and extrafont library for data visualization. Below is an explanation of the key steps and components.\nLibraries necessary for the project:\n\n\nlibrary(tidyverse)\nlibrary(grid)\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(scales)\n\n\nFonts necessary for the project:\n\n\nlibrary(extrafont)\n\n\nReading the data:\n\n\ndata_graph <- readxl::read_excel(\"./data graph xy final 2.xlsx\")\n\n\nThe code begins by creating a new dataset. First, the values of the x and Y coordinates are scaled down by multiplying them by 0.8. This adjusts the positions of the data points, making them smaller or more compact on the plot. Then, a new column called side_length is created by calculating the square root of the Women_Reproductive_Age column. This represents the side length of a square whose area is proportional to the number of women of reproductive age in each state. The idea is that larger populations will have larger squares, which will be useful for visualizing the data with different sized tiles. Next, another new column called border_color is created using the ifelse() function. This column determines whether the border of a square should be black or not. If the value of Abstinence_Required is TRUE, meaning that abstinence must be emphasized in sex education, the border color is set to black. If Abstinence_Required is FALSE, the border color is set to NA, meaning no border will be drawn.\n\n\ndata6 <- data_graph |>\n  mutate(\n    x = x * 0.8,\n    Y = Y * 0.8,\n    # Calculate side length from population\n    side_length = sqrt(Women_Reproductive_Age),\n    # Create border color column\n    border_color = ifelse(Abstinence_Required, \"black\", NA))\n\n\nThe {r} specifies that the chunk contains R code, while fig.width and fig.height control the size of the resulting plot in inches. Specifically, fig.width=10 sets the figure’s width to 10 inches, and fig.height=9 sets its height to 9 inches. Together, these options ensure the visualization fits appropriately into the document and is clear and visually appealing.\nThe placement coordinates were obtained from mobilefish.com to ensure accurate alignment. Fill colors indicate abortion accessibility - orange for restricted or banned access and gray for largely available access. What is more, the black borders were included - states that require abstinence in sex education are outlined in black (Abstinence_Required == TRUE). States without this requirement have no border. The border color legend is customized using scale_color_identity().\nThe color of the squares depends on the Abortion Accessibility variable (fill). “Restricted” is orange (#FEA151) and “Available” is grey (#E8E8E8). scale_fill_manual customizes the square colors for the two levels of abortion accessibility.\nNames of the states are displayed in the upper-left corner of each square for clarity. However, some of them must have been placed outside the square because of its size. In order to do this a condition for inside/outside names of states was created. A new variable was added indicate whether the state is “inside” or “outside” the main grid of squares in the visualization. It helped to adjust text placement and visibility in the final visualization.\n\n\ndata7<- data6 |>\n  mutate(inside = case_when(\n    Name %in% c(\"Alaska\", \"Mont.\", \"Wyo.\", \"N.D.\", \"S.D.\", \"Vt.\", \"Maine\",\n                \"Hawaii\", \"D.C.\") ~ FALSE,  \n    .default = TRUE \n  ))\n\n\nThe caption below the graph was also added to provide context about the data sources and visualization. theme_void() removes gridlines, axes, and unnecessary elements for a clean, minimalist appearance. legend.position = “none” hides the legend because the annotations explain the categories clearly. Margin and caption styling was also included in the code. White background for the whole graph was set. The plot’s overall visual design is finalized by fixed aspect ratio that was maintained so that the squares are proportional and not distorted.\nAnnotations added explanatory text, squares for legend and arrow to the chart (for example numbers indicating population thresholds). The legend in this graph was replaced by annotations with annotated tiles. Moreover, text annotation highlights a specific data point (8 million women) and curve annotation draws a curved arrow pointing to the relevant square.\nAdditionally, the font used in the plot has been carefully chosen with the help of the extrafont package to match the original design as closely as possible. The font, such as “Nirmala UI,” was selected to replicate the appearance of the source graphic, enhancing the visual similarity to the reference while maintaining a clean and professional aesthetic.\nBelow you can find the whole code for the replica.\n\n\nggplot(data7) +\n  # Squares with borders (depending on Abstinence_Required)\n  geom_tile(aes(\n    x = x,  \n    y = Y,  \n    fill = Abortion_Accessibility,  # Fill color based on abortion accessibility\n    width = side_length,  \n    height = side_length,   \n    color = border_color    # Border color determined by Abstinence_Required\n  ), size = 1) +  # Thicker border to enhance the visibility\n  \n  # Add state names inside the squares in the upper-left corner\n  geom_text(aes(\n    # positioning based on size, but you can adjust for specific states too\n    x = x - side_length / 2 + ifelse(inside, 3, 0),\n    y = Y + side_length / 2 + ifelse(inside, -3, +8),\n    label = Name  # Place state names\n  ),\n    size = 3,  # Slightly larger text size for better readability\n    color = \"black\",  # Set text color to black for contrast\n    hjust = 0,  # Align text to the left\n    vjust = 1,  # Align text to the top\n    fontface = \"plain\",  # Non-bold text\n    family = \"Nirmala UI Semilight\"\n  ) +  \n  \n  # Customizing the fill for abortion accessibility\n  scale_fill_manual(\n    values = c(\n      \"Restricted\" = \"#FEA151\",    # Orange\n      \"Available\" = \"#E8E8E8\"  # Grey\n    )\n  ) +\n  \n  # Customizing the border color legend\n  scale_color_identity(\n    name = NULL,  # Remove default legend title\n    labels = c(\"Black border: Abstinence is required\\nin sex education\"),  # Cleaned label\n    guide = guide_legend(\n      override.aes = list(\n        size = 7,  # Set size of legend squares\n        shape = 15  # Use square shapes in the legend\n      )\n    )\n  ) +\n  \n  # Title, subtitle, and caption\n  labs(\n    caption = \"Not all states require that schools teach sex education, nor do all states specify which topics must be covered. But al least 28 states require that when sex\\ned is taught, abstinence must be stressed over other methods of birth control.\\n\\nSource: Sex ed policy data from the Guttmacher Institute. Number of reproductive-age women per state from the CDC.; it includes only people ages 15 to\\n44 who identify as women. Graphic by Sara Chodosh.\"\n  ) +\n  \n  # Theme to remove gridlines and axis, and add proper styling\n  theme_void() +  # Clean background without gridlines or axes\n  theme(\n    legend.position = \"none\",\n    plot.caption = element_text(size = 10, family = \"Nirmala UI Semilight\", \n                                hjust = 0, color = \"gray50\"),\n    plot.margin = margin(20, 20, 20, 20),  # Add spacious margin around the plot\n    panel.background = element_rect(fill = \"white\", color = NA), # White background\n    plot.background = element_rect(fill = \"white\", color = NA)\n  ) +\n  coord_fixed(expand=0) +\n  \n  annotate(\"text\", x = 255, y = 830, \n           label = \"States are sized by the number\\nof women of reproductive age\", \n           color = \"black\", size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 280, y = 845, label = \"500,000\", color = \"black\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 230, y = 845, label = \"100,000\", color = \"black\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 140, y = 900, \n           label = \"Abstinence is required to be\\nstressed in sex education\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, vjust = 1, \n           family = \"Nirmala UI\") +\n  annotate(\"text\", x = 255, y = 900, \n           label = \"Abortion is heavily restricted or banned,\\nor likely will be soon\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, \n           vjust = 1, family = \"Nirmala UI\") +\n  annotate(\"text\", x = 370, y = 900, \n           label = \"Abortion is\\nlargely available\", color = \"black\", \n           size = 3, fontface = \"bold\", hjust = 0.5, vjust = 1, \n           family = \"Nirmala UI\") +\n  annotate(\"tile\", x = 140, y = 860, height = 15, width = 15 , \n           fill = \"white\", color = \"black\", size = 1) +\n  annotate(\"tile\", x = 230, y = 860, height = 10, width = 10, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 252, y = 860, height = 15, width = 15, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 280, y = 860, height = 20, width = 20, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 370, y = 860, height = 15, width = 15, fill = \"#E8E8E8\") +\n  annotate(\"text\", x = 70, y = 590, \n           label = \"8 million women of\\nreproductive age\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"curve\", x = 45, y = 595 , xend = 25, yend = 615 , color = \"black\",\n           curvature = -0.5, arrow = arrow(length = unit(0.2, \"cm\")))\n\n\n\nFinal result\nWhen I first saw the graph, my initial impression was that the lack of a title made it more challenging to understand, especially when working with a Demers cartogram, which is not a standard visualization type. To address this, I added a title as an annotation positioned at the top of the chart, replacing the default labs() setup. This allows precise positioning, ensuring the title does not interfere with other elements of the visualization. Without a title, it is harder to immediately grasp the purpose or main insight of the chart mainly for readers who may not be familiar with the context of the analysis.\nAnother change that I wanted to introduce was using a darker shade of grey color so that it is visible on the white background and easier for graph readers to distinguish. It improves visibility and interpretation of categories in the Abortion_Accessibility variable. Previously, poor contrast with the white background might have caused confusion. The lighter color, while functional, lacked sufficient contrast against the white background, making it harder for readers to quickly distinguish between categories. Together, these updates make the chart more informative, professional, and reader-friendly.\nYou can find the whole code below for the final graph with changed mentioned above.\n\n\nggplot(data7) +\n  # Squares with borders (depending on Abstinence_Required)\n  geom_tile(aes(\n    x = x,  \n    y = Y,  \n    fill = Abortion_Accessibility,  # Fill color based on abortion accessibility\n    width = side_length,  \n    height = side_length,   \n    color = border_color    # Border color determined by Abstinence_Required\n  ), size = 1) +  # Thicker border to enhance the visibility\n  \n  # Add state names inside the squares in the upper-left corner\n  geom_text(aes(\n    # positioning based on size, but you can adjust for specific states too\n    x = x - side_length / 2 + ifelse(inside, 3, 0),\n    y = Y + side_length / 2 + ifelse(inside, -3, +8),\n    label = Name  # Place state names\n  ),\n    size = 3,  # Slightly larger text size for better readability\n    color = \"black\",  # Set text color to black for contrast\n    hjust = 0,  # Align text to the left\n    vjust = 1,  # Align text to the top\n    fontface = \"plain\",  # Non-bold text\n    family = \"Nirmala UI Semilight\"\n  ) +  \n  \n  # Customizing the fill for abortion accessibility\n  scale_fill_manual(\n    values = c(\n      \"Restricted\" = \"#FEA151\",    # Orange\n      \"Available\" = \"gray\"  # Grey\n    )\n  ) +\n  \n  # Customizing the border color legend\n  scale_color_identity(\n    name = NULL,  # Remove default legend title\n    labels = c(\"Black border: Abstinence is required\\nin sex education\"),  # Cleaned label\n    guide = guide_legend(\n      override.aes = list(\n        size = 7,  # Set size of legend squares\n        shape = 15  # Use square shapes in the legend\n      )\n    )\n  ) +\n  \n  # Title, subtitle, and caption\n  labs(\n    caption = \"Not all states require that schools teach sex education, nor do all states specify which topics must be covered. But al least 28 states require that when sex\\ned is taught, abstinence must be stressed over other methods of birth control.\\n\\nSource: Sex ed policy data from the Guttmacher Institute. Number of reproductive-age women per state from the CDC.; it includes only people ages 15 to\\n44 who identify as women. Graphic by Sara Chodosh.\"\n  ) +\n  \n  # Theme to remove gridlines and axis, and add proper styling\n  theme_void() +  # Clean background without gridlines or axes\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(size = 12, face = \"bold\", family = \"Nirmala UI\", hjust = 0.5, vjust = 0),\n    plot.caption = element_text(size = 10, family = \"Nirmala UI Semilight\", hjust = 0, color = \"gray50\"),\n    plot.margin = margin(20, 20, 20, 20),  # Add spacious margin around the plot\n    panel.background = element_rect(fill = \"white\", color = NA), # Dodane białe tło\n    plot.background = element_rect(fill = \"white\", color = NA)\n  ) +\n  coord_fixed(expand=0) +\n  \n  annotate(\"text\", x = 255, y = 895, \n           label = \"Abortion law and abstinence in sex education by states\",\n           fontface = \"bold\", family = \"Nirmala UI\", size = 7, vjust = 1) +\n  annotate(\"text\", x = 255, y = 815, \n           label = \"States are sized by the number\\nof women of reproductive age\", \n           color = \"black\", size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 280, y = 830, label = \"500,000\", color = \"black\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 230, y = 830, label = \"100,000\", color = \"black\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"text\", x = 140, y = 875, \n           label = \"Abstinence is required to be\\nstressed in sex education\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, vjust = 1, family = \"Nirmala UI\") +\n  annotate(\"text\", x = 255, y = 875, \n           label = \"Abortion is heavily restricted or banned,\\nor likely will be soon\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, \n           vjust = 1, family = \"Nirmala UI\") +\n  annotate(\"text\", x = 370, y = 875, \n           label = \"Abortion is\\nlargely available\", \n           color = \"black\", size = 3, fontface = \"bold\", hjust = 0.5, \n           vjust = 1, family = \"Nirmala UI\") +\n  annotate(\"tile\", x = 140, y = 845, height = 15, width = 15 , \n           fill = \"white\", color = \"black\", size = 1) +\n  annotate(\"tile\", x = 230, y = 845, height = 10, width = 10, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 252, y = 845, height = 15, width = 15, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 280, y = 845, height = 20, width = 20, fill = \"#FEA151\") +\n  annotate(\"tile\", x = 370, y = 845, height = 15, width = 15, fill = \"gray\") +\n  annotate(\"text\", x = 70, y = 590, \n           label = \"8 million women of\\nreproductive age\", \n           size = 3, family = \"Nirmala UI Semilight\") +\n  annotate(\"curve\", x = 45, y = 595 , xend = 25, yend = 615 , color = \"black\",\n           curvature = -0.5, arrow = arrow(length = unit(0.2, \"cm\")))\n\n\n\nAlternative graph\nWhile the original visualization utilized a Demers cartogram to explore the relationship between abortion accessibility and abstinence requirements in sex education across states, the alternative bar chart shown above offers a more traditional yet effective approach. This horizontal bar chart organizes states by their abortion accessibility and whether abstinence is required to be stressed in sex education. Each bar represents the number of women of reproductive age per state, with color-coding distinguishing states where abortion is heavily restricted or largely available. A black border around bars indicates states where abstinence must be emphasized in sex education.\n\n\ndata7 <- data7 |>\n  mutate(\n    # Black border if Abstinence_Required == TRUE\n    border_color = ifelse(Abstinence_Required == TRUE, \"black\", NA) \n  )\n\n\nThe first line of code cleans and converts the Women_Reproductive_Age column into numeric values, making it ready for analysis. The following lines of code correct specific values in the Women_Reproductive_Age_num column by directly assigning them the correct values for rows 5, 6, 11, 24, and 31 in order to get rid of commas and points.\n\n\ndata7$Women_Reproductive_Age_num <- as.numeric(\n  gsub(\",\", \".\", gsub(\"\\\\.\", \"\", data7$Women_Reproductive_Age)))\ndata7$Women_Reproductive_Age_num[5] <- 7938770\ndata7$Women_Reproductive_Age_num[6] <- 1211040\ndata7$Women_Reproductive_Age_num[11] <- 2251070\ndata7$Women_Reproductive_Age_num[24] <- 1100650\ndata7$Women_Reproductive_Age_num[31] <- 1752900\n\n\nUnlike the cartogram, where the state sizes and positions might confuse readers unfamiliar with the Demers projection, the bar chart follows an easily interpretable structure. The bar chart allows for precise, quantitative comparisons between states. Readers can quickly measure the number of women in reproductive age per state without needing to estimate areas or interpret a less conventional chart style with squares. The inclusion of labels and a legend ensures that the chart remains self-explanatory. Readers can instantly identify which states fall into specific policy categories, supported by clear annotations.\n\n\nbarplot <- ggplot(data7, aes(x = reorder(State, -Women_Reproductive_Age_num), \n                             y = Women_Reproductive_Age_num, \n                             fill = Abortion_Accessibility)) +\n  geom_bar(\n    stat = \"identity\",\n    aes(color = border_color),\n    size = 0.5,\n    width = 0.7\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Restricted\" = \"#FEA151\",\n      \"Available\" = \"gray\"\n    ),\n    name = \"Abortion Accessibility\",\n    labels = c(\"Abortion is heavily restricted or banned,\\nor likely will be soon\", \"Abortion is\\nlargely available\")\n  ) +\n  scale_color_manual(\n    values = c(\"black\" = \"black\"),\n    na.value = \"transparent\",\n    guide = \"none\"\n  ) +\n  labs(\n    title = \"Abortion law and abstinence in sex education by states\",\n    x = \" \", \n    y = \"Number of women in reproductive age\",\n    caption = \"The data comes from:\\nSex Education Policy and Abortion Accessibility: Guttmacher Institute.\\nNumber of Women in Reproductive Age: Centers for Disease Control and Prevention (CDC).\"\n  ) +\n  theme_void() +\n  theme(\n    plot.title = element_text(size = 14, face = \"bold\", family = \"Nirmala UI\", hjust = 0.5),\n    axis.title.x = element_text(size = 12, family = \"Nirmala UI Semilight\"), \n    axis.title.y = element_text(size = 12, angle = 90, family = \"Nirmala UI Semilight\"),\n    axis.text.x = element_text(hjust = 1, size = 10, family = \"Nirmala UI Semilight\"),\n    axis.text.y = element_text(size = 10, family = \"Nirmala UI Semilight\", hjust = 1),\n    legend.position = c(0.8, 0.8),\n    legend.title = element_text(family = \"Nirmala UI Semilight\", face = \"bold\"),\n    legend.text = element_text(family = \"Nirmala UI Semilight\"),\n    panel.background = element_rect(fill = \"white\", color = NA),\n    plot.background = element_rect(fill = \"white\", color = NA),\n    plot.margin = margin(20, 20, 35, 20),\n    plot.caption = element_text(hjust = 0, vjust=1, margin = margin(t = 15),\n                                family = \"Nirmala UI Semilight\", size=9)\n  ) +\n  coord_flip() +\n  scale_y_continuous(labels = comma) +\n  annotate(\"text\", x = 35, y = 5000100 * 0.95, \n           label = \"Black border of bars indicates:\\nAbstinence is required to be stressed\\nin sex education\",\n           color = \"black\", size = 3, hjust = 0, vjust = 1, family = \"Nirmala UI Semilight\")\n\n\n\n\nprint(barplot)\n\n\n\nThe one notable drawback of the bar chart is its inability to convey geographic information, such as the spatial location of states on the map. This is a strength of the Demers cartogram, which visually emphasizes the geographic distribution of abortion policies across the United States. By omitting this spatial context, the bar chart loses a layer of meaning that could help readers identify regional patterns and trends more intuitively. However, this dataset does not exhibit a clear or obvious regional pattern in abortion accessibility or abstinence policies. As such, the geographic positioning of states becomes less critical. For instance, states with similar abortion policies, such as Texas and New York, are located in entirely different regions but share comparable data points. The lack of a distinct regional trend makes omitting geographic variables less impactful.\nDespite this limitation, the bar chart remains a strong alternative to the cartogram. Its simplicity, clarity, and ability to present precise data make it a valuable visualization tool, particularly for audiences focused on quantitative insights. While the geographic dimension is sacrificed, the bar chart excels in readability and accessibility, offering an effective way to present complex data in a straightforward manner.\n\n\n\n",
    "preview": "projects/2024/100437701/100437701_files/figure-html5/unnamed-chunk-7-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1920,
    "preview_height": 1785
  },
  {
    "path": "projects/2024/100446517/",
    "title": "Book reading habits",
    "description": "This project explains how to replicate and create an alternative version of a\nchart from Eurostat about book reading habits.",
    "author": [
      {
        "name": "Aurora Sterpellone",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nNecessary Libraries\nLoad the data\nData cleaning and transformation\nStep 1: Filter Relevant Data\nStep 2: Convert and Recode Variables\nStep 3: Reorder Categories and Remove Unnecessary Entries\nStep 4: Aggregate Data\nStep 5: Reshape Data for Visualization\nStep 6: Reorder Countries\nStep 7: Define Colours\n\nCreate the Stacked Bar Plot\nGraph Refinement\nFont\nSpace between countries\nBackground colour and some more changes\nCountries’ names\nFurther adjustments\n\nMy graph enhancement\nCreating the graph\nSome shortcomings\n\n\n\nIntroduction\nIn 2022, according to EU statistics on income and living conditions, 52.8% of the EU population aged 16 years or over reported reading books in the past 12 months.\nThe “Book Reading Habits over the Past 12 Months (2022)” graph, created by Eurostat, the statistical office of the European Union, provides an insightful look into reading habits across different EU countries and a few non-EU countries.\nThe data reflects not only cultural and educational trends in book readership but also highlights variations between countries, offering a window into broader societal behaviors. This information is valuable for understanding literacy levels, cultural engagement, and potential market demand in the publishing industry across Europe and its neighboring regions.\nBook Reading Habits over past 12 months, 2022. Source: Eurostat.Necessary Libraries\nThe following libraries are used for the graph replication and the graph improvement.\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\nlibrary(sysfonts)\nlibrary(showtext)\n\n\nLoad the data\nLoad the dataset into the environment. Here, ilc_scp27_linear represents the dataset containing information on book reading habits.\n\n\ndata <- read.csv(file = \"data/ilc_scp27_linear.csv\")\n\n\nData cleaning and transformation\nStep 1: Filter Relevant Data\nFirst, the data is cleaned by extracting only the relevant data for the year 2022 and selecting records where the unit is expressed in percentages. Thanks to the select( ) function, only the relevant columns geo (country), n_book (book categories), and OBS_VALUE (percentage) are kept.\nThe mutate() function ensures the n_book column is treated as a factor, which is necessary for ordering and labeling later.\n\n\n# Filter the data for the year 2022 and relevant columns\ndata_filtered <- data %>%\n  filter(TIME_PERIOD == 2022, unit == \"PC\") %>%\n  select(geo, n_book, OBS_VALUE) %>%\n  mutate(n_book = as.factor(n_book))\n\n\nStep 2: Convert and Recode Variables\nEnsure the OBS_VALUE column is numeric for accurate aggregation and plotting.\n\n\n# Convert OBS_VALUE to numeric\ndata_filtered$OBS_VALUE <- as.numeric(data_filtered$OBS_VALUE)\n\n\nThe n_book variable, which categorizes the number of books read, is then re-coded with descriptive labels, simplifying the category for “0 books” to a blank space.\n\n\n# Recode the 'n_book' column with more descriptive labels\ndata_filtered$n_book <- recode(data_filtered$n_book, \n                               `0` = \"0 books\",\n                               `LT5` = \"Less than 5 books\",\n                               `5-9` = \"5 to 9 books\",\n                               `GE10` = \"10 books or more\")\n\n\nStep 3: Reorder Categories and Remove Unnecessary Entries\nI then reordered categories and remove unnecessary entries.\nReorder levels for n_book: Define the order of book categories for consistent stacking in the plot. This ensures that “0 books” is at the bottom, and “10 books or more” is at the top.\nReplace and exclude specific entries: (a) replace EU27_2020 with the simplified label EU; (b) exclude the entry EA20 (Euro area) from the dataset; (c) remove the “0 books” category since it is not required for the final visualization.\n\n\n#1 Reorder the levels of n_book factor\ndata_filtered$n_book <- factor(data_filtered$n_book,\n                               levels = c(\"10 books or more\", \"5 to 9 books\",\n                                          \"Less than 5 books\",\"0 books\"))\n\n#2 Replace EU_27_2020 with EU\ndata_filtered$geo <- recode(data_filtered$geo, \"EU27_2020\" = \"EU\")\n\n#2 Remove the EA20 and 0 books category from the dataset\ndata_filtered <- data_filtered %>%\n  filter(geo != \"EA20\")  %>%\n  filter(n_book != \"0 books\")\n\n\nStep 4: Aggregate Data\nThen I aggregated the data to avoid duplicates and ensure data integrity. First, I grouped data by country (geo) and book category (n_book). Then calculated the mean percentage (OBS_VALUE) for each group. Finally, used na.rm = TRUE to handle missing values.\n\n\n# Aggregate data to avoid duplicates (if any)\ndata_aggregated <- data_filtered %>%\n  group_by(geo, n_book) %>%\n  summarise(OBS_VALUE = mean(OBS_VALUE, na.rm = TRUE)) %>%\n  ungroup()\n\n\nStep 5: Reshape Data for Visualization\nTo make it easier to create a stacked bar plot, I pivoted the data from long format (one row per country and book category) to wide format (one row per country with separate columns for each book category).\n\n\n# Pivot data for visualization\nplot_data <- data_aggregated %>%\n  pivot_wider(names_from = n_book, values_from = OBS_VALUE, values_fill = 0)\n\n\nStep 6: Reorder Countries\nTo ensure that EU appears first, followed by other countries in a decreasing order.\nI tried to order the countries in decreasing order based on the sum of their percentages (OBS_VALUE), to do so I used mutate and arrange to reorder the factor levels for geo. Trying to ensures that countries are plotted in decreasing order of total percentages, with the desired stacking order maintained.\n\n\n# Calculate total percentage (OBS_VALUE) for each country\ngeo_order <- data_aggregated %>%\n  group_by(geo) %>%\n  summarise(total_value = sum(OBS_VALUE, na.rm = TRUE)) %>%\n  ungroup() %>%\n  arrange(desc(total_value)) %>% # Order by total_value in descending order\n  pull(geo) # Extract the ordered list of countries\n\n# # Reorder geo: EU first, then countries in decreasing order of total_value\n# data_aggregated$geo <- factor(data_aggregated$geo, \n#                               levels = c(\"EU\", geo_order[geo_order != \"EU\"])) # Ensure EU is first\n\n# Reorder geo: EU first, then countries in decreasing order, NO and CH last\ngeo_order_final <- c(\"EU\", geo_order[!(geo_order %in% c(\"EU\", \"NO\", \"CH\"))], \"NO\", \"CH\")\n\n# Apply the new order to the geo factor\ndata_aggregated$geo <- factor(data_aggregated$geo, levels = geo_order_final)\n\n\nStep 7: Define Colours\nDefine consistent colours for each book category.\n\n\n# Define colors for all book categories (ensure all levels of n_book are covered)\nunique_books <- unique(data_aggregated$n_book)\ncolors <- c(\"#b09121\", \"#97affc\",\"#244095\")[1:length(unique_books)]\n\n\nCreate the Stacked Bar Plot\nKey Features:\naes(): Maps countries (geo) to the x-axis, percentages (OBS_VALUE) to the y-axis, and book categories (n_book) to the fill color.\ngeom_bar(): Creates a stacked bar plot.\nscale_fill_manual(): Applies custom colors to each book category.\nlabs(): Adds a title, subtitle, axis labels, and legend title.\ntheme_minimal(): Uses a clean theme with minimal distractions.\ntheme(): Customizes the text orientation, gridlines, and legend position.\n\n\n# Create the stacked bar plot\nggplot(data_aggregated, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors) +\n  labs(title = \"Book reading habits over past 12 months, 2022\",\n       subtitle = \"(% of people aged 16 and over)\",\n       x = NULL,\n       y = \"Percentage\",\n       fill = \" \") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        panel.grid.major.x = element_blank(),\n        legend.position = \"top\",\n        plot.subtitle = element_text(face = \"italic\"))\n\n\n\nThe resulting stacked bar plot shows the distribution of book reading habits across different countries in 2022, with “Less than 5 books” at the bottom, “5 to 9 books” in the middle, and “10 books or more” at the top. The EU is highlighted as the first entry, followed by other countries alphabetically. The graph uses descriptive labels, visually appealing colors, and clear annotations for easy interpretation.\nGraph Refinement\nFont\nI had previously loaded the necessary libraries: sysfonts (which provides access to Google Fonts) and showtext (which ensures that non-standard fonts render correctly in plots).\nThe fonts used in the original graph were checked using an online font detector (What the font). However, the original font was unavailable and ‘Roboto Condensed’ was reported as the most similar free font. The font is found in Google fonts and is uploaded using the ‘sysfonts’ package.\nI had to add and activate the Roboto Condensed font.\n\n\nsysfonts::font_add_google(\"Roboto Condensed\", family = \"roboto_condensed\")\nshowtext_auto() \n\n\nTo ensure that the custom font is applied consistently when the code is rendered in a Quarto or R Markdown document, I had to configure chung options for Quarto/R Markdown: fig.showtext = TRUE: Ensures that showtext is used for rendering fonts in figures.\n\n\nknitr::opts_chunk$set(echo = TRUE, fig.align = \"center\", fig.showtext = TRUE)\n\n\nThen, I applied the custom font in the ggplot theme:\n\n\nggplot(data_aggregated, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors) +\n  labs(\n    title = \"Book reading habits over past 12 months, 2022\",\n    subtitle = \"(% of people aged 16 and over)\",\n    x = NULL,\n    y = \"Percentage\",\n    fill = \"Books Read\"\n  ) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"top\",\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\nThe final plot uses the “Roboto Condensed” font across all text elements (title, subtitle, legend, axis labels, etc.), ensuring a clean and cohesive visual style. This is particularly useful for creating professional-quality visualizations that match specific branding or design requirements.\nSpace between countries\nThe original graph separates the EU average from the other countries, leaving the EU bar on the far left of the graph, and the other countries alphabetically ordered on the right.\nTo do so, I created a dummy level and explicitly added to ‘geo’ variable. The dummy space (geo = ” “) creates a visual gap between the bar for EU and the rest of the countries.Then, to ensure the ‘geo’ variable has the correct order for the bars in the graph, I have make explicit the levels:”EU” is placed first; ” ” (a dummy space) is added as a placeholder to create the gap; the remaining countries are sorted alphabetically and placed after the dummy space.\n\n\n# Add the dummy level explicitly to geo : explicitly reorder geo levels to place EU first, then space, then others\ndata_aggregated$geo <- factor(data_aggregated$geo, \n                              levels = c(\"EU\", \" \", geo_order[geo_order != \"EU\"]))\n\n\nThen, I added add a blank row that represents the gap in the bar chart: a new row is created with geo = ” “, no book category (n_book = NA), and OBS_VALUE = 0 so it doesn’t affect the graph’s data.\nAnd, since adding a dummy row can reset the factor levels, I explicitly reapplied the correct levels.\nI then ensure the geo column in the updated dataset (data_aggregated_with_space) retains the correct order of levels, including the dummy space.\n\n\n# Add a row for the dummy space with 0 values\ndummy_row <- data.frame(geo = \" \", n_book = NA, OBS_VALUE = 0)\ndata_aggregated_with_space <- bind_rows(data_aggregated, dummy_row)\n\n# Ensure the dummy row is treated as part of the factor\ndata_aggregated_with_space$geo <- factor(data_aggregated_with_space$geo, levels = levels(data_aggregated$geo))\n\n\nFinally, we plot the stacked bar chart\n\n\n# Plot with a gap between EU and the other countries\nggplot(data_aggregated_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors, na.translate = FALSE) +\n  labs(title = \"Book reading habits over past 12 months, 2022\",\n       subtitle = \"(% of people aged 16 and over)\",\n       x = NULL,\n       y = \"Percentage\",\n       fill = \"Books Read\") +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"top\",\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n\nBackground colour and some more changes\nA few more changes:\nChange the background color to #f5f5f5 () : Use theme() to set panel.background and plot.background. The colour used in the original graph was checked using an online colour detector (Image color picker.com).\nChange the y-axis ticks to show every percentage: Use scale_y_continuous() and specify the breaks.\nRemove the legend title “Books Read.”\n\n\nggplot(data_aggregated_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors, na.translate = FALSE) +\n  labs(title = \"Book reading habits over past 12 months, 2022\",\n       subtitle = \"(% of people aged 16 and over)\",\n       x = NULL,\n       y = \"Percentage\",\n       fill = \" \") + # Remove legend title by leaving it blank\n  scale_y_continuous(breaks = seq(0, 100, by = 10)) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"top\",\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.background = element_rect(fill = \"#f5f5f5\", color = NA),  # Set panel background\n    plot.background = element_rect(fill = \"#f5f5f5\", color = NA)    # Set plot background\n  )\n\n\n\nCountries’ names\nI need to put countries’ names instead of the codes.\n\n\n# Replace country codes with full names\ndata_aggregated_with_space$geo <- recode(data_aggregated_with_space$geo,\n                                         \"EU\" = \"EU\",\n                                         \" \" = \" \",\n                                         \"CH\" = \"SWITZERLAND\",\n                                         \"LU\" = \"LUXEMBOURG\",\n                                         \"DK\" = \"DENMARK\",\n                                         \"NO\" = \"NORWAY\",\n                                         \"SE\" = \"SWEDEN\",\n                                         \"FI\" = \"FINLAND\",\n                                         \"EE\" = \"ESTONIA\",\n                                         \"NL\" = \"NETHERLANDS\",\n                                         \"IE\" = \"IRELAND\",\n                                         \"CZ\" = \"CZECHIA\",\n                                         \"AT\" = \"AUSTRIA\",\n                                         \"FR\" = \"FRANCE\",\n                                         \"SI\" = \"SLOVENIA\",\n                                         \"BE\" = \"BELGIUM\",\n                                         \"ES\" = \"SPAIN\",\n                                         \"PL\" = \"POLAND\",\n                                         \"HU\" = \"HUNGARY\",\n                                         \"LT\" = \"LITHUANIA\",\n                                         \"MT\" = \"MALTA\",\n                                         \"PT\" = \"PORTUGAL\",\n                                         \"LV\" = \"LATVIA\",\n                                         \"SK\" = \"SLOVAKIA\",\n                                         \"HR\" = \"CROATIA\",\n                                         \"EL\" = \"GREECE\",\n                                         \"IT\" = \"ITALY\",\n                                         \"RS\" = \"SERBIA\",\n                                         \"BG\" = \"BULGARIA\",\n                                         \"ME\" = \"MONTENEGRO\",\n                                         \"TR\" = \"TURKEY\",\n                                         \"RO\" = \"ROMANIA\",\n                                         \"CY\" = \"CYPRUS\",\n                                         \"DE\" = \"GERMANY\")\n\n# Re-plot the graph with full country names\nggplot(data_aggregated_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors, na.translate = FALSE) +\n  labs(title = \"Book reading habits over past 12 months, 2022\",\n       subtitle = \"(% of people aged 16 and over)\",\n       x = NULL,\n       y = \"Percentage\",\n       fill = \" \") +\n  scale_y_continuous(breaks = seq(0, 100, by = 10)) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"top\",\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.background = element_rect(fill = \"#f5f5f5\", color = NA),\n    plot.background = element_rect(fill = \"#f5f5f5\", color = NA)\n  )\n\n\n\nFurther adjustments\nBold Title\n\n\nggplot(data_aggregated_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  scale_fill_manual(values = colors, na.translate = FALSE) +\n  labs(title = \"Book reading habits over past 12 months, 2022\",\n       subtitle = \"(% of people aged 16 and over)\",\n       x = NULL,\n       y = \"Percentage\",\n       fill = \" \") +\n  scale_y_continuous(breaks = seq(0, 100, by = 10)) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    legend.position = \"top\",\n    plot.title = element_text(face = \"bold\"),  # Make the title bold\n    plot.subtitle = element_text(face = \"italic\"),  # Subtitle italic\n    panel.background = element_rect(fill = \"#f5f5f5\", color = NA),\n    plot.background = element_rect(fill = \"#f5f5f5\", color = NA)\n  )\n\n\n\nMy graph enhancement\nFor my graph replication, I opted to separate each country’s bars to make it easier to distinguish between the various categories of books read. Each book category is represented by a separate bar for clarity. As part of the process, I loaded the necessary libraries and data, then I did some data cleaning and transformation to prepare it for visualization: (1) filter the data for 2022 and specific columns, (2) convert OBS_VALUE to numeric, (3) recode n_book with descriptive labels, (4) reorder n_book levels, (5) rename geo for EU regions, (6) filter out specific regions and categories.\n\n\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(sysfonts)\nlibrary(showtext)\n\n\n\n\ndata <- read.csv(file = \"data/ilc_scp27_linear.csv\")\n\n# data cleaning and transformation:\n\n# Filter the data for the year 2022 and relevant columns\ndata_filtered <- data %>%\n  filter(TIME_PERIOD == 2022, unit == \"PC\") %>%\n  select(geo, n_book, OBS_VALUE) %>%\n  mutate(n_book = as.factor(n_book))\n\n# Convert OBS_VALUE to numeric\ndata_filtered$OBS_VALUE <- as.numeric(data_filtered$OBS_VALUE)\n\n# Recode the 'n_book' column with more descriptive labels\ndata_filtered$n_book <- recode(data_filtered$n_book, \n                               `0` = \"0 books\",\n                               `LT5` = \"Less than 5 books\",\n                               `5-9` = \"5 to 9 books\",\n                               `GE10` = \"10 books or more\")\n\n# Reorder the levels of n_book factor\ndata_filtered$n_book <- factor(data_filtered$n_book,\n                               levels = c(\"10 books or more\", \"5 to 9 books\",\n                                          \"Less than 5 books\"))\n\n# Replace EU27_2020 with EU\ndata_filtered$geo <- recode(data_filtered$geo, \"EU27_2020\" = \"EU\")\n\n# Remove EA20 and \"0 books\" category\ndata_filtered <- data_filtered %>%\n  filter(geo != \"EA20\" & n_book != \"0 books\")\n\n\nThen:\nAggregating and adding dummy data: aggregate data by geo and n_book, add dummy rows for spacing;\n\n\n# Aggregate data to avoid duplicates (if any)\ndata_aggregated <- data_filtered %>%\n  group_by(geo, n_book) %>%\n  summarise(OBS_VALUE = mean(OBS_VALUE, na.rm = TRUE)) %>%\n  ungroup()\n\n# Add dummy rows for spacing\ndummy_data <- data.frame(\n  geo = \" \",\n  n_book = unique(data_aggregated$n_book),\n  OBS_VALUE = 0\n)\n\n# Combine real data and dummy data\ndata_with_space <- bind_rows(data_aggregated, dummy_data)\n\n\nReordering Geographic Regions: determine the order for geo, apply the order to geo, rename country codes to full names;\n\n\n# Order the geo factor: EU first, descending total values, then NO/CH, and space at the end\ngeo_order <- data_aggregated %>%\n  group_by(geo) %>%\n  summarise(total_value = sum(OBS_VALUE, na.rm = TRUE)) %>%\n  arrange(desc(total_value)) %>%\n  pull(geo)\n\ngeo_order_final <- c(\"EU\", geo_order[!(geo_order %in% c(\"EU\", \"NO\", \"CH\"))], \"NO\", \"CH\", \" \")\n\n# Apply the new order to the geo factor\ndata_with_space$geo <- factor(data_with_space$geo, levels = geo_order_final)\n\ndata_with_space$geo <- recode(data_with_space$geo,\n                                         \"EU\" = \"EU\",\n                                         \" \" = \" \",\n                                         \"CH\" = \"SWITZERLAND\",\n                                         \"LU\" = \"LUXEMBOURG\",\n                                         \"DK\" = \"DENMARK\",\n                                         \"NO\" = \"NORWAY\",\n                                         \"SE\" = \"SWEDEN\",\n                                         \"FI\" = \"FINLAND\",\n                                         \"EE\" = \"ESTONIA\",\n                                         \"NL\" = \"NETHERLANDS\",\n                                         \"IE\" = \"IRELAND\",\n                                         \"CZ\" = \"CZECHIA\",\n                                         \"AT\" = \"AUSTRIA\",\n                                         \"FR\" = \"FRANCE\",\n                                         \"SI\" = \"SLOVENIA\",\n                                         \"BE\" = \"BELGIUM\",\n                                         \"ES\" = \"SPAIN\",\n                                         \"PL\" = \"POLAND\",\n                                         \"HU\" = \"HUNGARY\",\n                                         \"LT\" = \"LITHUANIA\",\n                                         \"MT\" = \"MALTA\",\n                                         \"PT\" = \"PORTUGAL\",\n                                         \"LV\" = \"LATVIA\",\n                                         \"SK\" = \"SLOVAKIA\",\n                                         \"HR\" = \"CROATIA\",\n                                         \"EL\" = \"GREECE\",\n                                         \"IT\" = \"ITALY\",\n                                         \"RS\" = \"SERBIA\",\n                                         \"BG\" = \"BULGARIA\",\n                                         \"ME\" = \"MONTENEGRO\",\n                                         \"TR\" = \"TURKEY\",\n                                         \"RO\" = \"ROMANIA\",\n                                         \"CY\" = \"CYPRUS\",\n                                         \"DE\" = \"GERMANY\")\n\n\nDefining Colors for Book Categories: assign specific colors to book categories.\n\n\n# Define colors for book categories\ncolors <- c(\"#DD4F5E\", \"#A5C360\", \"#4ebcd5\")\n\n\nFinally, I moved on generating the graph.\nCreating the graph\nFirst, I generated the bar graph creating a grouped bar chart with geo on the x-axis, OBS_VALUE (percentage) on the y-axis, and n_book categories distinguished by different colors. I adjusted aesthetics (like the legend, title, subtitle, and axis text) and added a background color.\n\n\n#### Plot ####\nggplot(data_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = position_dodge(width = 0.8), width = 0.7) +\n  scale_fill_manual(values = colors) +\n  labs(\n    title = \"Book Reading Habits: 2022\",\n    subtitle = \"Percentage of people aged 16 and over\",\n    x = NULL,\n    y = \"Percentage (%)\",\n    fill = \"Books Read\"\n  ) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    legend.position = \"top\",\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\")\n  )\n\n\n## background color\nggplot(data_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = position_dodge(width = 0.8), width = 0.7) +\n  scale_fill_manual(values = colors) +\n  labs(\n    title = \"Book Reading Habits: 2022\",\n    subtitle = \"(Percentage of people aged 16 and over)\",\n    x = NULL,\n    y = \"Percentage\",\n    fill = \"Books Read\"\n  ) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    legend.position = \"top\",\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.background = element_rect(fill = \"#eeeee4\", color = NA),\n    plot.background = element_rect(fill = \"#eeeee4\", color = NA)\n  )\n\n\n\nSome shortcomings\nI tried to add numbers, but I don’t like it.\n\n\n# numbers?\nggplot(data_with_space, aes(x = geo, y = OBS_VALUE, fill = n_book)) +\n  geom_bar(stat = \"identity\", position = position_dodge(width = 0.8), width = 0.7) +\n  geom_text(\n    aes(label = round(OBS_VALUE, 1)), \n    position = position_dodge(width = 0.8),\n    vjust = -0.5, \n    size = 3\n  ) +\n  scale_fill_manual(values = colors) +\n  labs(\n    title = \"Book Reading Habits: 2022\",\n    subtitle = \"Percentage of people aged 16 and over\",\n    x = NULL,\n    y = \"Percentage (%)\",\n    fill = \"Books Read\"\n  ) +\n  theme_minimal(base_family = \"roboto_condensed\") +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    legend.position = \"top\",\n    plot.title = element_text(face = \"bold\"),\n    plot.subtitle = element_text(face = \"italic\"),\n    panel.background = element_rect(fill = \"#eeeee4\", color = NA),\n    plot.background = element_rect(fill = \"#eeeee4\", color = NA)\n  )\n\n\n\nI tried creating bars by “stacking books”, but looked nothing like it.\n\n\n# Load libraries\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Example Data: Replace with your actual dataset\ndata_filtered <- data.frame(\n  geo = c(\"EU\", \"EU\", \"EU\", \"CH\", \"CH\", \"CH\", \"LU\", \"LU\", \"LU\",\n          \"DK\", \"DK\", \"DK\", \"NO\", \"NO\", \"NO\", \"SE\", \"SE\", \"SE\", \"FI\", \"FI\", \"FI\", \n          \"EE\", \"EE\", \"EE\", \"NL\", \"NL\", \"NL\", \"IE\", \"IE\", \"IE\", \"CZ\", \"CZ\", \"CZ\", \n          \"AT\", \"AT\", \"AT\", \"FR\", \"FR\", \"FR\", \"SI\", \"SI\", \"SI\", \"BE\", \"BE\", \"BE\",\n          \"ES\", \"ES\", \"ES\", \"PL\", \"PL\", \"PL\", \"HU\", \"HU\", \"HU\", \"LT\", \"LT\", \"LT\", \n          \"MT\", \"MT\", \"MT\", \"PT\", \"PT\", \"PT\", \"LV\", \"LV\", \"LV\", \"SK\", \"SK\", \"SK\", \n          \"HR\", \"HR\", \"HR\", \"EL\", \"EL\", \"EL\", \"IT\", \"IT\", \"IT\", \"RS\", \"RS\", \"RS\",\n          \"BG\", \"BG\", \"BG\", \"ME\", \"ME\", \"ME\", \"TR\", \"TR\", \"TR\", \"RO\", \"RO\", \"RO\", \n          \"CY\", \"CY\", \"CY\", \"DE\", \"DE\", \"DE\"),\n  n_book = c(\"10 books or more\", \"5 to 9 books\", \"Less than 5 books\",\n             \"10 books or more\", \"5 to 9 books\", \"Less than 5 books\",\n             \"10 books or more\", \"5 to 9 books\", \"Less than 5 books\"),\n  OBS_VALUE = c(30, 40, 30, 20, 50, 30, 10, 60, 30)\n)\n\n# Duplicate rows to simulate \"stacked books\"\nbooks_data <- data_filtered %>%\n  mutate(num_books = round(OBS_VALUE / 5)) %>%\n  uncount(num_books, .id = \"book_id\") %>%   \n  group_by(geo, n_book) %>%\n  mutate(y_position = row_number())             \n\n# Plot using geom_tile()\nggplot(books_data, aes(x = geo, y = y_position, fill = n_book)) +\n  geom_tile(width = 0.7, height = 0.3, color = \"white\") +  \n  scale_fill_manual(\n    values = c(\"Less than 5 books\" = \"#a8c9a8\",\n               \"5 to 9 books\" = \"#4b8b4b\",\n               \"10 books or more\" = \"#2d4d2d\")\n  ) +\n  labs(\n    title = \"Reading Habits in Europe\",\n    subtitle = \"Each tile represents a 'book' read\",\n    x = NULL,\n    y = \"Book Count\",\n    fill = \"Books Read\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    panel.grid = element_blank(),\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2024/100446517/100446517_files/figure-html5/unnamed-chunk-20-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100528259/",
    "title": "An 8-Bit Look at the Evolution of BMI Values of Olympic Athletes",
    "description": "This study displays the evolution of BMI values of Olympic athletes who \ncompeted in the Summer Olympic Games of 1960 and 2016.",
    "author": [
      {
        "name": "Gür Piren",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nOriginal Chart\nPackages and fonts\nReplication\nWorking with the data\nPlotting\nDownsides of the original plot\n\nAlternative Plot\nPossible improvements\nChallenges\nWorking with the data\nPlotting\n\nAlternative Plot After Class Presentation\nWorking with the data\nOnto the plot\n\nConcluding Notes\n\nOriginal Chart\nThe Olympic Games have long been a platform to showcase the pinnacle of human performance and athleticism. Over the years, the physical features of athletes competing in these prestigious events have transformed significantly. This chart from Visual Capitalist displays the evolution of Olympic athletes’ sizes, illustrating trends in height and weight across sports and genders. It utilises BMI categories to place various sports to capture changes over time.\nThere are several reasons as to why I picked this plot. At first sight, it attracts attention with its coloured tiles, and it looks well-organised with the facets and labeled data points. Getting above such features with a brand new design seemed challenging - and I liked the idea.\nSecond, after careful exploration, I noticed that there was something wrong with the representation of sports: some sports were not present in the 1960 Summer Olympic games, however they were displayed it the facets that demonstrate 2016 games, which was precisely the moment that gave me the idea that this work was in fact not perfect.\nTo not spoil all the fun by revealing the ideas, let’s proceed to data cleaning and adjusting section.\nOlympic Graph. Source: Visual CapitalistPackages and fonts\n\n\n# For replication graph\n\nlibrary(tidyverse)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggrepel)\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\n\n# Extras - For alternative plot\n\nlibrary(grid)\nlibrary(ggtext)\nlibrary(gridExtra)\n\n\n# Fonts for the replication plot \n\nfont_add_google(\"Crimson Pro\", \"crimson-pro\")\nfont_add_google(\"Outfit\", \"outfit\")\nfont_add_google(\"Cormorant Garamond\", \"cormorant-garamond\")\nfont_add_google(\"Montserrat\", \"Montserrat\")\nfont_add_google(\"Archivo Black\", \"ArchivoBlack\")\nfont_add_google(\"Piazzolla\", \"PiazzollaExtraLight\")\n\n# Fonts for the improved plot\n\nfont_add_google(\"Press Start 2P\", \"press-start\")\nfont_add_google(\"VT323\", \"vt323\") \nfont_add_google(\"DotGothic16\", \"dotgothic16\")\n\nshowtext_auto()\n\n\nThe data set displays personal records of Olympic athletes.\nThe original plot focuses on athletes who are at least 20 years old and competed in 1960 and 2016 Summer Olympic games. Taking into account their height and weight values, it then calculates BMI values of athletes and categorise them.\nIn so doing, it creates four different facets and coloured tiles in each one of them. Obviously, each colour tile represents a BMI category.\nThe four facets are designed to represent 1960 and 2016 Summer Olympic games, and male and female athletes.\nReplication\nWorking with the data\nReading the dataset\n\n\ndata_main <- read_csv(\"athlete_events.csv\")\n\n\nAs we will only need the sports branches, Olympic game’s year information and the name, gender, and the BMI values of the athletes, I get rid of everything else.\n\n\nolympics_tidy <- data_main |> \n  filter(Age >= 20, Year %in% c(2016, 1960), Season == \"Summer\") |> \n  select(-c(Team, Games, NOC, City, Event, Medal)) |> \n  distinct(Name, .keep_all = TRUE)\n\n\nSome athletes have no height or weight (or either) info. This is just to have an idea of what’s going on.\n\n\nmissing_values <- olympics_tidy |> \n  summarize(\n    missing_height = sum(is.na(Height)),\n    missing_weight = sum(is.na(Weight))\n  )\n\nmissing_values\n\n# A tibble: 1 × 2\n  missing_height missing_weight\n           <int>          <int>\n1            255            326\n\nI want to create a BMI variable for future use, as BMIs will be the main concern of this study.\n\n\nolympics_tidy <-\n  olympics_tidy |> \n  mutate(BMI = Weight / (Height / 100)^2)\n\n\nNow let’s acquire the means for height, weight, and BMI values for different branches, across genders and for the two Olympic games.\n\n\nolympics_tidy <- olympics_tidy |> \n  summarise(\n    height_mean = mean(Height, na.rm = TRUE), \n    weight_mean = mean(Weight, na.rm = TRUE),\n    BMI_mean = mean(BMI, na.rm = TRUE),\n    .by = c(\"Sport\", \"Sex\", \"Year\"))\n\n\nRecoding ‘Sex’ for better readability.\n\n\nolympics_tidy <- olympics_tidy |> \n  mutate(Sex = recode(Sex, `M` = \"Men\", `F` = \"Women\"))\n\n\nAlthough the values range from 30 to 170 for weight and from 143 to 218 for height, the graph seems to omit some observations and use different ranges.\nAfter a careful and (highly) manual measurement, I decided that for weight the range would be from 45 to 105, and for height it would be 155 and 205.\nThis can be observed in the original graph.\nSince I’ll be viusalising ‘Gender’ and changes in ‘Height’, ‘Weight’, I will be using facets.\nLet’s organise the data taking into account the new value ranges indicated above, and then proceed to labeling BMI ranges.\nTo do that, I first reframe my data set indicating new ranges for Height and Weight values.\nFollowing this, I create a new variable named ‘BMI Label’, which will store BMI categories and their values. Then, this variable will help create tiles for each BMI category.\nUsing ‘ordered = TRUE’, I ensure the logical order between ‘Underweight’, ‘Normal’, ‘Overweight’, and ‘Obese’ categories.\n\n\nolympics_reframed <- crossing(\n  Height = 155:205,\n  Weight = 45:105,\n  Sex = c(\"Men\", \"Women\"),\n  Year = c(1960, 2016)\n) |> \n  mutate(\n    BMI = Weight / (Height / 100)^2,\n    `BMI Label` = factor(case_when(\n      BMI <= 18.5 ~ \"Underweight\",    \n      BMI > 18.5 & BMI <= 24.9 ~ \"Normal\",  \n      BMI > 24.9 & BMI <= 29.9 ~ \"Overweight\", \n      BMI > 29.9 ~ \"Obese\"\n    ), \n    levels = c(\"Underweight\", \"Normal\", \"Overweight\", \"Obese\"), \n    ordered = TRUE)\n  )\n\n\nPlotting\nLet’s begin with stating x any y axes. I will use ‘weight_mean’ and ‘height_mean’ from ‘olympics_tidy’ data set.\nNext, ‘geom_tile’ will enable me to create tiles based on BMI categories that I have indicated in ‘BMI Label’ column in ‘olympics_reframed’.\nI have used a separate data set called ‘olympics_reframed’ for my own ease. All these information could probably work out together in a single data set.\nThe filling of the tiles will be automatic. I will be changing it in the next step.\n\n\nfinal_graph <- ggplot(olympics_tidy) +\n  aes(weight_mean, height_mean) +\n  geom_tile(data = olympics_reframed, aes(x = Weight, y = Height, fill = `BMI Label`))\n\nfinal_graph\n\n\n\nHere, I enhance the appearance of my existing graph by customizing the fill colours for different BMI categories. I use scale_fill_manual() to manually set specific colours for each category, such as “Underweight,” “Normal,” “Overweight,” and “Obese,” assigning colours as close as possible to the original plot.\nI also adjust the legend with setting ‘guides()’ to NULL in order to remove the title.\n\n\nfinal_graph <-\n  final_graph +\n  scale_fill_manual(values = c(\n    \"Underweight\" = \"cadetblue2\",\n    \"Normal\" = \"darkolivegreen2\",\n    \"Overweight\" = \"lightgoldenrod1\",\n    \"Obese\" = \"lightcoral\")) +\n  guides(fill = guide_legend(title = NULL))\n\nfinal_graph\n\n\n\nIt’s time to set the title and subtitle for of the plot and add axes titles. Lastly, I add the caption at the bottom right of the original plot indicating the source of data.\n\n\nfinal_graph <-\n  final_graph +\n  labs(\n    x = \"WEIGHT (KG)\",\n    y = \"HEIGHT (CM)\",\n    title = \"OLYMPIC ATHLETES ARE GETTING BIGGER\",\n    subtitle = \"Mean weight and height by sport at the 1960 and 2016 Summer Olympics. Values calculated \\nfor athletes 20 years or older, compared to the BMI classification for the general population.\",\n    caption = \"Source: Kaggle • Graphic: Georgios Karamanis\"\n  ) \nfinal_graph\n\n\n\nNo party without our good old friends: data points! Using geom_point, I invite them to the party.\n\n\nfinal_graph <-\n  final_graph +\n  geom_point()\n\nfinal_graph\n\n\n\nSince I will be comparing 1960 and 2016 Summer Olympics while displaying BMI values based on gender, I will need 4 different facets.\nThe ‘Sex’ variable has two values (Men and Women), and the ‘Year’ variable only has 1960 and 2016. Therefore, four facets.\nLastly, I tell R to not add extra space to x and y axes using coord_cartesian(expand = FALSE).\n\n\nfinal_graph <-\n  final_graph +\n  facet_grid(Sex ~ Year) +\n  coord_cartesian(expand = FALSE) \n\nfinal_graph\n\n\n\nIn the original plot, the legend is located at the top, right below the subtitle. First I relocate it on the top and ensure that it is centered. Then, I place it in a horizontal way. Lastly, I ensure that the legend key sizes somewhat match to that of original plot.\n\n\nfinal_graph <-\n  final_graph +\n  theme(\n    legend.position = \"top\",           \n    legend.justification = \"center\",     \n    legend.direction = \"horizontal\",\n    legend.key.size = unit(0.7, \"cm\")\n    )\n\nfinal_graph\n\n\n\nUsing strip.text, I ensure the colour for texts in the strips and match their size to the original plot.\nUsing plot.title and plot.subtitle, I set sizes, alignments, and margins of the title and subtitle. For the title, I use ‘ArchivoBlack’, and for the subtitle, I use ‘Montserrat’ (both from Google fonts).\nAfter setting the margins of the plot and the caption that is at the bottom right, I move to indicating sizes for the legend, x and y axes (for both axis texts and axis titles).\nFor axis titles, I use ‘cormorant-garamond’ from Google fonts.\nLastly, I change the background colour for facet strips and set the colour for outer borders to = NA. This way, it will look as if I have no borders for the strips.\n\n\nfinal_graph <-\n  final_graph +\n  theme(\n    strip.text = element_text(color = \"black\", size = 20),\n    plot.title = element_text(size = 36, hjust = 0.5, family = \"ArchivoBlack\",\n                              margin = margin(t = 10, b = 5, l = 15, r = 15)),\n    plot.subtitle = element_text(size = 18, hjust = 0.5, family = \"Montserrat\",\n                                 face = \"plain\", lineheight = 1, margin = margin(t = 5, b = 10, l = 15, r = 15), color = \"grey15\"),\n    plot.margin = margin(20, 10, 10, 10),\n    plot.caption = element_text(size = 16, hjust = 1, lineheight = 1.2),\n    legend.text = element_text(size = 14),  \n    axis.text.x = element_text(size = 14),  \n    axis.text.y = element_text(size = 14),\n    axis.title.x = element_text(size = 16, family = \"cormorant-garamond\"),\n    axis.title.y = element_text(size = 16, family = \"cormorant-garamond\"),\n    strip.background = element_rect(fill = \"gray95\", color = NA),\n    plot.background = element_rect(fill = \"gray95\"),\n    legend.background = element_rect(fill = \"gray95\")\n)\n\n\n\n\nfinal_graph\n\n\n\nThe only thing that is missing right now (pretty much) is labeling data points.\nTo make it look a bit more like the original plot, I begin with changing the colour, size, and the transparency level of my data points. (see geom_point(…)).\nThanks to geom_text_repel, I will be able to put labels to the data points. Since each data point represents an Olympic sport, these texts will be name of Olympic sports.\nFirstly, I ensure all sports names are in capital letters, using ‘label = toupper(Spor)’.\nNext, I set the font of data labels to ‘Montserrat’ and set their size to 4.\nTo have a clean and readable plot, I had to ensure that text labels do not overlap. Using ‘nudge_x’ and ‘nudge_y’, I slightly moved text labels horizontally and vertically. ‘box.padding’, on the other hand, adds padding around each label’s box to create more space between the text and other elements, so it helps the cause dearly. Lastly, using ‘max.overlaps’, I ensured to limit the maximum number of overlapping labels to be shown; so that excess overlaps are suppressed.\n‘min.segment.length’ helps me to somewhat restrict as to which connecting lines will be displayed, so I set it to 1.2 and disable the ones that would be longer than that value. With ‘segment.size’, I make those connecting lines extremely thin and through ‘segment.color’, their colour is indicated as ‘grey30’.\nI use the same colour for my text labels using “color = ‘grey30’”. Lastly, I hide a possible legend for the data labels through ‘show.legend = FALSE’.\n\n\nfinal_graph <-\n  final_graph +\n  geom_point(color = \"gray40\", size = 1.5, alpha = 0.7) +\n  geom_text_repel(aes(label = toupper(Sport)),\n                  family = \"Montserrat\",  \n                  size = 4,              \n                  nudge_y = 3,          \n                  nudge_x = 1.5,          \n                  box.padding = 0.75,    \n                  max.overlaps = 15, \n                  min.segment.length = 1.2,\n                  segment.size = 0.1,\n                  segment.color = \"grey30\",\n                  color = \"grey30\",\n                  show.legend = FALSE)  \n\nfinal_graph\n\n\n\nDownsides of the original plot\nThe initial plot displays some Olympic events that did not exist in 1960 but took place in the 2016 Olympic Games (e.g., Tennis). I don’t need to show them as they do not contribute to the study and add noise to the data, particularly in women’s sports. This is due to the fact that women’s sports were not as diverse in 1960 as they were in 2016.\nThere are extremely few or no ‘Underweight’ and ‘Obese’ athletes in the initial study. Using tiles for nonexistent categories seems redundant.\nAnother issue with the plot is that the data point trends are not easy to follow. For any sport, it is quite difficult to determine whether it has experienced an increase or decrease over time.\nAlternative Plot\nPossible improvements\nAs the original plot’s biggest weakness is the difficulty in tracking individual sports’ trends over time, I try to address this issue by using a slope chart as my alternative plot. A slope chart is useful when comparing trends over time, using two data points for each observation and a line that connects those two data points.\nMost sports branches have somewhat similar BMI values, which eventually leads to a plot that has many overlappings. A slope chart is likely to reduce those overlappings while still emphasising trends.\nI can change the title, coming up with a more striking one. Also I can use a fancy font. The font and colouring has actually been my favourite part for this study.\nWho does not love 8-bit stuff? Well, not me. The inspiration of my alternative plot will be 8-bit aesthetics. I had to do it, because for my whole childhood I played ‘Track & Field’!\nChallenges\nThe closely clustered nature of the data points and the lack of direct connections between 1960 and 2016 data for each sport make trend analysis challenging. I will try to address these issues in my slope chart, but highly close numbers of BMI values pose threats to clarity of my plot.\nIn my first attempt, I completely excluded women’s sports that were present in both Olympic games (which amounted to 6 branches in total).\nIn the second attempt, I’ll omit some of the men’s sports branches and include women’s sports into my plot. But for now, let’s move onto the first one.\nWorking with the data\nLet’s first read the data and start with the improvement.\n\n\nathletes <- read_csv(\"athlete_events.csv\")\n\n\nAs the original study suggests, I filter 1960 and 2016 Summer Olympic Games, and athletes that were at least 20 years old.\nThen I move onto create a BMI variable for the athletes in my dataset.\n\n\nathletes <- athletes |> \n  filter(Year %in% c(1960, 2016), Season == \"Summer\", Age >= 20) |> \n  mutate(BMI = Weight / (Height / 100)^2)\n\n\nIn this chunk of code, I create two subsets of my dataset that will display sports branches that male athletes competed in 1960 and 2016 Summer Olmypics.\nLastly, I want to see which sports are common in both Olympic games to prevent data noise in the future. Using ‘pull’, I acquire those sports for each year and then store their intersection in ‘common_sports_men’.\n\n\nsports_1960_men <- athletes |> \n  filter(Year == 1960, Sex == \"M\") |> \n  pull(Sport)\n\nsports_2016_men <- athletes |> \n  filter(Year == 2016, Sex == \"M\") |> \n  pull(Sport)\n\n\ncommon_sports_men <- intersect(sports_1960_men, sports_2016_men)\n\n\nTo create a subset of data with only male athletes that competed in intersecting sports, I filter my dataset. Then, for a tidy table, I drop unnecessary columns.\n\n\nfiltered_male_athletes <- athletes |> \n  filter(Sex == \"M\" & Sport %in% common_sports_men) |> \n  select(-Name, -Team, -NOC, -Games, -City, -Event, -Medal)\n\n\nNow I am at the point where I need to create an average BMI value for each sports in my dataset. I group BMI values by ‘Year’ and ‘Sports’ as they will be displayed on the basis of competition year and event type.\nThen I sort them in alphabetical order for my own use.\n\n\navg_bmi_men <- filtered_male_athletes |> \n  group_by(Sport, Year) |> \n  summarize(Avg_BMI = mean(BMI, na.rm = TRUE), .groups = 'drop')\n\navg_bmi_men <- avg_bmi_men |> \n  arrange(Sport)\n\n\nThis is where I manually group sports for each facet, considering their BMI values in 1960 and 2016. This way, I am planning to reduce overlappings as efficiently as possible.\n\n\navg_bmi_men <- avg_bmi_men |> \n  mutate(Facet_Group = case_when(\n    Sport %in% c(\"Water Polo\", \"Sailing\", \"Hockey\", \"Diving\", \"Football\") ~ \"1\",\n    Sport %in% c(\"Shooting\", \"Modern Pentathlon\", \"Rowing\", \"Cycling\", \"Wrestling\") ~ \"2\",\n    Sport %in% c(\"Weightlifting\", \"Swimming\", \"Athletics\", \"Boxing\", \"Canoeing\") ~ \"3\",\n    TRUE ~ \"4\"\n  ))\n\n\nThis was one of my favourite parts doing my alternative plot. Retro work!!\nThe aesthetics of my plot will be providing a retro look.\nSo, I assign colours for each sports so that they will (try to) not confuse the reader.\n\n\nretro_colours <- c(\n  \"Athletics\" = \"#00a046\",       \n  \"Basketball\" = \"#FF6F20\",     \n  \"Boxing\" = \"#fcab98\",         \n  \"Canoeing\" = \"#7fcdbb\",        \n  \"Cycling\" = \"#bcbddc\",        \n  \"Diving\" = \"#000000\",          \n  \"Equestrianism\" = \"#a65628\",   \n  \"Fencing\" = \"#A3D900\",         \n  \"Football\" = \"#ec213e\",        \n  \"Gymnastics\" = \"#d8b365\",      \n  \"Hockey\" = \"#F1C40F\",          \n  \"Modern Pentathlon\" = \"#FF448C\",\n  \"Rowing\" = \"#10EA00\",          \n  \"Sailing\" = \"#636363\",         \n  \"Shooting\" = \"#D167BF\",        \n  \"Swimming\" = \"#4400AA\",         \n  \"Weightlifting\" = \"#7A9A01\",   \n  \"Wrestling\" = \"#80BFFF\",       \n  \"Water Polo\" = \"#0057A1\"       \n)\n\n\nPlotting\nFrom the avg_bmi_men table, I extract BMI values for both years and genders. Next, I specify the x and y axes for my plot. Lastly, I ensure that the grouping is based on the type of sport.\nThe geom_line function helps me create lines that connect values from two Olympic years. Using the ‘linetype’ parameter, I apply dotted lines to give an 8-bit feel to the plot. Similarly, by using ‘geom_point’, I employ square-shaped data points and adjust their size.\nWith ‘facet_wrap’, I arrange the sports in facets that I matched earlier. By using ‘ncol = 2’, I display all my facets in two columns.\n\n\nimproved_graph <- \n  ggplot(avg_bmi_men, aes(x = factor(Year), y = Avg_BMI, group = Sport, color = Sport)) +\n  geom_line(linetype = \"dotted\", linewidth = 1.5) + \n  geom_point(size = 2, shape = 15) +\n  facet_wrap(~ Facet_Group, ncol = 2) \n\nimproved_graph\n\n\n\nQuickly changing the structure of the legend into a two-column one. I will be using the space below the legend.\n\n\nimproved_graph <-\n  improved_graph +\n  guides(color = guide_legend(ncol = 2))\n\nimproved_graph\n\n\n\nIt is time I name the title, subtitle, and caption, as well as the x and y axes.\nI also change the randomly assigned colors of data points and lines to the colors I manually picked and stored in ‘retro_colours’ earlier.\nAs the BMI values range between 20 and 29, I customize the y-axis, ensuring that the values increment by 1 unit (scale_y_continuous).\n\n\nimproved_graph <-\n  improved_graph + \n  labs(title = \"Avg. BMI of Male Olympic Athletes \\nby Sport (1960 vs 2016)\",\n       subtitle = \"Have they lowkey gotten fatter?\",\n       caption = \"My first ever original plot © \",\n       x = \"Year\",\n       y = \"Average BMI\",\n       color = \"Olympic sports\") +\n  scale_color_manual(values = retro_colours) +\n  scale_y_continuous(breaks = seq(20, 29, by = 1)) \n\nimproved_graph\n\n\n\nI customise the plot title using ‘plot.title’, applying the “press-start” font for consistency, and set it to bold for emphasis.\nFor the plot subtitle, I use ‘plot.subtitle’ with the “vt323” font from Google fonts, adjusting the alignment to ensure it appears centred below the title.\n\n\nimproved_graph <-\n  improved_graph +\n  theme(\n    plot.title = element_text(family = \"press-start\", size = 10, face = \"bold\", \n                              hjust = 0.2, color = \"yellow2\"),  \n    plot.subtitle = element_text(family = \"vt323\", size = 14, hjust = 0.5, color = \"#abdbe3\")\n  )\n\nimproved_graph\n\n\n\nI customise the axis text using ‘axis.text’, setting the colour to light blue and applying the “press-start” font for a consistent style.\nThe axis titles are styled with ‘axis.title’, making them bold and yellow to ensure they stand out.\n\n\nimproved_graph <-\n  improved_graph +\n  theme(\n    axis.text = element_text(size = 5, color = \"lightblue1\", family = \"press-start\"), \n    axis.title = element_text(size = 8, face = \"bold\", family = \"press-start\", color = \"yellow2\"),\n  )\n\nimproved_graph\n\n\n\nI set the plot background colour using ‘plot.background’, filling it with a dark grey. The panel background is customised with ‘panel.background’, applying a lighter grey and defining a subtle border for clear look of sections. For the grid lines, I adjust the major grid lines using ‘panel.grid.major’, setting their colour to a light grey.\nI also configure the minor grid lines with ‘panel.grid.minor’, ensuring they maintain a harmonious appearance with a very light grey.\n\n\nimproved_graph <-\n  improved_graph +\n  theme(\n   plot.background = element_rect(fill = \"grey15\"),  \n    panel.background = element_rect(fill = \"grey95\", color =\"grey95\", linewidth = 2),     \n    panel.grid.major = element_line(color = \"grey90\"),     \n    panel.grid.minor = element_line(color = \"grey95\")\n  )\n\nimproved_graph\n\n\n\nI position the legend on the right with ‘legend.position’, ensuring a clean layout. The legend title is styled with ‘legend.title’. I also apply the “press-start” font here. I adjust the size of the legend keys with ‘legend.key.size’. For the legend text, I use ‘legend.text’ to define the font properties and colour, enhancing readability.\nThe background of the legend is refined using ‘legend.background’, to give it a light grey fill with a subtle border for better definition.\nI remove the facet strip titles by setting ‘strip.text to element_blank()’, because I do not want to see them.\n\n\nimproved_graph <-\n  improved_graph +\n  theme(\n    legend.position = \"right\",\n    legend.title = element_text(family = \"press-start\",\n                                size = 10,\n                                color = \"blue\"),  \n    legend.key.size = unit(0.4, \"cm\"),  \n    legend.text = element_text(size = 5, family = \"press-start\", color = \"blue\"),  \n    legend.background = element_rect(fill = \"grey95\", color = \"grey70\", size = 2),  \n    strip.text = element_blank()\n  )\n\nimproved_graph\n\n\n\nFor the honours, let’s put the copyright.\nUsing ‘plot.caption’ and ‘plot.margin’, I set the properties of my caption such as the font type, size colour, alignment, and margin.\nLastly, I adjust the overall plot margins using ‘plot.margin’, defining the space around the entire plot.\n\n\nimproved_graph <-\n  improved_graph +\n  labs(\n    caption = \"My first ever original plot © \") +\n  theme(\n   plot.caption = element_text(size = 6, family = \"press-start\", color = \"yellow2\",\n                                hjust = 2.2, margin = margin(b = 14)),\n   plot.margin = margin(7, 12, 1, 5)\n)\n\nimproved_graph\n\n\n\nI then create an annotation background using a light grey rectangle and add text to it, explaining the BMI categories: ‘Underweight’, ‘Normal’, ‘Overweight’, and ‘Obese’, all styled with a blue color.\nFinally, I arrange the main graph alongside the annotation so that the graph occupies 92% of the height and the annotation takes up 8%, ensuring a clear and informative presentation.\n\n\nannotation_background <- rectGrob(\n  gp = gpar(fill = \"grey90\")  \n)\n\n# Creating the annotation text\nannotation_grob <- textGrob(\n  \"BMI ≤ 18.5 'Underweight' 18.5 < BMI < 25 'Normal' 25 ≤ BMI < 30 'Overweight' BMI ≥ 30 'Obese'\", \n  gp = gpar(fontsize = 5, \n            fontfamily = \"press-start\", \n            col = \"blue\")\n)\n\ncombined_annotation <- grobTree(annotation_background, annotation_grob)\n\ngrid.arrange(improved_graph, \n             combined_annotation,  \n             heights = c(0.92, 0.08),  \n             ncol = 1)\n\n\n\nAlternative Plot After Class Presentation\nDuring my presentation for my initial improved plot, I received recommendations on several aspects of my work. At the end of this document, I will put an evaluation for those recommendations and what I have done to address the issues that were raised.\nWorking with the data\nLet’s start with reading the data.\n\n\ndata <- read_csv(\"athlete_events.csv\")\n\n\nI erase the columns that I will not be using.\n\n\ncleaned_data <- data %>%\n  select(-Team, -NOC, -Games, -City, -Event, -Medal)\n\n\nHere, I filter 1960 and 2016 Summer Olympics and athletes >= 20 years old.\n\n\nfiltered_data <- cleaned_data |> \n  filter(Year %in% c(1960, 2016), \n         Season == \"Summer\", \n         Age >= 20)\n\n\nI want to detect those sports that are common in both Olympic game years for men.\n\n\nsports_1960_men <- filtered_data |> \n  filter(Year == 1960, Sex == \"M\") |> \n  pull(Sport)\n\nsports_2016_men <- filtered_data |> \n  filter(Year == 2016, Sex == \"M\") |> \n  pull(Sport)\n\n\nI find the intersection for men, this is essential for ensuring meaningful data representation.\n\n\ncommon_sports_men <- intersect(sports_1960_men, sports_2016_men)\n\ncommon_sports_men\n\n [1] \"Shooting\"          \"Weightlifting\"     \"Football\"         \n [4] \"Boxing\"            \"Water Polo\"        \"Hockey\"           \n [7] \"Wrestling\"         \"Rowing\"            \"Fencing\"          \n[10] \"Athletics\"         \"Basketball\"        \"Cycling\"          \n[13] \"Gymnastics\"        \"Sailing\"           \"Canoeing\"         \n[16] \"Modern Pentathlon\" \"Swimming\"          \"Equestrianism\"    \n[19] \"Diving\"           \n\nThen, I do the same for women, because there is a lot of data noise at women’s sports. Vast majority of women’s sports in 2016 did not exist in 1960 Summer Olympics.\n\n\nsports_1960_women <- filtered_data |> \n  filter(Year == 1960, Sex == \"F\") |> \n  pull(Sport)\n\nsports_2016_women <- filtered_data |> \n  filter(Year == 2016, Sex == \"F\") |> \n  pull(Sport)\n\n\nLet’s find the intersection for women as well.\n\n\ncommon_sports_women <- intersect(sports_1960_women, sports_2016_women)\n\ncommon_sports_women\n\n[1] \"Gymnastics\"    \"Athletics\"     \"Fencing\"       \"Canoeing\"     \n[5] \"Swimming\"      \"Diving\"        \"Equestrianism\" \"Sailing\"      \n\nKeeping only the intersecting sports will help me ensure there is no data noise.\n\n\nolympics <- filtered_data |> \n  filter(Year %in% c(1960, 2016),\n         (Sport %in% common_sports_men & Sex == \"M\") | \n         (Sport %in% common_sports_women & Sex == \"F\"))\n\n\nNow I will work on BMI values and categories. So let’s create a BMI variable first.\n\n\nfiltered_data_BMI <- olympics |> \n  mutate(BMI = Weight / (Height / 100)^2)\n\n\nI calculate average BMI values for each sport.\n\n\navg_BMI <- filtered_data_BMI |> \n  group_by(Sport, Year, Sex) |> \n  summarize(avg_BMI = mean(BMI, na.rm = TRUE), .groups = 'drop')\n\n\nFor the three facets that I will create in my plot, I specify sports.\n\n\navg_BMI <- avg_BMI |> \n  mutate(Facet_Group = case_when(\n    Sport %in% c(\"Water Polo\", \"Wrestling\", \"Swimming\", \"Shooting\", \n                 \"Weightlifting\", \"Gymnastics\", \"Equestrianism\", \"Canoeing\", \"Sailing\", \"Hockey\") ~ \"1\",\n    Sport %in% c(\"Gymnastics\", \"Athletics\", \"Fencing\", \"Canoeing\", \n                 \"Swimming\", \"Diving\", \"Equestrianism\", \"Sailing\") ~ \"2\",\n  ))\n\n\nPicking colours again!\n\n\nretro_colours_2 <- c(\n  \"Athletics\" = \"#00a046\",       \n  \"Basketball\" = \"#FF6F20\",      \n  \"Boxing\" = \"#fcab98\",          \n  \"Canoeing\" = \"#7fcdbb\",        \n  \"Cycling\" = \"#bcbddc\",         \n  \"Diving\" = \"#FF448C\",          \n  \"Gymnastics\" = \"#d8b365\",      \n  \"Hockey\" = \"#F1C40F\",          \n  \"Rowing\" = \"#10EA00\",          \n  \"Sailing\" = \"#4400AA\",         \n  \"Shooting\" = \"#D167BF\",        \n  \"Swimming\" = \"#0057A1\",         \n  \"Weightlifting\" = \"#7A9A01\",   \n  \"Wrestling\" = \"#80BFFF\",       \n  \"Water Polo\" = \"#636363\"  \n)\n\n\nOnto the plot\nIn this section, I define two character vectors for male and female Olympic sports, categorizing them into two groups for men and one for women. These sports are chosen on the basis of their presence in both Olympic Games. In men’s sports, I manually picked those that will display little or no overlap.\n\n\nmen_sports <- c(\"Athletics\", \"Canoeing\", \"Swimming\", \"Shooting\", \"Weightlifting\", \n                \"Gymnastics\", \"Basketball\", \"Boxing\", \"Sailing\", \"Hockey\", \"Wrestling\")\nwomen_sports <- c(\"Gymnastics\", \"Athletics\", \"Fencing\", \n                  \"Canoeing\", \"Swimming\", \"Diving\", \"Sailing\")\n\n\nNext, I enhance the avg_BMI dataset by creating a new column named Facet_Group, which assigns a numeric identifier based on the athlete’s sex and sport. Male athletes participating in sports from men_sports receive a “1,” and female athletes are tagged with a “2” for sports from women_sports.\nAfterwards, I filter the data to keep only the rows with defined Facet_Group values, resulting in the filtered_avg_BMI dataset containing relevant entries.\n\n\navg_BMI <- avg_BMI |> \n  mutate(Facet_Group = case_when(\n    Sport %in% men_sports & Sex == \"M\" ~ \"1\", \n    Sport %in% women_sports & Sex == \"F\" ~ \"2\"\n  ))\n\nfiltered_avg_BMI <- avg_BMI |> \n  filter(!is.na(Facet_Group))\n\n\nThe next step involves visualizing the data with ggplot, where I create improved_graph_2. Here, I specify the x and y axes, grouping by sport and color coding them accordingly. I utilize the geom_line function for connecting lines and geom_point for square-shaped data points. This time, I apply facet_grid to arrange the facets flexibly, with free y-axis scales and labeled to distinguish male and female groups.\n\n\nimproved_graph_2 <- ggplot(filtered_avg_BMI, aes(x = factor(Year), y = avg_BMI, \n                                                 group = Sport, color = Sport)) +\n  geom_line(linewidth = 1.5, linetype = \"dotted\") + \n  geom_point(size = 2, shape = 15) +\n  facet_grid(~ Facet_Group, scales = \"free\", \n             labeller = as_labeller(c(\"1\" = \"Male\", \"2\" = \"Female\")))\n\nimproved_graph_2\n\n\n\nOnce the basic structure is in place, I add the title, subtitle, and axis labels. I also customize the colors for the lines and points using retro_colours_2 and ensure the y-axis is properly segmented with scale_y_continuous.\n\n\nimproved_graph_2 <-\n  improved_graph_2 +\n  labs(title = \"Avg. BMI of Olympic Athletes \\nby Olympic Sports (1960 vs 2016)\",\n       subtitle = \"Have they lowkey gotten fatter?\",\n       x = \"Year\",\n       y = \"Average BMI\",\n       color = \"Olympic Sports\") +\n  scale_color_manual(values = retro_colours_2) + # Custom colors for the sports\n  scale_y_continuous(breaks = seq(20, 29, by = 1))\n\nimproved_graph_2\n\n\n\nUsing ‘plot.title = element(…)’ and ‘plot.subtitle = element(…)’, I set the type, size, alignment, and the colour of fonts for my title and subtitle.\n\n\nimproved_graph_2 <-\n  improved_graph_2 +\n  theme(\n    plot.title = element_text(family = \"press-start\", size = 10, face = \"bold\", \n                              hjust = 0.5, color = \"yellow2\"),\n    plot.subtitle = element_text(family = \"vt323\", size = 14, hjust = 0.5, color = \"#abdbe3\")\n  )\n    \nimproved_graph_2\n\n\n\nThe code ‘plot.background = element_rect(fill = “grey15”)’ sets the plot’s background to dark grey.\nNext, through ‘panel.spacing = unit(1, “lines”)’ I adjust the space between panels, making each section more distinct.\nBy using panel.background = element_rect(fill = “grey95”, color =“grey95”, linewidth = 2), I give each panel a light grey background and a subtle border to clearly define the sections. I set major grid lines to light grey with ‘panel.grid.major = element_line(color = “grey90”)’, ensuring they support readability without being distracting. For minor grid lines, ‘panel.grid.minor = element_line(color = “grey95”)’ maintains a consistent layout.\n\n\nimproved_graph_2 <-\n   improved_graph_2 +\n  theme(\n    plot.background = element_rect(fill = \"grey15\"),\n    panel.spacing = unit(1, \"lines\"),\n    panel.background = element_rect(fill = \"grey95\", color =\"grey95\", linewidth = 2),\n    panel.grid.major = element_line(color = \"grey90\"),  \n    panel.grid.minor = element_line(color = \"grey95\")\n  )\n\nimproved_graph_2\n\n\n\nI adjust the axis text with ‘axis.text’ to enhance visibility and set the colour to light blue. Next, I rotate the y-axis text using ‘axis.text.y’ at an angle for better readability. For the x-axis, I apply ‘axis.text.x’ to angle the text, ensuring clarity for closely spaced labels. This is different from the initial improved plot.\nLastly, I customise the axis titles with ‘axis.title’, making them bold and using a yellow colour to maintain a consistent style.\n\n\nimproved_graph_2 <-\n   improved_graph_2 +\n  theme(\n    axis.text = element_text(size = 5, color = \"lightblue1\", family = \"press-start\"), \n    axis.text.y = element_text( angle = 45),\n    axis.text.x = element_text( angle = 25),\n    axis.title = element_text(size = 8, face = \"bold\", family = \"press-start\",\n                              color = \"yellow2\")\n  )\nimproved_graph_2\n\n\n\nI position the legend on the right using ‘legend.position’. The legend title is customised with ‘legend.title’, I use the font “press-start” font for consistency. Then, I adjust the size of legend keys with ‘legend.key.size’.For the legend text, I use ‘legend.text’ to set the font properties and colour, enhancing its visibility. The background of the legend is changed with ‘legend.background’, providing a light grey fill and a subtle border. I modify the facet strip titles with ‘strip.text’, and it makes them bold and blue for emphasis.\nFinally, guides() helps format the legend layout, positioning it into two columns for better organisation.\n\n\nimproved_graph_2 <-\n  improved_graph_2 +\n  theme(\n    legend.position = \"right\",\n    legend.title = element_text(family = \"press-start\", size = 10, color = \"blue\"),\n    legend.key.size = unit(0.4, \"cm\"),\n    legend.text = element_text(size = 5, family = \"press-start\", color = \"gray15\"),\n    legend.background = element_rect(fill = \"grey95\", color = \"grey70\", size = 2),\n    strip.text = element_text(size = 7, face = \"bold\", family = \"press-start\", color = \"blue\")\n  ) + \n  guides(color = guide_legend(ncol = 2))\n  \n\nimproved_graph_2\n\n\n\nFor the honours, let’s put the copyright.\nUsing ‘plot.caption’ and ‘plot.margin’, I set the properties of my caption such as the font type, size colour, alignment, and margin. Don’t worry about the alignment of the caption for now. The issue will resolve in the next (and last) step.\nLastly, I adjust the overall plot margins using ‘plot.margin’, defining the space around the entire plot.\n\n\nimproved_graph_2 <-\n  improved_graph_2 +\n  labs(\n    caption = \"My first original plot © \"\n  ) +\n  theme(\n    plot.caption = element_text(size = 6, family = \"press-start\", color = \"yellow2\",\n                                hjust = 1.7, margin = margin(b = 10)),\n    plot.margin = margin(7, 12, 1, 5)\n  )\n\nimproved_graph_2\n\n\n\nI conclude this section by organising the plot together with annotations. The ‘annotation_background’ is created using ‘rectGrob’, which provides a rectangular background with a fill colour of grey90. For the text annotation, I employ ‘textGrob’ to add BMI classification information, styling it with the specified size, font family, and blue colour.\nTo combine both the plot and its annotations for final presentation, I utilise grid.arrange, ensuring that the main graph occupies 92% of the height while the annotation takes up the remaining 10%, aligning them in a single column (ncol = 1).\nThis final improved_graph_2 now includes both the graphical data and the informative annotations integrated for better interpretation.\n\n\nannotation_background <- rectGrob(gp = gpar(fill = \"grey90\"))\n\nannotation_grob <- textGrob(\n  \"BMI ≤ 18.5 'Underweight' 18.5 < BMI < 25 'Normal' 25 ≤ BMI < 30 'Overweight' BMI ≥ 30 'Obese'\",\n  gp = gpar(fontsize = 5.5, fontfamily = \"press-start\", col = \"blue\")\n)\n\ncombined_annotation <- grobTree(annotation_background, annotation_grob)\n\n# To combine the plot and annotations\nimproved_graph_2 <- \n  grid.arrange(improved_graph_2, \n             combined_annotation, \n             heights = c(0.92, 0.08),  \n             ncol = 1)\n\n\n\nConcluding Notes\nOne of the main criticisms I received during my plot presentation was that women’s sports were excluded from my initial work. To address this data loss, I considered recommendations from the class and created a fifth facet for women’s sports present in both the 1960 and 2016 Summer Olympic Games. This was somewhat problematic because the BMI values for some sports overlapped, and adding an extra facet just made the plot look unbalanced.\nTo remedy this, I set aside some of the men’s sports and adjusted the number of facets to two. This eventually served to enable me to pick those sports which would overlap very little - or not at all.\nAnother issue raised during the presentation was related to the annotation. When a classmate asked about what the BMI values represented, I realized that my annotation might not be as visible to the reader as I intended. Therefore, I slightly increased its size to enhance visibility. But really, it is not that bad! :)\nLastly, I received criticism about my legend’s colorfulness and the space it occupies in the plot. I decided not to address the colorfulness; because I like it that way. The space issue was resolved when I moved to two facets and reduced the number of sports displayed. Now, I believe my plot has a better balance between the sizes of the plot and legend.\nTime for self-criticism - What I do not like very much about this plot is the spaces in the upper area of women’s sports facet. I was not able to find a way around it to make it appear more filled, since it is due to the nature of data. Women’s BMI values start at a low point and do not show dramatic increases that would fill the upper side of the facet.\n\n\n\n",
    "preview": "projects/2024/100528259/100528259_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2496,
    "preview_height": 2688
  },
  {
    "path": "projects/2024/100532846/",
    "title": "Reproducing Learning Outcomes Graph",
    "description": "Household Income and Test Scores (Dev Patel & Justin Sandefur, 2020)",
    "author": [
      {
        "name": "Sophie Greta Kersten",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nOriginal Graph\nLibraries\nData cleaning and transformation\n\nImproved Graph\n1) Interactive Graph\n2) Analysis of learning outcomes by income class with color differentiation\n3) Learning outcomes worldwide: point spread with coloured continents and income categories as facets\n4) Income categories and continents: scatter plot of maths test scores\n5) Visualization of Test Scores vs. Income: Continental Color Grouping\n\n\nIntroduction\nInternational statistics, such as the United Nations’ Human Development Index, tend to prioritise school attendance rates over actual learning outcomes.\nIt is imperative to assess both the quantity (years of schooling) and the quality (actual learning achievements) in order to provide a realistic evaluation of the performance of education systems.\nAn essential indicator for evaluating the quality of education is the analysis of test scores.\nWhile these should not be the sole focus of education, they reveal critical inequalities and help identify problematic systems.\nThe graph entitled “Learning outcomes of children around the world, by household income” illustrates the relationship between household income (on the x-axis, logarithmically scaled) and children’s mathematics test scores (on the y-axis) in different countries.\nIt draws attention to the existence of inequalities between and within countries.\nThe upward-sloping lines indicate that in the majority of countries, test scores improve as household income increases.In countries with a lower standard of living, such as Morocco, the majority of students perform less well than the most economically disadvantaged students in Brazil.\nEven the most affluent students in Brazil do not attain the same level of performance as the most disadvantaged students in countries such as Finland, South Korea, and the Netherlands.\nA key insight is that differences between countries are often greater than those within countries, even in economically unequal nations such as the United States.\nFor instance, in the US, the performance gap between the richest and poorest students is 53 points.\nNevertheless, students from poorer countries fall far below this level overall, regardless of their household income.\nNotation: As the original data was available in Strata format, the author of the study (not the author of the graph) was kind enough to provide me with the finished CSV file. However, this data differs from that in the graph, which is why there are differences in the presentation that I could not avoid.\nOriginal Graph\nOriginal graph.Libraries\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(plotly)\nlibrary(ggtext)\nlibrary(grid)\n\n\nData cleaning and transformation\nThe data is exported from the CSV file in RStudio as a data frame.\nSubsequently, an association is established between the country codes (code) and the complete country names (country_name).\nAs only the codes are stored in the learning curve table, it is necessary to have the assignment for the purpose of the visualization.\n\n\nlearningcurve <- read.csv(\"data/learningcurve.csv\")\n\ncountry_names <- data.frame(\n  ccode = c(  \"ARG\", \"ARM\", \"AUS\", \"AUT\", \"BEN\", \"BWA\", \"BRA\", \"BFA\", \"BDI\", \"CMR\", \n              \"TCD\", \"CHL\", \"COL\", \"COG\", \"CRI\", \"CIV\", \"CZE\", \"DNK\", \"DOM\", \"ECU\", \n              \"FIN\", \"GEO\", \"DEU\", \"GTM\", \"HKG\", \"HND\", \"HRV\",\"HUN\", \"IRN\", \"IRL\", \"ITA\", \n              \"JPN\", \"KAZ\", \"LTU\", \"MEX\", \"MAR\", \"NLD\", \"NZL\", \"NIC\", \"NER\", \"NOR\", \n              \"PAN\", \"PRY\", \"PER\", \"POL\", \"PRT\", \"ROU\", \"RUS\", \"SWE\", \"SEN\", \"SRB\", \n              \"SGP\", \"SVK\", \"SVN\", \"KOR\", \"ESP\", \"TWN\", \"THA\", \"TGO\", \"TUN\", \"TUR\", \n              \"GBR\", \"URY\", \"USA\"),\n  country_name = c(\"Argentina\", \"Armenia\", \"Australia\", \"Austria\", \"Benin\", \"Botswana\", \"Brazil\",\n                   \"Burkina Faso\",\"Burundi\", \"Cameroon\", \"Chad\", \"Chile\", \"Colombia\", \"Congo\", \n                   \"Costa Rica\", \"Côte d’Ivoire\",\"Croatia\",\"Czechia\", \"Denmark\", \"Dominican Republic\",\n                   \"Ecuador\", \"Finland\", \"Georgia\", \"Germany\", \"Guatemala\", \"Hong Kong\", \"Honduras\",\n                   \"Hungary\", \"Iran\", \"Ireland\", \"Italy\", \"Japan\", \"Kazakhstan\", \"Lithuania\", \n                   \"Mexico\", \"Morocco\", \"Netherlands\", \"New Zealand\", \"Nicaragua\", \"Niger\", \n                   \"Norway\", \"Panama\", \"Paraguay\", \"Peru\", \"Poland\", \"Portugal\", \"Romania\", \n                   \"Russia\", \"Sweden\", \"Senegal\", \"Serbia\", \"Singapore\", \"Slovakia\", \"Slovenia\",\n                   \"South Korea\", \"Spain\",\"Taiwan\", \"Thailand\", \"Togo\", \"Tunisia\", \"Turkey\", \n                   \"United Kingdom\", \"Uruguay\", \"United States\")\n)\n\n\nThe data is subjected to a filtration process at the level of the query.\nIn the initial stage of the process, only those countries from the Learningcurve table that have been previously saved in the ‘country_name’ data frame are transferred.\nIt should be noted that not all countries are represented in the final visualization.\nFor subsequent processing, only the columns designated as ‘logincome’, ‘masterimss’ and ‘Code’ are transferred.\nSubsequently, a left join is performed in order to link the columns from Learningcurve with the full country names.\nThe column designated as ‘logincome’ is transformed into the actual income value and labelled ‘income_actual’.\nUltimately, any rows containing Nas or exhibiting negative income values are excluded.\nThe final result is a data frame, designated “all_results,” which contains comprehensive information regarding income, test results, and country names.\n\n\nall_results <- learningcurve |> \n  filter(ccode %in% country_names$ccode) |> \n  select(logincome, mastertimss, ccode) |> \n  left_join(country_names, by = c(\"ccode\" = \"ccode\")) |> \n  mutate(\n    income_actual = exp(logincome),\n    country = country_name\n  ) |> \n  filter(!is.na(logincome) & !is.na(mastertimss) & logincome > 0)\n\n\nThe aes() function is used to specify which variables are used for the X-axis (income_actual), Y-axis (mastertimss), and the colours of the lines (country).The X-axis represents the actual household income, which has been transformed into a logarithmic scale using scale_x_log10(). This transformation effectively handles the wide range of income values, with predefined breaks (100, 200, 500) and labels formatted as currency using the scales::label_dollar() function.The Y-axis displays the mathematical test scores (mastertimss), ranging from 300 to 600, as defined by scale_y_continuous(). The axis also includes 50-point.\nThe LOESS smoothing method is applied using geom_smooth() with span = 0.6, which balances detail and smoothness.The lines are plotted with a width of 0.3.The legend is intentionally removed (legend.position = “none”) to avoid clutter.Annotations are added using annotate at the top of the plot, labelling it with “Test score in mathematics.”\nThe theme is defined with theme_minimal(), and there are a few customisations:\n- The plot title and subtitle are centered using hjust = 0.5 and styled with element_text().\n- The axis titles and tick labels are customized in terms of size, font (Arial), and color (steelblue4 for the X-axis and darkgreen for the Y-axis).\n- The panel gridlines use dashed and dotted lines (linetype = “dashed” and linetype = “dotted”)\n-The caption is styled using element_markdown()The colour scheme for countries is specified using a custom palette in the country_colors variable (not included in this code snippet but applied via scale_color_manual()).\n\n\ngraph <- ggplot(all_results, aes(x = income_actual, y = mastertimss, color = country)) +\n  geom_smooth(method = \"loess\", se = FALSE, span = 0.6, size = 0.3) +\n\n  scale_x_log10(\n    breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000),\n    labels = scales::label_dollar(accuracy = 1)\n  ) +\n  scale_y_continuous(breaks = seq(300, 600, by = 50), limits = c(300, 600)) +\n  coord_cartesian(xlim = c(100, 50000)) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(size = 24, family = \"Arial\", face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 16, family = \"Arial\", hjust = 0.5, color = \"gray50\"),\n    axis.title.x = element_text(size = 12, family = \"Arial\", color = \"steelblue4\"),\n    axis.title.y = element_text(size = 12, family = \"Arial\", color = \"darkgreen\"),\n    axis.text.x = element_text(size = 10, family = \"Arial\", color = \"steelblue4\"),\n    axis.text.y = element_text(size = 10, family = \"Arial\", color = \"darkgreen\"),\n    panel.grid.major = element_line(linetype = \"dashed\"),\n    panel.grid.minor = element_line(linetype = \"dotted\"),\n    plot.caption = element_markdown(size = 10, family = \"Arial\", hjust = 0, color = \"gray50\")\n  ) +\n  annotate(\"text\", x = 100, y = 600, label = \"Test score in\\nmathematics\", \n           angle = 0, color = \"darkgreen\", size = 4, family = \"Arial\")\n\n\nIn this section, we commence the process of identifying the points at which the corresponding country labels will be positioned.\nGiven that some countries are situated at the commencement of their respective lines, while others are located at the conclusion of said lines, it is necessary to make the requisite adjustments.\nThe data is initially grouped by country.\nThe lowest and highest incomes and test scores are determined for each country using the ‘start_income’/‘end_income’ and ‘start_score’/‘end_score’ variables, respectively, in order to establish the points for each country.\nThe Loess function is employed to generate the smooth lines, which are created through a local regression.\nThe lines are calculated as smooth estimates of the MasterTIMSS data set, based on the actual income data.\nThe countries identified by the ‘if-else’ query are all those whose labels should be positioned at the beginning of the line.The remaining cases are automatically assigned to the end of the line.\nIn some instances, the distance between the labels and the corresponding countries was excessive, necessitating manual adjustments to the position of the labels.\nIn the case of specific countries (e.g. Colombia, Germany), the positions for the labels (label_x, label_y) have been overwritten. Ultimately, the resulting data frame, designated as “line_points,” encompasses the income and test results for each country, along with the designated label position.\n\n\nline_points <- all_results |> \n  group_by(country) |> \n  summarize(\n    start_income = min(income_actual),\n    end_income = max(income_actual),\n    start_score = predict(loess(mastertimss ~ income_actual, data = cur_data(), span = 0.6), \n                          newdata = data.frame(income_actual = min(income_actual))),\n    end_score = predict(loess(mastertimss ~ income_actual, data = cur_data(), span = 0.6), \n                        newdata = data.frame(income_actual = max(income_actual)))\n  ) |> \n  mutate(\n    label_position = ifelse(country %in% c(\"Russia\", \"Portugal\", \"Serbia\",\"Hungary\",\"Italy\",\"Romania\",\"Armenia\",\"Thailand\",\"Burundi\",\"Chile\",\"Iran\",\"Togo\",\"Gerogia\",\"Mexico\",\"Turkey\",\"Congo\",\"Botswana\",\"Senegal\",\"Niger\",\"Burkina Faso\",\"Chad\",\"Benin\",\"Honduras\",\"Guatemala\",\"Nicaragua\",\"Cameroon\",\"Tunisia\", \"Kazakhstan\"), \"start\", \"end\"),\n    label_x = ifelse(label_position == \"start\", start_income, end_income),\n    label_y = ifelse(label_position == \"start\", start_score, end_score)\n  ) |> \n  mutate(\n    label_x = case_when(\n      country == \"Colombia\" ~ 22000,  \n      country == \"Denmark\" ~ 18000,          \n      country == \"Argentina\" ~ 30000,\n      country == \"Germany\" ~ 17500,\n      country == \"Peru\" ~ 18000,\n      country == \"Guatemala\" ~ 1500,\n      country == \"Paraguay\" ~ 15000,\n      TRUE ~ label_x                      \n    ),\n    label_y = case_when(\n      country == \"Colombia\" ~ 400,   \n      country == \"Denmark\" ~ 370,          \n      country == \"Argentina\" ~ 450,\n      country == \"Germany\" ~ 370, \n      country == \"Peru\" ~ 360,\n      country == \"Guatemala\" ~ 530,\n      country == \"Paraguay\" ~ 400,\n      TRUE ~ label_y                      \n    )\n  )\n\n\n\n\nplot <- ggplot(all_results, aes(x = income_actual, y = mastertimss, color = country)) +\n  geom_smooth(method = \"loess\", se = FALSE, span = 0.6, size = 0.3) +\n  geom_text_repel(data = line_points, aes(x = label_x, y = label_y, label = country), size = 3) +\n  # Scales and aesthetics\n  scale_x_log10(\n    breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000),\n    labels = scales::label_dollar(accuracy = 1)\n  ) +\n  scale_y_continuous(breaks = seq(300, 600, by = 50), limits = c(300, 600)) +\n  coord_cartesian(xlim = c(100, 50000)) +\n  \n  # Theme\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(size = 24, family = \"Arial\", face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 16, family = \"Arial\", hjust = 0.5, color = \"gray50\"),\n    axis.title.x = element_text(size = 12, family = \"Arial\", color = \"steelblue4\"),\n    axis.title.y = element_text(size = 12, family = \"Arial\", color = \"darkgreen\"),\n    axis.text.x = element_text(size = 10, family = \"Arial\", color = \"steelblue4\"),\n    axis.text.y = element_text(size = 10, family = \"Arial\", color = \"darkgreen\"),\n    panel.grid.major = element_line(linetype = \"dashed\"),\n    panel.grid.minor = element_line(linetype = \"dotted\"),\n    plot.caption = element_markdown(size = 10, family = \"Arial\", hjust = 0, color = \"gray50\")\n  ) +\n  annotate(\"text\", x = 100, y = 600, label = \"Test score in\\nmathematics\", \n           angle = 0, color = \"darkgreen\", size = 4, family = \"Arial\")\nplot\n\n\n\nTo keep the colors as close as possible to the original, each color is selected and assigned individually for the graph.\n\n\ncountry_colors <- c(\n  \"Argentina\" = \"#081F4E\", \"Armenia\" = \"#092255\",\"Australia\" = \"#3F69BE\",\n  \"Austria\" = \"#759EEF\", \"Benin\" = \"#799DE5\", \"Botswana\" = \"#248B63\",\n  \"Brazil\" = \"#1E9667\", \"Burkina Faso\" = \"#1CA63C\", \"Burundi\" = \"#1CA687\",\n  \"Cameroon\" = \"#29C2E7\", \"Chad\" = \"#138AD0\", \"Chile\" = \"#1A97E2\",\n  \"Colombia\" = \"#19D6AB\", \"Congo\" = \"#19D6D0\", \"Costa Rica\" = \"#5DC4DB\",\n  \"Côte d’Ivoire\" = \"#4BCAE7\",\"Croatia\"=\"#28D29D\" ,\"Czechia\" = \"#31AC39\",\n  \"Denmark\" = \"#47ABBF\", \"Dominican Republic\" = \"#890F4C\", \"Ecuador\" = \"#30C11C\", \n  \"Finland\" = \"#1735A0\",\"Georgia\" = \"#363A48\", \"Germany\" = \"#2B2D34\",\n  \"Guatemala\" = \"#6016DD\", \"Hong Kong\" = \"#157ED3\", \"Honduras\" = \"#097A35\",\n  \"Hungary\" = \"#0E9141\",\"Iran\" = \"#4D341C\", \"Ireland\" = \"#5A77D6\", \"Italy\" = \"#6927AD\",\n  \"Japan\" = \"#6D1AC4\", \"Kazakhstan\" = \"#AF106E\", \"Lithuania\" = \"#755322\",\n  \"Mexico\" = \"#7E3379\", \"Morocco\" = \"#AAAAAA\", \"Netherlands\" = \"#FF9D3C\",\n  \"New Zealand\" = \"#4AC444\", \"Nicaragua\" = \"#A5B360\", \"Niger\" = \"#C2C4B9\",\n  \"Norway\" = \"#8F120B\", \"Panama\" = \"#61140F\", \"Paraguay\" = \"#7F24A4\",\n  \"Peru\" = \"#A68A49\", \"Poland\" = \"#B5AFA1\", \"Portugal\" = \"#B07D04\",\n  \"Romania\" = \"#A03002\", \"Russia\" = \"#97217D\", \"Sweden\" = \"#CA227B\",\n  \"Senegal\" = \"#A02B8B\", \"Serbia\" = \"#0D2752\", \"Singapore\" = \"#9F2110\",\n  \"Slovakia\" = \"#B22815\", \"Slovenia\" = \"#C30C41\", \"South Korea\" = \"#DB1DC5\",\n  \"Spain\" = \"#C89024\", \"Taiwan\" = \"#CD23A2\", \"Thailand\" = \"#A157AA\",\n  \"Togo\" = \"#D92398\", \"Tunisia\" = \"#EA2965\", \"Turkey\" = \"#DF7B35\",\n  \"United Kingdom\" = \"#8C8B9B\", \"Uruguay\" = \"#652A83\", \"United States\" = \"#C1153E\"\n)\n\n\n\n\ngraph2 <- plot +\n  scale_color_manual(values = country_colors)\ngraph2\n\n\n\nThe query creates a graphic object that positions the logo in the top right-hand corner of the plot, with a size that is fixed relative to the plot. This is the logo of ‘Our World in Data’.\n\n\nimage_grob <- rasterGrob(\n  png::readPNG(\"data/Our_World_in_Data_logo.png\"),\n  x = 0.997, y = 0.992,  \n  hjust = 1, vjust = 1, \n  width = unit(0.07, \"npc\"),  \n  height = unit(0.07, \"npc\") \n)\n\n\nTo recreate the annotation:\nA vertical double arrow is drawn using the annotate(‘segment’) function. The lines start and end at the x-coordinate 100 (x = 100, xend = 100) and are located on the Y-axis between 503-550. To add two points to the arrow, ‘ends=’Both’ is set. The arrowheads are closed (filled in) with type = ‘closed’. The length of the arrow is 0.2 cm (length = unit(0.2, ‘cm’)) The colour and thickness of the line is set to red and 0.3. A text is added to the arrow. The text describes the difference between the test scores of the richest and poorest students in the USA (53 points). The position of the text is x = 190, y = 530.\n\n\nannotate(\"segment\", x = 100, xend = 100, y = 503, yend = 550, \n           arrow = arrow(ends = \"both\", type = \"closed\", length = unit(0.2, \"cm\")), \n           color = \"#C71845\", size = 0.3) +\n  annotate(\"text\", x = 190, y = 530, \n           label = \"The difference in test scores between the richest\\nand the poorest students in the US is 53 Points\", \n           color = \"#C71845\", size = 3, fontface = \"plain\")\n\n\nTo recreate the arrows:\nThe arrows at the bottom of the graph are created using the geom_curve() function. X and Y values determine the start and end points of the arrows. Curvature is used to determine the ‘curvature’ of the arrows. A positive value indicates an upward curvature and a negative value indicates a downward curvature. As with the arrow before, the length, thickness and type can be changed manually until the arrow looks like the original.\n\n\n  geom_curve(aes(x = 500, y = 318, xend = 500, yend = 340),   \n             curvature = 0.2, arrow = arrow(length = unit(0.15, \"cm\"), type = \"closed\"), \n             color = \"#890F4C\", size = 0.3, lineend = \"round\") +\n  geom_curve(aes(x = 7500, y = 340, xend = 7500, yend = 362),  \n             curvature = -0.2, arrow = arrow(length = unit(0.15, \"cm\"), type = \"closed\"), \n             color = \"#890F4C\", size = 0.3, lineend = \"round\") \n\n\nRecreate Labels:\n\n\nlabs(\n    title = \"Learning outcomes of children around the world, by household income\",\n    subtitle = \"Each line plots the average test scores in mathematics by the level of income of the family's household\",\n    x = \"Annual household income (adjusted for price differences between countries)\\non a logarithmic axis\",\n    y = \"\",\n    color = \"Country\", \n    caption = \"<span style='color:gray;'>Data source: Dev Patel and Justin Sandefur (2020) - A Rosetta Stone for Human Capital. The outlier Yemen is not shown for better readability.<br>\n    <span style='color:steelblue4;'>OurWorldInData.org<\/span> - Research and data to make progress against the world's largest problem.<span style='color:steelblue4;'>&nbsp;&nbsp;&nbsp;Licensed under CC-BY<\/span> by the author Max Roser<\/span>\"\n  ) \n\n\nAnd if you put all the steps together, you get the reconstructed graph:\n\n\ngraph3 <- graph2 +\n  # US Annotation\n  annotate(\"segment\", x = 100, xend = 100, y = 503, yend = 550, \n           arrow = arrow(ends = \"both\", type = \"closed\", length = unit(0.2, \"cm\")), \n           color = \"#C71845\", size = 0.3) +\n  annotate(\"text\", x = 190, y = 530, \n           label = \"The difference in test scores between the richest\\nand the poorest students in the US is 53 Points\", \n           color = \"#C71845\", size = 3, fontface = \"plain\") +\n  \n  # Dominican Republic Arrows: Both arrows curve upward\n  geom_curve(aes(x = 500, y = 318, xend = 500, yend = 340),   \n             curvature = 0.2, arrow = arrow(length = unit(0.15, \"cm\"), type = \"closed\"), \n             color = \"#890F4C\", size = 0.3, lineend = \"round\") +\n  geom_curve(aes(x = 7500, y = 340, xend = 7500, yend = 362),  \n             curvature = -0.2, arrow = arrow(length = unit(0.15, \"cm\"), type = \"closed\"), \n             color = \"#890F4C\", size = 0.3, lineend = \"round\") +\n  \n  # Text annotations for Dominican Republic\n  annotate(\"text\", x = 200, y = 300, \n           label = \"Poorest households in the Dominican Republic:\\nAnnual household income: $680\\nTest scores of the children: 318\", \n           color = \"#890F4C\", size = 3, fontface = \"plain\", hjust = 0) +\n  annotate(\"text\", x = 8000, y = 320, \n           label = \"Richest households in the Dominican Republic:\\nAnnual household income: $7,560\\nTest scores of the children: 362\", \n           color = \"#890F4C\", size = 3, fontface = \"plain\", hjust = 0) +\n  \n  # Labels\n  labs(\n    title = \"Learning outcomes of children around the world, by household income\",\n    subtitle = \"Each line plots the average test scores in mathematics by the level of income of the family's household\",\n    x = \"Annual household income (adjusted for price differences between countries)\\non a logarithmic axis\",\n    y = \"\",\n    color = \"Country\", \n    caption = \"<span style='color:gray;'>Data source: Dev Patel and Justin Sandefur (2020) - A Rosetta Stone for Human Capital. The outlier Yemen is not shown for better readability.<br>\n    <span style='color:steelblue4;'>OurWorldInData.org<\/span> - Research and data to make progress against the world's largest problem.<span style='color:steelblue4;'>&nbsp;&nbsp;&nbsp;Licensed under CC-BY<\/span> by the author Max Roser<\/span>\"\n  )\ngraph3\n\n\n\nImproved Graph\nThe original visualization is well chosen as it allows the author to demonstrate both the similarities and differences between and within countries, which is important in order to clearly convey the message of the graphic.However, the visualization also has weaknesses: due to the large number of lines, the visualization sometimes appears overloaded, especially in the middle income range, which can result in lines overlapping and the chart appearing confusing at first glance.\nFurthermore, the repeated use of colors for certain lines, a phenomenon that is unavoidable given the large number of countries represented, complicates the assignment of lines to specific countries.Notwithstanding these limitations, it is this author’s opinion that no alternative visualization exists that would more effectively convey the intended message.The following section will present the various approaches that have been trialled in an effort to optimize the presentation.\n1) Interactive Graph\nThis query generates an interactive visualization that illustrates the correlation between household income and the mathematics test scores of children across the globe.\nFirstly, the variables ‘income_actual’ (representing actual income) and ‘mastertimss’ (representing maths test scores) are positioned on the axes.\nThe colours and countries remain unchanged, and the original code is utilised.\nThe addition of titles and axis labels is achieved through the utilisation of the labs() function.\nSubsequently, the plot is transformed into an interactive format through the utilisation of the ggplotly() function.\nThis conversion permits users to magnify or reduce the scale of the graph and select specific data points to obtain more detailed information.\n\n\ninteractive_plot <- ggplot(all_results, aes(x = income_actual, y = mastertimss, color = country)) +\n  geom_smooth(method = \"loess\", se = FALSE, span = 0.6, size = 0.3) +\n  scale_color_manual(values = country_colors) +  \n  labs(\n    title = \"Learning outcomes of children around the world, by household income\",\n    subtitle = \"Each line plots the average test scores in mathematics by the level of \n    income of the family's household\",\n    x = \"Annual household income (adjusted for price differences between countries)\",\n    y = \"Test score in mathematics\",\n    color = \"Country\"\n  ) +\n  theme_minimal()\n\nggplotly(interactive_plot)\n\n\n\nDiscussion:\nThe interactivity facilitates the viewing and comparison of individual countries, while the visualisation enables the determination of exact scores for each income by simply moving the cursor over the respective line.Despite these advantages, the chart remains cluttered due to the large number of data points, with most countries overlapping, which complicates the clear extraction of information.\nThe absence of contextual cues, such as arrows and annotations, that were present in the original static chart, further complicates the effective conveyance of key information.\n2) Analysis of learning outcomes by income class with color differentiation\nThe learning curve data has been filtered to include only those countries present in the country_names dataset.\nThe relevant variables, namely logincome, mastertimss, ccode and classification, are selected for further analysis.\nThe classification column is defined as a factor and arranged in a specific order, as follows: The income categories are defined as follows: low income, lower-middle income, upper-middle income, and high income.\nThe process of removing distinct and duplicate rows ensures that each value of logincome is represented only once, thereby reducing the overall volume of data.\n\n\n\nSubsequently, the axes (income_actual for the x-axis and mastertimss for the y-axis), colour (based on the income category classification), and labels (country names) are defined.\nThe grey points displayed on the graph are generated using geom_jitter and are based on the all_results dataset.\nThe grey points represent the entire dataset without income categorisation.\nSubsequently, geom_point adds coloured points, which are mapped to their respective income categories.\nFacet_grid creates separate plots for each income category, with independent axis scaling.\nThe use of the labs function enables the title, subtitle and axis labels to be set in a manner that provides a clear explanation of the purpose and content of the plot.\nThe guides function allows the size of the coloured points in the legend to be optimised, thus enhancing their visibility.Faceting by income categories (low, middle, high income) permits a comprehensive comparison between these groups, while the grey points represent the overall data independently of the income categorisation.\n\n\np1 <- ggplot(all_results, \n             aes(income_actual, mastertimss, color = classification, label = country)) + \n  geom_jitter(data = transform(all_results, classification = NULL), \n              colour = \"#DCD7D8\", width = 0.01, height = 0.01) +  \n  geom_point(alpha = 0.7) +  \n  scale_color_manual(values = c(\"#CC79A7\", \"#56B4E9\",\"#E69F00\", \"#F0E442\")) +\n  facet_grid(~classification, scales = \"free\") + \n  theme_bw() + \n  labs(\n    title = \"Learning Outcomes of Children Worldwide by Household Income and Income Categories\",\n    subtitle = \"Class country\",\n    x = \"Annual household income (adjusted for price differences between countries)\",\n    y = \"Test score in mathematics\"\n  ) +\n  scale_x_log10(breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000)) +  \n  scale_y_continuous(limits = c(300, 600)) +  \n  theme(\n    text = element_text(size = 8),\n    legend.position = \"none\",\n    plot.title = element_markdown(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_markdown(face = \"bold\", hjust = 0.5),\n    axis.title.x  = element_markdown(),\n    axis.title.y = element_markdown(),\n    plot.caption = element_markdown(face = \"bold\", hjust = 0.1)\n  ) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\np1\n\n\n\nDiscussion:\nThe visualization provides a clear breakdown into income categories, thus facilitating the identification of differences between these categories.\nThe grey dots in the background provide supplementary context by mapping the entire data set, while the colored dots focus on specific categories.\nThe logarithmic scaling of the x-axis is instrumental in the visualization of substantial disparities in income without the distortion of extreme values.\nThe visualisation’s minimalist and clear design is effective in its emphasis on the key elements.\nHowever, the visualization does exhibit certain deficiencies.\nIn categories with a high number of data points, such as ‘Upper middle income’ and ‘High income’, there is a considerable amount of overlap, which hinders the clear recognition of patterns or differences.\nThe labelling of the x-axis is dense, which can make interpretation difficult due to the logarithmic scaling.\nAdditionally, the absence of annotations or highlighting to accentuate significant trends or outliers hinders the discernment of key messages.\nFurthermore, the potential exists for the creation of additional differentiations within the income categories, for example by continent, in order to provide insights that are specific to a regional context.\nDespite the reduction in the number of income values, the density of points remains substantial.\nIt is recommended that this point density be reduced further, a measure which would considerably enhance the readability of the text.\n3) Learning outcomes worldwide: point spread with coloured continents and income categories as facets\nThe data is initially processed as outlined in the preceding graph.\nThe relevant countries are selected, the data is cleaned, and the ‘Classification’ column is defined as a factor.\nHowever, an additional column is incorporated that manually allocates each country to a continent, thereby enabling regional analyses.\n\n\ncountry_names <- data.frame(\n  ccode = c(\"ARG\", \"ARM\", \"AUS\", \"AUT\", \"BEN\", \"BWA\", \"BRA\", \"BFA\", \"BDI\", \"CMR\", \n            \"TCD\", \"CHL\", \"COL\", \"COG\", \"CRI\", \"CIV\", \"CZE\", \"DNK\", \"DOM\", \"ECU\", \n            \"FIN\", \"GEO\", \"DEU\", \"GTM\", \"HKG\", \"HND\", \"HRV\", \"HUN\", \"IRN\", \"IRL\", \"ITA\", \n            \"JPN\", \"KAZ\", \"LTU\", \"MEX\", \"MAR\", \"NLD\", \"NZL\", \"NIC\", \"NER\", \"NOR\", \n            \"PAN\", \"PRY\", \"PER\", \"POL\", \"PRT\", \"ROU\", \"RUS\", \"SWE\", \"SEN\", \"SRB\", \n            \"SGP\", \"SVK\", \"SVN\", \"KOR\", \"ESP\", \"TWN\", \"THA\", \"TGO\", \"TUN\", \"TUR\", \n            \"GBR\", \"URY\", \"USA\"),\n  country_name = c(\"Argentina\", \"Armenia\", \"Australia\", \"Austria\", \"Benin\", \"Botswana\", \n                   \"Brazil\", \"Burkina Faso\",\"Burundi\", \"Cameroon\", \"Chad\", \"Chile\", \"Colombia\", \"Congo\", \n                   \"Costa Rica\", \"Côte d’Ivoire\",\"Croatia\",\"Czechia\", \"Denmark\", \"Dominican Republic\", \n                   \"Ecuador\", \"Finland\", \"Georgia\", \"Germany\", \"Guatemala\", \"Hong Kong\", \"Honduras\", \n                   \"Hungary\", \"Iran\", \"Ireland\", \"Italy\", \"Japan\", \"Kazakhstan\", \"Lithuania\", \"Mexico\", \n                   \"Morocco\", \"Netherlands\", \"New Zealand\", \"Nicaragua\", \"Niger\", \"Norway\", \"Panama\", \n                   \"Paraguay\", \"Peru\", \"Poland\", \"Portugal\", \"Romania\", \"Russia\", \"Sweden\", \"Senegal\",\n                   \"Serbia\", \"Singapore\", \"Slovakia\", \"Slovenia\", \"South Korea\", \"Spain\",\"Taiwan\", \n                   \"Thailand\", \"Togo\", \"Tunisia\", \"Turkey\", \"United Kingdom\", \"Uruguay\", \"United States\")\n)\ncountry_names$continent <- c(\n  \"South America\", \"Asia\", \"Oceania\", \"Europe\", \"Africa\", \"Africa\", \"South America\", \"Africa\", \"Africa\", \n  \"Africa\", \"Africa\", \"South America\", \"South America\", \"Africa\", \"North America\", \"Africa\",\n  \"Europe\", \"Europe\", \"North America\", \"South America\",  \"Europe\", \"Asia\", \"Europe\", \"North America\", \n  \"Asia\", \"North America\", \"Europe\", \"Europe\", \"Asia\", \"Europe\", \"Europe\", \"Asia\", \"Asia\", \"Europe\", \n  \"North America\", \"Africa\", \"Europe\", \"Oceania\", \"North America\", \"Africa\", \"Europe\", \"North America\",\n  \"South America\", \"South America\", \"Europe\", \"Europe\", \"Europe\", \"Europe\", \"Europe\", \"Africa\", \"Europe\", \n  \"Asia\", \"Europe\", \"Europe\", \"Asia\", \"Europe\", \"Asia\", \"Asia\", \"Africa\", \"Africa\", \"Europe\", \n  \"Europe\", \"South America\", \"North America\"\n)\n\n\n\n\nall_results <- learningcurve |> \n  filter(ccode %in% country_names$ccode) |> \n  select(logincome, mastertimss, ccode, classification) |> \n  left_join(country_names, by = c(\"ccode\" = \"ccode\")) |> \n  mutate(\n    income_actual = exp(logincome),\n    country = country_name\n  ) |> \n  filter(!is.na(logincome) & !is.na(mastertimss) & logincome > 0)\n\nall_results$classification <- factor(\n  all_results$classification,\n  levels = c(\"Low income\", \"Lower middle income\", \"Upper middle income\", \"High income\")\n)\n\nall_results <- all_results |> \n  distinct(logincome, .keep_all = TRUE)\n\n\nThe actual household income (income_actual) is displayed on the x-axis in logarithmic scale in order to facilitate the visualisation of the substantial disparities in income.\nThe Y-axis displays the students’ maths test scores (mastertimss).\nEach data point is assigned a colour according to the continent of the corresponding country, thereby highlighting regional disparities.\nThe points in the graph are represented by two layers.\nThe first layer comprises grey background points, generated using the geom_jitter function.\nThese points are displayed in grey (colour = ‘#DCD7D8’) and show all countries, regardless of their continental affiliation.\nThe jitter effect introduces a slight randomness (width = 0.01, height = 0.01) to reduce overlaps and separate the dots from each other.\nConversely, the coloured foreground points, created with geom_point, are displayed in a different manner.\nThese points are semi-transparent (alpha = 0.5) and colour-coded by continent.\nThese points are distinguished from the grey background points by their transparency (alpha = 0.5) and serve to highlight the specific data points for each continent.\nTo structure the data according to income categories, the visualisation is faceted into columns using facet_grid.\nEach column thereby represents an income category (classification), including low income, lower middle income, upper middle income and high income.\nWithin each category, the X and Y axes are scaled independently (scales = ‘free’), which enhances the clarity of the distribution of the data within the individual categories.\nFinally, the legibility of the legend is optimised by enlarging the displayed points with guides.\nThis enhances the legibility of the colours and their corresponding assignment to the continents.\nThe amalgamation of these elements culminates in a visually appealing and meticulously structured presentation, unveiling both global and regional disparities in test values and household incomes.\n\n\np2 <- ggplot(all_results, \n             aes(income_actual, mastertimss, color = continent, label = country)) + \n  geom_jitter(data = transform(all_results, continent = NULL), \n              colour = \"#DCD7D8\", width = 0.01, height = 0.01) +  \n  geom_point(alpha = 0.5) + \n  scale_color_manual(values = c(\"Africa\" = \"#FF5733\", \n                                \"Asia\" = \"#33FF57\", \n                                \"Europe\" = \"#3357FF\", \n                                \"North America\" = \"#FFD133\",\n                                \"South America\" = \"#8A33FF\", \n                                \"Oceania\" = \"#33FFF7\")) +  \n  facet_grid(~classification, scales = \"free\") +  \n  theme_bw() + \n  labs(\n    title = \"Learning Outcomes of Children Worldwide by Household Income and Continent\",\n    subtitle = \"Class country\",\n    x = \"Annual household income (adjusted for price differences between countries)\",\n    y = \"Test score in mathematics\",\n    color = \"Continent\"\n  ) +\n  scale_x_log10(breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000)) +  \n  scale_y_continuous(limits = c(300, 600)) +  \n  theme(\n    text = element_text(size = 8),\n    legend.position = \"right\",  # Verschiebe Legende nach rechts\n    plot.title = element_markdown(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_markdown(face = \"bold\", hjust = 0.5),\n    axis.title.x  = element_markdown(),\n    axis.title.y = element_markdown(),\n    plot.caption = element_markdown(face = \"bold\", hjust = 0.1)\n  ) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\np2\n\n\n\nDiscussion:\nThe visualization shows well that there are clear differences between the income categories.\nIt shows that higher incomes tend to be associated with higher maths test scores.\nThe colour coding by continent also makes it possible to identify regional patterns, such as the dominance of Africa in the low income category.\nNevertheless, the message remains rather superficial: No in-depth analysis possible:The presentation allows the data to be explored, but does not make specific patterns or outliers visible.\nThis makes it difficult to draw clear conclusions or formulate specific regional or global messages.\nLack of focus: Visualization does not provide a clear answer to a specific question or hypothesis.\nIt is more suitable for exploratory purposes, but the core message remains unclear.\n4) Income categories and continents: scatter plot of maths test scores\nThe visualization facilitates a clear comparison between these dimensions by dividing them into income categories and continents.\nThe utilization of color coding for the representation of continents serves to facilitate the identification of regional disparities.\nThe employment of a logarithmic x-axis ensures the lucid presentation of income distribution.\nThe presence of grey dots in the background serves to provide additional context, illustrating the entirety of the data set, while colored dots focus on specific continents.\n\n\ncountry_names <- data.frame(\n  ccode = c(\"ARG\", \"ARM\", \"AUS\", \"AUT\", \"BEN\", \"BWA\", \"BRA\", \"BFA\", \"BDI\", \"CMR\", \n            \"TCD\", \"CHL\", \"COL\", \"COG\", \"CRI\", \"CIV\", \"CZE\", \"DNK\", \"DOM\", \"ECU\", \n            \"FIN\", \"GEO\", \"DEU\", \"GTM\", \"HKG\", \"HND\", \"HRV\", \"HUN\", \"IRN\", \"IRL\", \"ITA\", \n            \"JPN\", \"KAZ\", \"LTU\", \"MEX\", \"MAR\", \"NLD\", \"NZL\", \"NIC\", \"NER\", \"NOR\", \n            \"PAN\", \"PRY\", \"PER\", \"POL\", \"PRT\", \"ROU\", \"RUS\", \"SWE\", \"SEN\", \"SRB\", \n            \"SGP\", \"SVK\", \"SVN\", \"KOR\", \"ESP\", \"TWN\", \"THA\", \"TGO\", \"TUN\", \"TUR\", \n            \"GBR\", \"URY\", \"USA\"),\n  country_name = c(\"Argentina\", \"Armenia\", \"Australia\", \"Austria\", \"Benin\", \"Botswana\", \"Brazil\", \"Burkina Faso\",\"Burundi\", \"Cameroon\", \"Chad\", \"Chile\", \"Colombia\", \"Congo\", \"Costa Rica\", \"Côte d’Ivoire\",\"Croatia\",\"Czechia\", \"Denmark\", \"Dominican Republic\", \"Ecuador\", \"Finland\", \"Georgia\", \"Germany\", \"Guatemala\", \"Hong Kong\", \"Honduras\", \"Hungary\", \"Iran\", \"Ireland\", \"Italy\", \"Japan\", \"Kazakhstan\", \"Lithuania\", \"Mexico\", \"Morocco\", \"Netherlands\", \"New Zealand\", \"Nicaragua\", \"Niger\", \"Norway\", \"Panama\", \"Paraguay\", \"Peru\", \"Poland\", \"Portugal\", \"Romania\", \"Russia\", \"Sweden\", \"Senegal\", \"Serbia\", \"Singapore\", \"Slovakia\", \"Slovenia\", \"South Korea\", \"Spain\",\"Taiwan\", \"Thailand\", \"Togo\", \"Tunisia\", \"Turkey\", \"United Kingdom\", \"Uruguay\", \"United States\")\n)\ncountry_names$continent <- c(\n  \"South America\", \"Asia\", \"Oceania\", \"Europe\", \"Africa\", \"Africa\", \"South America\", \"Africa\", \"Africa\", \"Africa\", \n  \"Africa\", \"South America\", \"South America\", \"Africa\", \"North America\", \"Africa\", \"Europe\", \"Europe\", \"North America\", \"South America\", \n  \"Europe\", \"Asia\", \"Europe\", \"North America\", \"Asia\", \"North America\", \"Europe\", \"Europe\", \"Asia\", \"Europe\", \"Europe\", \n  \"Asia\", \"Asia\", \"Europe\", \"North America\", \"Africa\", \"Europe\", \"Oceania\", \"North America\", \"Africa\", \"Europe\", \n  \"North America\", \"South America\", \"South America\", \"Europe\", \"Europe\", \"Europe\", \"Europe\", \"Europe\", \"Africa\", \"Europe\", \n  \"Asia\", \"Europe\", \"Europe\", \"Asia\", \"Europe\", \"Asia\", \"Asia\", \"Africa\", \"Africa\", \"Europe\", \n  \"Europe\", \"South America\", \"North America\"\n)\n\n\nall_results <- learningcurve |> \n  filter(ccode %in% country_names$ccode) |> \n  select(logincome, mastertimss, ccode, classification) |> \n  left_join(country_names, by = c(\"ccode\" = \"ccode\")) |> \n  mutate(\n    income_actual = exp(logincome),\n    country = country_name\n  ) |> \n  filter(!is.na(logincome) & !is.na(mastertimss) & logincome > 0)\n\nall_results$classification <- factor(\n  all_results$classification,\n  levels = c(\"Low income\", \"Lower middle income\", \"Upper middle income\", \"High income\")\n)\n\nall_results <- all_results |> \n  distinct(logincome, .keep_all = TRUE)\n\n\nThe plot shows the actual household income (income_actual) on the logarithmically scaled x-axis to better visualise large differences in income.\nThe Y-axis shows the maths test scores (mastertimss), which represent the performance of students in the different income categories.\nEach data point is colour coded by income category (classification), which allows for quick visual differentiation.\nThe grey background points are displayed with geom_jitter and show the overall distribution of all countries regardless of their income category.\nTo reduce overlaps, the points are shifted slightly at random (jitter), with a small shift in width and height (width = 0.01, height = 0.01).\nThese points are kept in grey (colour = ‘#DCD7D8’) to clarify the context but not to distract from the main data points.The foreground points drawn with geom_point are semi-transparent (alpha = 0.5) and colour coded according to income categories.\nThe colours are specifically defined: Blue (#5A77D6) for one category, light blue (#56B4E9) for another, red (#D55E00) and yellow (#F0E442) for other categories.\nThis coding makes it possible to quickly recognise differences between the income categories visually.\nThe visualisation is faceted into rows and columns using facet_grid.\nThe rows represent the continents, while the columns represent the income categories (classification).\nEach facet has independent X- and Y-axis scales (scales = ‘free’), which makes the distribution of data within each category and continent more visible.\nThe text elements have been adapted to improve readability and clarity.\nTitles and subtitles are centred (hjust = 0.5) and highlighted (face = ‘bold’), while the axis titles and ticks are displayed in a smaller font size (size = 8) to save space and focus on the data.\nOverall, the plot enables a detailed analysis of the maths test values in relation to household income, income categories and continents.\n\n\np3 <- ggplot(all_results, \n             aes(income_actual, mastertimss, color = classification, label = country)) + \n  geom_jitter(data = transform(all_results, classification = NULL), \n              colour = \"#DCD7D8\", width = 0.01, height = 0.01) +  \n  geom_point(alpha = 0.5) +  \n  scale_color_manual(values = c(\"#5A77D6\", \"#56B4E9\",\"#D55E00\", \"#F0E442\")) +\n  facet_grid(continent ~ classification, scales = \"free\") +  \n  theme_bw() + \n  labs(\n    title = \"Learning Outcomes of Children Worldwide by Household Income and Income Categories\",\n    subtitle = \"Class country\",\n    x = \"Annual household income (adjusted for price differences between countries)\",\n    y = \"Test score in mathematics\"\n  ) +\n  scale_x_log10(breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000)) +  \n  scale_y_continuous(limits = c(300, 600)) +  \n  theme(\n    text = element_text(size = 8),\n    legend.position = \"none\",\n    plot.title = element_markdown(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_markdown(face = \"bold\", hjust = 0.5),\n    axis.title.x  = element_markdown(),\n    axis.title.y = element_markdown(),\n    plot.caption = element_markdown(face = \"bold\", hjust = 0.1)\n  ) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\n\np3\n\n\n\nDiscussion:\nThe visualisation shows that maths test scores tend to increase with rising household income, particularly in the higher income categories (upper middle income and high income).\nThe continents are shown separately, which makes it possible to recognise regional differences.\nFor example, it is clear that Africa is mainly represented in the lower income categories, while North America and Europe dominate the higher categories.\nHowever, the message remains relatively general.\nNo specific patterns or outliers are highlighted that would be decisive for a deeper analysis.\nThe faceting is helpful to understand the data structure, but at the same time makes it difficult to identify global trends as the data is spread across many small plots.\n5) Visualization of Test Scores vs. Income: Continental Color Grouping\nThe data is processed in a manner consistent with the preceding queries.\nThe countries are filtered from the original data, and the country names are added.\nSubsequently, the initial and concluding points for the labels are determined.\nThe Loess function is employed once more, as was the case in the original graph.\nThe countries are then grouped by continent and colour coded: Each continent is assigned a unique colour palette, which is then applied during the visualisation process.\nThe final plot illustrates linear trends for each country, thereby demonstrating the relationship between income and test scores, with countries clearly designated with labels and colours.\nThe objective is to accentuate the disparities between continents and to reduce the colour palette to achieve a more lucid visualization.\n\n\nall_results <- learningcurve %>%\n  filter(ccode %in% country_names$ccode) %>%\n  select(logincome, mastertimss, ccode) %>%\n  left_join(country_names, by = c(\"ccode\" = \"ccode\")) %>%\n  mutate(\n    income_actual = exp(logincome),\n    country = country_name\n  ) %>%\n  filter(!is.na(logincome) & !is.na(mastertimss) & logincome > 0)\n\nline_points <- all_results %>%\n  group_by(country) %>%\n  summarize(\n    start_income = min(income_actual),\n    end_income = max(income_actual),\n    start_score = predict(loess(mastertimss ~ income_actual, data = cur_data(), span = 0.6), \n                          newdata = data.frame(income_actual = min(income_actual))),\n    end_score = predict(loess(mastertimss ~ income_actual, data = cur_data(), span = 0.6), \n                        newdata = data.frame(income_actual = max(income_actual)))\n  ) %>%\n  mutate(\n    label_position = ifelse(country %in% c(\"Russia\", \"Portugal\", \"Serbia\",\"Hungary\",\"Italy\",\"Romania\",\"Armenia\",\"Thailand\",\"Burundi\",\"Chile\",\"Iran\",\"Togo\",\"Gerogia\",\"Mexico\",\"Turkey\",\"Congo\",\"Botswana\",\"Senegal\",\"Niger\",\"Burkina Faso\",\"Chad\",\"Benin\",\"Honduras\",\"Guatemala\",\"Nicaragua\",\"Cameroon\",\"Tunisia\", \"Kazakhstan\"), \"start\", \"end\"),\n    label_x = ifelse(label_position == \"start\", start_income, end_income),\n    label_y = ifelse(label_position == \"start\", start_score, end_score)\n  ) %>%\n  mutate(\n    label_x = case_when(\n      country == \"Colombia\" ~ 22000,  \n      country == \"Denmark\" ~ 18000,          \n      country == \"Argentina\" ~ 30000,\n      country == \"Germany\" ~ 17500,\n      country == \"Peru\" ~ 18000,\n      country == \"Guatemala\" ~ 1500,\n      country == \"Paraguay\" ~ 15000,\n      TRUE ~ label_x                      \n    ),\n    label_y = case_when(\n      country == \"Colombia\" ~ 400,   \n      country == \"Denmark\" ~ 370,          \n      country == \"Argentina\" ~ 450,\n      country == \"Germany\" ~ 370, \n      country == \"Peru\" ~ 360,\n      country == \"Guatemala\" ~ 530,\n      country == \"Paraguay\" ~ 400,\n      TRUE ~ label_y                      \n    )\n  )\n\n\nThe only step that differs from the original graph is the colour assignment.\nHere the colours are manually assigned to the continent.\nThe colors in the country_colors list represent the continents of the respective countries: South America = yellow Asia = green Oceania = purple Europe = red Africa = blue North and Central America = orange\n\n\ncountry_colors <- c(\n  \"Argentina\" = \"#F9E79F\",\n  \"Brazil\" = \"#F9E79F\",\n  \"Chile\" = \"#F9E79F\",\n  \"Colombia\" = \"#F9E79F\",\n  \"Ecuador\" = \"#F9E79F\",\n  \"Paraguay\" = \"#F9E79F\",\n  \"Peru\" = \"#F9E79F\",\n  \"Uruguay\" = \"#F9E79F\",\n\n  \"Armenia\" = \"#229954\",\n  \"Hong Kong\" = \"#229954\",\n  \"Iran\" = \"#229954\",\n  \"Japan\" = \"#229954\",\n  \"Kazakhstan\" = \"#229954\",\n  \"Singapore\" = \"#229954\",\n  \"South Korea\" = \"#229954\",\n  \"Taiwan\" = \"#229954\",\n  \"Thailand\" = \"#229954\",\n  \"Georgia\" = \"#229954\",\n\n  \"Australia\" = \"#7D3C98\", \"New Zealand\" = \"#6C3483\",\n\n  \"Austria\" = \"#E74C3C\",\n  \"Croatia\" = \"#E74C3C\",\n  \"Czechia\" = \"#E74C3C\",\n  \"Denmark\" = \"#E74C3C\",\n  \"Finland\" = \"#E74C3C\",\n  \"Germany\" = \"#E74C3C\",\n  \"Hungary\" = \"#E74C3C\",\n  \"Ireland\" = \"#E74C3C\",\n  \"Italy\" = \"#E74C3C\",\n  \"Lithuania\" = \"#E74C3C\",\n  \"Netherlands\" = \"#E74C3C\",\n  \"Norway\" = \"#E74C3C\",\n  \"Poland\" = \"#E74C3C\",\n  \"Portugal\" = \"#E74C3C\",\n  \"Romania\" = \"#E74C3C\",\n  \"Russia\" = \"#E74C3C\",\n  \"Serbia\" = \"#E74C3C\",\n  \"Slovakia\" = \"#E74C3C\",\n  \"Slovenia\" = \"#E74C3C\",\n  \"Spain\" = \"#E74C3C\",\n  \"Sweden\" = \"#E74C3C\",\n  \"United Kingdom\" = \"#E74C3C\",\n \n  \"Benin\" = \"#3498DB\",\n  \"Botswana\" = \"#3498DB\",\n  \"Burkina Faso\" = \"#3498DB\",\n  \"Burundi\" = \"#3498DB\",\n  \"Cameroon\" = \"#3498DB\",\n  \"Chad\" = \"#3498DB\",\n  \"Congo\" = \"#3498DB\",\n  \"Côte d’Ivoire\" = \"#3498DB\",\n  \"Morocco\" = \"#3498DB\",\n  \"Niger\" = \"#3498DB\",\n  \"Senegal\" = \"#3498DB\",\n  \"Togo\" = \"#3498DB\",\n  \"Tunisia\" = \"#3498DB\",\n  \n  \"Costa Rica\" = \"#E67E22\", \n  \"Dominican Republic\" = \"#E67E22\",\n  \"Guatemala\" = \"#E67E22\", \n  \"Honduras\" = \"#E67E22\", \n  \"Mexico\" = \"#E67E22\",\n  \"Nicaragua\" = \"#E67E22\", \n  \"Panama\" = \"#E67E22\", \n  \"United States\" = \"#E67E22\"\n)\n\n\n\n\np4 <- ggplot(all_results, aes(x = income_actual, y = mastertimss, color = country)) +\n  geom_smooth(method = \"loess\", se = FALSE, span = 0.6, size = 0.4) +\n  scale_color_manual(values = country_colors) +\n  geom_text_repel(data = line_points, aes(x = label_x, y = label_y, label = country), size = 3) +\n\n  # Scales and aesthetics\n  scale_x_log10(\n    breaks = c(100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000),\n    labels = scales::label_dollar(accuracy = 1)\n  ) +\n  scale_y_continuous(breaks = seq(300, 600, by = 50), limits = c(300, 600)) +\n  coord_cartesian(xlim = c(100, 50000)) +\n  \n  # Labels\n  labs(\n    title = \"Learning outcomes of children around the world, by household income\",\n    subtitle = \"Each line plots the average test scores in mathematics by the level of income of the family's household\",\n    x = \"Annual household income (adjusted for price differences between countries)\\non a logarithmic axis\",\n    y = \"\",\n    color = \"Country\", \n    caption = \"<span style='color:gray;'>Data source: Dev Patel and Justin Sandefur (2020) - A Rosetta Stone for Human Capital. The outlier Yemen is not shown for better readability.<br>\n    <span style='color:darkblue;'>OurWorldInData.org<\/span> - Research and data to make progress against the world's largest problem.<span style='color:darkblue;'>&nbsp;&nbsp;&nbsp;Licensed under CC-BY<\/span> by the author Max Roser<\/span>\"\n  ) +\n  \n  # Theme\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(size = 24, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 16, hjust = 0.5),\n    axis.title.x = element_text(color = \"steelblue4\", size = 12),\n    axis.title.y = element_text(color = \"darkgreen\", size = 12),\n    axis.text.x = element_text(color = \"steelblue4\", size = 10),\n    axis.text.y = element_text(color = \"darkgreen\", size = 10),\n    panel.grid.major = element_line(linetype = \"dashed\"),\n    panel.grid.minor = element_line(linetype = \"dotted\"),\n    plot.caption = element_markdown(size = 10, hjust = 0, color = \"gray50\")\n  ) +\n  annotate(\"text\", x = 100, y = 600, label = \"Test score in\\nmathematics\", angle = 0, color = \"darkgreen\", size = 4)\np4\n\n\n\nDiscussion\nDespite the discernible patterns exhibited by the colour coding, such as the tendency of blue colours to be associated with lower test scores and income, and green or orange colours to be associated with higher values, the chart remains perplexing in its overall presentation.\nIt is not possible to derive clear statements about differences between the continents.\nThe convergence of lines, particularly within the middle income range, further complicates the interpretation of the chart.\nFurthermore, a challenge arises in the comparison of countries within a specific continent.\nThe absence of interactive elements or annotations further exacerbates the challenge of interpreting the data.\nReferences\nMax Roser (2022) - “Millions of children learn only very little.\nHow can the world provide a better education to the next generation?”\nPublished online at OurWorldinData.org.\nRetrieved from: ‘https://ourworldindata.org/better-learning’ [Online Resource]\n\n\n\n",
    "preview": "projects/2024/100532846/100532846_files/figure-html5/graph3-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2688,
    "preview_height": 1920
  },
  {
    "path": "projects/2024/100536210/",
    "title": "Is economic growth in your country still costing natural resources?",
    "description": "Sustainable production and consumption are essential. Since the mid-1990s,\nmany countries have increased their natural capital by 26.8%, proving that\neconomic growth can happen without depleting resources. Yet, some countries\nstill depend on resource exploitation for growth.",
    "author": [
      {
        "name": "Jia Lin",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nBackground\nOriginal graph\n\nWorking with Datasets\nLibraries and dataset\nMerging dataset with income levels\nMapping data points\n\nGraph Replication\nShiny UI for the graph\nShiny server for the graph\nBuilding the graph\nGraph replication\n\nGraph Improvement\nImproved Graph UI in Shiny\nImproved Graph server in Shiny\nBuilding the improved graph\nFinal improved graph\n\n\nIntroduction\nBackground\nSustainable development refers to maintaining economic growth and living standards without depleting natural resources or harming the environment, such as through pollution or poor waste management. The World Bank’s Sustainable Development Goal 12.2 aims to achieve sustainable management and efficient use of natural resources by 2030.\nCountries that rely heavily on non-renewable resources, such as oil, natural gas, and coal, for income often struggle to achieve long-term sustainability, as their economies face challenges once these resources are depleted. In contrast, nations that utilize renewable resources, such as sustainable forestry and fisheries, along with clean energy sources like wind and solar power, are more likely to sustain growth and environmental balance.\nOne way to assess economic sustainability is by examining whether a country’s Gross Domestic Product (GDP) depends on natural resource consumption. So, have countries truly moved toward sustainable development over the past few decades?\nOriginal graph\nworld_bank1 graph. Source: World Bank SDG Atlas Goal 12I chose this chart because it comes from the World Bank’s Sustainable Development Goal (SDG) 12 report—“Responsible Consumption and Production”—which visually illustrates the relationship between economic growth and changes in natural capital across countries from 1996 to 2018. The x-axis represents growth in natural capital (%), while the y-axis represents growth in GDP (%).\nThe chart highlights three main areas. The unsustainable growth zone in the upper left shows countries with high GDP growth but a decline in natural capital, indicating reliance on resource consumption. The sustainable growth zone in the upper right represents countries where both GDP and natural capital grow, reflecting sustainable development. Finally, the negative growth zone below the x-axis highlights countries experiencing a decline in GDP, regardless of changes in natural capital.\nUsing colors to distinguish income levels, the chart provides a clear and comparative view of global sustainability trends. It serves as a valuable reference for assessing whether countries are moving toward sustainable development.\nworld_bank2 graph. Source: World Bank SDG Atlas Goal 12In fact, this is a dynamic interactive chart. When the mouse hovers over a country’s 2018 data point, the entire path for that country is highlighted, showcasing its performance across different years. Other data points for the country also appear along the path. For example, as shown in the chart, hovering over Vietnam’s 2018 data point reveals a GDP growth rate of 452% and a natural capital growth rate of 97%. Additionally, users can move the mouse to any data point along the path to view specific indicators for that year in real time, providing valuable insights into the relationship between economic and environmental development.\nWorking with Datasets\nLibraries and dataset\n\n\nlibrary(dplyr)\nlibrary(plotly)\nlibrary(tibble)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(readr)\nlibrary(shiny)\n\n\nIn this project, I first loaded the following R packages using library() to support data processing and visualization tasks.\nIt is worth noting that the interactive charts in this project primarily rely on tools such as Shiny and Plotly to achieve dynamic effects. However, since this project is presented in R Markdown format, the interactive features cannot be directly displayed in a static document. Therefore, I will provide relevant links in later presentations to allow further exploration and interaction with the dynamic visualizations.\n\n\ngoal_12 <- read_delim(file = \"goal12.cwon.csv\", delim = \";\", col_names = TRUE)\nhead(goal_12)\n\n# A tibble: 6 × 9\n  code  countryname  year   nca   gdp growth_gdp growth_nca\n  <chr> <chr>       <dbl> <dbl> <dbl>      <dbl>      <dbl>\n1 ALB   Albania      1995 6715. 2666.       0          0   \n2 ALB   Albania      1996 6421. 2980.      11.8       -4.37\n3 ALB   Albania      1997 5512. 2718.       1.94     -17.9 \n4 ALB   Albania      1998 4767. 3021.      13.3      -29.0 \n5 ALB   Albania      1999 4827. 3472.      30.2      -28.1 \n6 ALB   Albania      2000 4930. 3861.      44.8      -26.6 \n# ℹ 2 more variables: loggrowth_gdp <dbl>, loggrowth_nca <dbl>\n\nNext, I imported the required data. I assigned the data to the variable goal_12 and loaded it from the specified file. I used a semicolon to split the data into columns, with the first row being used as column names. Finally, I stored the data in tibble format for easier handling.\nMerging dataset with income levels\n\n\nincome_level <- tibble(\n  countryname = c(\n    \"Albania\", \"United Arab Emirates\", \"Argentina\",\n    \"Armenia\", \"Australia\", \"Austria\",\n    \"Azerbaijan\", \"Burundi\", \"Belgium\",\n    \"Benin\", \"Burkina Faso\", \"Bangladesh\",\n    \"Bulgaria\", \"Bahrain\", \"Bosnia and Herzegovina\",\n    \"Belarus\", \"Belize\", \"Bolivia\",\n    \"Brazil\", \"Botswana\", \"Central African Republic\",\n    \"Canada\", \"Switzerland\", \"Chile\",\n    \"China\", \"Côte d'Ivoire\", \"Cameroon\",\n    \"Dem. Rep. Congo\", \"Congo\", \"Colombia\",\n    \"Comoros\", \"Costa Rica\", \"Czech Republic\",\n    \"Germany\", \"Djibouti\", \"Denmark\",\n    \"Dominican Republic\", \"Ecuador\", \"Egypt\",\n    \"Spain\", \"Estonia\", \"Ethiopia\",\n    \"Finland\", \"France\", \"Gabon\",\n    \"United Kingdom\", \"Georgia\", \"Ghana\",\n    \"Guinea\", \"The Gambia\", \"Greece\",\n    \"Guatemala\", \"Guyana\", \"High income\",\n    \"Honduras\", \"Croatia\", \"Haiti\",\n    \"Hungary\", \"Indonesia\", \"India\",\n    \"Ireland\", \"Iran\", \"Iraq\",\n    \"Iceland\", \"Italy\", \"Jamaica\",\n    \"Jordan\", \"Japan\", \"Kazakhstan\",\n    \"Kenya\", \"Kyrgyz Republic\", \"Cambodia\",\n    \"Korea\", \"Kuwait\", \"Lao PDR\",\n    \"Lebanon\", \"Liberia\", \"Low income\",\n    \"Sri Lanka\", \"Lower middle income\", \"Lesotho\",\n    \"Lithuania\", \"Luxembourg\", \"Latvia\",\n    \"Morocco\", \"Moldova\", \"Madagascar\",\n    \"Maldives\", \"Mexico\", \"North Macedonia\",\n    \"Mali\", \"Malta\", \"Mongolia\",\n    \"Mozambique\", \"Mauritania\", \"Mauritius\",\n    \"Malawi\", \"Malaysia\", \"Namibia\",\n    \"Niger\", \"Nigeria\", \"Nicaragua\",\n    \"Netherlands\", \"Norway\", \"Nepal\",\n    \"Oman\", \"Pakistan\", \"Panama\",\n    \"Peru\", \"Philippines\", \"Papua New Guinea\",\n    \"Poland\", \"Portugal\", \"Paraguay\",\n    \"West Bank and Gaza\", \"Qatar\", \"Romania\",\n    \"Russia\", \"Rwanda\", \"Saudi Arabia\",\n    \"Senegal\", \"Singapore\", \"Solomon Islands\",\n    \"Sierra Leone\", \"El Salvador\", \"Suriname\",\n    \"Slovak Republic\", \"Slovenia\", \"Sweden\",\n    \"Eswatini\", \"Chad\", \"Togo\",\n    \"Thailand\", \"Tajikistan\", \"Turkmenistan\",\n    \"Trinidad and Tobago\", \"Tunisia\", \"Turkey\",\n    \"Tanzania\", \"Uganda\", \"Ukraine\",\n    \"Upper middle income\", \"Uruguay\", \"United States\",\n    \"Venezuela\", \"Vietnam\", \"Yemen\",\n    \"South Africa\", \"Zambia\", \"Zimbabwe\"),\n  income_level = c(\n    \"Upper Middle Income\", \"High Income\", \"Upper Middle Income\",\n    \"Upper Middle Income\", \"High Income\", \"High Income\",\n    \"Upper Middle Income\", \"Low Income\", \"High Income\",\n    \"Low Income\", \"Low Income\", \"Lower Middle Income\",\n    \"Upper Middle Income\", \"High Income\", \"Upper Middle Income\",\n    \"Upper Middle Income\", \"Upper Middle Income\", \"Lower Middle Income\",\n    \"Upper Middle Income\", \"Upper Middle Income\", \"Low Income\",\n    \"High Income\", \"High Income\", \"Upper Middle Income\",\n    \"Upper Middle Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"Low Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"Lower Middle Income\", \"Upper Middle Income\", \"High Income\",\n    \"High Income\", \"Lower Middle Income\", \"High Income\",\n    \"Upper Middle Income\", \"Upper Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"High Income\", \"Low Income\",\n    \"High Income\", \"High Income\", \"Upper Middle Income\",\n    \"High Income\", \"Upper Middle Income\", \"Lower Middle Income\",\n    \"Low Income\", \"Low Income\", \"High Income\",\n    \"Upper Middle Income\", \"Upper Middle Income\", \"High Income\",\n    \"Lower Middle Income\", \"High Income\", \"Lower Middle Income\",\n    \"High Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"High Income\", \"High Income\", \"Upper Middle Income\",\n    \"Upper Middle Income\", \"High Income\", \"Upper Middle Income\",\n    \"Lower Middle Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"High Income\", \"Lower Middle Income\",\n    \"Lower Middle Income\", \"Low Income\", \"Low Income\",\n    \"Lower Middle Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"High Income\", \"High Income\",\n    \"Lower Middle Income\", \"Upper Middle Income\", \"Low Income\",\n    \"Upper Middle Income\", \"Upper Middle Income\", \"Upper Middle Income\",\n    \"Low Income\", \"High Income\", \"Lower Middle Income\",\n    \"Low Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"Low Income\", \"Upper Middle Income\", \"Upper Middle Income\",\n    \"Low Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"High Income\", \"Lower Middle Income\",\n    \"High Income\", \"Lower Middle Income\", \"High Income\",\n    \"Upper Middle Income\", \"Lower Middle Income\", \"Lower Middle Income\",\n    \"High Income\", \"High Income\", \"Upper Middle Income\",\n    \"Lower Middle Income\", \"High Income\", \"High Income\",\n    \"Upper Middle Income\", \"Low Income\", \"High Income\",\n    \"Lower Middle Income\", \"High Income\", \"Lower Middle Income\",\n    \"Low Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"High Income\", \"High Income\", \"High Income\",\n    \"Lower Middle Income\", \"Low Income\", \"Low Income\",\n    \"Upper Middle Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"High Income\", \"Lower Middle Income\", \"Upper Middle Income\",\n    \"Lower Middle Income\", \"Low Income\", \"Lower Middle Income\",\n    \"Upper Middle Income\", \"High Income\", \"High Income\",\n    \"Lower Middle Income\", \"Lower Middle Income\", \"Low Income\",\n    \"Upper Middle Income\", \"Low Income\", \"Lower Middle Income\"\n  ))\nincome_level\n\n# A tibble: 150 × 2\n   countryname          income_level       \n   <chr>                <chr>              \n 1 Albania              Upper Middle Income\n 2 United Arab Emirates High Income        \n 3 Argentina            Upper Middle Income\n 4 Armenia              Upper Middle Income\n 5 Australia            High Income        \n 6 Austria              High Income        \n 7 Azerbaijan           Upper Middle Income\n 8 Burundi              Low Income         \n 9 Belgium              High Income        \n10 Benin                Low Income         \n# ℹ 140 more rows\n\nIn the original data, I noticed that there was no column representing the income level of each country. However, income level is crucial for my project as it will be used to categorize data points, highlight paths, and more. Therefore, I manually created a new dataset named income_level, which includes the columns “countryname” and “income_level”, with each country’s income level corresponding accordingly.\n\n\ngoal_12 <- goal_12 |>\n  left_join(income_level, by = \"countryname\")\nhead(goal_12) |> \n  select(countryname, income_level, everything())\n\n# A tibble: 6 × 10\n  countryname income_level        code   year   nca   gdp growth_gdp\n  <chr>       <chr>               <chr> <dbl> <dbl> <dbl>      <dbl>\n1 Albania     Upper Middle Income ALB    1995 6715. 2666.       0   \n2 Albania     Upper Middle Income ALB    1996 6421. 2980.      11.8 \n3 Albania     Upper Middle Income ALB    1997 5512. 2718.       1.94\n4 Albania     Upper Middle Income ALB    1998 4767. 3021.      13.3 \n5 Albania     Upper Middle Income ALB    1999 4827. 3472.      30.2 \n6 Albania     Upper Middle Income ALB    2000 4930. 3861.      44.8 \n# ℹ 3 more variables: growth_nca <dbl>, loggrowth_gdp <dbl>,\n#   loggrowth_nca <dbl>\n\nAfter labeling the corresponding income level for each country, I used left_join() to merge the original dataset with the income_level dataset. As a result, the goal_12 dataframe now contains all the original columns, and for each row, it adds the corresponding income_level column based on the countryname.\nMapping data points\n\n\nnew_breaks_x <- c(-91, -75, -50, 0, 100, 300, 1000)\nnew_mapped_x <- c(-300, -180, -90, 0, 90, 180, 300)\n\n\nIn the mapping process, I created two vectors for x-axis: new_breaks_x and new_mapped_x, which are used to segment the original data into specific intervals and map these intervals to a new range. The reason for doing this is that when using the original data for visualization, we found that the chart display wasn’t ideal, likely because the range of the data was either too large or too small, causing some data points to appear very crowded or unclear in the chart. Specifically, new_breaks_x defines the segmentation points of the original data, which are divided into different intervals based on the characteristics of the data, while new_mapped_x is the new range we want to map these intervals to.\n\n\ncustom_map_x <- function(value) {\n  if (value < min(new_breaks_x)) {\n    mapped <- new_mapped_x[1] - 20\n  } else if (value > max(new_breaks_x)) {\n    mapped <- new_mapped_x[length(new_mapped_x)] + 20\n  } else {\n    mapped <- approx(x = new_breaks_x, y = new_mapped_x, xout = value, rule = 2)$y\n  }\n  return(mapped)\n}\n\n\nNext, I created the custom_map_x function, which maps the input raw data value value to a new range. First, if value is smaller than the minimum breakpoint, it will be mapped to the new range’s minimum value with an offset subtracted; if value is larger than the maximum breakpoint, it will be mapped to the new range’s maximum value with an offset added. If value falls within the middle breakpoints, linear interpolation is used to calculate the corresponding mapped value. This way, the range of the original data is adjusted to a more suitable interval, improving the display of the data in visualization.\n\n\ngoal_12 <- goal_12 |>\n  mutate(mapped_growth_nca = purrr::map_dbl(growth_nca, custom_map_x))\nhead(goal_12) |> select(countryname, mapped_growth_nca, income_level, everything())\n\n# A tibble: 6 × 11\n  countryname mapped_growth_nca income_level   code   year   nca   gdp\n  <chr>                   <dbl> <chr>          <chr> <dbl> <dbl> <dbl>\n1 Albania                  0    Upper Middle … ALB    1995 6715. 2666.\n2 Albania                 -7.86 Upper Middle … ALB    1996 6421. 2980.\n3 Albania                -32.2  Upper Middle … ALB    1997 5512. 2718.\n4 Albania                -52.2  Upper Middle … ALB    1998 4767. 3021.\n5 Albania                -50.6  Upper Middle … ALB    1999 4827. 3472.\n6 Albania                -47.8  Upper Middle … ALB    2000 4930. 3861.\n# ℹ 4 more variables: growth_gdp <dbl>, growth_nca <dbl>,\n#   loggrowth_gdp <dbl>, loggrowth_nca <dbl>\n\nThe purpose of this code is to transform each value in the growth_nca column of the goal_12 dataframe using the previously defined custom_map_x function, and store the transformed results in a new column called mapped_growth_nca. In this way, we adjust the original data values to a more suitable range, making them easier for subsequent analysis and visualization.\n\n\nnew_breaks_y <- c(-45, 0, 100, 300, 1000)\nnew_mapped_y <- c(-150, 0, 250, 600, 1000)\n\ncustom_map_y <- function(value) {\n  if (value < min(new_breaks_y)) {\n    mapped <- new_mapped_y[1] - 20\n  } else if (value > max(new_breaks_y)) {\n    mapped <- new_mapped_y[length(new_mapped_y)] + 50\n  } else {\n    mapped <- approx(x = new_breaks_y, y = new_mapped_y, xout = value, rule = 2)$y\n  }\n  return(mapped)\n}\n\ngoal_12 <- goal_12 |>\n  mutate(\n    mapped_growth_gdp = purrr::map_dbl(growth_gdp, custom_map_y))\n\nhead(goal_12) |> select(countryname, mapped_growth_gdp, mapped_growth_nca, income_level, everything())\n\n# A tibble: 6 × 12\n  countryname mapped_growth_gdp mapped_growth_nca income_level   code \n  <chr>                   <dbl>             <dbl> <chr>          <chr>\n1 Albania                  0                 0    Upper Middle … ALB  \n2 Albania                 29.5              -7.86 Upper Middle … ALB  \n3 Albania                  4.84            -32.2  Upper Middle … ALB  \n4 Albania                 33.3             -52.2  Upper Middle … ALB  \n5 Albania                 75.5             -50.6  Upper Middle … ALB  \n6 Albania                112.              -47.8  Upper Middle … ALB  \n# ℹ 7 more variables: year <dbl>, nca <dbl>, gdp <dbl>,\n#   growth_gdp <dbl>, growth_nca <dbl>, loggrowth_gdp <dbl>,\n#   loggrowth_nca <dbl>\n\nSimilarly, I performed a similar operation for the y-axis mapping. I created the new_breaks_y and new_mapped_y vectors to define the segmentation and mapping rules for the original and target data. Then, I defined the custom_map_y function to map each value in the growth_gdp column, ensuring that the values are adjusted to the new range. Finally, using mutate() and purrr::map_dbl(), I stored the mapped values in a new column called mapped_growth_gdp.\nGraph Replication\nShiny UI for the graph\n\n\nui <- fluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      selectInput(\"selected_country\",\n                  \"Search for a country:\",\n                  choices = c(\"All\", unique(goal_12$countryname)),\n                  selected = \"All\",\n                  selectize = TRUE))),\n  fluidRow(\n    column(\n      width = 12,\n      plotlyOutput(\"filtered_plot\", height = \"700px\"))))\n\n\nAfter organizing my data, I used it to create the graph. To achieve this, I used Shiny because it helped me build an interactive web application that allowed users to select and view different data according to their needs. First, I created the user interface (UI) using Shiny, which was divided into two parts: the first part was a dropdown menu (selectInput), which allowed users to select the country they wanted to view, with the option to choose “All” or a specific country from the dataset; the second part was a graph area (plotlyOutput), used to display the country path filtered by the selected country, with the graph’s height set to 700 pixels. The entire page layout was controlled using fluidRow and column.\nHowever, unfortunately, R Markdown cannot directly display the interactive graph created with Shiny. Therefore, at the end of this section, I will provide a link to the Shiny app so that everyone can view my graph replication.\nShiny server for the graph\n\n\nserver <- function(input, output, session) {\n  output$filtered_plot <- renderPlotly({\n    selected_country <- input$selected_country\n    filtered_data <- if (selected_country == \"All\") {\n      goal_12} \n    else {\n      goal_12 |> filter(countryname == selected_country)\n    }\n    #Codes for creating the graph content\n  })\n}\n\n\nIn a Shiny application, the core function of the server part is to handle user input and dynamically update the output content on the page based on that input. My code follows this process by filtering data and generating corresponding charts based on the country selected by the user. When the user selects a country from the dropdown menu, Shiny automatically captures this choice and updates the chart display accordingly.\nFirst, the line output$filtered_plot <- renderPlotly({}) specifies that a Plotly chart will be rendered in output$filtered_plot, ensuring that whenever the user input changes, Shiny will regenerate and update the chart display. This allows the chart to respond in real-time to the user’s actions.\nNext, the line selected_country <- input$selected_country retrieves the country selected by the user from the dropdown menu in the UI and stores it in the selected_country variable. input$selected_country is an object automatically provided by Shiny, reflecting the user’s selection in real-time.\nThen, the line filtered_data <- if (selected_country == “All”) { goal_12 } else { goal_12 |> filter(countryname == selected_country) } filters the data based on the user’s selection using a conditional statement. If the user selects “All”, filtered_data will include all the data from the goal_12 dataset. If the user selects a specific country, the filter() function will filter the data by the country’s name, ensuring that only that country’s data is displayed. Thus, filtered_data will dynamically change based on the user’s choice; if “All” is selected, all countries’ data will be shown; if a specific country is selected, only that country’s data will be displayed.\nIt is important to note that in the server part, we must create and return a chart object (this part is indicated in the code by the # comment). This is because only by returning a valid chart object will Shiny be able to display the chart in the UI. Without returning the chart object, even if the data is correctly filtered, the chart will not be rendered.\nBuilding the graph\n\n\np <- ggplot(goal_12) +\n  scale_y_continuous(\n    breaks = c(0, 200, 400, 600, 800, 1000),\n    limits = c(-125, 1100)\n  ) +\n  scale_x_continuous(\n    breaks = c(-300, -200, -100, 0, 100, 200, 300),\n    limits = c(-300, 300)\n  ) +\n  theme_minimal() +\n  theme(\n    panel.grid.major = element_line(color = \"#cececc\"), \n    panel.grid.minor = element_blank(),                 \n    panel.background = element_rect(fill = \"white\", color = NA), \n    plot.background = element_rect(fill = \"white\", color = NA)   \n  )\np\n\n\n\nFirst, I used ggplot2 to create the framework of this graph. I explicitly defined the y and x axis tick marks and ranges using scale_y_continuous and scale_x_continuous, ensuring that the visualization covered the necessary data range. Then, I applied theme_minimal to establish a clean and professional white background theme, and further customized the appearance using theme. For example, I set the major grid lines to a light gray color and removed the minor grid lines, among other adjustments.\n\n\nfig <- ggplotly(p)\n\n\nSince my graph is an interactive dynamic plot, where the data needs to support features like zooming and hovering to display detailed information, I used ggplotly to convert the static plot generated by ggplot into an interactive Plotly chart.\n\n\n    fig <- fig |>\n      add_trace(\n        data = goal_12,\n        x = ~mapped_growth_nca,\n        y = ~mapped_growth_gdp,\n        type = 'scatter',\n        mode = 'lines',\n        line = list(color = \"#cececc\", width = 0.8),\n        showlegend = FALSE,\n        split = ~countryname,\n        hoverinfo = 'none'\n      )\n fig\n\n\n\nAfter converting the ggplot graph into a Plotly chart, I used add_trace() to add a scatter line plot to the chart. The x-axis represents the growth in natural capital (mapped_growth_nca), and the y-axis represents the growth in GDP (mapped_growth_gdp). By setting type = ‘scatter’ and mode = ‘lines’, I connected the data points with lines to form a line chart. The line color is set to gray (#cececc), the line width is 0.8, and the legend is not displayed (showlegend = FALSE). Additionally, the chart is split by country data (split = ~countryname), but no hover information is shown (hoverinfo = ‘none’). With this code, I successfully added a line chart to display the relationship between the growth in natural capital and GDP growth for different countries.\n fig <- fig |>\n   add_trace(\n    data = filtered_data,\n    x = ~mapped_growth_nca,\n    y = ~mapped_growth_gdp,\n    type = 'scatter',\n    mode = 'lines',\n    line = list(\n      color = ~case_when(\n        selected_country == \"All\" ~ \"#cececc\",\n        income_level == \"Low Income\" ~ \"#aa2626\",\n        income_level == \"Lower Middle Income\" ~ \"#d36f8e\",\n        income_level == \"Upper Middle Income\" ~ \"#7b8ad0\",\n        income_level == \"High Income\" ~ \"#1a607d\",\n        TRUE ~ \"#cececc\"\n      ),\n      width = ~case_when(\n        selected_country == \"All\" ~ 0.75,\n        TRUE ~ 3\n      )\n    ),\n    split = ~countryname,\n    hoverinfo = 'none',\n    showlegend = FALSE\n  )\n\nNext, I added a new line chart to the previous plot. By setting type = ‘scatter’ and mode = ‘lines’, I connected the data points into a line. The color and width of the line change depending on the selected country or income level. For example, when “All” is selected, the line color is gray with a width of 0.75; when a specific income level is chosen, the line color adjusts according to the income level. As shown in the graph, when Australia is selected, the line color corresponds to the dark blue of Australia’s income level. Additionally, the chart is split by country data, but hover info and the legend are not displayed.\n fig <- fig |>\n   add_trace(\n     data = filtered_data |>  filter(year == 2018),\n     x = ~mapped_growth_nca,\n     y = ~mapped_growth_gdp,\n     type = 'scatter',\n     mode = 'markers',\n     marker = list(\n       size = 8.5,\n       color = ~case_when(\n         selected_country == \"All\" ~ case_when(\n           income_level == \"Low Income\" ~ \"#aa2626\",\n           income_level == \"Lower Middle Income\" ~ \"#d36f8e\",\n           income_level == \"Upper Middle Income\" ~ \"#7b8ad0\",\n           income_level == \"High Income\" ~ \"#1a607d\",\n           TRUE ~ \"grey\"\n         ),\n           income_level == \"Low Income\" ~ \"#aa2626\",\n           income_level == \"Lower Middle Income\" ~ \"#d36f8e\",\n           income_level == \"Upper Middle Income\" ~ \"#7b8ad0\",\n           income_level == \"High Income\" ~ \"#1a607d\",\n           TRUE ~ \"grey\"\n        ),\n        line = list(color = \"white\", width = 1)\n       ),\n      text = ~paste(\n       \"<span style='font-size:12px;'>\", toupper(countryname), \", \", year, \"<\/span><br>\",\n      \"<span style='font-size:11px;'>\", sprintf(\"%.0f%%\", growth_gdp), \"<\/span><br>\",\n      \"<span style='color:#6c757d; font-size:10px;'>Growth in GDP<\/span><br>\",\n      \"<span style='font-size:12px;'>\", sprintf(\"%.0f%%\", growth_nca), \"<\/span><br>\",\n      \"<span style='color:#6c757d; font-size:10px;'>Growth in natural capital<\/span>\"\n       ),\n      hoverinfo = 'text',\n      showlegend = FALSE)\n\nAbove, I have built the paths for the countries. Next, I constructed the data points for each country. I added data points for the growth in natural capital and GDP for each country in 2018 to the chart. The color of each data point is differentiated based on income level, with low-income countries in red, high-income countries in dark blue, and other income levels in different colors. When the user hovers over a data point, the country name, year, and corresponding growth percentage are displayed.\n\nAdditionally, I used a conditional expression color = ~case_when(…) to assign a color to each data point. When the user selects “All countries,” the 2018 data points for each country are colored according to their income level. However, when a specific country is selected (for example, Argentina in the chart), the data point for Argentina will be displayed in purple (the color corresponding to “Upper Middle Income”), and the data for other countries will be hidden.\n fig <- fig |>\n  add_trace(\n    data = filtered_data |>  filter(year != 2018),\n    x = ~mapped_growth_nca,\n    y = ~mapped_growth_gdp,\n    type = 'scatter',\n    mode = 'markers',\n    marker = list(\n      size = 5.5,\n      color = ~case_when(\n        selected_country == \"All\" ~ \"rgba(255, 255, 255, 0)\",\n        income_level == \"Low Income\" ~ \"#aa2626\",\n        income_level == \"Lower Middle Income\" ~ \"#d36f8e\",\n        income_level == \"Upper Middle Income\" ~ \"#7b8ad0\",\n        income_level == \"High Income\" ~ \"#1a607d\",\n        TRUE ~ \"grey\"\n      ),\n      line = list(color = \"white\", width = 0.8)\n    ),\n    text = ~case_when(\n      selected_country == \"All\" ~ \"\",\n      TRUE ~ paste(\n        \"<span style='font-size:12px;'>\", toupper(countryname), \", \", year, \"<\/span><br>\",\n        \"<span style='font-size:11px;'>\", sprintf(\"%.0f%%\", growth_gdp), \"<\/span><br>\",\n        \"<span style='color:#6c757d; font-size:10px;'>Growth in GDP<\/span><br>\",\n        \"<span style='font-size:12px;'>\", sprintf(\"%.0f%%\", growth_nca), \"<\/span><br>\",\n        \"<span style='color:#6c757d; font-size:10px;'>Growth in natural capital<\/span>\")),\n    hoverinfo = 'text', showlegend = FALSE,\n    visible = ~ifelse(selected_country == \"All\", \"legendonly\", \"visible\"))\n  \n\nAnd then, I also constructed the data points for the years other than 2018. So I continued to use the conditional expression color = ~case_when(…) to assign colors to each data point. This conditional expression works by assigning different colors to the data points based on various conditions. If the user selects “All” (all countries), the color of the data points becomes transparent, and the user can only see the data points for each country in 2018. If a specific country is selected (e.g., Brazil in the chart), the color of the data points is determined by the income level. In this case, Brazil is classified as an upper-middle-income country, so its path and data points are displayed in purple. If none of the conditions are met, the data points are filled with the default color, grey. Other parts of the code handle the size of the data points, line style, and the information displayed when the user hovers over the data points.\n fig <- fig |>\n  layout(\n    plot_bgcolor = \"#f6f5f3\", paper_bgcolor = \"#f6f5f3\",\n    xaxis = list(\n      title = list(\n        text = \"Growth in natural capital →\",\n        font = list(size = 12), standoff = 20),\n      tickvals = new_mapped_x,\n      ticktext = c(\"-91%\", \"-75%\", \"-50%\", \"0%\", \"+100%\", \"+300%\",\"+1000%\"),\n      range = c(min(new_mapped_x) - 50, max(new_mapped_x) + 50),\n      showline = FALSE, zeroline = TRUE,\n      tickangle = 0, tickfont = list(size = 8)),\n    yaxis = list(\n      title = list(\n        text = \"Growth in GDP →\", font = list(size = 12)),\n      tickvals = new_mapped_y,\n      ticktext = c(\"-50%\", \"0%\", \"+100%\", \"+300%\", \"+1000%\"),\n      range = c(min(new_mapped_y) - 20, max(new_mapped_y) + 80),\n      showline = FALSE, zeroline = TRUE,\n      tickfont = list(size = 8)),\n    hoverlabel = list(\n      bgcolor = \"white\", font = list(color = \"black\"),\n      align = \"left\"),\n    margin = list(t = -10,b = -10,l = 0,r = 0))\n\nSo far, I have completed the construction of the paths and data points for all the countries. Now, I have reached the final step in creating the chart — setting up the chart layout. In this part of the code, I customized the layout of the chart, adjusting various aesthetic elements to improve its appearance and readability. The background color of the plot and paper is set to a light beige. The x-axis and y-axis labels display the growth in natural capital and GDP, respectively. Additionally, the tick marks on the axes are set to show specific values, such as “-91%”, “-75%”, and others, reflecting different growth rates.\nFor the x-axis, I used the new_mapped_x values to set the tick positions, while for the y-axis, the tick positions are determined by the new_mapped_y values. I also slightly adjusted the axis range to ensure the data points are well-spaced and fully visible. The axis lines are hidden (showline = FALSE), but the zero lines remain visible (zeroline = TRUE).\nThe hover labels have a white background, black font color, and left-aligned text to ensure the information is clearly visible when users hover over a data point. Finally, I slightly reduced the margins of the chart, setting t = -10, b = -10, l = 0, and r = 0 to make the chart more compact and fit the available space.\nfig <- fig |>\n   layout(     \n    shapes = list(\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.055, y0 = -0.125, x1 = 0.065, y1 = -0.105,\n        fillcolor = \"#aa2626\", line = list(color = \"#aa2626\")),\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.285, y0 = -0.125, x1 = 0.295, y1 = -0.105,\n        fillcolor = \"#d36f8e\", line = list(color = \"#d36f8e\")),\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.615, y0 = -0.125, x1 = 0.625, y1 = -0.105,\n        fillcolor = \"#7b8ad0\", line = list(color = \"#7b8ad0\")),\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.88, y0 = -0.125, x1 = 0.89, y1 = -0.105,\n        fillcolor = \"#1a607d\", line = list(color = \"#1a607d\"))),\n    annotations = list(\n      list(\n        x = 0.07, y = -0.13,\n        text = \"Low Income\", showarrow = FALSE,\n        font = list(size = 10, color = \"black\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.3, y = -0.13,\n        text = \"Lower Middle Income\", showarrow = FALSE,\n        font = list(size = 10, color = \"black\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.72, y = -0.13,\n        text = \"Upper Middle Income\", showarrow = FALSE,\n        font = list(size = 10, color = \"black\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.95, y = -0.13,\n        text = \"High Income\", showarrow = FALSE,\n        font = list(size = 10, color = \"black\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.5, y = 1.125,\n  text = \"Growth in natural capital per and GDP per capita(%), 1996-2018\",\n        showarrow = FALSE,\n        font = list(size = 17, color = \"black\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.1, y = 0.85,\n        text = \"UNSUSTAINABLE GROWTH\",\n        showarrow = FALSE,\n        font = list(size = 12, color = \"#706f7d\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.9, y = 0.85,\n        text = \"SUSTAINABLE GROWTH\",\n        showarrow = FALSE,\n        font = list(size = 12, color = \"#706f7d\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\"),\n      list(\n        x = 0.5, y = 0.028,\n        text = \"NEGATIVE GROWTH\", showarrow = FALSE,\n        font = list(size = 12, color = \"#706f7d\", weight = \"bold\"),\n        xref = \"paper\", yref = \"paper\")))\n\nIn this part of the code, I continued to add shapes and annotations to the chart layout. First, using shapes, I added four circular markers to the chart, each representing a different income level. These circles are positioned and sized relative to the chart’s paper coordinate system by setting xref and yref to “paper,” and the fill and border colors of each circle correspond to the income level.\nThen, using annotations, I added several labels at different positions on the chart to indicate income level categories. Each annotation is placed in the paper coordinate system using xref and yref, and the text is styled with font to define the font, color, and weight. The annotations include labels for low income, lower middle income, upper middle income, and high income.\nAs in the original chart, the top and bottom of the chart also have text labels indicating “SUSTAINABLE GROWTH” and “UNSUSTAINABLE GROWTH” to clearly highlight the meaning of different areas. Additionally, the text “NEGATIVE GROWTH” is added at the bottom.\nGraph replication\nHere is my Graph replication. You can click the link to explore the interactive chart in more detail: Graph replication.\nGraph Improvement\nIn discussions with the professor, we agreed that the original graph, which displayed data from all countries in a single chart, became too cluttered with paths and data points, resulting in a visually chaotic presentation. Therefore, I have decided to make improvements and optimizations to the graph. I plan to filter the data based on income level, placing countries with different income levels into separate graphs. This approach is to make each graph more concise and clear, allowing users to more easily compare the growth trends of countries with different income levels. At the same time, the dataset content remains consistent with the replicate graph. Therefore, I focused on showcasing the improved parts, specifically the UI and server aspects.\nImproved Graph UI in Shiny\n\n\nui <- fluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      h2(\n        \"Growth in natural capital per and GDP per capita (%), 1996-2018\",\n        style = \"text-align: center; margin-bottom: -50px; font-size: 18px;\"))),\n  fluidRow(\n    column(\n      width = 12,\n      selectInput(\"selected_country\",\n                  \"Search for a country:\",\n                  choices = c(\"All\", unique(goal_12$countryname)),\n                  selected = \"All\",\n                  selectize = TRUE))),\n  fluidRow(\n    column(\n      width = 6, plotlyOutput(\"low_income_plot\", height = \"350px\")),\n    column(\n      width = 6, plotlyOutput(\"lower_middle_income_plot\", height = \"350px\"))),\n  fluidRow(\n    column(\n      width = 6, plotlyOutput(\"upper_middle_income_plot\", height = \"350px\")),\n    column(\n      width = 6, plotlyOutput(\"high_income_plot\", height = \"350px\"))))\n\n\nIn the UI section of the Shiny application, I created a main title (h2), which is “Growth in natural capital and GDP per capita (%), 1996-2018”. The second part retains the dropdown menu (selectInput) from the replicate graph, allowing users to select a country from the goal_12 dataset. The third and fourth parts are divided into two rows, each containing two chart outputs. These rows are organized using fluidRow and column to ensure the layout adapts to different screen sizes. Each column contains a plotlyOutput, which will display interactive charts for different income levels: low income, lower middle income, upper middle income, and high income. The height of each chart is set to 350 pixels.\nImproved Graph server in Shiny\n\n\nserver <- function(input, output, session) {\n  render_income_plot <- function(income_level_filter, income_level_name) {\n    renderPlotly({\n      selected_country <- input$selected_country\n      filtered_data <- goal_12 |> filter(income_level == income_level_filter)\n      if (selected_country != \"All\") {\n        filtered_data <- filtered_data |> filter(countryname == selected_country)}\n      #Codes for creating the replicate graph content\n    })}\n  output$low_income_plot <- render_income_plot(\"Low Income\", \"Low Income\")\n  output$lower_middle_income_plot <- render_income_plot(\n    \"Lower Middle Income\", \"Lower Middle Income\")\n  output$upper_middle_income_plot <- render_income_plot(\n    \"Upper Middle Income\", \"Upper Middle Income\")\n  output$high_income_plot <- render_income_plot(\"High Income\", \"High Income\")\n}\n\n\nIn this code, a function named render_income_plot is first defined. This function takes two parameters: income_level_filter and income_level_name. The income_level_filter is used to specify the income level of the data to be filtered (e.g., “Low Income”, “Upper Middle Income”), while income_level_name is used for naming or labeling the charts. The purpose of this function is to filter the data based on income level and generate the corresponding interactive chart.\nNext, inside the function, renderPlotly is used to render a Plotly chart. First, the selected country selected_country is obtained. If the user selects “All”, all countries’ data will be displayed. Otherwise, the filter() function is used to further filter the data based on the selected country. This way, by selecting different income levels and countries, the user can view the corresponding chart.\nIn the latter part of the code, I use the render_income_plot function to filter the data based on income levels and generate a separate chart for each income level. By doing this, countries with low income, lower middle income, upper middle income, and high income are displayed in separate charts, making each chart clearer and avoiding the overcrowding of information.\nBuilding the improved graph\nNow we have reached the “building the improved graph” stage. All the paths and data points added are consistent with the code from the replicate graph. Here, I will focus on explaining the changes in the layout.\nshapes <- list()\n  if (income_level_filter == \"Low Income\") {\n    shapes <- list(\n      list(\n        type = \"circle\", \n        xref = \"paper\", yref = \"paper\",\n        x0 = 0.429, y0 = -0.127, x1 = 0.44, y1 = -0.107,\n        fillcolor = \"#aa2626\", line = list(color = \"#aa2626\")))}\n  else if (income_level_filter == \"Lower Middle Income\") {\n    shapes <- list(\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.437, y0 = -0.127, x1 = 0.448, y1 = -0.107,\n        fillcolor = \"#d36f8e\", line = list(color = \"#d36f8e\")))}\n  else if (income_level_filter == \"Upper Middle Income\") {\n    shapes <- list(\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.405, y0 = -0.13, x1 = 0.416, y1 = -0.11,\n        fillcolor = \"#7b8ad0\", line = list(color = \"#7b8ad0\")))}\n  else if (income_level_filter == \"High Income\") {\n    shapes <- list(\n      list(\n        type = \"circle\", xref = \"paper\", yref = \"paper\",\n        x0 = 0.444, y0 = -0.13, x1 = 0.455, y1 = -0.11,\n        fillcolor = \"#1a607d\", line = list(color = \"#1a607d\")))}\nThe main purpose of this code is to customize the visual appearance of the chart by adding different shapes for each income level, providing a visual cue to help distinguish between different income groups. The shapes variable is initially set as an empty list, and then, based on the value of income_level_filter, different circles are added to the chart layout. For “Low Income”, a red circle is added at a specified location on the chart. For “Lower Middle Income”, a light pink circle is added. For “Upper Middle Income”, a light blue circle is placed, and for “High Income”, a dark blue circle is added. Each shape is positioned on the chart using a set of coordinates (x0, y0, x1, y1). The fillcolor property sets the circle’s fill color, and the line property specifies the circle’s border color.\n  fig <- fig |>\n    layout( \n    shapes = shapes,\n      annotations = list(\n        list(\n          x = -0.11, y = 1,\n          text = if (income_level_filter == \"Low Income\")\n            \"Growth in GDP →\" else \"\",\n          showarrow = FALSE,\n          font = list(size = 12, color = \"black\", weight = \"bold\"),\n          xref = \"paper\", yref = \"paper\",\n          textangle = -90),\n        list(\n          x = 0.99, y = -0.15,\n          text = if (income_level_filter == \"High Income\")\n            \"Growth in natural capital →\" else \"\",\n          showarrow = FALSE,\n          font = list(size = 12, color = \"black\", weight = \"bold\"),\n          xref = \"paper\", yref = \"paper\"),\n        list(\n            x = 0.5, y = -0.145,\n            text = if (income_level_filter == \"Low Income\")\n              \"Low Income\" else \"\",\n            showarrow = FALSE,\n            font = list(size = 10, color = \"black\", weight = \"bold\"),\n            xref = \"paper\", yref = \"paper\"),\n         list(\n            x = 0.55, y = -0.145,\n            text = if (income_level_filter == \"Lower Middle Income\")\n              \"Lower Middle Income\" else \"\",\n            showarrow = FALSE,\n            font = list(size = 10, color = \"black\", weight = \"bold\"),\n            xref = \"paper\", yref = \"paper\"),\n         list(\n            x = 0.52, y = -0.15,\n            text = if (income_level_filter == \"Upper Middle Income\")\n              \"Upper Middle Income\" else \"\",\n            showarrow = FALSE,\n            font = list(size = 10, color = \"black\", weight = \"bold\"),\n            xref = \"paper\", yref = \"paper\"),\n         list(\n            x = 0.52, y = -0.15,\n            text = if (income_level_filter == \"High Income\")\n            \"High Income\" else \"\",\n            showarrow = FALSE,\n            font = list(size = 10, color = \"black\", weight = \"bold\"),\n            xref = \"paper\", yref = \"paper\")))\n\nThis code adds shapes and annotations to the chart based on different income levels. Specifically, it first uses shapes = shapes to add the previously defined circles (which vary in color and position depending on the income level) to the chart. Then, it uses annotations to add text labels to different areas of the chart to better explain the content.\nFor the annotations, the code first uses an if statement to check the income level condition and adds the corresponding text labels to specific positions on the chart. For example, for the low-income group, when income_level_filter == “Low Income”, the chart will display the labels “Growth in GDP →” and “Low Income”. For the high-income group, when income_level_filter == “High Income”, it will display the labels “Growth in natural capital →” and “High Income”.\nEach annotation’s position is specified using xref = “paper” and yref = “paper”, meaning that all annotations and shapes are positioned relative to the paper’s coordinate system. The font, size, and color of the text are also defined to be clear and readable.\nFinal improved graph\nFinally, I have provided the link for you to explore the final improved graph:\nfinal improved graph.\n\n\n\n",
    "preview": "projects/2024/100536210/images/fig7.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2868,
    "preview_height": 1734
  },
  {
    "path": "projects/2024/100540803/",
    "title": "Global Fish Stock Overfishing Status",
    "description": "Replication of a chart illustrating fish capture and abundance relative to sustainable levels.",
    "author": [
      {
        "name": "Linghan Zheng",
        "url": {}
      }
    ],
    "date": "2025-01-13",
    "categories": [
      "2024"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nOriginal graph\r\nReplication with data\r\nLibraries and dataset\r\n\r\nBuilding the graph\r\nThe first plot\r\nThe second plot\r\nThe third plot\r\nThe fourth plot\r\nLimitations\r\n\r\nImprovement\r\nFinal graph\r\nConclusion\r\n\r\nIntroduction\r\nOverfishing poses a significant threat to marine ecosystems by causing declining fish populations, reduced fish sizes, and even the potential extinction of species. A fish stock becomes overfished when its abundance (population size) falls below levels needed to sustain its maximum sustainable yield (MSY)—the largest amount of fish that can be sustainably captured over the long term.\r\nTo better understand fish stock health, Kobe plots are used as a dynamic tool to evaluate the relationship between fish stock capture and abundance relative to the MSY.\r\nThe x-axis represents fish stock abundance relative to the level that can produce the MSY.\r\nThe y-axis represents fish stock capture relative to the MSY.\r\nThe plot divides fish stocks into four quadrants based on their abundance and capture levels:\r\nOverfished and currently overfishing: Low abundance and high capture.\r\nNot overfished but currently overfishing: High capture but sufficient abundance.\r\nOverfished but currently not overfishing: Low abundance and reduced capture.\r\nNot overfished and currently not overfishing: Sufficient abundance and low capture.\r\nThis framework, supported by data from the US National Oceanic and Atmospheric Administration (NOAA), provides insights into long-term sustainability and helps guide fisheries management strategies.\r\nOriginal graph\r\nNote: The original graph can be found on the World Bank SDG Atlas - Goal 14: Life Below Water.\r\nReplication with data\r\nLibraries and dataset\r\nThe entire project, including the replication phase and later enhancements, will make use of the following libraries:\r\n\r\n\r\nlibrary(ggplot2)       \r\nlibrary(plotly)        \r\nlibrary(dplyr)         \r\nlibrary(cowplot)       \r\nlibrary(RColorBrewer)  \r\nlibrary(stringr)       \r\nlibrary(tidyr) \r\nlibrary(readxl)\r\nlibrary(tibble)\r\n\r\n\r\nThe project begins with importing the necessary datasets. The read.csv function from the base R package is used for loading CSV files.\r\n\r\n\r\ndata <- read.csv(\"goal14.kobe.csv\")\r\nhead(data)\r\n\r\n              species                        area year B_Bmsy F_Fmsy\r\n1     Acadian redfish  Gulf of Maine/Georges Bank 2020  1.536  0.447\r\n2       Alaska plaice Bering Sea/Aleutian Islands 2021  1.578  0.467\r\n3        Alaska skate Bering Sea/Aleutian Islands 2021  2.276  0.337\r\n4            Albacore              North Atlantic 2020  1.320  0.634\r\n5     American plaice  Gulf of Maine/Georges Bank 2019  1.161  0.345\r\n6 Arrowtooth flounder Bering Sea/Aleutian Islands 2021  2.574  0.106\r\n         species_code                   area_code\r\n1     Acadian_redfish  Gulf_of_Maine/Georges_Bank\r\n2       Alaska_plaice Bering_Sea/Aleutian_Islands\r\n3        Alaska_skate Bering_Sea/Aleutian_Islands\r\n4            Albacore              North_Atlantic\r\n5     American_plaice  Gulf_of_Maine/Georges_Bank\r\n6 Arrowtooth_flounder Bering_Sea/Aleutian_Islands\r\n\r\nBuilding the graph\r\nThe first plot\r\nTo begin the visualization, the x-axis and y-axis are established as the foundation of the plot. Orange points are plotted on the graph, representing specific data points, and two solid black lines are added at 𝑥=1 and 𝑦=1 to divide the plot into quadrants. These lines serve as reference thresholds, indicating the boundaries for key categories within the plot.\r\n\r\n\r\n p1<-ggplot(data, aes(x = B_Bmsy, y = F_Fmsy)) +\r\n  geom_vline(xintercept = 1, linetype = \"solid\", color = \"black\") +\r\n  geom_hline(yintercept = 1, linetype = \"solid\", color = \"black\") +\r\n  geom_point(color = \"white\", size = 3.5, alpha = 0.9, shape = 21, fill = \"#dc7118\", stroke = 0.8, na.rm = TRUE)\r\np1\r\n\r\n\r\n\r\nNext, I enhance the visualization by adding special points to highlight specific data points. These points are emphasized by adjusting their size, color, and borders to make them visually distinct. Finally, I add a title, axis labels, and adjust the placement of elements to ensure the visualization is aesthetically pleasing and easy to interpret.\r\n\r\n\r\nspecial_points <- data.frame(\r\n  x = c(0.44, 1.18, 1.58, 0.29),\r\n  y = c(2.2, 1.61, 0.88, 0.47),\r\n  label = c(\"Red snapper\", \"Silky shark\", \"Pacific ocean perch\", \"Atlantic herring\")\r\n)\r\np1<-p1+geom_point(data = special_points, aes(x = x, y = y), size = 5.5, shape = 21, fill = NA, color = \"black\", stroke = 0.9, na.rm = TRUE) +\r\n  geom_point(data = special_points, aes(x = x, y = y), size = 3.5, shape = 21, fill = \"#dc7118\", color = NA, na.rm = TRUE) +\r\n  coord_cartesian(xlim = c(0, 3), ylim = c(0, 3)) +\r\n  scale_x_continuous(breaks = seq(0, 3, 0.5)) +\r\n  scale_y_continuous(breaks = seq(0, 3, 0.5)) +\r\n  labs(\r\n    title = \"Understanding Overfishing Through Kobe Plot\",\r\n    subtitle = \"Dots represent fish stocks\",\r\n    x = \"Abundance (Relative to MSY target size) →\",\r\n    y = \"Capture (Relative to MSY ) →\"\r\n  ) +\r\n  theme_minimal() +\r\n  theme(\r\n    plot.title = element_text(size = 18, hjust = 0.5, margin = margin(b = 10)),\r\n    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 20)),\r\n    axis.title = element_text(size = 12),\r\n    axis.text = element_text(size = 12)\r\n  )\r\np1\r\n\r\n\r\n\r\nAt the end of the first plot, I added text labels for the special points to provide additional context. These labels identify the highlighted points with their respective names and are positioned carefully to ensure they are legible and aesthetically placed without overlapping other elements.\r\n\r\n\r\np1<-p1+geom_text(\r\n    data = special_points,\r\n    aes(x = x, y = y, label = label),\r\n    color = \"black\",\r\n    fontface = \"bold\",\r\n    size = 4,\r\n    hjust = -0.1\r\n  )\r\np1\r\n\r\n\r\n\r\nThe second plot\r\nFor the second plot, an interactive plot is created. The first step is to plot all the orange points, representing the dataset, and enable interactive hover functionality. This allows users to see additional information about each point when they hover their mouse over it. The hover text includes key details such as species name, geographic area, and relative abundance and capture metrics.\r\n\r\n\r\np2 <- plot_ly() |>\r\n  add_trace(\r\n    data = data,\r\n    x = ~B_Bmsy,\r\n    y = ~F_Fmsy,\r\n    text = ~paste(\r\n      \"<b style='font-size:16px;'>\", toupper(species), \"<\/b>\",\r\n      \"<br><b style='font-size:16px;'>\", toupper(area), \"<\/b>\",\r\n      \"<br><b style='font-size:16px;'>\", round(F_Fmsy, 2), \"<\/b>\", \"<br>Capture (Relative to MSY)\",\r\n      \"<br><b style='font-size:16px;'>\", round(B_Bmsy, 2), \"<\/b>\", \"<br>Abundance (Relative to MSY target size)\"\r\n    ),\r\n    hoverinfo = \"text\",\r\n    type = 'scatter',\r\n    mode = 'markers',\r\n    marker = list(\r\n      color = '#dc7118',\r\n      size = 10,\r\n      opacity = 0.9,\r\n      line = list(color = 'white', width = 1)\r\n    )\r\n  )\r\np2\r\n\r\n\r\n\r\nTo highlight the special points with a black border, the plot is constructed using three layers:\r\nLayer 1: Orange Points The base layer contains all the orange points representing the dataset.\r\nLayer 2: White Outline for Special Points A white outer circle is added around the special points to make them stand out visually.\r\nLayer 3: Black Highlight for Special Points The final layer adds a black border around the special points, ensuring they are clearly distinguished.\r\n\r\n\r\np2 <- p2 |>\r\n  add_trace(\r\n    x = c(0.44, 1.18, 1.58, 0.29),\r\n    y = c(2.2, 1.61, 0.88, 0.47),\r\n    type = 'scatter',\r\n    mode = 'markers',\r\n    marker = list(\r\n      size = 16,\r\n      color = \"rgba(0,0,0,0)\",\r\n      line = list(color = \"black\", width = 2)\r\n    ),\r\n    hoverinfo = \"skip\"\r\n  )\r\np2\r\n\r\n\r\n\r\nTo ensure that the special points are not overshadowed by the previously added black outer rings, I rendered them as solid orange circles, and when the mouse hovers over these points, a popup box displays detailed information, including the name, region, abundance, and capture values.\r\n\r\n\r\np2 <- p2 |>\r\n  add_trace(\r\n    x = c(0.44, 1.18, 1.58, 0.29),\r\n    y = c(2.2, 1.61, 0.88, 0.47),\r\n    type = 'scatter',\r\n    mode = 'markers',\r\n    marker = list(\r\n      size = 10,\r\n      color = \"#dc7118\",\r\n      line = list(color = \"white\", width = 1)\r\n    ),\r\n    text = c(\r\n      \"<b style='font-size:16px;'>RED SNAPPER<\/b><br><b style='font-size:16px;'>SOUTHERN ATLANTIC COAST<\/b><br><b style='font-size:16px;'>2.2<\/b><br>Capture (Relative to MSY)<br><b style='font-size:16px;'>0.44<\/b><br>Abundance (Relative to MSY target size)\",\r\n      \"<b style='font-size:16px;'>SILKY SHARK<\/b><br><b style='font-size:16px;'>CARIBBEAN SEA<\/b><br><b style='font-size:16px;'>1.61<\/b><br>Capture (Relative to MSY)<br><b style='font-size:16px;'>1.18<\/b><br>Abundance (Relative to MSY target size)\",\r\n      \"<b style='font-size:16px;'>PACIFIC OCEAN PERCH<\/b><br><b style='font-size:16px;'>NORTHERN PACIFIC<\/b><br><b style='font-size:16px;'>0.88<\/b><br>Capture (Relative to MSY)<br><b style='font-size:16px;'>1.58<\/b><br>Abundance (Relative to MSY target size)\",\r\n      \"<b style='font-size:16px;'>ATLANTIC HERRING<\/b><br><b style='font-size:16px;'>NORTHERN ATLANTIC<\/b><br><b style='font-size:16px;'>0.47<\/b><br>Capture (Relative to MSY)<br><b style='font-size:16px;'>0.29<\/b><br>Abundance (Relative to MSY target size)\"\r\n    ),\r\n    hoverinfo = \"text\"\r\n  )\r\np2\r\n\r\n\r\n\r\nLabels such as “Red Snapper” and “Silky Shark” are added to each special point, positioned slightly to the right for better readability, with a consistent style in size, color, and font.\r\n\r\n\r\np2 <- p2 |>\r\n  add_annotations(\r\n    x = c(0.44, 1.18, 1.58, 0.29),\r\n    y = c(2.2, 1.61, 0.88, 0.47),\r\n    text = c(\"<b>Red snapper<\/b>\", \"<b>Silky shark<\/b>\", \"<b>Pacific ocean perch<\/b>\", \"<b>Atlantic herring<\/b>\"),\r\n    showarrow = FALSE,\r\n    xanchor = \"left\",\r\n    xshift = 10,\r\n    font = list(size = 12, color = \"black\", family = \"Arial, sans-serif\")\r\n  )\r\np2\r\n\r\n\r\n\r\nThis code comprehensively adjusts the chart layout by setting the title, axis ranges, styles, and gridlines, as well as adding annotations for quadrant directions (e.g., “NOT OVERFISHED →”). It defines hover label styles, adds a gray rectangle and two black lines (x=1, y=1) to divide the quadrants, adjusts margins for better display, and hides the legend, ensuring the chart is clear, readable, and visually well-structured.\r\n\r\n\r\np2 <- p2 |>\r\n  layout(\r\n    title = list(\r\n      text = \"<b>Understanding Overfishing Through Kobe Plot<\/b><br><sub>Dots represent fish stocks<\/sub>\",\r\n      font = list(size = 18, family = \"Arial, sans-serif\", color = \"black\"),\r\n      y=0.96\r\n    ),\r\n    xaxis = list(\r\n      title = \"\",\r\n      range = c(0, 3),\r\n      titlefont = list(size = 12, color = \"#b0b0b0\", family = \"Arial, sans-serif\"),\r\n      title_standoff = 15,\r\n      showline = TRUE,\r\n      linecolor = \"#D3D3D3\",\r\n      linewidth = 1,\r\n      zeroline = FALSE,\r\n      showgrid = TRUE,\r\n      gridcolor = \"#D3D3D3\"\r\n    ),\r\n    yaxis = list(\r\n      title = \"\",\r\n      range = c(0, 3),\r\n      titlefont = list(size = 12, color = \"#b0b0b0\", family = \"Arial, sans-serif\"),\r\n      showline = TRUE,\r\n      linecolor = \"#D3D3D3\",\r\n      linewidth = 1,\r\n      zeroline = FALSE,\r\n      showgrid = TRUE,\r\n      gridcolor = \"#D3D3D3\"\r\n    ),\r\n    shapes = list(\r\n      list(type = \"rect\",\r\n           x0 = 0, x1 = 3, y0 = 0, y1 = 3,\r\n           line = list(color = \"#D3D3D3\", width = 1)),\r\n      list(type = \"line\", x0 = 1, x1 = 1, y0 = 0, y1 = 3,\r\n           line = list(color = \"black\", dash = \"solid\"), layer = \"below\"),\r\n      list(type = \"line\", x0 = 0, x1 = 3, y0 = 1, y1 = 1,\r\n           line = list(color = \"black\", dash = \"solid\"), layer = \"below\")\r\n    ),\r\n    annotations = list(\r\n      list(\r\n        x = 1.01, y = 2.95,\r\n        text = \"<b>NOT OVERFISHED →<\/b>\",\r\n        showarrow = FALSE,\r\n        xanchor = \"left\",\r\n        font = list(size = 12, color = \"black\", family = \"Arial, sans-serif\")\r\n      ),\r\n      list(\r\n        x = 0.99, y = 2.95,\r\n        text = \"<b>← OVERFISHED<\/b>\",\r\n        showarrow = FALSE,\r\n        xanchor = \"right\",\r\n        font = list(size = 12, color = \"black\", family = \"Arial, sans-serif\")\r\n      ),\r\n      list(\r\n        x = 0.01, y = 0.95,\r\n        text = \"<b>↓ NOT OVERFISHING<\/b>\",\r\n        showarrow = FALSE,\r\n        xanchor = \"left\",\r\n        font = list(size = 12, color = \"black\", family = \"Arial, sans-serif\")\r\n      ),\r\n      list(\r\n        x = 0.01, y = 1.05,\r\n        text = \"<b>↑ OVERFISHING<\/b>\",\r\n        showarrow = FALSE,\r\n        xanchor = \"left\",\r\n        font = list(size = 12, color = \"black\", family = \"Arial, sans-serif\")\r\n      ),\r\n      list(\r\n        x = 0, y = 3,\r\n        text = \"↑ Capture (Relative to MSY)\",\r\n        showarrow = FALSE,\r\n        xanchor = \"left\",\r\n        yanchor = \"bottom\",\r\n        textangle = 0,\r\n        font = list(size = 12, color = \"#808080\", family = \"Arial, sans-serif\")\r\n      ),\r\n      list(\r\n        x = 1, y = -0.08,\r\n        xref = \"paper\", yref = \"paper\",\r\n        text = \"Abundance (Relative to MSY target size) →\",\r\n        showarrow = FALSE,\r\n        xanchor = \"right\",\r\n        yanchor = \"middle\",\r\n        font = list(size = 12, color = \"#808080\", family = \"Arial, sans-serif\")\r\n      )\r\n    ),\r\n    hoverlabel = list(\r\n      bgcolor = \"white\",\r\n      font = list(size = 14, family = \"Arial, sans-serif\", color = \"black\"),\r\n      bordercolor = \"black\",\r\n      align = \"left\"\r\n    ),\r\n    margin = list(t = 80, b = 70, l = 30, r = 30) ,\r\n    showlegend = FALSE\r\n  )\r\n\r\np2\r\n\r\n\r\n\r\nThe third plot\r\nThe first segment of code for the third plot uses ggplot2 to create a chart with the following features: orange circular points to represent valid data points, light-colored background fills for the four quadrants to distinguish different states (with colors sampled from the original plot), white-filled regions to hide areas outside the defined range, and vertical and horizontal black lines to divide the quadrants.\r\n\r\n\r\np3 <- ggplot(data, aes(x = B_Bmsy, y = F_Fmsy)) +\r\n  geom_point(data = subset(data, B_Bmsy >= 0 & B_Bmsy <= 3 & F_Fmsy >= 0 & F_Fmsy <= 3),\r\n             color = \"white\", size = 3.5, alpha = 0.5, shape = 21, fill = \"#dc7118\", stroke = 0.8) +\r\n  geom_rect(aes(xmin = 0, xmax = 1, ymin = 1, ymax = 3), fill = \"#F1cac9\", alpha = 0.03) +\r\n  geom_rect(aes(xmin = 1, xmax = 3, ymin = 1, ymax = 3), fill = \"#F9e4b5\", alpha = 0.03) +\r\n  geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1), fill = \"#eecdb1\", alpha = 0.03) +\r\n  geom_rect(aes(xmin = 1, xmax = 3, ymin = 0, ymax = 1), fill = \"#b9d9e5\", alpha = 0.03) +\r\n  annotate(\"rect\", xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf, fill = \"white\")+\r\n  annotate(\"rect\", xmin = 3, xmax = Inf, ymin = -Inf, ymax = Inf, fill = \"white\") +\r\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0, fill = \"white\") +\r\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = 3, ymax = Inf, fill = \"white\") +\r\n  annotate(\"segment\", x = 1, xend = 1, y = 0, yend = 3, color = \"black\", linewidth = 0.7) +\r\n  annotate(\"segment\", x = 0, xend = 3, y = 1, yend = 1, color = \"black\", linewidth = 0.7)\r\np3\r\n\r\n\r\n\r\nThe following code adds quadrant labels, adjusts coordinate ranges, defines axis ticks and labels, and refines the chart’s appearance through title, subtitle, and theme settings, enhancing its clarity, visual appeal, and interpretability.\r\n\r\n\r\np3<-p3+annotate(\"text\", x = 0.5, y = 2, label = \"Overfished and currently\\noverfishing\", size = 4, color = \"black\") +\r\n  annotate(\"text\", x = 2, y = 2, label = \"Not overfished but currently\\noverfishing\", size = 4, color = \"black\") +\r\n  annotate(\"text\", x = 0.5, y = 0.5, label = \"Overfished but currently not\\noverfishing\", size = 4, color = \"black\") +\r\n  annotate(\"text\", x = 2, y = 0.5, label = \"Not overfished and currently not\\noverfishing\", size = 4, color = \"black\") +\r\n\r\n  coord_cartesian(xlim = c(0, 3), ylim = c(0, 3), clip = \"on\") +\r\n  scale_x_continuous(breaks = seq(0, 3, 0.5)) +\r\n  scale_y_continuous(breaks = seq(0, 3, 0.5)) +\r\n  labs(\r\n    title = \"Understanding Overfishing Through Kobe Plot\",\r\n    subtitle = \"Dots represent fish stocks\",\r\n    x = \"Abundance (Relative to MSY target size) →\",\r\n    y = \"Capture (Relative to MSY ) →\"\r\n  ) +\r\n  theme_minimal() +\r\n  theme(\r\n    plot.title = element_text(size = 18, hjust = 0.5, margin = margin(b = 10)),\r\n    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 20)),\r\n\r\n    axis.title.x = element_text(size = 12, color = \"#808080\", face = \"bold\"),\r\n    axis.title.y = element_text(size = 12, color = \"#808080\", face = \"bold\"),\r\n\r\n    axis.text.x = element_text(size = 12, color = \"darkgray\", margin = margin(t = 0)),\r\n    axis.text.y = element_text(size = 12, color = \"darkgray\", margin = margin(r = 0)),\r\n\r\n    axis.ticks.length = unit(-4, \"pt\"),\r\n\r\n    panel.grid.major = element_line(color = \"#b0b0b0\", linewidth = 0.5),\r\n    panel.grid.minor = element_blank()\r\n  )\r\np3\r\n\r\n\r\n\r\nThe fourth plot\r\nThe fourth plot, created using ggplot2, is a static Kobe Plot that includes the following features: orange circular points representing valid data, light-colored quadrant backgrounds sampled from the original plot, two black dividing lines (x=1 and y=1), quadrant labels with light gray text (e.g., “Overfished and currently overfishing”), highlighted special points with orange fill, white outer rings, and black borders to ensure clarity, as well as clear text labels for the special points. Additionally, the chart is refined with adjusted axis ranges, scales, titles, and gridlines for improved clarity and aesthetics.\r\n\r\n\r\nspecial_points2<- data.frame(\r\n  x = c(1.92, 1.91, 1.58, 0.21),\r\n  y = c(0.03, 0.52, 0.88, 1.09),\r\n  label = c(\"Pacific ocean perch\", \"Pacific ocean perch\", \"Pacific ocean perch\", \"Pacific bluefin tuna\")\r\n)\r\np4 <- ggplot(data, aes(x = B_Bmsy, y = F_Fmsy)) +\r\n  geom_point(data = subset(data, B_Bmsy >= 0 & B_Bmsy <= 3 & F_Fmsy >= 0 & F_Fmsy <= 3),\r\n             color = \"white\", size = 3.5, alpha = 0.3, shape = 21, fill = \"#dc7118\", stroke = 0.8) +\r\n  geom_rect(aes(xmin = 0, xmax = 1, ymin = 1, ymax = 3), fill = \"#F1cac9\", alpha = 0.03) + \r\n  geom_rect(aes(xmin = 1, xmax = 3, ymin = 1, ymax = 3), fill = \"#F9e4b5\", alpha = 0.03) + \r\n  geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1), fill = \"#eecdb1\", alpha = 0.03) + \r\n  geom_rect(aes(xmin = 1, xmax = 3, ymin = 0, ymax = 1), fill = \"#b9d9e5\", alpha = 0.03) + \r\n  annotate(\"rect\", xmin = -Inf, xmax = 0, ymin = -Inf, ymax = Inf, fill = \"white\")+\r\n  annotate(\"rect\", xmin = 3, xmax = Inf, ymin = -Inf, ymax = Inf, fill = \"white\") +\r\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = 0, fill = \"white\") + \r\n  annotate(\"rect\", xmin = -Inf, xmax = Inf, ymin = 3, ymax = Inf, fill = \"white\") +\r\n  annotate(\"segment\", x = 1, xend = 1, y = 0, yend = 3, color = \"black\", size = 0.7) + \r\n  annotate(\"segment\", x = 0, xend = 3, y = 1, yend = 1, color = \"black\", size = 0.7) + \r\nannotate(\"text\", x = 0.5, y = 2, label = \"Overfished and currently\\noverfishing\",\r\n           size = 4, color = rgb(0, 0, 0, alpha = 0.25)) +\r\n  annotate(\"text\", x = 2, y = 2, label = \"Not overfished but currently\\noverfishing\",\r\n           size = 4, color = rgb(0, 0, 0, alpha = 0.25)) +\r\n  annotate(\"text\", x = 0.5, y = 0.3, label = \"Overfished but currently not\\noverfishing\",\r\n           size = 4, color = rgb(0, 0, 0, alpha = 0.25)) +\r\n  annotate(\"text\", x = 2, y = 0.3, label = \"Not overfished and currently not\\noverfishing\",\r\n           size = 4, color = rgb(0, 0, 0, alpha = 0.25))+\r\n  coord_cartesian(xlim = c(0, 3), ylim = c(0, 3), clip = \"on\") +\r\n  scale_x_continuous(breaks = seq(0, 3, 0.5)) +\r\n  scale_y_continuous(breaks = seq(0, 3, 0.5)) +\r\n  labs(\r\n    title = \"Understanding Overfishing Through Kobe Plot\",\r\n    subtitle = \"Dots represent fish stocks\",\r\n    x = \"Abundance (Relative to MSY target size) →\",\r\n    y = \"Capture (Relative to MSY ) →\"\r\n  ) +\r\n  theme_minimal() +\r\n  theme(\r\n    plot.title = element_text(size = 18, hjust = 0.5, margin = margin(b = 10)),\r\n    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 20)),\r\n\r\n    axis.title.x = element_text(size = 12, color = \"#808080\", face = \"bold\"),\r\n    axis.title.y = element_text(size = 12, color = \"#808080\", face = \"bold\"),\r\n\r\n    axis.text.x = element_text(size = 12, color = \"darkgray\", margin = margin(b = 10)),\r\n    axis.text.y = element_text(size = 12, color = \"darkgray\", margin = margin(l = 10)),\r\n    axis.ticks.length = unit(-4, \"pt\"),\r\n    panel.grid.major = element_line(color = \"#b0b0b0\", size = 0.5),\r\n    panel.grid.minor = element_blank()\r\n  )+\r\n  geom_text(\r\n    data = special_points2,\r\n    aes(x = x, y = y, label = label),\r\n    color = \"black\",\r\n    fontface = \"bold\",\r\n    size = 4,\r\n    hjust = -0.1\r\n  )+\r\n  geom_point(data = special_points2, aes(x = x, y = y), color = \"white\", size = 3.5, alpha = 0.9, shape = 21, fill = \"#dc7118\", stroke = 0.8, na.rm = TRUE) +\r\n  geom_point(data = special_points2, aes(x = x, y = y), size = 5.5, shape = 21, fill = NA, color = \"black\", stroke = 0.9, na.rm = TRUE) +\r\n  geom_point(data = special_points2, aes(x = x, y = y), size = 3.5, shape = 21, fill = \"#dc7118\", color = NA, na.rm = TRUE)\r\np4\r\n\r\n\r\n\r\nLimitations\r\nIssues in the First Two Plots: The first two plots suffer from insufficient information density, as they only display the distribution of data points without providing a quadrant background or labels to explain the meaning of the quadrants. Additionally, the special points are not prominent enough, making it challenging to draw the viewer’s attention to them.\r\nIssues in the Third Plot (Quadrant Division): The third plot has several issues, including quadrant labels with high transparency, making them difficult to read. The background color classification lacks sufficient contrast, making it harder to distinguish between the quadrants. Furthermore, the color selection does not fully consider “eco-friendly” tones, which may not be intuitive or scientifically appropriate. Lastly, the plot does not include a legend to explain the meaning of each background color.\r\nIssues in the Fourth Plot (Special Point Annotation): In the fourth plot, the special point labels are too dense, which leads to visual clutter, especially in areas where many points are concentrated. Additionally, the background colors have high transparency, resulting in low contrast and reduced visual clarity, which diminishes the overall effectiveness of the plot.\r\nImprovement\r\nAs an improvement, the first step in this code defines a function, get_ocean, to categorize locations in the dataset into “Pacific Ocean,” “Atlantic Ocean,” or “Other” based on area names and stores the result in a new Ocean column. It then groups and sorts the data by species (species), year (year), and ocean region (Ocean), rearranging the columns to place species and Ocean at the front. Finally, it segments the data into time periods (e.g., 2006-2010) and adds a new year_range column, providing well-structured spatial and temporal data for further analysis.\r\n\r\n\r\nget_ocean <- function(area) {\r\n  if (grepl(\"Pacific|Bering Sea|Aleutian Islands|Alaska|California|Washington|Oregon|Hawaii|Puget Sound|Central Valley|Columbia River|Bristol Bay|Saint Matthew Island|Pribilof Islands\",\r\n            area, ignore.case = TRUE)) {\r\n    return(\"Pacific Ocean\")\r\n  } else if (grepl(\"Atlantic|Gulf of Mexico|Mid-Atlantic|Georges Bank|Maine|Cape Cod|Puerto Rico|St\\\\. Croix|St\\\\. Thomas|Florida Keys|East Florida\",\r\n                   area, ignore.case = TRUE)) {\r\n    return(\"Atlantic Ocean\")\r\n  } else {\r\n    return(\"Other\")\r\n  }\r\n}\r\ndata$Ocean <- sapply(data$area, get_ocean)\r\n\r\ngrouped_data <- data |>\r\n  group_by(species, year, Ocean) |>\r\n  arrange(year, Ocean) |>\r\n  ungroup() |>\r\n  mutate(Ocean = Ocean) |>\r\n  select(species, Ocean, everything()) |>\r\n  mutate(\r\n    year_range = cut(\r\n      year,\r\n      breaks = c(2005, 2010, 2015, 2020, Inf),\r\n      labels = c(\"2006-2010\", \"2011-2015\", \"2016-2020\", \"2021-Present\"),\r\n      right = TRUE\r\n    ))\r\n\r\n\r\nThe PlotA code uses ggplot2 to create a static chart that visualizes the distribution of fishery resources across different time periods and ocean regions:\r\nData Points: Points are plotted using geom_point, with position_jitter applied to add random offsets and prevent overlap.\r\nColors: Classified by time periods: 2006-2010 in blue, 2011-2015 in green, 2016-2020 in orange, and 2021-Present in red.\r\nShapes: Classified by ocean type: Pacific Ocean as circles and Atlantic Ocean as diamonds.\r\nChart Styling: Titles, subtitles, axis labels, and legend styles are customized for clarity and visual appeal. This chart effectively illustrates the distribution of fishery resources and their classifications across different time periods and ocean regions.\r\n\r\n\r\nplotA <- ggplot(grouped_data, aes(x = B_Bmsy, y = F_Fmsy, color = year_range, shape = Ocean)) +\r\n  geom_vline(xintercept = 1, linetype = \"solid\", color = \"black\", size = 0.7) +\r\n  geom_hline(yintercept = 1, linetype = \"solid\", color = \"black\", size = 0.7) +\r\n  geom_point(position = position_jitter(width = 0.05, height = 0.05), size = 3, stroke = 1, alpha = 0.8) +\r\n  coord_cartesian(xlim = c(0, 3), ylim = c(0, 3)) +\r\n  scale_color_manual(values = c(\"2006-2010\" = \"#1f78b4\",\r\n                                \"2011-2015\" = \"#33a02c\",\r\n                                \"2016-2020\" = \"#ff7f00\",\r\n                                \"2021-Present\" = \"#e31a1c\")) +\r\n  scale_shape_manual(values = c(\"Pacific Ocean\" = 20, \"Atlantic Ocean\" = 4)) +\r\n  annotate(\"text\", x = 1.05, y = 2.95, label = \"NOT OVERFISHED →\",\r\n           hjust = 0, fontface = \"bold\", size = 2.5, color = \"black\") +\r\n  annotate(\"text\", x = 0.95, y = 2.95, label = \"← OVERFISHED\",\r\n           hjust = 1, fontface = \"bold\", size = 2.5, color = \"black\") +\r\n  annotate(\"text\", x = 0.01, y = 0.95, label = \"↓ NOT OVERFISHING\",\r\n           hjust = 0, vjust = 1, fontface = \"bold\", size = 2.5, color = \"black\") +\r\n  annotate(\"text\", x = 0.01, y = 1.05, label = \"↑ OVERFISHING\",\r\n           hjust = 0, vjust = 0, fontface = \"bold\", size = 2.5, color = \"black\") +\r\n  scale_x_continuous(breaks = seq(0, 3, 0.5)) +\r\n  scale_y_continuous(breaks = seq(0, 3, 0.5)) +\r\n  labs(\r\n    title = \"\",\r\n    subtitle = \"Abundance vs. Capture Relative to MSY\",\r\n    x = \"Abundance (Relative to MSY target size) →\",\r\n    y = \"Capture (Relative to MSY) →\",\r\n    color = \"Year Range\",\r\n    shape = \"Ocean\"\r\n  ) +\r\n  theme_minimal() +\r\n  theme(\r\n    plot.title = element_text(size = 18, hjust = 0.5, margin = margin(b = 10)),\r\n    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 20)),\r\n    axis.title = element_text(size = 12),\r\n    axis.text = element_text(size = 12),\r\n    legend.position = \"right\",\r\n    legend.title = element_text(size = 10, face = \"bold\"),\r\n    legend.text = element_text(size = 9)\r\n  )\r\nplotA\r\n\r\n\r\n\r\nThe PlotB code uses ggplot2 to create a faceted stacked bar chart that illustrates the changes in fish stock statuses across different ocean regions and time periods. The data is first classified into four statuses (e.g., “Healthy”) based on B_Bmsy and F_Fmsy, then plotted as bars grouped by time periods and faceted by ocean regions.\r\nThe chart uses a color palette to distinguish statuses, adds a dashed line for emphasis, and applies styling for clarity, effectively visualizing the trends in fish stock statuses over time and across regions.\r\n\r\n\r\ngrouped_data <- grouped_data %>%\r\n  mutate(\r\n    status = case_when(\r\n      B_Bmsy < 1 & F_Fmsy > 1 ~ \"Overfished & Overfishing\",\r\n      B_Bmsy >= 1 & F_Fmsy > 1 ~ \"Not Overfished & Overfishing\",\r\n      B_Bmsy < 1 & F_Fmsy <= 1 ~ \"Overfished but Not Overfishing\",\r\n      B_Bmsy >= 1 & F_Fmsy <= 1 ~ \"Healthy\"\r\n    )\r\n  )\r\nplotB <- ggplot(grouped_data, aes(x = year_range, fill = status)) +\r\n  geom_bar(position = \"stack\", color = \"white\", width = 0.7) +\r\n  facet_wrap(~Ocean, scales = \"free_x\") +\r\n  scale_fill_brewer(palette = \"Set2\") +\r\n  annotate(\"segment\", x = 5, xend = 5, y = 0, yend = Inf,\r\n           linetype = \"dashed\", color = \"black\", size = 1) +\r\n  labs(\r\n    title = \" \",\r\n    subtitle = \"Comparing Fish Stocks Status Across Oceans Over Time\",\r\n    x = \"Year Range\",\r\n    y = \"Count of Fish Stocks\",\r\n    fill = \"Status\"\r\n  ) +\r\n  theme_minimal() +\r\n  theme(\r\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\r\n    plot.subtitle = element_text(size = 12, hjust = 0.5, margin = margin(b = 10)),\r\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\r\n    axis.title = element_text(size = 12, face = \"bold\"),\r\n    legend.title = element_text(size = 10, face = \"bold\"),\r\n    legend.text = element_text(size = 9),\r\n    strip.text = element_text(size = 12, face = \"bold\"),\r\n    panel.spacing = unit(1, \"lines\")\r\n  )\r\nplotB\r\n\r\n\r\n\r\nFinal graph\r\nThis code combines two plots (plotA and plotB) into a single layout using plot_grid, arranging them side by side with two columns (ncol = 2). It then creates a title using ggdraw and draw_label, setting it with bold font, size 16, and centered alignment (hjust = 0.5). Finally, it combines the title and the plots into one final layout with plot_grid, stacking the title above the combined plots in a vertical arrangement, with the title taking 10% of the height and the plots taking the remaining 90%.\r\n\r\n\r\ncombined_plot<- plot_grid(\r\n  plotA, plotB,\r\n  ncol = 2\r\n)\r\ntitle <- ggdraw() + draw_label(\"Fish Stock Status by Year Range and Ocean\", fontface = 'bold', size = 16, hjust = 0.5)\r\np5<-plot_grid(title, combined_plot, ncol = 1, rel_heights = c(0.1, 1))\r\np5\r\n\r\n\r\n\r\nConclusion\r\nIn this project, I successfully replicated and improved the original visualizations to better analyze and communicate the distribution and status of fish stocks over time and across ocean regions. The replication process ensured consistency with the original while establishing a foundation for enhancements.\r\nKey improvements included refining the visual clarity of quadrant divisions, making special points more prominent, and providing clearer labels and annotations. Additionally, I introduced more informative categorizations, such as time periods and ocean regions, and utilized color palettes that are visually intuitive and eco-friendly.\r\nThese enhancements not only preserved the integrity of the original visualizations but also made them more interpretable and accessible for further analysis and decision-making.\r\n\r\n\r\n\r\n",
    "preview": "projects/2024/100540803/100540803_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100452420/",
    "title": "Serena Williams Career",
    "description": "It shows the ranking of the famous tennis player.",
    "author": [
      {
        "name": "Diego Fernández-Alvarez",
        "url": {}
      }
    ],
    "date": "2025-01-12",
    "categories": [
      "2024"
    ],
    "contents": "\r\n\r\nContents\r\nOriginal Chart\r\nReplication of the graph\r\nLibraries and Data Preparation\r\nAdding an extra color for the number one ranking\r\n\r\nCreating the Plot\r\nSetting the Aesthetics\r\nAnnotations and Titles\r\nLast Adjustments\r\n\r\nImprovements\r\nDifficulties encountered\r\n\r\nThis post details my process of replicating a chart that visualizes Serena Williams’s world tennis ranking from 1998 to 2022. The original chart was published by The New York Times, and you can view it here.\r\nBelow is the original chart for reference:\r\nOriginal PlotOriginal Chart\r\nThe chart displays Serena Williams’s fluctuating WTA (Women’s Tennis Association) rankings throughout her career.\r\nthere are some relevant features such as a reverse y-axis that ranks her at the top with “No. 1” and descends to “20.”. Also, the color orange in the line indicates periods when she held the No. 1 ranking. Finally there are some text annotations summarizing key moments in her career, such as her initial rise to No. 1, her return after childbirth, and her record-breaking 186 consecutive weeks at No. 1.\r\nI selected this graph for its explanatory power and simplicity, making it easy to interpret even for readers unfamiliar with tennis. Moreover, as a lifelong tennis fan, I have a personal connection to the topic.\r\nReplication of the graph\r\nLibraries and Data Preparation\r\nFor this project, I primarily used the tidyverse package in R for data manipulation and visualization. Obtaining the dataset was challenging, as the official WTA website does not provide comprehensive rankings data. Fortunately, I discovered a GitHub repository by Jeff Sackmann that contained historical WTA rankings. However, the data was divided by decades (90s, 00s, 10s, and 20s) and included all players.\r\nTo prepare the data, I joined the four tables into a single dataset (wta_data). After identifying Serena Williams’s player ID (200033), I filtered the data to create the final dataset (serena_data) for the analysis.\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\n# Reading the data\r\nwta90s <- as_tibble(read.csv(\"wta_rankings_90s.csv\"))\r\nwta00s <- as_tibble(read.csv(\"wta_rankings_00s.csv\"))\r\nwta10s <- as_tibble(read.csv(\"wta_rankings_10s.csv\"))\r\nwta20s <- as_tibble(read.csv(\"wta_rankings_20s.csv\"))\r\n\r\nwta_data <- rbind(wta90s, wta00s, wta10s, wta20s)\r\n\r\nserena_data <- wta_data |>\r\n  filter(player == 200033) |> \r\n  select(ranking_date, rank) |>\r\n  mutate(ranking_date = as.Date(as.character(ranking_date), \"%Y%m%d\"))\r\n\r\n\r\nAdding an extra color for the number one ranking\r\nTo replicate the orange line segments indicating Serena’s No. 1 status, I created a line_color column based on specific date ranges. I had to select the specific weeks when Serena was number 1 so when the line goes through those periods of time, the color turns orange and blue in any other cases.\r\n\r\n\r\nserena_data <- serena_data |>\r\n  mutate(line_color = ifelse(ranking_date >= as.Date(\"2002-04-24\") &\r\n                               ranking_date <= as.Date(\"2003-05-15\") |\r\n                               ranking_date >= as.Date(\"2008-06-20\") &\r\n                               ranking_date <= as.Date(\"2008-07-13\") |\r\n                               ranking_date >= as.Date(\"2008-11-30\") &\r\n                               ranking_date <= as.Date(\"2009-01-20\") |\r\n                               ranking_date >= as.Date(\"2009-08-15\") &\r\n                               ranking_date <= as.Date(\"2010-07-15\") |\r\n                               ranking_date >= as.Date(\"2012-12-15\") &\r\n                               ranking_date <= as.Date(\"2016-06-15\") |\r\n                               ranking_date >= as.Date(\"2016-11-10\") &\r\n                               ranking_date <= as.Date(\"2016-12-25\")|\r\n                               ranking_date >= as.Date(\"2017-02-02\") &\r\n                               ranking_date <= as.Date(\"2017-02-15\")|\r\n                               ranking_date >= as.Date(\"2009-07-27\") &\r\n                               ranking_date <= as.Date(\"2009-08-01\"),\r\n                             \"#FF851B\", \"#3093CF\"))\r\n\r\n\r\nCreating the Plot\r\nSetting the Aesthetics\r\nThe plot uses ggplot2 to map the x-axis to ranking_date and the y-axis to rank. The y-axis is reversed to emphasize the “No. 1” rank, displaying values from 1 to 20 in intervals of 5, as shown in the original plot. The x-axis spans from 01/01/1998 to 31/12/2022, corresponding to the timeline of Serena’s career, ending in the year of her retirement.\r\n\r\n\r\np <- ggplot(serena_data, aes(x = ranking_date, y = rank)) +\r\n  geom_line(color = serena_data$line_color,\r\n            size = ifelse(serena_data$line_color == \"#FF851B\", 1.5, 1)) +\r\n  scale_y_reverse(limits = c(20, 1),\r\n                  breaks = c(1, 5, 10, 15, 20),\r\n                  labels = c(\"No. 1\" = expression(bold(\"No. 1\")), \"5\", \"10\", \"15\", \"20\")) +\r\n  scale_x_date(\r\n    limits = c(as.Date(\"1998-01-01\"), as.Date(\"2022-12-31\")),\r\n    breaks = seq(as.Date(\"1998-01-01\"), as.Date(\"2022-01-01\"), by = \"1 year\"),\r\n    date_labels = \"          |  '%y\"\r\n  )\r\np\r\n\r\n\r\n\r\nTo match the style of the original chart, I used theme_minimal and customized grid lines and axis labels.\r\n\r\n\r\np <- p +\r\n  theme_minimal(base_size = 10) +\r\n  theme(\r\n    axis.text.x = element_text(color = \"grey\"),\r\n    plot.title = element_text(hjust = 0.47, face = \"bold\", size = 10),\r\n    axis.title.y = element_blank(),\r\n    axis.title.x = element_blank(),\r\n    axis.text.y = element_text(hjust = 1, color = \"black\"),\r\n    panel.grid.major.x = element_blank(),\r\n    panel.grid.minor = element_blank())\r\np\r\n\r\n\r\n\r\nAnnotations and Titles\r\nAnnotations provide context to key moments in Serena’s career. I included the four comments from the original graph. Additionally, I added the title to the plot. Here’s how I implemented these changes:\r\n\r\n\r\np <- p +\r\n  labs(\r\n    title = \"Serena Williams's world ranking since 1998\",\r\n    x = \"\",\r\n    y = \"\"\r\n  ) +\r\n  annotate(\"text\", x = as.Date(\"2001-10-01\"), y = 1.8,\r\n           label = \"Williams first rose to\\nNo. 1 in July 2002, at\\nage 20. She stayed\\nNo. 1 for 49 weeks.\",\r\n           size = 2.5, hjust = 1) +\r\n  annotate(\"text\", x = as.Date(\"2005-02-01\"), y = 18,\r\n           label = \"Her ranking\\nfell below\\n20 in 2006.\",\r\n           size = 2.5, hjust = 1) +\r\n  annotate(\"text\", x = as.Date(\"2013-08-01\"), y = 3.2,\r\n           label = \"She stayed No.1 for\\n186 consecutive weeks\\nfrom Feb. 2013 to\\nSept. 2016.\",\r\n           size = 2.5, hjust = 0) +\r\n  annotate(\"text\", x = as.Date(\"2017-02-01\"), y = 18,\r\n           label = \"She gave birth to\\nher daughter in\\n2017 and returned\\nto tennis in 2018.\",\r\n           size = 2.5, hjust = 1)\r\np\r\n\r\n\r\n\r\nLast Adjustments\r\nFinally, the arrows, dotted lines, and source were added to the chart. Both the arrows and dotted lines were created using the annotate function. The source is placed at the bottom of the chart, as in the original. Although I did not obtain the data directly from the WTA, I aimed to replicate the original plot as closely as possible.\r\n\r\n\r\np <- p +\r\n  annotate(\"segment\", x = as.Date(\"1999-03-25\"), xend = as.Date(\"1999-03-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"1998-11-07\"), xend = as.Date(\"1998-11-07\"), y = 17, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2006-01-25\"), xend = as.Date(\"2006-01-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2007-01-25\"), xend = as.Date(\"2007-01-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2011-05-20\"), xend = as.Date(\"2011-05-20\"), y = 17, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2011-10-01\"), xend = as.Date(\"2011-10-01\"), y = 14, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2017-09-01\"), xend = as.Date(\"2017-09-01\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2018-09-01\"), xend = as.Date(\"2018-09-01\"), y = 16, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"curve\", x = as.Date(\"2002-01-01\"), y = 1, xend = as.Date(\"2002-06-01\"), yend = 1,\r\n           curvature = 0,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2005-05-01\"), y = 18, xend = as.Date(\"2006-01-01\"), yend = 20,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2017-07-01\"), y = 18, xend = as.Date(\"2018-04-01\"), yend = 20,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2013-07-01\"), y = 2, xend = as.Date(\"2013-04-01\"), yend = 1.2,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n  labs(caption = \"Source: Women's Tennis Association\") +\r\n  theme(\r\n    plot.caption = element_text(hjust = 0.311, face = \"bold\", vjust = -1, size = 7, color = \"grey\"),\r\n    plot.caption.position = \"plot\"\r\n  )\r\np\r\n\r\n\r\n\r\nImprovements\r\nThe graph is straightforward and clearly illustrates the player’s career trajectory. While showing a player’s ranking is insightful, I thought it would be more interesting to include the titles she won throughout her career. This addition allows for a deeper analysis of why her ranking dropped on certain occasions and on which surface she played more comfortably, winning the most titles.\r\nI could not include all tournaments, as the final table would have been too large. Instead, I chose to focus on the four most important tennis tournaments: the Grand Slams. These events award the most points to players, making them a reliable indicator of a player’s ranking.\r\nI renamed the previous graph to “serena_ranking_plot” and removed the original source to attach the new graph at the bottom. Additionally, I used theme(plot.margin) to reduce the margins and improve the layout.\r\n\r\n\r\nserena_ranking_plot <- ggplot(serena_data, aes(x = ranking_date, y = rank)) +\r\n  geom_line(color = serena_data$line_color,\r\n            size = ifelse(serena_data$line_color == \"#EE6A24\", 1.5, 1)) +\r\n  scale_y_reverse(limits = c(20, 1),\r\n                  breaks = c(1, 5, 10, 15, 20),\r\n                  labels = c(\"No. 1\" = expression(bold(\"No. 1\")), \"5\", \"10\", \"15\", \"20\"))+\r\n  scale_x_date(\r\n    limits = c(as.Date(\"1998-01-01\"), as.Date(\"2022-12-31\")),\r\n    breaks = seq(as.Date(\"1998-01-01\"), as.Date(\"2022-01-01\"), by = \"1 year\"),\r\n    date_labels = \"        |  '%y\"\r\n  ) +\r\n  labs(\r\n    title = \"Serena Williams's world ranking and Grand Slam tournaments\",\r\n    x = \"\",\r\n    y = \"\"\r\n  ) +\r\n  theme_minimal(base_size = 12) +\r\n  theme(\r\n    axis.text.x = element_text(color = \"black\"),\r\n    plot.title = element_text(hjust = 0.5, face = \"bold\", size = 9),\r\n    axis.title.y = element_blank(),\r\n    axis.text.y = element_text(hjust = 1, color = \"black\"),\r\n    panel.grid.major.x = element_blank(),\r\n    panel.grid.minor.x = element_blank()) +\r\n  annotate(\"text\", x = as.Date(\"2001-10-01\"), y = 1.6,\r\n           label = \"Williams first rose to\\nNo. 1 in July 2002, at\\nage 20. She stayed\\nNo. 1 for 49 weeks.\",\r\n           size = 3, hjust = 1) +\r\n  annotate(\"text\", x = as.Date(\"2005-03-01\"), y = 18,\r\n           label = \"Her ranking\\nfell below\\n20 in 2006.\",\r\n           size = 3, hjust = 1) +\r\n  annotate(\"text\", x = as.Date(\"2013-08-01\"), y = 3,\r\n           label = \"She stayed No.1 for\\n186 consecutive weeks\\nfrom Feb. 2013 to\\nSept. 2016.\",\r\n           size = 3, hjust = 0) +\r\n  annotate(\"text\", x = as.Date(\"2017-04-01\"), y = 18,\r\n           label = \"She gave birth to\\nher daughter in\\n2017 and returned\\nto tennis in 2018.\",\r\n           size = 3, hjust = 1) +\r\n  annotate(\"segment\", x = as.Date(\"1999-03-25\"), xend = as.Date(\"1999-03-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"1998-11-07\"), xend = as.Date(\"1998-11-07\"), y = 17, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2006-01-25\"), xend = as.Date(\"2006-01-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2007-01-25\"), xend = as.Date(\"2007-01-25\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2011-05-20\"), xend = as.Date(\"2011-05-20\"), y = 17, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2011-10-01\"), xend = as.Date(\"2011-10-01\"), y = 14, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2017-09-01\"), xend = as.Date(\"2017-09-01\"), y = 15, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"segment\", x = as.Date(\"2018-09-01\"), xend = as.Date(\"2018-09-01\"), y = 16, yend = 20,\r\n           linetype = \"dotted\", color = \"#3093CF\", size = 0.7) +\r\n  annotate(\"curve\", x = as.Date(\"2002-01-01\"), y = 1, xend = as.Date(\"2002-06-01\"), yend = 1,\r\n           curvature = 0,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2005-05-01\"), y = 18, xend = as.Date(\"2006-01-01\"), yend = 20,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2017-07-01\"), y = 18, xend = as.Date(\"2018-04-01\"), yend = 20,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) +\r\n\r\n  annotate(\"curve\", x = as.Date(\"2013-07-01\"), y = 2, xend = as.Date(\"2013-04-01\"), yend = 1.2,\r\n           curvature = -0.3,\r\n           arrow = arrow(length = unit(0.1, \"cm\"), type = \"closed\"),\r\n           color = \"black\",\r\n           size = 0.4) + \r\n  theme(plot.margin = margin(5, 0, 0, 0))\r\n\r\n\r\nThe data for the tournaments was collected from this website, but it was incomplete. I had to create an Excel file and complete the table with all the years and tournaments she played in.\r\nThe libraries used for the improvements were patchwork (to join the two tables) and readxl (to read the Excel file).\r\nAfter cleaning the data and selecting relevant columns, I created the plot, assigning the color orange to tournaments she won, grey to those she did not play, and blue to those she played but did not win. I also adjusted the margins using theme(plot.margin) and ordered the tournaments in chronological order.\r\nLastly, I joined both graphs, adjusting the heights so that the years matched in both tables.\r\n\r\n\r\nlibrary(patchwork)\r\nlibrary(readxl)\r\nserena_slams <- read_xlsx(\"SerenaWilliams_slams_data.xlsx\")\r\n\r\nserena_slams <- serena_slams |> \r\n  mutate(tournament = \r\n           str_replace(\r\n             Tournament,\"^(US Open|French Open|Wimbledon|Australian Open).*\", \"\\\\1\")) |> \r\n  select(Result, Year, tournament)\r\n\r\nserena_slams$tournament <- factor(serena_slams$tournament, levels = c(\"US Open\", \"Wimbledon\", \"French Open\", \"Australian Open\"))\r\n\r\nserena_slams_plot <- ggplot(serena_slams, aes(x = Year, y = tournament, fill = factor(Result))) +\r\n  geom_tile(color = \"black\")+\r\n  scale_fill_manual(values = c(\"Won\" =\"orange\", \"Did not play\" = \"grey\", \"Played\" = \"#63B8FF\"))+\r\n  labs(fill = \"Year\") +\r\n  theme_minimal()+             \r\n  coord_fixed() +\r\n  theme(plot.margin = margin(0, 0, 5, 0),\r\n        axis.title.y = element_blank(), \r\n        axis.text.x = element_blank(), \r\n        axis.title.x = element_blank(),\r\n        axis.ticks = element_blank())\r\n\r\n\r\nserena_ranking_plot/serena_slams_plot + \r\n  plot_layout(heights = c(2, 1)) \r\n\r\n\r\n\r\nDifficulties encountered\r\nThe source data was not available due to WTA restrictions, so I had to search for it on GitHub. The main challenge was that the datasets were divided by decades, so I had to import four separate datasets (90s, 00s, 10s, and 20s) and then join the tables.\r\nFinding the player ID (200033) was also tricky, but thankfully it was mentioned by the GitHub user.\r\nAnother challenge was determining the line colors (orange and blue). I had to create an additional column to specify the color: orange for when Serena was ranked number one, and blue for when she was not.\r\nJoining the two plots and ensuring they aligned closely was time-consuming. I spent considerable time adjusting the margins to ensure that both charts were joined seamlessly and that the years matched properly.\r\n\r\n\r\n\r\n",
    "preview": "projects/2024/100452420/100452420_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1920,
    "preview_height": 748
  },
  {
    "path": "projects/2024/100543010/",
    "title": "Key Global Partners in U.S. Trade for 2023",
    "description": "Worldwide U.S. Trade in Billions by country in 2023",
    "author": [
      {
        "name": "Jason Brunner",
        "url": {}
      }
    ],
    "date": "2025-01-12",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nThe Visualization\nThe Data\nThe map\nThe final replication\n\nThe Improvement\nAdjusting the scales\n\n\nIntroduction\nThe U.S. totaled over $5.1 trillion in trade for the year 2023. This is a truly\nstaggering amount and it poses the interesting question, which the major trade\npartners are. By looking at trade through this visualization we can also see\nhow our world today is globalized and connected, even in times of rising global\ntensions.\nThe original visualization can be found following this link https://www.voronoiapp.com/economy/-Top-Global-Trading-Partners-of-the-US-in-2023-2172).\nOriginal visualizationThe Visualization\nThe Data\nGetting the data and downloading the packages\nFirst we are going to start by loading the packages. For the Flagon package we\nhave to take a little detour, since it is not available through the regular\nR function. Therefore, we will download and load it at a later step.\n\n\nlibrary(ggplot2) \nlibrary(rnaturalearth) \nlibrary(showtext) \nlibrary(sysfonts) \nlibrary(readxl) \nlibrary(dplyr) \nlibrary(ggpattern) \nlibrary(devtools) \nlibrary(patchwork) \nlibrary(ggtext) \n\n\nLuckily, the data for this visualization was available and only had to be\ndownloaded and then transformed to be imported into R. The original data source\nis cited as comtrade, U.S. Census and WTO.\n\n\ntrade_data <- read_excel(\"Data Final Project.xlsx\")\n\n\nThe dataset is already tidy data and is ready to be used for our visualization.\nThe raw trade data which we have imported before now has to be modified to fit\nthe trade categories displayed in our visualization and later it will be\nmerged with our main world dataset.\nYou might wonder why they are split in these specific categories. The reason\nis, that later on when we create the legend we can’t use a straight forward\napproach and will need to become a bit creative. More about this will follow\nonce we reach the legend.\n\n\ntrade_data <- trade_data %>%\n  mutate(trade_category = case_when(\n    `U.S. Trade (Billion US$)` < 0.1 ~ \"0\",\n    `U.S. Trade (Billion US$)` < 1 ~ \"0.1\", \n    `U.S. Trade (Billion US$)` < 10 ~ \"1\",\n    `U.S. Trade (Billion US$)` < 100 ~ \"10\",\n    `U.S. Trade (Billion US$)` < 1000 ~ \"100\",\n    TRUE ~ \"1000\"))\n\n\nThe map\nCreating the basic plot\nThe next step will be to focus on the actual world map. For this we take\nadvantage of the rnaturalearth package which provides us with a comprehensive\ndataset about the world. We will also need to perform a few modifications to\nbetter fit the original plot. As you will also notice, we filter the United\nStates out of the dataset. This is because the United States are filled with\nthe US Flag and therefore we need to exclude it momentarily from our base\ndataset to be able to do this modification later.\nAs mentioned earlier, we will now in the same step merge our trade data with the\nworld data we have created so we get our base dataset to then start with our\nplot. Lastly we also define the colours used in the visualization. They have\nbeen obtained by using an online tool to get the colour codes from any colour\nyou provide it.\nAdditionally we also need to download the font. Using an online tool we were\nable to determine the font as “montserrat”. Luckily it is also available as a\nfree download and we can use it for our visualization.\n\n\nworld <- ne_countries()\n\nexcluded_countries <- c(\"French Southern and Antarctic Lands\",\"Antarctica\",\n                        \"Falkland Islands / Malvinas\")\n\n#removing the excluded countries and the United States\nworld <- world %>% \n  filter(!name_long %in% excluded_countries) %>% \n  filter(!name_long %in%  \"United States\")\n\n#incorporate the trade data into to world dataset\nworld <- left_join(world, trade_data, by = c(\"name_long\" = \"Country\"))\n\n#defining the colours used for the map\ncolors <- c(\"#bdbcfe\", \"#9494cd\", \"#6d6f9c\", \"#49476a\", \"#21213c\")\n\nfont_add_google(\"Montserrat\", \"montserrat\")\nshowtext_auto()\n\n\nNow we have everything ready to actually create the first draft of our\nvisualization. There is still a long way to go but we can plot the first\ndraft with the help of the ggplot2 package to see the map with the exclusions\nand the colours for the trade data.\n\n\nX <- ggplot(data = world) +\n  geom_sf(aes(fill = as.character(trade_category)), \n          color = \"#faf8f4\", \n          linewidth = 0.05) +\n  coord_sf(crs = \"+proj=robin\") +\n  scale_fill_manual(values = colors)\n\nX\n\n\n\nAfter having created our first plot we will continue enhancing it and\ngetting it closer to the original one. The first thing that comes to mind, apart\nfrom the legend, are the gridlines present in the plot and the background.\nWe can start to fix one of two problems easily by adding the following lines of\ncode to our ggplot. In the same step we will also go ahead and add the title and\nsubtitle to our plot. To make the title and subtitle look right, we also\nadjust the font corresponding to the original visualization. By defining this\nin our theme, it will automatically be adjusted for all text elements.\n\n\nX <- X + theme_void() +\n  labs(title = \"Key Global Partners in U.S. Trade for 2023\", \n       subtitle = paste(\"In 2023, U.S. trade totaled $5,192 billion. \",\n                        \"Trade with NAFTA partnes-Mexico ($803\\nbillion \",\n                        \"and Canada ($784 billion)-accounted for 30.6% of the \",\n                        \"total. The European\\nUnion was the next largest \",\n                        \"partner, contribution $986 billion, or 18.5% of total\",\n                        \" trade.\\nTrade with China amounted to $596 billion, \",\n                        \"representing 11.5% of the total.\", sep = \"\")) +\n  \n  #now the theme is being modified to replicate the title and subtitle from the\n  #original plot and in the same step we also adjust the background\n  theme(plot.title = element_text(hjust = 0.5, \n                                  size = 18, \n                                  face = \"bold\", \n                                  colour = \"#042f4a\"),\n        plot.background = element_rect(fill = \"#faf8f4\"),\n        plot.subtitle = element_text(hjust = 0.05,\n                                     vjust = -1),\n        text = element_text(family = \"montserrat\"))\n  \nX\n\n\n\nNow it already looks much more familiar. Let’s not focus on the details like\npositioning and font size yet, but we will look at the more important things\nlike the legend. First of all we need to turn the legend and make it horizontal\nand position it somewhat in the top right corner. We also need to fix the labels\nand get rid of the NA category.\nIn order to get the labels of the scale to their correct position, there were\nsome tricks needed. By default the labels would be centered under each category\nand by moving them to the left or right they wouldn’t center, since they\nall have a different length.\nOn a side note: If you look closely and compare the visualization and the\noriginal one, you will note a difference in the colourization of Libya.\nIn the original plot the categorization of Libya does not correspond with the\nreported trade value from the dataset.\n\n\nX <- X + theme(legend.direction = \"horizontal\",\n        legend.position = c(0.82, 0.99),\n        legend.title = element_text(size = 14, \n                                    face = \"bold\", \n                                    color = \"#030001\"),\n        legend.text = element_text(size = 12, \n                                   color = \"#030001\"),\n        legend.margin = margin(t = 0, r = 0, b = 0, l = 0),\n        panel.margin = margin(t = 50, r = 50, b = 50, l = 50)) +\n  \n  scale_fill_manual(values = colors, name = \"U.S. Trade (Billion US$)\",\n                    breaks = c(\"0\", \"0.1\", \"1\", \"10\", \"100\", \"1000\"),\n                    labels = c(\"   0  \",\n                               \" 0.1  \", \n                               \"    1 \", \n                               \"  10  \", \n                               \"100   \",\n                               \"1'000\")) +\n  \n  guides(fill = guide_legend(\n    title.position = \"top\",\n    title.hjust = 0,\n    label.position = \"bottom\",\n    label.hjust = -1,\n    label.vjust = 0.5,\n    keywidth = unit(1.5, \"cm\"),\n    keyheight = unit(0.4, \"cm\")))\n\nX\n\n\n\nThe flag\nAfter creating the basic map, we can start adding the details. Most\nnotably, the flag is still missing. For this we are going to use the flagon\npackage to get the image of the flag and the spData package for the isolated\nU.S. mainland and Alaska multipolygon. The flagon package is not available to\nbe downloaded through the regular R function, therefore we must take a slightly\ndifferent approach and download it directly from Github.\nFor Alaska it took a bit of a trial and error process, to figure out the\nappropriate scale parameter, so that we get the portion of the flag we were\nlooking for.\n\n\nusa <- spData::us_states |> sf::st_union()\nalaska <- spData::alaska\n\n\ninstall_github(\"coolbutuseless/flagon\")\nlibrary(flagon)\nflag <- flags(\"US\", filetype = \"png\")\n\nX1 <- X +\n  geom_sf_pattern(data = usa, \n                  pattern = 'image',\n                  pattern_filename = flag,\n                  pattern_type = \"expand\",\n                  color = NA) +\n  geom_sf_pattern(data = alaska, \n                  pattern = 'image', \n                  pattern_filename = flag,\n                  pattern_type = \"none\", \n                  pattern_scale= 0.3, \n                  pattern_gravity = \"southwest\",\n                  color = NA)+\n  coord_sf(crs = \"+proj=robin\")\n\n\nThe EU-27 subplot\nHaving fitted the flag we now continue by creating the EU-27 subplot.\nFirst we had to define a new vector with the EU-27 countries from the original\nplot. After this, the world dataset is filtered so only the EU-27 countries\nremain and we can create the new plot. After that we then only have to set the\nborders so we don’t get the islands in the Atlantic.\n\n\nEU_27 <- c(\"Austria\", \"Belgium\", \"Bulgaria\", \"Croatia\", \"Cyprus\", \n           \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\", \"France\", \n           \"Germany\", \"Greece\", \"Hungary\", \"Ireland\", \"Italy\", \"Latvia\", \n           \"Lithuania\", \"Luxembourg\", \"Malta\", \"Netherlands\", \"Poland\", \n           \"Portugal\", \"Romania\", \"Slovakia\", \"Slovenia\", \"Spain\", \"Sweden\")\n\nworld_EU <- world %>% \n  filter(name_long %in% EU_27)\n\nEU <- ggplot(data = world_EU) +\n  geom_sf(fill = \"#01339a\", \n          color = \"#faf8f4\", \n          linewidth = 0.25) +\n  \n  #setting the limits of the plot to cut off the Atlantic islands\n  coord_sf(xlim = c(-20,40), \n           ylim = c(35,70)) +\n  coord_sf(crs = \"+proj=longlat\") +\n  theme_void()\n\n\nAdding them together\nTo finalize the map of our plot we add the EU-27 plot to the main plot. There\nis a package called ggpatchwork for this, which allows us to position it and\nscale it accordingly. This will now yield our final map which only needs\nthe annotations to make it complete.\n\n\nM <- X1 + inset_element(EU, left = 0.13, bottom = 0.4, right = 0.63, \n                       top = 0.725)\n\nM\n\n\n\nAnnotations\nTo finalize our plot we now need to add all the annotations. This step is a bit\ntedious, since every annotation has to be added manually. Additionally to this,\ncertain elements of the annotation have to be somewhat “constructed”, like the\nbackground of the numbers corresponding to the countries.\nTo simplify the process of finding the correct font size and\nbeing able to adjust it across all annotations efficiently, the font size is\ndefined by a variable. Since the annotations are hierarchical, we can layer\nshapes and texts on top of each other. This allowed the creation of the circles\nwhit a number on top. There is also the instance of Germany and the Netherlands,\nwhere this feature of layering has been taken further advantage of. For these\ntwo annotations, the background has been filled with the colour of the main\nbackground, so we can cover up some small islands there. These were not able to\nbe filtered out, since their geometrical information is stored in the\nsame variable as the data for the mainland.\nFor the legend we also use some tricks. By default R does not allow the\ncreation of legends with rounded edges. To bypass this restriction, we will\ncreate a geom and lay it over the edges of the rectangular legend to create\nthe illusion of a rounded edge.\nAdditionaly, we used a special form of annotation, taking full advantage of the\nggtext package. As you can see, certain annotations are performed using the\nrichtext geom parameter, which gives us a lot of options to then modify the\ntext. Only with this we were able to define custom breaks and also make\ncertain parts of the annotation bold without any other restrictions.\n\n\nfont_size <- 3\n\nX2 <- X1 +\n  geom_point(x = -9700000, y = 2100000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -9700000, y = 2100000, \n           label = \"1\", color = \"white\") +\n  annotate(\"richtext\", x = -9700000, y = 1400000,\n           label = \"Mexico<br><b>$803B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = -8200000 , y = 5800000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -8200000 , y = 5800000 + 700000, \n           label = \"2\", color = \"white\") +\n  annotate(\"richtext\", x= -8200000, y = 5800000,\n           label = \"Canada<br><b>$784B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  geom_point(x = 9100000 -800000, y = 3700000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 9100000 - 800000, y = 3700000 + 180000, \n           label = \"3\", color = \"white\") +\n  annotate(\"richtext\", x= 9100000, y = 3700000,\n           label = \"China<br><b>$596B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 1690000, y = 7800000,\n           label = \"Germany<br><b>$240B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = \"#faf8f4\",\n           label.color = NA) +\n  geom_point(x = 1680000, y = 7800000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 1680000, y = 7800000 + 700000, \n           label = \"4\", color = \"white\") +\n  \n  geom_point(x = 13000000, y = 3900000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 13000000, y = 3900000 + 700000, \n           label = \"5\", color = \"white\") +\n  annotate(\"richtext\", x= 13000000, y = 3900000,\n           label = \"Japan<br><b>$228B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 12600000 -1000000, y = 3000000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 12600000 -1000000, y = 3000000 + 180000, \n           label = \"6\", color = \"white\") +\n  annotate(\"richtext\", x= 12600000, y = 3000000,\n           label = \"S.Korea<br><b>$185B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 70000, y = 7800000,\n           label = \"Netherlands<br><b>$122B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = \"#faf8f4\",\n           label.color = NA) +\n  \n  geom_point(x = -300000 -370000, y = 6550000 + 600000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -300000 -370000, y = 6550000 + 600000, \n           label = \"7\", color = \"white\") +\n  annotate(\"richtext\", x= -300000, y = 6550000,\n           label = \"UK<br><b>$140B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 12200000 -900000, y = 2350000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 12200000 -900000, y = 2350000 + 180000, \n           label = \"8\", color = \"white\") +\n  annotate(\"richtext\", x= 12200000, y = 2350000,\n           label = \"Taiwan<br><b>$130B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 10750000 , y = 1500000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 10750000 , y = 1500000 + 700000, \n           label = \"9\", color = \"white\") +\n  annotate(\"richtext\", x= 10750000, y = 1500000,\n           label = \"Vietnam<br><b>$129B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 7450000 -390000, y = 2400000 + 400000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 7450000 -390000, y = 2400000 + 400000, \n           label = \"10\", color = \"white\") +\n  annotate(\"richtext\", x= 7450000, y = 2200000,\n           label = \"India<br><b>$127B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 7300000, y = 6500000,\n           label = \"Russia<br><b>$5.5B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n   \n  annotate(\"richtext\", x= -4000000, y = 4000000,\n           label = \"EU-27<br><b>$960B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= -4800000, y = -850000,\n           label = \"Brazil<br><b>$86B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 3250000, y = -4000000,\n           label = \"South Africa<br><b>$21B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 12500000, y = -2500000,\n           label = \"Australia<br><b>$50B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= -900000, y = 5000000,\n           label = \"France<br><b>$104B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= -1400000, y = 4250000,\n           label = \"Spain<br><b>$49B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 1500000, y = 3500000,\n           label = \"Italy<br><b>$104B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 7500000, y = 9029500, \n             size = 4.6,\n             color = \"#bdbcfe\") +\n  geom_point(x = 16100000, y = 9029500, \n             size = 4.6,\n             color = \"#21213c\") +\n  \n  annotate(\"text\", label = \"1,000\",\n             x = 16300000, y = 8400000,\n             family = \"montserrat\",\n             size = 4.24)\n\n\nThe final replication\nNow that we have added all the annotations to the plot, adjusted the legend\nas well as created our EU subplot, we can bring everything together and\npresent the final visualization\n\n\nM <- X2 + inset_element(EU, left = 0.13, bottom = 0.4, right = 0.63, \n                       top = 0.725)\n\nM\n\n\n\nThe Improvement\nLet’s look at an idea on how to improve the visualization. One thing which\nalways seemed a bit intriguing whilst looking at the map was, that the\ncategorization makes many countries look the same, or very close to each other,\neven though their trade levels are vastly different. With the improved version\nthis issue should be resolved.\nAdjusting the scales\nFirst we want to get rid of the categorization of the trade data. The visual\ndifference from a $2 billion and a $595 billion country is just too small, and\nfor countries like India and China ($127 billion vs. $595 billion) it is even\nnon existent.\nSince we still have to deal with a vast array of different trade levels we will\nkeep the idea of a logarithmic scale, but this time we will make it continuous\nand not discrete as in the case before. For this we will need an additional\npackage, so we can define the scales in a better way.\nTo further enhance the readability, the plotting of the dataset has been\nmodified, so that we only take values from 0.025 to 800 in to account.\nThis means, that the values below and above these two barriers are going to be\nplotted as values on the border.\n\n\nlibrary(scales)\n\nA <- ggplot(data = world) +\n  geom_sf(aes(fill = world$`U.S. Trade (Billion US$)`), \n          color = \"#faf8f4\", \n          linewidth = 0.05,\n          show.legend = TRUE) +\n  coord_sf(crs = \"+proj=robin\") +\n  \n  labs(title = \"Key Global Partners in U.S. Trade for 2023\", \n       subtitle = paste(\"In 2023, U.S. trade totaled $5,192 billion. \",\n                        \"Trade with NAFTA partnes-Mexico ($803\\nbillion \",\n                        \"and Canada ($784 billion)-accounted for 30.6% of the \",\n                        \"total. The European\\nUnion was the next largest \",\n                        \"partner, contribution $986 billion, or 18.5% of total\",\n                        \" trade.\\nTrade with China amounted to $596 billion, \",\n                        \"representing 11.5% of the total.\", sep = \"\")) +\n  \n  scale_fill_gradient(name = \"U.S. Trade (Billion US$)\",\n                      low = \"#E4DFF0\",\n                      high = \"#240083\",\n                      trans = \"log\",\n                      breaks = c(0.1,50,800),\n                      labels = c(\"0.1\",\"50\",\"800\"),\n                      limits = c(0.025,800),\n                      oob = scales::squish,\n                      \n                      guide = guide_colorbar(\n                        title.position = \"top\",\n                        title.hjust = 0.5,\n                        label.position = \"bottom\",\n                        barwidth = unit(5,\"cm\"),\n                        barheight = unit(0.5,\"cm\")\n                      )) +  \n\n  \n  theme_void() +\n  theme(plot.title = element_text(hjust = 0.5,\n                                  size = 18,\n                                  face = \"bold\",\n                                  colour = \"#042f4a\"),\n        plot.subtitle = element_text(hjust = 0.05,\n                                     vjust = -1),\n        plot.background = element_rect(fill = \"#faf8f4\"),\n        legend.direction = \"horizontal\",\n        legend.position = c(0.82,0.98)) \n\n\nAfter these adjustments in the code, the rest of it will be very similar to the\nformer code. Therefore we will add all the annotations and the U.S. Flag. One of\nthe differences is, that we don’t need to make all the manual adjustments to\nthe legend.\n\n\n#adding the annotations\nfont_size <- 3\n  \n  A1 <- A +\n  geom_point(x = -9700000, y = 2100000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -9700000, y = 2100000, \n           label = \"1\", color = \"white\") +\n  annotate(\"richtext\", x = -9700000, y = 1400000,\n           label = \"Mexico<br><b>$803B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = -8200000 , y = 5800000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -8200000 , y = 5800000 + 700000, \n           label = \"2\", color = \"white\") +\n  annotate(\"richtext\", x= -8200000, y = 5800000,\n           label = \"Canada<br><b>$784B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  geom_point(x = 9100000 -800000, y = 3700000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 9100000 - 800000, y = 3700000 + 180000, \n           label = \"3\", color = \"white\") +\n  annotate(\"richtext\", x= 9100000, y = 3700000,\n           label = \"China<br><b>$596B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 1690000, y = 7800000,\n           label = \"Germany<br><b>$240B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = \"#faf8f4\",\n           label.color = NA) +\n  geom_point(x = 1680000, y = 7800000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 1680000, y = 7800000 + 700000, \n           label = \"4\", color = \"white\") +\n  \n  geom_point(x = 13000000, y = 3900000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 13000000, y = 3900000 + 700000, \n           label = \"5\", color = \"white\") +\n  annotate(\"richtext\", x= 13000000, y = 3900000,\n           label = \"Japan<br><b>$228B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 12600000 -1000000, y = 3000000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 12600000 -1000000, y = 3000000 + 180000, \n           label = \"6\", color = \"white\") +\n  annotate(\"richtext\", x= 12600000, y = 3000000,\n           label = \"S.Korea<br><b>$185B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 70000, y = 7800000,\n           label = \"Netherlands<br><b>$122B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = \"#faf8f4\",\n           label.color = NA) +\n  \n  geom_point(x = -300000 -370000, y = 6550000 + 600000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = -300000 -370000, y = 6550000 + 600000, \n           label = \"7\", color = \"white\") +\n  annotate(\"richtext\", x= -300000, y = 6550000,\n           label = \"UK<br><b>$140B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 12200000 -900000, y = 2350000 + 180000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 12200000 -900000, y = 2350000 + 180000, \n           label = \"8\", color = \"white\") +\n  annotate(\"richtext\", x= 12200000, y = 2350000,\n           label = \"Taiwan<br><b>$130B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 10750000 , y = 1500000 + 700000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 10750000 , y = 1500000 + 700000, \n           label = \"9\", color = \"white\") +\n  annotate(\"richtext\", x= 10750000, y = 1500000,\n           label = \"Vietnam<br><b>$129B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  geom_point(x = 7450000 -390000, y = 2400000 + 400000, \n             size = 6.5, stroke = 1, shape = 21,\n             color = \"violet\", fill = \"black\") +\n  annotate(\"text\", x = 7450000 -390000, y = 2400000 + 400000, \n           label = \"10\", color = \"white\") +\n  annotate(\"richtext\", x= 7450000, y = 2200000,\n           label = \"India<br><b>$127B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 7300000, y = 6500000,\n           label = \"Russia<br><b>$5.5B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  \n  annotate(\"richtext\", x= -4000000, y = 4000000,\n           label = \"EU-27<br><b>$960B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= -4800000, y = -850000,\n           label = \"Brazil<br><b>$86B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= 3250000, y = -4000000,\n           label = \"South Africa<br><b>$21B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 12500000, y = -2500000,\n           label = \"Australia<br><b>$50B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA,\n           color = \"white\") +\n  \n  annotate(\"richtext\", x= -900000, y = 5000000,\n           label = \"France<br><b>$104B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= -1400000, y = 4250000,\n           label = \"Spain<br><b>$49B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA) +\n  \n  annotate(\"richtext\", x= 1500000, y = 3500000,\n           label = \"Italy<br><b>$104B<\/b>\",\n           size = font_size,\n           lineheight = 0.8,\n           fill = NA,\n           label.color = NA)\n\n\n#adding the U.S. Flag\nusa <- spData::us_states |> sf::st_union()\nalaska <- spData::alaska\n\n\nA1 <- A1 +\n  geom_sf_pattern(data = usa, \n                  pattern = 'image',\n                  pattern_filename = flag,\n                  pattern_type = \"expand\",\n                  color = NA) +\n  geom_sf_pattern(data = alaska, \n                  pattern = 'image', \n                  pattern_filename = flag,\n                  pattern_type = \"none\", \n                  pattern_scale= 0.3, \n                  pattern_gravity = \"southwest\",\n                  color = NA)+\n  coord_sf(crs = \"+proj=robin\")  \n  \n  \n \n#adding the EU plot \nEU1 <- ggplot(data = world_EU) +\n  geom_sf(fill = \"#240083\", \n          color = \"#faf8f4\", \n          linewidth = 0.25) +\n  coord_sf(xlim = c(-20,40), \n           ylim = c(35,70)) +\n  coord_sf(crs = \"+proj=longlat\") +\n  theme_void()\n\n\nNow that we have added all the key elements from before again, we are just left\nwith joining the main plot and the EU subplot. This is done easily again\nwith the same function from the patchwork package.\n\n\nIm <- A1 + inset_element(EU1, left = 0.13, bottom = 0.4, right = 0.63, \n                        top = 0.725)\nIm\n\n\n\nLimitations\nOne thing that differs from both the replication and the improved version is,\nthat the footnotes from the original visualization are not included. This has\nbeen done on purpose, since they don’t provide any benefit or information\nregarding the visualization. In the improved version the new scale is a\ncontinuous logarithmic scale, that allowed us to visualize a dataset with\nvalues ranging from 0.0001 to 960. This therefore comes at a small price of the\nlegend breaks not being evenly spaced. An idea could be, to disproportionately\nstretch the legend to make the breaks more evenly spaced. Currently this is not\npossible in R, it is also questionable if it would even generate any benefit or\nmake the legend harder to read.\nAnother limitation of this visualization is, that we do not see how the trade\nis structured. We only see that the U.S. trades with Mexico, but we don’t know\nif they import more or export more. For a further project this could be an\ninteresting and challenging idea, to incorporate this additional information\nin to the visualization.\n\n\n\n",
    "preview": "projects/2024/100543010/100543010_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2025-01-17T11:48:24+01:00",
    "input_file": {},
    "preview_width": 2688,
    "preview_height": 1536
  },
  {
    "path": "projects/2024/100452242/",
    "title": "ODA: the catalyst for progress",
    "description": "Using The World Bank's ODA data to reproduce its original graph and other visualizations. \"ODA\" is the abbreviation for \"official development assistance\", which refers to the government aid provided to promote the economic development and welfare of developing countries.",
    "author": [
      {
        "name": "Yijia Lin",
        "url": {}
      }
    ],
    "date": "2025-01-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nGetting and cleaning data\nBuilding the chart\nTitles and the timeline\nBar plots\n\nFinal Result\nAlternative visualization\nInteractive visualization\n\nThe SDG Target appeals to the revitalization of the global partnership for development, where the official development assistance (ODA) plays a crucial role. The target 17.2 expects “the commitment by many developed countries to achieve the target of 0.7 per cent of gross national income for official development assistance (ODA/GNI) to developing countries and 0.15 to 0.20 per cent of ODA/GNI to least developed countries” (The World Bank, 2024). This graph from The World Bank visualizes the performance of the first 20 countries which contribute most on ODA.\nThe World Bank’s Absolute Spending for ODA chart. Source: The World Bank.The aim of this tutorial is to reproduce the chart and propose some alternative visualizations using the same dataset.\n\n\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(tidyverse)\nlibrary(grid)\nlibrary(countrycode)\nlibrary(showtext)\nlibrary(ggforce) \nlibrary(patchwork)\n\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Regular\")\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Bold\", regular.wt=700)\nshowtext_auto()\n\n\nGetting and cleaning data\nAll the data needed for this map can be downloaded directly from The World Bank by this link. They provide a complete data set with the spending on ODA of every country from 1960 to 2021, and especially, since 1970, they have the data of total ODA and ODA to LDCs (Least Developed Countries) separately. Let’s take a glimpse of the data:\n\n\noda_data <- read.csv(\"goal17.oda.csv\")\nglimpse(oda_data)\n\nRows: 1,582\nColumns: 14\n$ iso3                           <chr> \"AUT\", \"AUT\", \"AUT\", \"AUT\", \"…\n$ year                           <int> 1960, 1961, 1962, 1963, 1964,…\n$ viz_oda_usdmn                  <dbl> 1.53660, 42.45602, 32.30225, …\n$ viz_oda_usdmn_nom              <dbl> 0.10, 2.90, 2.30, 4.20, 6.60,…\n$ viz_gni_constant               <dbl> 96498.48, 101748.10, 103929.0…\n$ viz_odagni_pct                 <dbl> 0.001592, 0.041727, 0.031081,…\n$ viz_odamn_covid                <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ viz_odamn_refugees             <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ viz_oda_ukr                    <int> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ viz_oda_usdmn_nocovid          <dbl> 1.53660, 42.45602, 32.30225, …\n$ viz_oda_usdmn_nocovid_noref    <dbl> 1.53660, 42.45602, 32.30225, …\n$ viz_oda_usdmn_nocovid_norefukr <dbl> 1.53660, 42.45602, 32.30225, …\n$ viz_oda_ldc_pctgni             <dbl> NA, NA, NA, NA, NA, NA, NA, N…\n$ viz_oda_ldc_usdmn              <dbl> NA, NA, NA, NA, NA, NA, NA, N…\n\nsummary(oda_data)\n\n     iso3                year      viz_oda_usdmn      \n Length:1582        Min.   :1960   Min.   :     0.59  \n Class :character   1st Qu.:1980   1st Qu.:   362.38  \n Mode  :character   Median :1996   Median :  1722.91  \n                    Mean   :1994   Mean   :  7191.88  \n                    3rd Qu.:2010   3rd Qu.:  4865.17  \n                    Max.   :2022   Max.   :211319.70  \n                                   NA's   :7          \n viz_oda_usdmn_nom  viz_gni_constant   viz_odagni_pct   \n Min.   :     0.1   Min.   :       0   Min.   :0.00159  \n 1st Qu.:   134.2   1st Qu.:  176106   1st Qu.:0.18834  \n Median :   802.3   Median :  412387   Median :0.30915  \n Mean   :  4951.7   Mean   : 2419102   Mean   :0.37741  \n 3rd Qu.:  3161.9   3rd Qu.: 1428197   3rd Qu.:0.48433  \n Max.   :203995.3   Max.   :56900000   Max.   :1.40455  \n NA's   :7          NA's   :45         NA's   :53       \n viz_odamn_covid    viz_odamn_refugees  viz_oda_ukr      \n Min.   :    0.00   Min.   :    0.00   Min.   :    0.00  \n 1st Qu.:    0.00   1st Qu.:    0.00   1st Qu.:    0.00  \n Median :    0.00   Median :    0.00   Median :    0.00  \n Mean   :   58.63   Mean   :  231.12   Mean   :   10.76  \n 3rd Qu.:    0.00   3rd Qu.:   34.71   3rd Qu.:    0.00  \n Max.   :21879.01   Max.   :30095.44   Max.   :16100.00  \n                                                         \n viz_oda_usdmn_nocovid viz_oda_usdmn_nocovid_noref\n Min.   :     0.59     Min.   :     0.59          \n 1st Qu.:   361.07     1st Qu.:   347.98          \n Median :  1722.91     Median :  1697.07          \n Mean   :  7132.99     Mean   :  6900.84          \n 3rd Qu.:  4862.31     3rd Qu.:  4691.09          \n Max.   :199297.30     Max.   :169201.80          \n NA's   :7             NA's   :7                  \n viz_oda_usdmn_nocovid_norefukr viz_oda_ldc_pctgni viz_oda_ldc_usdmn \n Min.   :     0.59              Min.   :0.0019     Min.   :    0.92  \n 1st Qu.:   347.98              1st Qu.:0.0501     1st Qu.:  165.72  \n Median :  1697.07              Median :0.0921     Median :  721.54  \n Mean   :  6890.04              Mean   :0.1265     Mean   : 2290.24  \n 3rd Qu.:  4691.09              3rd Qu.:0.1617     3rd Qu.: 1605.13  \n Max.   :154931.20              Max.   :0.5206     Max.   :49824.68  \n NA's   :7                      NA's   :411        NA's   :407       \n\nSince the chart only shows the first 20 countries with the highest proportion ODA/GNI to LDCs (Least Developed Countries) and I take the year 2021 as an example of static map, I select this specific subset of the data to compute the chart. Moreover, I have to eliminate the data of “DAC”, as it is not a specific country, but an organization called “Development Assistance Committee”, including 32 members. I also renamed some columns, whose names were not easy to understand. Finally, as the countries are coded in “iso3c” format, I use the package countrycode to decode them into complete country names.\n\n\nselected_year <- 2021\noda_filtered <- oda_data  |> \n  filter(year == selected_year & iso3 != \"DAC\")  |> \n  mutate(\n    country_label = countrycode(iso3, \"iso3c\", \"country.name\") \n  ) |> \n  select(country = country_label, oda_total = viz_oda_usdmn, \n         oda_pct_gni = viz_odagni_pct, \n         oda_ldc_total = viz_oda_ldc_usdmn, \n         oda_ldc_pct_gni = viz_oda_ldc_pctgni)  |> \n  drop_na()  |> \n  arrange(desc(oda_ldc_pct_gni))  |> \n  slice(1:20)\n\noda_filtered$country <- factor(oda_filtered$country,\n                               levels = oda_filtered$country[order(oda_filtered$oda_ldc_pct_gni)])\n\nsummary(oda_filtered)\n\n          country     oda_total         oda_pct_gni    \n United States: 1   Min.   :   70.84   Min.   :0.1832  \n New Zealand  : 1   1st Qu.: 1369.64   1st Qu.:0.2980  \n Portugal     : 1   Median : 4292.50   Median :0.4532  \n Austria      : 1   Mean   : 8673.87   Mean   :0.4867  \n Italy        : 1   3rd Qu.: 8603.46   3rd Qu.:0.5704  \n Canada       : 1   Max.   :47804.80   Max.   :0.9879  \n (Other)      :14                                      \n oda_ldc_total      oda_ldc_pct_gni  \n Min.   :   27.71   Min.   :0.05985  \n 1st Qu.:  400.09   1st Qu.:0.08747  \n Median : 1001.73   Median :0.11935  \n Mean   : 2308.77   Mean   :0.14552  \n 3rd Qu.: 2549.22   3rd Qu.:0.14406  \n Max.   :14235.94   Max.   :0.45326  \n                                     \n\nBuilding the chart\nThe chart could be seen as a composition of two graphs, the timeline for selecting years and the barplots below.\nTitles and the timeline\nFirst of all, I need to create a timeline from 1960 to 2021, with the breaks for each 5 years.\n\n\nyear_axis_plot <- ggplot() +\n  geom_hline(yintercept = 0, color = \"gray\", size = 2) +\n  scale_x_continuous(limits = c(1960, 2021), breaks = seq(1960, 2020, by = 5))\nyear_axis_plot\n\n\n\nThen, I will change the theme into minimal to remove the grey background, I need to remove the labels on the y-axis, and make the year numbers close to the x-axis by flattening the graph with the function coord_fixed().\n\n\nyear_axis_plot <- year_axis_plot +\n  coord_cartesian(clip = \"off\") +\n  geom_hline(yintercept = 0, color = \"gray50\", size = 0.5, inherit.aes = FALSE) +\n  scale_x_continuous(limits = c(1960, 2023), breaks = seq(1960, 2020, by = 5)) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(10, 5, 5, 5) \n  ) +\n  coord_fixed(ratio = 0.1) \n\nyear_axis_plot\n\n\n\nNext step would be add the label of the selected year, 2021, with a blue background of a special figure similar to an rectangle or ellipse. I will draw an rectangle and two circles on each side to replicate that figure. There is also a vertical line connecting the label of 2021 and the timeline.\n\n\nyear_axis_plot1 <- ggplot() +\n  coord_cartesian(clip = \"off\") +\n  geom_hline(yintercept = 0, color = \"gray50\", size = 0.4, inherit.aes = FALSE) +\n  scale_x_continuous(limits = c(1960, 2023), breaks = seq(1960, 2020, by = 5)) +\n\n  geom_rect(aes(xmin = 2019, xmax = 2023, ymin = 9, ymax = 25), \n            fill = \"#0171bc\", inherit.aes = FALSE ) +\n  annotate(\"point\", x = 2019.3, y = 17, size = 3, color = \"#0171bc\", fill = \"#0171bc\", shape = 21)+\n  annotate(\"point\", x = 2022.7, y = 17, size = 3, color = \"#0171bc\", fill = \"#0171bc\", shape = 21)+\n  geom_segment(aes(x = 2021, xend = 2021, y = -5, yend = 10), \n               color = \"black\", size = 0.3, inherit.aes = FALSE) +\n  annotate(\"text\", x = 2021, y = 17, label = \"<2021>\", color = \"white\", \n           size = 2.5, fontface = \"bold\", hjust = 0.5) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(size = 6),\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(5, 5, 0, 5) \n  ) +\n  coord_fixed(ratio = 0.08) \n\nyear_axis_plot1\n\n\n\nFinally, I will add the title and subtitle with the free font closest to the original font with the function annotate().\n\n\nsysfonts::font_add_google(\"Quicksand\", family=\"Quicksand\")\nshowtext::showtext_auto()\n\n\np1 <- year_axis_plot1 +\n  labs(\n    title = \"Absolute spending for ODA (2021)\", \n    subtitle = \"ODA in billion dollars (percentage of GNI)\"\n  ) +\n    theme(\n    plot.title = element_text(size = 12, face = \"bold\", hjust = 0.5, margin = margin(b = 5)),\n    plot.subtitle = element_text(size = 9, color = \"#b1b0b7\", hjust = 0.5, margin = margin(b = 10))\n  ) \n\np1\n\n\n\nBar plots\nNext, let’s build the bar plots step by step. First of all, the first level should be the thin black and red bar plots, which represents the proportion Total ODA/GNI and ODA to LDCs / GNI. Besides, the red bar plot should be hollow, that is, with red outlines and white filler color, while the proportion ODA to LDCs / GNI falls short of the 0.15% target. The countries’ names should be in bold in the same situation. To achieve this, we need to create a few columns in the data set to specify the color, the fill and the font for each country. Finally, I need to scale up these percentages by a thousand times to be visible after adding the absolute ODA values later.\n\n\noda_filtered <- oda_filtered %>%\n  mutate(\n    value_label = sprintf(\"%.1f\", oda_total / 1000), \n    pct_label = paste0(\"(\", sprintf(\"%.2f\", oda_pct_gni), \"%)\"), \n    font_weight = ifelse(oda_ldc_pct_gni >= 0.15, \"bold\", \"plain\"),\n    fill = ifelse(oda_ldc_pct_gni >= 0.15, \"#e56766\", \"white\"),\n    color = ifelse(oda_ldc_pct_gni >= 0.15, \"white\", \"#e56766\"),\n  )\noda_filtered$country <- factor(oda_filtered$country, \n                               levels = oda_filtered$country[order(oda_filtered$oda_ldc_pct_gni)])\n\n\n\n\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Regular\")\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Bold\", regular.wt=700)\nshowtext_auto()\n\nbarplot<- ggplot(oda_filtered) +\n  geom_col(aes(x = oda_pct_gni * 100000, y = country), \n               fill = \"black\", color=\"white\", width = 0.2) +\n  geom_col(aes(x = oda_ldc_pct_gni * 100000, y = country), \n               fill = oda_filtered$fill, color = oda_filtered$color,  width = 0.2, size=0.2)+\n  geom_text(aes(x = -35000, y = country, label = value_label), \n            hjust = 0, size = 3.2, family = \"sans\") +\n  geom_text(aes(x = -3500, y = country, label = pct_label), \n            hjust = 1, size = 3.2, family = \"sans\") +\n  geom_text(\n    data = subset(oda_filtered, font_weight == \"plain\"),\n    aes(x = -70000, y = country, label = country),\n    fontface = \"plain\", hjust = 0, size = 3, family = \"Noto Sans Regular\"\n  ) +\n  geom_text(\n    data = subset(oda_filtered, font_weight == \"bold\"),\n    aes(x = -70000, y = country, label = country),\n    hjust = 0, size = 3, family = \"Noto Sans Bold\"\n  ) +\n  labs(\n    title = NULL,\n    subtitle = NULL,\n    x = NULL,\n    y = NULL\n  ) +\n  scale_x_continuous(expand = expansion(mult = c(0.01, 0.2))) + \n  theme_minimal() +\n  theme(\n    axis.text.y = element_blank(),\n    axis.text.x = element_blank(), \n    plot.title = NULL,\n    plot.subtitle = NULL,\n    panel.grid.major.y = element_blank(), \n  panel.grid.major.x = element_blank(), \n  panel.grid.minor.x = element_blank(), \n   plot.margin = margin(5, 10, 5, 5)\n  )\nbarplot\n\n\n\nThen, we will add these blue and red transparent thick bar plots, which represent the absolute amount of ODA, and ODA to LDCs of theses countries, and after that, a red vertical line to mark up the 0.15% target.\n\n\np2<- barplot+\n  geom_bar(aes(x = oda_total, y = country), stat = \"identity\", fill = \"#d2e3ea\", alpha = 0.3) +\n  geom_bar(aes(x = oda_ldc_total, y = country), stat = \"identity\", fill = \"#e56766\", alpha = 0.3) +\n  geom_vline(xintercept = 0.15 * 100000,  color = \"#e56766\", size= 0.3) +\n  annotate(\"text\", x = 0.15 * 100000, y = -0.02, label = \"Target: .15% to LDCs\", \n         color = \"gray40\", size = 2.6, hjust = 0.5, family = \"sans\")+\n  coord_cartesian(clip = \"off\")\np2\n\n\n\nFinal Result\nFinally, we need to joint vertically these two plots in a proper proportion, and then I will add an external caption to specify the data source, although the original graph didn’t contain it:\n\n\nfinal_plot <- p1 / p2 +\n  plot_layout(heights = c(0.8, 9.2))\n\ncaption_rep <- \"**Data source** : The World Bank\"\nfinal_plot<- final_plot +\n  labs(caption = caption_rep)+\n  theme(plot.caption = element_markdown(size = 7.5,\n                                        color = \"#636363\",\n                                        hjust = 0),\n        plot.caption.position = \"plot\")\nfinal_plot\n\n\n\nAlternative visualization\nThe original graph is very difficult to interpret, because it includes a lot of information — combining the percentages with the total amounts, as well as total ODA with ODA to LDCs, and then the x-axis lost its purpose. When the percentages were scaled up, the x-axis could no longer show any specific numbers, and the length of the bars was just used for sorting.\nMy alternative visualization was to separate the percentage and total amounts, so that the x-axis could once again show meaningful values, and the length of the bars would correspond to actual numbers, making the graph easier to read. I also added a legend to explain the different colors and their meanings. I hope this will help the readers understand the graph more easily.\n\n\n# Adjust the mapping in p_left and p_right\np_left <- ggplot(oda_filtered) +\n  geom_col(aes(x = -oda_pct_gni, y = country), \n           fill = \"#0171bc\", color=\"#0171bc\", width = 0.6, alpha = 0.8, size=0.3) +\n  geom_col(aes(x = -oda_ldc_pct_gni, y = country), \n           fill = oda_filtered$fill, color = oda_filtered$color, \n           width = 0.6, alpha = 0.8, size=0.5) +\n  geom_vline(xintercept = -0.15 , color = \"#e56766\", size = 0.5) +\n  annotate(\"text\", x = -0.15, y = 0.2, label = \"Target: .15% to LDCs\", \n           color = \"gray40\", size = 2, hjust = 0.5, family = \"sans\") +\n  coord_cartesian(clip = \"off\")+\n  scale_x_continuous(\n    breaks = seq(-1, 0, by = 0.25),\n    labels = function(x) paste0(abs(x), \"%\")\n  ) +\n  labs(x = \"Percentage of Gross National Income (%)\", y = NULL) +\n  theme_minimal() +\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.margin = margin(5, 0, 5, 7),\n    axis.title.x = element_text(\n      family = \"Quicksand\",    # Font setting\n      size = 7,           # Font size\n      face = \"bold\",       # Bold font\n      color = \"black\"      # Font color\n    )\n  ) +\n  scale_y_discrete()\n\n# Legend: Total ODA and ODA to LDCs\np_legend <- ggplot() +\n  annotation_custom(grob = rectGrob(gp = gpar(fill = \"#0171bc\", \n                                              col = \"white\")), \n                    xmin = -0.1, xmax = 0, ymin = 0.7, ymax = 0.9) +\n  annotation_custom(grob = textGrob(\"Total ODA\", \n                                    gp = gpar(fontsize = 5,\n                                              fontface = \"bold\", col = \"black\"),\n                                    hjust = 0), \n                    xmin = 0.05, xmax = 0.1, ymin = 0.7, ymax = 0.9) +\n  annotation_custom(grob = rectGrob(gp = gpar(fill = \"#e56766\", \n                                              col = \"white\")), \n                    xmin = -0.1, xmax = 0, ymin = 0.2, ymax = 0.4) +\n  annotation_custom(grob = textGrob(\"ODA to LDCs\", \n                                    gp = gpar(fontsize = 5, \n                                              fontface = \"bold\", \n                                              col = \"black\"), \n                                    hjust = 0), \n                    xmin = 0.05, xmax = 0.1, ymin = 0.2, ymax = 0.4) +\n    coord_cartesian(clip = \"off\") +\n  theme_void() +  # Remove all background\n  theme(plot.margin = margin(0, 0, 0, 0)) +  # Adjust plot margins\n  coord_fixed(ratio = 0.5)\n\n# Adjust the right barplot\np_right <- ggplot(oda_filtered) +\n  geom_col(aes(x = oda_total, y = country), \n           fill = \"#0171bc\", color = \"white\", width = 0.6, alpha = 0.8) +\n  geom_col(aes(x = oda_ldc_total, y = country), \n           fill = \"#e56766\", color = \"white\", width = 0.6, alpha = 0.8) +\n  scale_x_continuous(\n    expand = expansion(mult = c(0, 0.05)),\n    labels = function(x) x / 10000  # Convert to scaled units\n  ) +\n  labs(x = \"Total Amount (10k Billion USD)\", y = NULL) +  # Adjusted title\n  theme_minimal() +\n  theme(\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title.x = element_text(\n      family = \"Quicksand\",    # Font setting\n      size = 7,           # Font size\n      face = \"bold\",       # Bold font\n      color = \"black\"      # Font color\n    ),\n    plot.margin = margin(5, 7, 5, 0)\n  ) +\n  scale_y_discrete() +\n  inset_element(p_legend, left = 0.7, bottom = 0.7, right = 1, top = 1)\n\n# Centered labels: country, percentage, and total amount\np_middle <- ggplot(oda_filtered) +\n  geom_text(aes(x = -0.1, y = country, label = paste0(sprintf(\"%.2f\", oda_pct_gni), \"%\")), \n            size = 3, hjust = 1, color = \"#0171bc\") +\n  geom_text(aes(x = 0.1, y = country, label = sprintf(\"%.1f\", oda_total / 1000)), \n            size = 3, hjust = 0, color = \"#0171bc\") +\n  # Plain font labels\n  geom_text(\n    data = subset(oda_filtered, font_weight == \"plain\"),\n    aes(x = 0, y = country, label = country),\n    fontface = \"plain\", hjust = 0.5, size = 2.8, family = \"Noto Sans Regular\"\n  ) +\n  # Bold font labels\n  geom_text(\n    data = subset(oda_filtered, font_weight == \"bold\"),\n    aes(x = 0, y = country, label = country),\n    hjust = 0.5, size = 2.8, family = \"Noto Sans Bold\"\n  ) +\n  coord_cartesian(clip = \"off\") +\n  theme_void() + # No background and grid\n  theme(\n    plot.margin = margin(0, 20, 0, 20)\n  )\n\n# Combine all plots\np2_2 <- p_left + p_middle + p_right + \n  plot_layout(widths = c(4, 2, 4))\n\nfinal_plot_v2 <- p1 / p2_2 +\n  plot_layout(heights = c(1, 9))\n\n\n\n\nfinal_plot_v2\n\n\n\nInteractive visualization\nFinally, I used the shiny package to produce an interactive graph.\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(countrycode)\nlibrary(showtext)\nlibrary(patchwork)\n\n# Add custom fonts\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Regular\")\nsysfonts::font_add_google(\"Noto Sans\", family=\"Noto Sans Bold\", regular.wt=700)\n\n# Enable showtext\nshowtext_auto()\n\n# Read data\noda_data <- read.csv(\"goal17.oda.csv\")\n\nui <- fluidPage(\n  titlePanel(\"Abosolute Spending for ODA\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"selected_year\", \"Select Year:\",\n                  min = 1970, max = 2021,\n                  value = max(oda_data$year), step = 1, sep = \"\")\n    ),\n    mainPanel(\n      uiOutput(\"dynamicPlotUI\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n\n  output$dynamicPlotUI <- renderUI({\n    selected_year <- input$selected_year\n    oda_filtered <- oda_data |>\n      filter(year == selected_year & iso3 != \"DAC\") |>\n      drop_na() |>\n      slice(1:20)\n\n\n    height_per_row <- 30\n    plot_height <- max(nrow(oda_filtered) * height_per_row, 800)\n\n    plotOutput(\"odaPlot\", height = paste0(plot_height, \"px\"))\n  })\n\n\n  output$odaPlot <- renderPlot({\n    selected_year <- input$selected_year\n    oda_filtered <- oda_data  |>\n      filter(year == selected_year & iso3 != \"DAC\")  |>\n      mutate(\n        country_label = countrycode(iso3, \"iso3c\", \"country.name\")\n      ) |>\n      arrange(desc(viz_oda_ldc_pctgni))  |>\n      select(country = country_label, oda_total = viz_oda_usdmn,\n             oda_pct_gni = viz_odagni_pct,\n             oda_ldc_total = viz_oda_ldc_usdmn,\n             oda_ldc_pct_gni = viz_oda_ldc_pctgni)  |>\n      drop_na()  |>\n      slice(1:20)\n\n    oda_filtered <- oda_filtered %>%\n      mutate(\n        value_label = sprintf(\"%.1f\", oda_total / 1000),\n        pct_label = paste0(\"(\", sprintf(\"%.2f\", oda_pct_gni), \"%)\"),\n        font_weight = ifelse(oda_ldc_pct_gni >= 0.15, \"bold\", \"plain\"),\n        fill = ifelse(oda_ldc_pct_gni >= 0.15, \"#e56766\", \"white\"),\n        color = ifelse(oda_ldc_pct_gni >= 0.15, \"white\", \"#e56766\")\n      )\n\n    oda_filtered$country <- factor(oda_filtered$country, levels = oda_filtered$country[order(oda_filtered$oda_ldc_pct_gni)])\n\n\n    p_left <- ggplot(oda_filtered) +\n      geom_col(aes(x = -oda_pct_gni, y = country),\n               fill = \"#0171bc\", color=\"#0171bc\", width = 0.4, alpha = 0.8, size=0.3) +\n      geom_col(aes(x = -oda_ldc_pct_gni, y = country),\n               fill = oda_filtered$fill, color = oda_filtered$color,\n               width = 0.4, alpha = 0.8, size=0.5) +\n      geom_vline(xintercept = -0.15 , color = \"#e56766\", size = 0.5) +\n      annotate(\"text\", x = -0.15, y = 0.2, label = \"Target: .15% to LDCs\",\n               color = \"gray40\", size = 6, hjust = 0.5, family = \"sans\") +\n      coord_cartesian(clip = \"off\") +\n      scale_x_continuous(\n        breaks = seq(-1, 0, by = 0.25),\n        labels = function(x) paste0(abs(x), \"%\")\n      ) +\n      labs(x = \"Percentage of Gross National Income (%)\", y = NULL) +\n      theme_minimal() +\n      theme(\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        plot.margin = margin(5, 0, 5, 7),\n        panel.spacing = unit(0.05, \"lines\"),\n        axis.title.x = element_text(size = 22, face = \"bold\", color = \"black\"),\n        axis.text.x = element_text(size = 20, face = \"bold\", color = \"black\")\n      )\n\n\n\n\n\n    p_right <- ggplot(oda_filtered) +\n      geom_col(aes(x = oda_total, y = country),\n               fill = \"#0171bc\", color = \"white\", width = 0.4, alpha = 0.8) +\n      geom_col(aes(x = oda_ldc_total, y = country),\n               fill = \"#e56766\", color = \"white\", width = 0.4, alpha = 0.8) +\n      scale_x_continuous(\n        expand = expansion(mult = c(0, 0.05)),\n        labels = function(x) x / 10000  # Convert to scaled units\n      ) +\n      labs(x = \"Total Amount (10k Billion USD)\", y = NULL) +  # Adjusted title\n      theme_minimal() +\n      theme(\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.spacing = unit(0.05, \"lines\"),\n        axis.title.x = element_text(\n          family = \"Quicksand\",    # Font setting\n          size = 22,           # Font size\n          face = \"bold\",       # Bold font\n          color = \"black\"      # Font color\n        ),\n        axis.text.x = element_text(size = 20, face = \"bold\", color = \"black\"),\n        plot.margin = margin(5, 7, 5, 0)\n      ) +\n      scale_y_discrete()\n\n    p_middle <- ggplot(oda_filtered) +\n      geom_text(aes(x = -0.1, y = country, label = paste0(sprintf(\"%.2f\", oda_pct_gni), \"%\")),\n                size = 8, hjust = 1, color = \"#0171bc\") +\n      geom_text(aes(x = 0.1, y = country, label = sprintf(\"%.1f\", oda_total / 1000)),\n                size = 8, hjust = 0, color = \"#0171bc\") +\n      geom_text(\n        data = subset(oda_filtered, font_weight == \"plain\"),\n        aes(x = 0, y = country, label = country),\n        fontface = \"plain\", hjust = 0.5, size = 8, family = \"Noto Sans Regular\"\n      ) +\n      geom_text(\n        data = subset(oda_filtered, font_weight == \"bold\"),\n        aes(x = 0, y = country, label = country),\n        hjust = 0.5, size = 8, family = \"Noto Sans Bold\"\n      ) +\n      coord_cartesian(clip = \"off\") +\n      theme_void() +\n      theme(plot.margin = margin(0, 20, 0, 20),\n            panel.spacing = unit(0.05, \"lines\"))\n\n    p_combined <- p_left + p_middle + p_right +\n      plot_layout(widths = c(4, 2, 4))\n\n    p_combined\n  })\n}\n\nshinyApp(ui, server)\nAs Shiny is not going to work in this blog post, I have published it in shinyapps.io and you are welcome to check the final output via this link:\nhttps://yicaa.shinyapps.io/Absolute_ODA_spending/\n\n\n\n",
    "preview": "projects/2024/100452242/100452242_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100453237/",
    "title": "The world’s most, and least, walkable cities",
    "description": "Ternary graph by ‘The Economist’  of commuting patterns in cities worldwide, highlighting the proportions of journeys made by car, active mobility (such as walking and cycling), and public transport. The data is based on the study 'The ABC of Mobility' by Rafael Prieto-Curiel and Juan P. Ospina.",
    "author": [
      {
        "name": "Pablo Aísa",
        "url": {}
      }
    ],
    "date": "2025-01-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nOriginal chart\n\nReplication\nLibraries\nData loading\nFirst representation with ggtern\nCreating the coloured regions\nPoints with the colour of the regions\nArrows\nAnnotations and the final result\n\nAlternative versions\nAlternative I\nAlternative II\n\n\nIntroduction\nThe Economist article reinterprets data from Rafael Prieto-Curiel and Juan P. Ospina’s study on mobility worldwide, The ABC of mobility. The study attempts to study the mobility of the inhabitants of 794 cities by grouping the types of transport into a triplet: A (active mobility), B (bus, public transport), and C (private car).\nThe Economist Data Team represents the data in an elegant and simple style. The article’s main graph is accompanied by an interactive table providing information about the cities, including their population and active mobility rate.\nI chose this graph because it seems an original way of presenting information on three variables. Besides, I am also really interested in issues related to urban mobility and possible differences between regions. The full article is available at this link.\nOriginal chart\nThe original graphic is an interactive ternary graphic in which a distinctive colour represents the three types of mobility mentioned above. In addition, when hovering over each point, the city’s name associated with that point is indicated. The graph contains commentary, so as you scroll down, it is divided into different continents, and the article comments on the most salient results.\nTernary graph. Source: The Economist, 2024.Replication\nLibraries\nThe first step is to load the libraries that will be used.\n\n\nlibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(scales)\nlibrary(ggtern)\nlibrary(patchwork)\nlibrary(plotly)\nlibrary(lemon)\nlibrary(showtext)\n\n\nData loading\nObtaining the data was easy since it is free and available on the Cities Moving website. This website presents all the data used for The ABC mobility study, including several interactive charts showing differences across countries and continents.\nThe main issue with the dataset was that it is updated from time to time so it is impossible to find which are the cities and observations that were included in the original chart. The data contains a variable where you can check which are the last observations, but this does not mean that these were the observations initially included since there are new cities that were not included before. To mitigate this situation, I created a table from the information contained in The Economist’s article. Below the graph, there is a table that contains the names of the 794 cities included in the study, but the names were not written in the same way that they are written in the mobility dataset. Therefore, I changed manually the names, erasing accents and modifying the special characters. This change provided me the possibility of joining the two tables, obtaining a final data of 773 observations, which was closer to 794 than the initial filter with the first table (866 observations).\n\n\n## Preparing the data frame\n\nmobility_data <- read_csv(\"ModalShare.csv\")\n\ncities <- read_csv2(\"cities.csv\")\n\nmobility_data <- mobility_data |>\n  filter(LastObservation == \"YES\", year <= 2019) |>\n  distinct(ObsID, .keep_all = TRUE)\n\nmobility <- mobility_data |>\n  left_join(cities, by = \"City\") |>\n  distinct(ObsID, .keep_all = TRUE) |> \n  drop_na(Population) \n\n\nOnce we have the data prepared, we can start with the replication process. The initial plot is a ternary graph with a scatter plot inside of it, containing information about three variables that are located on each of the sides of the triangle. There is a specific extension of ggplot for this type of graph which is ggtern.\nFirst representation with ggtern\nCreating a ternary graph could seem easy once you are adapted to having three coordinates instead of just two like in any other two-dimensional plot. The ggtern package helps a lot in facilitating the work since it uses almost the same arguments that are inside of ggplot. However, before starting to add the data, I wanted to create a simple graph to understand the dynamics of this type of visual representation.\n\n\n# Empty graph\n\ng <- ggtern() +\n  theme_void() + \n  theme_nolabels() +\n  theme(\n    legend.position = \"none\")\n\ng\n\n\n\nIt could be said that each of the sides of the triangle represents a coordinate (Left, Top and Right). The centre of the triangle represents the same quantity of the three variables that could be represented.\nTo see how the data interact with this type of representation, we could simply add a geom point to the ternary graph in which the three variables of the study are included.\n\n\n# Ternary graph with the data\n\ng <- ggtern(data = mobility, \n            aes(x = Car, y = Active, z = Bus)) +\n  geom_point(\n    alpha = 0.4,\n    aes(size = population),\n    color = \"#E3120B\",\n    show.legend = FALSE) +\n    scale_size(range = c(1, 6)) +\n  theme_void() + \n  theme_nolabels() +\n  theme(\n    legend.position = \"none\")\n\ng\n\n\n\nIt could be seen that there is still so much work to be done, but the distribution and the number of points are very similar to the original graph. For this representation, most of the arguments are not represented since this design matches The Economist’s style simplicity.\nCreating the coloured regions\nThe initial graph is separated into three different regions, each having a specific colour that then would be connected to the points and the variables. These regions can be applied to the ternary graph by using geom_polygon, but firstly, the different areas should be defined in another data frame. Normally, building a specific polygon would require a specific number of points with coordinates x and y. The problem is that to fit a polygon in this graph, the points require another coordinate which is z. After having this into account, the regions are created as follows and they are added to the chart.\n\n\n# Geom polygon and regions\n\nregions <- data.frame(\n  x = c(1, 0.5, 0.33, 0.5,\n        \n        0, 0.5, 0.33, 0,\n        \n        0, 0.5, 0.33, 0),\n  \n  y = c(0, 0.5, 0.33, 0,\n        \n        1, 0.5, 0.33, 0.5,\n        \n        0, 0, 0.33, 0.5),\n  \n  z = c(0, 0, 0.33, 0.5,\n        \n        0, 0, 0.33, 0.5,\n        \n        1, 0.5, 0.33, 0.5),\n  region = c(\n    \"Car1\", \"Car1\", \"Car1\", \"Car1\", \n    \"Active1\", \"Active1\", \"Active1\",\"Active1\", \n    \"Bus1\", \"Bus1\", \"Bus1\",\"Bus1\"))\n\ng <- ggtern(data = mobility, \n            aes(x = Car, y = Active, z = Bus)) +\n  geom_polygon(data = regions, \n               aes(x = x, y = y, z = z, fill = region), alpha = 0.25) +\n  geom_point(aes(size = population), \n             alpha = 0.5, show.legend = FALSE) +\n  scale_size(range = c(1, 6)) +\n  scale_fill_manual(\n    values = c(\n      \"Car1\" = \"#e3160f\", \n      \"Active1\" = \"#4d5fb4\", \n      \"Bus1\" = \"#74705f\")) +\n  theme_void() + \n  theme_nolabels() +\n  theme_hideticks() +\n  theme(\n    legend.position = \"none\")\ng\n\n\n\nThe plot maintains the same visual representation as before, without ticks or labels usually included in the default themes.\nPoints with the colour of the regions\nThe next step is to colour the points according to the colour of the region in which they are located. In order to achieve this, a function was created that assigns the different colours to the points. Several arguments are included within this function in order for it to work correctly, such as the inclusion of the function point.in.polygon from the sp package. The function created is then assigned to the data so that it can be included in the graph that is being replicated.\n\n\n## Points with the colour of the regions\n\nassign_region <- function(point, regions) {\n  region_list <- \n    split(regions, regions$region)\n  inside_region <- \n    sapply(region_list, function(region) {\n    sp::point.in.polygon(\n      point$Car, point$Active, region$x, region$y)\n  })\n  matched_region <- names(\n    which.max(inside_region))\n  if (length(matched_region) > 0) return(matched_region) else return(NA)\n}\n\n# Function to the data\n\nmobility <- mobility |>\n  rowwise() |> \n  mutate(region = \n           assign_region(cur_data(), regions)) |>\n  ungroup()\n\n# Graph\n\ng <- ggtern(data = mobility, \n            aes(x = Car, y = Active, z = Bus)) +\n  geom_polygon(data = regions, \n               aes(x = x, y = y, z = z, fill = region), \n               colour = \"white\", linewidth = 0.6, alpha = 0.2) +\n  geom_point(aes(size = population, color = region), \n             alpha = 0.35, show.legend = FALSE) +\n  scale_fill_manual(\n    values = c(\"Car1\" = \"#e3160f\", \n               \"Active1\" = \"#4d5fb4\", \n               \"Bus1\" = \"#74705f\")\n                    )+\n  scale_color_manual(\n    values = c(\"Car1\" = \"#e3160f\", \n               \"Active1\" = \"#4d5fb4\", \n               \"Bus1\" = \"#74705f\")\n                    )+\n  scale_size(range = c(1, 6)) +\n  theme_noticks() +\n  theme_nolabels()+\n  theme(\n    tern.axis.ticks = element_blank(),                          \n    tern.panel.background = element_rect(fill = \"white\", color = NA),           \n    panel.border = element_blank(),                             \n    plot.background = element_rect(fill = \"white\", color = NA),\n    legend.position = \"none\")\n\ng \n\n\n\nFor this section it was necessary to recreate the chart from the beginning, as the basic arguments of the ternary chart are being changed and cannot be assigned to an already created graph. It can be seen that the graph is already resembling the original one. The next steps will focus on improving the environment, trying to add the small arrows and annotations included in the original chart.\nArrows\nFinding the right typeface to imitate the arrows and annotations in the next two sections was easy, as The Economist Design System has an official website where they share data related to the style present in their articles. Nevertheless, the fonts used by The Economist are private and are not freely available for use in R. The fonts to be used try to be as close as possible to the original font.\nThe option chosen to be able to include the arrows in each corner has been the annotate function. The most challenging thing has been to find the exact location of the arrows, since like any other element of the graph, they also need information of the three coordinates (x, y, z).\n\n\nlibrary(showtext)\nfont_add_google(\"Merriweather\", \"Merriweather\")\nshowtext_auto()\n\ntheme(text = element_text(family = \"Merriweather\"))\n\nList of 1\n $ text:List of 11\n  ..$ family       : chr \"Merriweather\"\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi FALSE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n - attr(*, \"class\")= chr [1:2] \"theme\" \"gg\"\n - attr(*, \"complete\")= logi FALSE\n - attr(*, \"validate\")= logi TRUE\n\ng <- g + \n  annotate(\n    \"text\", x = 0.03, y = 0.94, z = 0.03, label = \"↑\", \n    size = 5, color = \"#4d5fb4\", family = \"Merriweather\") +\n  annotate(\n    \"text\", x = 0.03, y = 0.03, z = 0.94, label = \"↘\", \n    size = 5, color = \"#74705f\", family = \"Merriweather\") +\n  annotate(\n    \"text\", x = 0.94, y = 0.03, z = 0.03, label = \"↙\", \n    size = 5, color = \"#e3160f\", family = \"Merriweather\")\n\ng\n\n\n\nAnnotations and the final result\nIn this last part of code, the text annotations next to each corner are added, as well as a title for the graphic. It should be noted that the original graphic does not have a title, but what is intended to be included is the title of the article, with a strong similarity to the original font.\n\n\nfont_add_google(\"Noto Sans\", \"Noto\")\nfont_add_google(\"Newsreader\", \"News\")\nshowtext_auto()\n\ng <- g +\n  labs(\n    title = \"The world's most, and least, walkable cities\") +\n  theme_nomask() +\n  theme_notitles() +\n  theme(\n    plot.title = element_text(\n      family = \"News\",\n      size = 18,          \n      hjust = 0.5,\n      vjust = 0,\n      face = \"bold\",\n      color = \"black\"), \n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.margin = margin(0, 0, 0, 0)\n    ) +\n      annotate(geom  = \"text\",\n           x     = c(1, 0, 0),\n           y     = c(0, 1, 0),\n           z     = c(0, 0, 1),\n           angle = c(0, 0, 0),\n           vjust = c(1.25, -0.5, 1.25),\n           hjust = c(0, 0.5, 1),\n           label = c(\"Mostly journeys \\n by car\",\n                     \"Mostly active mobility \\n (walking and cycling)\",\n                     \"Mostly journeys \\n using public transport\"),\n           color = c(\"#e3160f\", \"#4d5fb4\", \"#74705f\"),\n           size = 3, family = \"Noto\", lineheight = 1)\n\ng\n\n\n\nAlternative versions\nIn my opinion, creating an improvement on the original graphic is not easy. The chart can convey the information in a simple way and in a novel format. To find an improvement that adds something to the graph, it is necessary to find a correct way to show the three variables as well. However, the graphic focuses very much on the three colours presented, even linking these colours with the points. The colour of the points could be used to show more information about the cities shown.\nTaking these factors into account and knowing all the information available in the data set, I thought of making two improvements related to displaying more information on the graph.\nAlternative I\nThe first alternative graphic maintains the original ggtern format but eliminates the colours of the regions and dots. In this case, a black colour is chosen for the annotations and the lines of the graph. On the other hand, the colours of the dots add more information to the graph, indicating the continent of each of the cities.\n\n\ng2 <- ggtern(data = mobility, \n            aes(x = Car, y = Active, z = Bus)) +\n  geom_point(aes(size = population, color = continent), \n             alpha = 0.7, show.legend = TRUE) +\n  scale_color_manual(values = c(\n    \"Asia\" = \"#66c2a5\",\n    \"Europe\" = \"#fc8d62\",\n    \"Africa\" = \"#a6d854\",\n    \"North America\" = \"#8da0cb\",\n    \"South America\" = \"#e78ac3\",\n    \"Oceania\" = \"#ffd92f\")) +\n  scale_size(range = c(1, 6)) +\n  theme_void() +\n  theme_nolabels() +\n  theme_hideticks() +\n  theme_notitles() +\n  guides(\n    size = \"none\",\n    color = guide_legend(override.aes = list(size = 5))\n    ) +\n  theme(\n      legend.title = element_text(face = \"bold\", size = 9),\n      legend.text = element_text(size = 8),\n      legend.box.background = element_rect(color = \"black\", fill = \"#EEE9E9\"),\n      legend.box.margin = margin(5, 5, 5, 5),\n      legend.position = c(0.9, 0.5),\n      plot.margin = NULL, \n      plot.title = element_text(\n        family = \"News\",\n        size = 18,          \n        hjust = 0.5,\n        vjust = 0,\n        face = \"bold\",\n        color = \"black\"), \n      axis.title.x = element_blank(),\n      axis.title.y = element_blank(),\n      tern.axis.line = element_line(color = \"black\", linewidth = 0.8)\n        ) +\n  annotate(\n  \"text\", x = 0.03, y = 0.94, z = 0.03, label = \"↑\", \n  size = 5, color = \"#292929\", family = \"Merriweather\") +\n  annotate(\n    \"text\", x = 0.03, y = 0.03, z = 0.94, label = \"↘\", \n    size = 5, color = \"#292929\", family = \"Merriweather\") +\n  annotate(\n    \"text\", x = 0.94, y = 0.03, z = 0.03, label = \"↙\", \n    size = 5, color = \"#292929\", family = \"Merriweather\"\n  ) +\n  labs(\n    title = \"The world's most, and least, walkable cities\",\n    color = \"Continent\"\n    ) +\n      annotate(geom  = \"text\",\n           x     = c(1, 0, 0),\n           y     = c(0, 1, 0),\n           z     = c(0, 0, 1),\n           angle = c(0, 0, 0),\n           vjust = c(1.25, -0.5, 1.25),\n           hjust = c(0, 0.5, 1),\n           label = c(\"Mostly journeys \\n by car\",\n                     \"Mostly active mobility \\n (walking and cycling)\",\n                     \"Mostly journeys \\n using public transport\"),\n           color = \"black\",\n           size = 3, family = \"Noto\", lineheight = 1)\n\ng2\n\n\n\nIn order to correctly define the colours assigned to the continents, a small legend has been added. In the case of the population of the cities, the previous scale has been maintained, so it has been decided not to show this information in the legend.\nAlternative II\nThe second alternative aims to move away from the three-parameter visual format to define the graph. In this way, it is intended to separate the three variables into three different scatterplots, in which the other variable represented will be the population size.\nTo achieve the desired visual representation, it was necessary to first modify the data and organise them in a long format. The three variables are merged into two, in this case, the names go to Transport and the values to Percentage. On the other hand, in order to be able to represent the three plots together and respecting the same scale used in the population axis, facet_grid was used together with arguments defined within the lemon package. The scale used to represent the population is intervals of powers of ten, so that all the points can be seen distributed. As there were very few cities with large populations, the normal population scale accumulated many points to the left of the axis, preventing relevant results from being seen.\n\n\nmobility_long <- mobility |> \n  pivot_longer(\n    cols = c(Car, Active, Bus), \n    names_to = \"Transport\", \n    values_to = \"Percentage\"\n  )\n\nfont_add_google(\"Roboto Condensed\", \"Roboto\")\nshowtext_auto()\n\np <- ggplot(mobility_long, aes(x = population, y = Percentage, color = Continent)) +\n  geom_point(size = 2.5, alpha = 0.7) +\n  facet_rep_grid(Transport ~ ., scales = \"fixed\") +\n  theme_minimal() +\n  labs(\n    title = \"Type of mobility by continent\",\n    x = \"Population (in millions)\",\n    y = \"Percentage (%)\",\n    color = \"Continent\") +\n  scale_x_log10(\n    breaks = c(1e5, 1e6, 1e7, 1e8, 1e9),\n    labels = label_number(scale = 1e-6, suffix = \"M\")\n  ) +\n  scale_y_continuous(\n    limits = c(0, 1), \n    breaks = c(0, 0.25, 0.5, 0.75, 1),\n    labels = c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\")\n    ) +\n  scale_color_manual(\n    values = c(\n      \"Asia\" = \"#66c2a5\",\n      \"Europe\" = \"#fc8d62\",\n      \"Africa\" = \"#a6d854\",\n      \"North America\" = \"#8da0cb\",\n      \"South America\" = \"#e78ac3\",\n      \"Oceania\" = \"#ffd92f\")\n  ) +\n  guides(\n    color = guide_legend(override.aes = list(size = 5))\n  ) +\n  theme(\n    text = element_text(family = \"Roboto\"),\n    strip.text = element_text(size = 14, face = \"bold\"),\n    panel.spacing = unit(1, \"lines\"),\n    plot.title = element_text(size = 20, face = \"bold\", hjust = 0.5),\n    axis.text = element_text(size = 8),\n    axis.title = element_text(size = 12, face = \"bold\", hjust = 0.5),\n    panel.grid.major.y = element_line(color = \"grey80\", linewidth = 0.4),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.line = element_line(color = \"black\", linewidth = 0.4),\n    axis.ticks = element_line(color = \"black\", linewidth = 0.15),\n    #Legend arguments\n    legend.title = element_text(face = \"bold\"),\n    legend.text = element_text(size = 10),\n    legend.box.background = element_rect(color = \"black\", fill = \"#EEE9E9\"),\n    legend.box.margin = margin(5, 5, 5, 5)\n  )\n\np\n\n\n\nThe graphic keeps the same colours and the legend of the previous alternative. It shows the different mobility patterns according to the continent.\n\n\n\n",
    "preview": "projects/2024/100453237/100453237_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2100,
    "preview_height": 2100
  },
  {
    "path": "projects/2024/100540594/",
    "title": "Global trade flows in 2022",
    "description": "Using UN Comtrade trade data of 2022 to reproduce the resourcetrade.earth\nworld map and produce an alternative network graph.",
    "author": [
      {
        "name": "Marvin-Julian Struckmeyer",
        "url": {}
      }
    ],
    "date": "2025-01-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\n1. Preliminaries\n2. Country labels and annotations\n3. Trade flows\n\nAlternative visualisation\n1. Preliminaries\n2. Network graphs\n\n\nIntroduction\nThe visualisation shown below by the resourcetrade.earth initiative explores global trade flows in 2022.\nOriginal visualization from resourcetrade.earthIt shows the biggest bilateral trade trade flows in 2022, i.e., trade between\ntwo different countries. The thickness of the curved trade flows represents trade\nvolume, while the gradient color scheme, the arrows and the thickness along the\nflow describe the directionality of trade. For instance,\nthe flows start very thin at the exporting country and get progressively thicker\nuntil they reach the importing country. The trade is in commodities, ranging from\nfertilizers, oilseeds or live animals to natural gas, iron and steel or pearls.\nThe raw data is from the UN Comtrade data set and then re-organised and cleaned\nby the team at resourcetrade.earth.\nThe actual visualisation was made by the design agency applied.works.\nThe rest of this blog post is divided in two steps. First, we will replicate the\nvisualisation. Then, we will produce alternative visualisations that aim to\naddress some of the original plot’s shortcomings.\nReplication\nThe replication process is divided in three separate steps:\nPreliminaries\nCountry labels and annotations\nTrade flows\n1. Preliminaries\nLibraries\nWe will use the following libraries for the replication.\n\n\n# core packages\nlibrary(tidyverse)  # includes ggplot2, dplyr, etc.\n\n# map data\nlibrary(maps)       # for map_data(\"world\")\n\n# labels\nlibrary(ggrepel)\n\n# import data\nlibrary(readxl)\n\n# font handling\nlibrary(showtext)   # for custom fonts\nlibrary(sysfonts)   # for font_add_google\n\n\nGet the data\nThe data is provided by resourcetrade.earth. We simply\nneed to click on the Download button in the right-bottom of the plot to download\nan Excel file.\n\n\ndata_raw <- read_excel(\n  \"resourcetradeearth-all-all-all-2022.xlsx\",\n  sheet = \"Trades\")\n\n\nClean the data\nThe initial dataset is extensive, containing almost 5 million observations with\nmany variables that are not needed for our visualization. Thus, we will clean\nthis dataset in two steps:\nFilter for only 2022 trade data, as this matches the time period shown in the\noriginal visualization\nSelect five essential variables: the ISO3 code and name for both exporting\nand importing countries, and the trade volume for each country pair or flow\n\n\ndata <- data_raw |> \n  # filter for only 2022 trade data\n  filter(Year == 2022) |> \n  # select essential variables: info about exporter, importer and trade volume\n  select(`Exporter ISO3`, Exporter, \n         `Importer ISO3`, Importer,\n         `Value (1000USD)`) |>\n  # finally, rename for easier handling later\n  rename(\n    Exporter_ISO3 = `Exporter ISO3`,\n    Importer_ISO3 = `Importer ISO3`,\n    Value = `Value (1000USD)`)\n\n\nAt this stage, our data is disaggregated by resource types (such as forestry\nproducts, fossil fuels, and metals). This means that for each country pair, we\nhave multiple rows representing different types of traded resources. However,\nthe original visualization shows total trade flows between countries, summed\nacross all resource types. Therefore, we need to aggregate the data by summing\nup all trade volumes for each country pair.\n\n\n# aggregate trade by country pairs\ndata_2 <- data |> \n  group_by(Exporter_ISO3, Exporter, Importer_ISO3, Importer) |> \n  summarize(Total_Value = sum(Value, na.rm = TRUE), .groups = 'drop')\n\n\nLooking at the original visualization, we can see a note in the bottom-right\ncorner, indicating that it displays the 76 largest trade flows. To match\nthis, we will filter our dataset to keep only the 76 largest trade flows.\n\n\n# filter for the 76 largest trade flows\ndata_2_filtered <- data_2 |> \n  slice_max(order_by = Total_Value, n = 76)\n\n\nWe also need to standardise some country names to make sure that the trade data\nand the map data use the same names.\n\n\n# create mapping for country name standardisation\ncountry_name_mapping <- data.frame(\n  original = c(\n    \"United States\", \"United Arab Emirates\", \"Korea, Republic\",\n    \"Russian Federation\", \"China, Hong Kong SAR\", \"Areas, nes\",\n    \"Rest of America, nes\", \"United Kingdom\"),\n  mapped = c(\n    \"USA\", \"UAE\", \"South Korea\", \"Russia\", \"Hong Kong\",\n    \"Areas, nes\", \"Rest of America, nes\", \"UK\"))\n\n# apply the standardised names to both exporters and importers\ndata_2_filtered <- data_2_filtered |> \n  # first standardise exporter names\n  left_join(country_name_mapping, by = c(\"Exporter\" = \"original\")) |> \n  mutate(Exporter = ifelse(!is.na(mapped), mapped, Exporter)) |> \n  select(-mapped) |> \n  # now standardise importer names\n  left_join(country_name_mapping, by = c(\"Importer\" = \"original\")) |> \n  mutate(Importer = ifelse(!is.na(mapped), mapped, Importer)) |> \n  select(-mapped)\n\n\nMap Processing\nBefore we create our world map, we need to establish base coordinates that we\nwill use both for positioning country labels and for drawing the trade flows\nbetween countries. We will start by creating an ‘empty’ base world map\nin three steps:\nSimplify the world map by removing small islands and regions that are not\nin the original plot\nCreate the two buffer zones to give the map depth\nApply the correct color scheme using precise hex codes\nWe used latlong.net, which provides precise\nlongitude and latitude data for geographic locations. Moreover, we used\nimagecolorpicker to get the hex color\ncodes of the land and sea masses and the two buffer zones.\n\n\nworld_map <- map_data(\"world\") |> \n  # filter many of the small islands\n  filter(!(region %in% c(\n    \"French Southern and Antarctic Lands\",\n    \"Micronesia\", \"Marshall Islands\", \"Kiribati\",\n    \"Tuvalu\", \"American Samoa\", \"Solomon Islands\",\n    \"Vanuatu\", \"New Caledonia\", \"Fiji\", \"Samoa\",\n    \"Tonga\", \"Cook Islands\", \"Wallis and Futuna\",\n    \"Niue\", \"Tokelau\", \"French Polynesia\",\n    \"Pitcairn Islands\", \"Comoros\", \"Mauritius\", \"Seychelles\",\n    \"Maldives\", \"Cape Verde\", \"Sao Tome and Principe\",\n    \"Saint Helena\", \"Palau\", \"Northern Mariana Islands\",\n    \"Nauru\", \"Christmas Island\", \"Cocos Islands\",\n    \"Norfolk Island\"))) |>\n  # filter out all Pacific islands except for Australia\n  filter(!(long > 140 & lat < 30 & lat > -30) | region == \"Australia\") |> \n  # filter out Antarctica\n  filter(lat > -60)\n\n\nThe original visualization has distinctive layers. These layers create some\n‘depth effect’. The land masses are bordered by a small dark grey buffer zone.\nAnd this buffer zone is bordered by another slightly larger light grey buffer\nzone. In the following, we will create these buffers or layers. I estimate that\nthe large buffer is about three times larger than the small buffer.\n\n\n# small buffer - closest to the actual landmass\nbuffer_small <- world_map |> \n  group_by(group) |> \n  mutate(\n    long = long + sign(long - mean(long)) * 1.25,\n    lat = lat + sign(lat - mean(lat)) * 1.25) \n\n# large buffer - creates the outermost layer\nbuffer_large <- world_map |> \n  group_by(group) |> \n  mutate(\n    long = long + sign(long - mean(long)) * 3.75,\n    lat = lat + sign(lat - mean(lat)) * 3.75)\n\n\nWe will use the “Gudea” font which comes closest to the font used in the\noriginal plot. We used myfonts.com to detect the font.\nNow we can plot the world map.\n\n\n# get the font right\nsysfonts::font_add_google(\"Gudea\", family = \"gudea\") \nshowtext::showtext_auto()\n\n# create the basic world map with layers\np <- ggplot() +\n  # sea layer (furthest)\n  geom_polygon(\n    data = buffer_large, \n    aes(x = long, y = lat, group = group),\n    fill = \"#ffffff\",\n    alpha = 0.15,\n    color = NA) +\n  # second transition layer\n  geom_polygon(\n    data = buffer_large, \n    aes(x = long, y = lat, group = group),\n    fill = \"#f9f9f9\", \n    color = NA) +\n  # first transition layer\n  geom_polygon(\n    data = buffer_small, \n    aes(x = long, y = lat, group = group),\n    fill = \"#eff0f0\", \n    color = NA) +\n  # land layer (topmost)\n  geom_polygon(\n    data = world_map, \n    aes(x = long, y = lat, group = group),\n    fill = \"#ffffff\",\n    alpha = 0.95,\n    color = \"#b8c6c7\",\n    size = 0.1) +\n  # set the coordinate system and aspect ratio\n  coord_fixed(1.3) +\n  # remove axes and grid\n  theme_void() +\n  # customize the theme\n  theme(\n    panel.background = element_rect(fill = \"#ffffff\"),\n    plot.background = element_rect(fill = \"#ffffff\"))\n\n# display the base map\nprint(p)\n\n\n\n2. Country labels and annotations\nPositioning of country labels\nFirst, we need to get the country names right. To this end, we create a mapping\nfrom the semi-official country names to the names used in the visualisation.\nNote that this mapping defines how the country names eventually appear on the\nmap, whereas the standardisation in country_name_mapping was about matching the\nnames in the trade dataset with the names used in the map data.\n\n\ncountry_labels <- data.frame(\n  Country = c(\n    # all the countries in the plot\n    \"Belgium\", \"Netherlands\", \"Germany\", \"France\", \"Italy\", \n    \"Switzerland\", \"Austria\", \"Spain\", \"UK\",\n    \"USA\", \"Canada\", \"Mexico\", \"Brazil\", \"Peru\", \"Chile\", \"Norway\",\n    \"Russia\", \"China\", \"Japan\", \"South Korea\", \"India\", \"Australia\",\n    \"Indonesia\", \"Malaysia\", \"Thailand\", \"Hong Kong\",\n    \"UAE\", \"Saudi Arabia\", \"Kuwait\", \"Qatar\", \"Oman\", \"Iraq\", \"Azerbaijan\",\n    \"Turkey\", \"Algeria\", \"Angola\", \"South Africa\"),\n  # the actual labels of all the countries in the plot\n  Label = c(\n    \"Bel\", \"Nld\", \"Germany\", \"Fra\", \"Italy\", \"Swi\", \"Austria\", \"Spain\", \"UK\",\n    \"United States\", \"Canada\", \"Mexico\", \"Brazil\", \"Peru\", \"Chile\", \"Norway\",\n    \"Russia\", \"China\", \"Japan\", \"Korea, \\nRep.\", \"India\", \"Australia\",\n    \"Indonesia\", \"Malaysia\", \"Thailand\", \"Hong Kong\",\n    \"UAE\", \"Saudi \\nArabia\", \"Kuwait\", \"Qatar\", \"Oman\", \"Iraq\", \"Azerbaijan\",\n    \"Turkey\", \"Algeria\", \"Angola\", \"South Africa\"))\n\n\nWe also need to add coordinates for the two special areas:\n“Rest of America, nes” and “Areas, nes”. Here, “nes” stands for “not elsewhere\nspecified” and refers to unknown trading partners. This can occur when reporting\ncountries do not submit details about the trading partner, either due to low-\nvalue trade or to protect company information. “Rest of America, nes” represents\nunspecified trading partners specifically within the Americas. We need to do\nthis manually:\n\n\nspecial_areas_coords <- data.frame(\n  Country = c(\"Areas, nes\", \"Rest of America, nes\"),\n  long = c(4.46, -111.861620),\n  lat = c(-50.49, 1.691649))\n\n\nOne of the key challenges in replicating this visualization is the precise\npositioning of country labels. The country labels are also the start and end\npoints of the trade flows. Thus, we really do need to get the labels’ positions\nright to match the original plot.\nThe positions of the country labels are not in the dataset. But we can\nautomatically determine the positions by calculating the centroid of each\ncountry and placing it at this point.\n\n\n# calculate basic country centroids\ncountry_coords <- world_map |> \n  group_by(region) |> \n  summarize(\n    long = mean(long),\n    lat = mean(lat)) |>  \n  rename(Country = region)\n\n# combine the country_coords with the special_areas_coords\nall_coords <- country_coords |> \n  bind_rows(special_areas_coords)\n\n# prepare the trade flow data by adding start and end coordinates for each flow\n# we do this here since we have just created our complete coordinate system and\n# we will need this data structure for both label positioning and trade flow\n# visualisation later\ndata_2_filtered_with_coords <- data_2_filtered |> \n  left_join(all_coords, by = c(\"Exporter\" = \"Country\")) |> \n  rename(Export_Long = long, Export_Lat = lat) |> \n  left_join(all_coords, by = c(\"Importer\" = \"Country\")) |> \n  rename(Import_Long = long, Import_Lat = lat)\n\n\nNow we can create a plot with the labels positioned at the countries’ centroids.\n\n\np + \n  geom_text(\n    data = country_labels %>% left_join(all_coords, by = \"Country\"),\n    aes(x = long, y = lat, label = Label),\n    size = 3)\n\n\n\nThe positions of the country labels do not match the positions in the original\nplot. For instance, the label “United States” is located at the North-West of\nthe US. This is because of Alaska shifting the centroid in this direction.\nAdditionally, the labels in Europe and the Middle East are too cluttered.\nWe can try geom_text_repel() from the ggrepel package which automatically\nadjusts label positions to avoid overlaps while trying to keep labels close to\ntheir associated points.\n\n\np + \n  geom_text_repel(\n    data = country_labels %>% left_join(all_coords, by = \"Country\"),\n    aes(x = long, y = lat, label = Label),\n    size = 3,\n    max.overlaps = Inf)\n\n\n\nWhile geom_text_repel() solves the issue of cluttered labels in Europe and the\nMiddle East, the positions of the labels still do not match the ones in the\noriginal plot.\nNote that an approach using the capital cities as reference points for the\ncountry labels does not work either. We have no alternative but to place the\ncountry labels manually, again using a longitude and latitude finder in the web.\n\n\n# custom coordinates of country labels\nlabel_adjustments <- data.frame(\n  Country = c(\n    # South America\n    \"Peru\", \"Brazil\", \"Chile\",\n    # North America\n    \"USA\", \"Canada\", \"Mexico\",\n    # Asia\n    \"Russia\", \"India\", \"Indonesia\", \"Malaysia\", \"Thailand\", \"China\", \"Japan\", \n    \"South Korea\", \"Oman\", \"UAE\", \"Qatar\", \"Saudi Arabia\", \"Kuwait\", \"Iraq\",\n    \"Hong Kong\",\n    # Europe\n    \"Norway\", \"Turkey\", \"Azerbaijan\", \"Spain\", \"France\", \"Italy\", \"UK\",\n    \"Belgium\", \"Germany\", \"Switzerland\", \"Netherlands\", \"Austria\",\n    # Africa\n    \"South Africa\", \"Angola\", \"Algeria\",\n    # Australia\n    \"Australia\"),\n  \n  long = c(\n    # South America\n    -75.951872, -56.385277, -70.830462,\n    # North America\n    -99.308645, -95.202345, -101.812930,\n    # Asia\n    71.909173, 77.324934, 119.847050, 112.765282, 101.445301, 102.411087, \n    139.182451, 127.749200, 58.621072, 57.301851, 55.324885, 37.991606, \n    44.178739, 40.544111, 115.203854,\n    # Europe\n    10.406986, 29.882086, 50.675979, -4.881616, 0.155130, 11.260573, -6.355075,\n    0.450087, 18.697300, 7.885837, 1.838480, 19.122010,\n    # Africa\n    25.354109, 18.169549, 2.914381,\n    # Australia\n    133.363988),\n  \n  lat = c(\n    # South America\n    -10.772603, -10.569497, -30.133251,\n    # North America\n    38.649053, 60.089502, 22.549343,\n    # Asia\n    61.363171, 20.014000, -4.952090, 1.019271, 14.721046, 35.037486, 33.954752, \n    37.660866, 15.703697, 21.612749, 26.063568, 21.687738, 29.666373, 33.928121,\n    21.943046,\n    # Europe\n    61.160132, 39.118608, 40.019727, 39.139647, 43.635898, 39.739402, 55.073748,\n    48.931973, 52.130221, 47.172791, 56.207238, 44.663403,\n    # Africa\n    -29.271098, -13.306108, 27.232120,\n    # Australia\n    -24.820393))\n\n# apply the adjustments to our labels\ncountry_labels_adj <- country_labels %>%\n  left_join(label_adjustments, by = \"Country\")\n\n\n\n\n# Add adjusted labels to our map\np +\n  geom_text(\n    data = country_labels_adj,\n    aes(x = long, y = lat, label = Label),\n        size = 1.65, fontface = \"bold\")\n\n\n\nNow, the positions of the country labels match the ones in the original plot\nquite well.\nRefinement of labels\nWhile the country labels are now correctly positioned, we still need to do fine-\ntuning to match the original plot’s labels. The original plot has some text\nhalo effect. This does not only look nice but also ensures better readability\nwhen labels overlap with trade flows. We recreate this halo effect as follows:\nPlace multiple white labels behind each text label (which is black)\nUse slightly larger white text (size 1.75-1.77) than black text\n(size 1.65) to create a solid white outline\nIn this step, we will also add the two “nes” areas.\n\n\np <- p + \n  geom_text(data = country_labels_adj,\n            aes(x = long - 0.1, y = lat, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            # we need to adjust the lineheight argument for \"Korea, \\nRep.\" and \n            # \"Saudi \\n Arabia\" to make sure that the vertical spacing is fine\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long + 0.1, y = lat, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat - 0.1, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat + 0.1, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  \n  # add country labels (white)\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat, label = Label),\n            size = 1.77,  # slightly larger than the black text\n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  \n  # add country labels (black)\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat, label = Label),\n            size = 1.65,  \n            color = \"black\",\n            fontface = \"bold\",\n            lineheight = .9) + \n  \n  # add rectangles for nes areas\n  geom_rect(data = data.frame(\n    xmin = c(special_areas_coords[1,2] - 11.75, \n             special_areas_coords[2,2] - 22.5),\n    xmax = c(special_areas_coords[1,2]  + 11.75, \n             special_areas_coords[2,2] + 22.5),\n    ymin = c(special_areas_coords[1,3] - 2.6, \n             special_areas_coords[2,3] - 2.6),\n    ymax = c(special_areas_coords[1,3] + 2.6, \n             special_areas_coords[2,3] + 2.6),\n    label = c(\"Areas, nes\", \"Rest of America, nes\")),\n    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#ffffff\",\n    alpha = .9,\n    color = \"#cccccc\", \n    size = 0.3) +\n  \n  # add text labels for nes areas\n  geom_text(data = data.frame(\n    x = c(special_areas_coords[1,2], special_areas_coords[2,2]),\n    y = c(special_areas_coords[1,3], special_areas_coords[2,3]),\n    label = c(\"Areas, nes\", \"Rest of America, nes\")),\n    aes(x = x, y = y, label = label),\n    size = 1.65, \n    fontface = \"bold\")  + \n  \n  theme(text = element_text(family = \"gudea\"))\n\nprint(p)\n\n\n\nAnnotations\nFinally, we can add the legend ‘Scale’ in the bottom-left. This legend helps\nreader understand the trade flows more easily by showing how the thickness of\nthe flows corresponds to trade volume. We leave out the other annotations\nas these do not add anything meaningful to the plot.\n\n\np <- p + \n  annotation_custom(\n    grid::rasterGrob(\n      png::readPNG(\"legend.png\"),\n      x = unit(0.15, \"npc\"),\n      y = unit(0.15, \"npc\"),\n      width = unit(0.1, \"npc\")))\n\nprint(p)\n\n\n\n3. Trade flows\nThe most complex part of this visualization is the trade flows. In the original\nplot the trade flows have a unique leftward curvature. They start from the\nexporting country and curve left before turning right at about halfway to the\nimporting country. Moreover, the flows get progressively larger: the flows are\nvery thin at their starting point (the exporting country) and get larger as they\nreach the importing country. Additionally, the colour of the flows changes as\nthey progress. Finally, the flows have an arrow which shows the\ndirectionality of trade.\nPrepare trade flow coordinates\nBefore we can create the trade flows, we need to ensure we have the correct\ncoordinates for both the start (exporter) and end (importer) of each flow.\nThese coordinates should match the positions of our manually adjusted country\nlabels rather than the geographical centroids we initially calculated.\n\n\n# merge our manual label positions with the trade flow data\ndata_2_filtered_with_coords <- data_2_filtered |> \n  # join with label_adjustments for exporter coordinates\n  left_join(label_adjustments, by = c(\"Exporter\" = \"Country\")) |> \n  rename(Export_Long = long, Export_Lat = lat) |> \n  # join again with label_adjustments for importer coordinates\n  left_join(label_adjustments, by = c(\"Importer\" = \"Country\")) |> \n  rename(Import_Long = long, Import_Lat = lat)\n\n# update any missing coordinates\ndata_2_filtered_with_coords <- data_2_filtered_with_coords |> \n  left_join(special_areas_coords, by = c(\"Exporter\" = \"Country\")) |> \n  mutate(\n    Export_Long = coalesce(Export_Long, long),\n    Export_Lat = coalesce(Export_Lat, lat)) |> \n  select(-long, -lat) |> \n  left_join(special_areas_coords, by = c(\"Importer\" = \"Country\")) |> \n  mutate(\n    Import_Long = coalesce(Import_Long, long),\n    Import_Lat = coalesce(Import_Lat, lat)) |> \n  select(-long, -lat)\n\n\nCalculating Bezier curves\nRather than directly using geom_bezier(), we create a custom function to\ncalculate the Bezier curves. The reason for this decision is that we will later\nneed to add arrows embedded in the trade flows. These arrows follow the same\npath as the trade flows but end a bit before the trade flows. Calculating the\nBezier curves ourselves allows us to access and control the curve coordinates,\nwhich is necessary to make the arrows shorter than the trade flows. This was\ndifficult to achieve with geom_bezier().\nWe go for simpler quadratic Bezier curves which use just one control point.\nHere is the function that calculates these curves:\n\n\ncalculate_bezier_points <- function(x1, y1, cx, cy, x2, y2, n = 100, \n                                  start_offset = 2, end_offset = 2) {\n  \n  # calculate points along the Bezier curve\n  t <- seq(0, 1, length.out = n)\n  x <- (1-t)^2 * x1 + 2*(1-t)*t * cx + t^2 * x2\n  y <- (1-t)^2 * y1 + 2*(1-t)*t * cy + t^2 * y2\n  points <- data.frame(x = x, y = y)\n  \n  # calculate distances from endpoints\n  start_distances <- sqrt((x - x1)^2 + (y - y1)^2)\n  end_distances <- sqrt((x - x2)^2 + (y - y2)^2)\n  \n  # filter points based on offset\n  valid_points <- points[start_distances >= start_offset & \n                        end_distances >= end_offset, ]\n  \n  # safety check: in case we filtered out too many points, \n  # return a minimal valid set\n  # rule: if filtering left us with fewer than 3 points \n  # (which would create a poor curve), then: \n    # (1) take just 3 points along the curve (at 15%, 50%, and 85% of the way)\n    # (2) calculate their positions using the same Bezier formula\n    # (3) use these as our points instead\n  if(nrow(valid_points) < 3) {\n    t_subset <- c(0.15, 0.5, 0.85)\n    x_subset <- (1-t_subset)^2 * x1 + \n      2*(1-t_subset)*t_subset * cx + t_subset^2 * x2\n    y_subset <- (1-t_subset)^2 * y1 + \n      2*(1-t_subset)*t_subset * cy + t_subset^2 * y2\n    valid_points <- data.frame(x = x_subset, y = y_subset)\n  }\n  \n  return(valid_points)\n}\n\n\nWe add some offset to the start and end. Removing points that are too close to\nthe start or end points will avoid overlap of the trade flows with the country\nlabels. For some specific cases, we will later use custom offsets.\nCreating initial trade flows\nNow that we have our custom function to calculate Bezier curves, we need to\ndetermine where we want to place the control point for each trade flow.\nThis control point will define how each curve bends. The process is as follows:\nFind the midpoint between the origin and destination of each trade flow\nCalculate how far to offset this midpoint perpendicular to the direction\nConvert the flows into a format with three points: start, control, and end\nFor the offset calculation, we make it proportional to the distance between\ncountries: longer trade flows get larger offsets, creating more pronounced\ncurves. These decisions are based on a careful observation of the original\nvisualisation.\n\n\n# calculate control points for Bezier curves\ntrade_flows_with_bezier <- data_2_filtered_with_coords |> \n  rowwise() |> \n  mutate(\n    # calculate midpoint for control point\n    xm = (Export_Long + Import_Long)/2,\n    ym = (Export_Lat + Import_Lat)/2,\n    \n    # calculate offset for control point\n    dx = Import_Long - Export_Long,\n    dy = Import_Lat - Export_Lat,\n    dist = sqrt(dx^2 + dy^2),\n    offset = 0.25 * dist,  # the result of a lot of testing\n    \n    # calculate control point with offset\n    control_x = xm - offset * (Import_Lat - Export_Lat)/dist,\n    control_y = ym + offset * (Import_Long - Export_Long)/dist) |>  \n  ungroup() |> \n  # create three rows per flow (start, control, end points)\n  group_by(Exporter, Importer) |> \n  summarise(\n    x = c(Export_Long, control_x, Import_Long),\n    y = c(Export_Lat, control_y, Import_Lat),\n    point = 1:3,\n    Total_Value = first(Total_Value))\n\n\nCustom offsets\nThe case of China needs special care as it is the most cluttered label.\nSpecifically, we need to use custom offsets for all the trade flows to China\nthat come from the West or North. If we did not use these, the ends of the trade\nflows would overlap too much with the label “China”.\n\n\n# first identify links to China that need special handling\nchina_exporters_not_South <- data_2_filtered_with_coords |> \n  filter(Importer == \"China\", !Exporter %in% \n           c(\"Malaysia\", \"Thailand\", \"Australia\", \"Hong Kong\", \"Indonesia\")) |> \n  pull(Exporter)\n\n# set custom offsets for specific trade routes\ncustom_offsets <- data.frame(\n  Exporter = c(\"Canada\", \"Russia\", china_exporters_not_South),\n  Importer = c(\"USA\", \"India\", rep(\"China\", times = \n                                     length(china_exporters_not_South))),\n  start_offset = c(2.5, 2, rep(2.25, \n                               times = length(china_exporters_not_South))),\n  end_offset = c(1.75, 2.5, rep(6.25, \n                                times = length(china_exporters_not_South))))\n\n\nFinal trade flows\nNow we can combine all the previous steps to create our final trade flows.\nFor each trade flow, we:\nApply the appropriate offsets (either custom or default) from our previous\ncalculations\nGenerate the curve points using our custom Bezier function\nScale the thickness of the flows based on trade volume\nCreate data for both the full flows and their embedded arrows\nPoint 3. is tricky. It is important to recognise that the thickness or sizes of\nthe trade flows has two parts: the size along each flow and the absolute size of\neach flow compared to others.\nFirst, we use a position-based factor (positions^1.1) to account for the varying\nsize or thickness along each flow. This creates the subtle tapering effect as in\nthe original plot.\nSecond, we use the absolute trade value raised to the power of 0.6 for the size\nof the entire flow.\nRegarding point 4: we create two sets of coordinates for each flow; one for the\nfull flow path (x_full, y_full) and one for the arrow path\n(x_arrow, y_arrow). Again, we would like the arrows to be slightly shorter.\nFinally, we use the position variable to create color gradients along each flow.\n\n\n# calculate bezier points with custom offsets\ntrade_flows_with_points <- trade_flows_with_bezier |> \n  left_join(custom_offsets, by = c(\"Exporter\", \"Importer\")) |> \n  group_by(Exporter, Importer) |> \n  do({\n    # use the custom offsets (2.25 and 2.5) if they exist\n    start_off <- ifelse(!is.na(first(.$start_offset)), \n                        first(.$start_offset), 2.25)\n    end_off <- ifelse(!is.na(first(.$end_offset)), \n                      first(.$end_offset), 2.5)\n    \n    points <- calculate_bezier_points(\n      .$x[1], .$y[1],\n      .$x[2], .$y[2],\n      .$x[3], .$y[3],\n      n = 100,\n      start_offset = start_off,\n      end_offset = end_off\n    )\n    \n    n_points <- nrow(points)\n    positions <- seq(0, 1, length.out = n_points)\n    \n    # calculate size scaling\n    value_scale <- (first(.$Total_Value)/1e6)^0.6\n    thickness <- positions^1.1\n    size_scaling <- thickness * value_scale * 0.08 ##\n    size_scaling <- pmax(0.01, size_scaling)\n    \n    data.frame(\n      x_full = points$x,\n      y_full = points$y,\n      x_arrow = c(head(points$x, -1), NA),\n      y_arrow = c(head(points$y, -1), NA),\n      point = 1:n_points,\n      position = 1 - positions^1.3,\n      size_scale = size_scaling,\n      Total_Value = first(.$Total_Value)\n    )\n  }) |> \n  \n  ungroup()\n\n\nAdjusting flow sizes\nThe size scaling formula works well for most trade flows. But the biggest flows\nneed special care.\n\n\n# define manual size adjustments for major trade routes\nmanual_adjustments <- data.frame(\n  Exporter = c(\"Canada\", \"UAE\", \"Australia\", \"Russia\", \"Areas, nes\", \n               \"Brazil\", \"USA\", \"Norway\", \"USA\"),\n  Importer = c(\"USA\", \"Areas, nes\", \"China\", \"China\", \"Germany\", \n               \"China\", \"Mexico\", \"Germany\", \"China\"),\n  manual_size = c(12, 8, 5.5, 3.75, 2.25, 3.5, 2.85, 2.5, 2.5) / 1.75) \n\n# apply manual sizes\ntrade_flows_with_points <- trade_flows_with_points |> \n  mutate(manual_size = NA_real_) |> \n  rows_update(manual_adjustments, by = c(\"Exporter\", \"Importer\")) |> \n  group_by(Exporter, Importer) |> \n  mutate(\n    size_scale = if_else(!is.na(manual_size),\n                         manual_size * (size_scale / max(size_scale)),\n                         size_scale)) |> \n  ungroup()\n\n\nGet the colors\nThe original plot uses a continuous color scale to color the trade flows as they\nprogress from the exporting country (pinkish) to the importing country (blueish).\nWe use eight different colors to approximate the continuous scale as well as\npossible, again using imagecolorpicker.\n\n\nflow_colors <- colorRampPalette(c(\n  \"#01a9e9\", \"#3894D3\", \"#6188CB\", \"#8581ca\",\n  \"#AA70BC\", \"#C662B0\", \"#e43998\", \"#D84CA5\"))\n\n\nPutting it all together\n\n\n# add the trade flows to our map\np <- p +\n  # full bezier curves with gradient\n  geom_path(data = trade_flows_with_points,\n            aes(x = x_full, y = y_full, \n                group = interaction(Exporter, Importer),\n                size = size_scale,\n                color = position)) +\n  # add custom color scale\n  scale_color_gradientn(\n    colours = flow_colors(500),\n    guide = \"none\") +\n  scale_size_identity() + \n  # add arrows\n  geom_path(data = trade_flows_with_points,\n            aes(x = x_arrow, y = y_arrow, \n                group = interaction(Exporter, Importer)),\n            size = 0.12, \n            arrow = arrow(length = unit(0.10, \"cm\"), \n                         type = \"closed\",\n                         ends = \"last\"),\n            color = \"black\",\n            alpha = .7)\n\n# now we need to add the labels and boxes for the nes areas again because we \n# want the labels and boxes to be on top of the flows\np <- p + \n  geom_text(data = country_labels_adj,\n            aes(x = long - 0.1, y = lat, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            # we need to adjust the lineheight argument for \"Korea, \\nRep.\" and \n            # \"Saudi \\n Arabia\" to make sure that the vertical spacing is fine\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long + 0.1, y = lat, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat - 0.1, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat + 0.1, label = Label),\n            size = 1.75,  \n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  \n  # add country labels (white)\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat, label = Label),\n            size = 1.77,  # slightly larger than the black text\n            color = \"white\",\n            fontface = \"bold\",\n            lineheight = .9) +\n  \n  # add country labels (black)\n  geom_text(data = country_labels_adj,\n            aes(x = long, y = lat, label = Label),\n            size = 1.65,  \n            color = \"black\",\n            fontface = \"bold\",\n            lineheight = .9) + \n  \n  # add rectangles for nes areas\n  geom_rect(data = data.frame(\n    xmin = c(special_areas_coords[1,2] - 11.75, \n             special_areas_coords[2,2] - 22.5),\n    xmax = c(special_areas_coords[1,2]  + 11.75, \n             special_areas_coords[2,2] + 22.5),\n    ymin = c(special_areas_coords[1,3] - 2.6, \n             special_areas_coords[2,3] - 2.6),\n    ymax = c(special_areas_coords[1,3] + 2.6, \n             special_areas_coords[2,3] + 2.6),\n    label = c(\"Areas, nes\", \"Rest of America, nes\")),\n    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#ffffff\",\n    alpha = .9,\n    color = \"#cccccc\", \n    size = 0.3) +\n  \n  # add text labels for nes areas\n  geom_text(data = data.frame(\n    x = c(special_areas_coords[1,2], special_areas_coords[2,2]),\n    y = c(special_areas_coords[1,3], special_areas_coords[2,3]),\n    label = c(\"Areas, nes\", \"Rest of America, nes\")),\n    aes(x = x, y = y, label = label),\n    size = 1.65, \n    fontface = \"bold\") + \n  \n  theme(text = element_text(family = \"gudea\"))\n\nprint(p)\n\n\n\nAlternative visualisation\nThe original plot is visually appealing. It also effectively communicates the\nkey patterns in global commodities trade. First, China imports massive amounts\nof commodities, reflecting its status as the world’s manufacturing powerhouse.\nSecond, the US trades commodities mainly with Canada and Mexico, leading to\nrelatively regional supply chains in North America. Third, intra-european trade\nis strong. Fourth, the Middle East is a major player in commodities trade.\nHowever, the original plot still faces some issues.\nFirst, the plot becomes cluttered in high-density trading regions, particularly\naround China and Europe. In these regions, trade flows overlap and arrows become\ndifficult to distinguish, potentially obscuring important patterns.\nSecond, the plot uses four visual channels (flows, arrows, colours and line\nthickness) to represent the direction of trade flows. This is considered bad\npractice as one data attribute should be mapped to one visual channel only.\nThird, the plot focuses only on the 76 largest trade flows. If we wanted to add\nmore flows, the readability of the plot would worsen further. In other words,\nthe plot has limited scalability.\nWhile the original plot offers interactivity features (e.g., highlighting\nspecific country’s trade flows when clicking on it) to address these issues\n(especially the problem of clutter), we can explore network graphs as an\nalternative approach. Networks offer the following advantages for visualising\nthis bilateral trade data. First, by freeing nodes from geographic constraints,\nwe can emphasize economic relationships and reveal true trading hubs, thereby\ngaining deeper knowledge about the structural relationships in global trade.\nSecond, network graphs are more scalable. Force-directed layouts handle dense\nconnections much better by finding optimal node positions that minimise edge\ncrossings. In this way, we could relatively easily show hundreds of trade flows.\nThird, network graphs can have higher information density. As we will see, we can\ncolor the edges to encode additional information, e.g., continental clusters or\ngroupings.\nWe will explore two different network visualization approaches using\nforce-directed layouts: Fruchterman-Reingold and Kamada-Kawai algorithms.\n1. Preliminaries\n\n\n# we go for the igraph package, even though there are plenty of other good\n# choices as well, e.g., ggnetwork or tidygraph\nlibrary(igraph)\n\n# create continent mapping: for the legend and the coloring of the nodes/ edges\ncontinent_mapping <- list(\n  Europe = c(\"AUT\", \"BEL\", \"CHE\", \"DEU\", \"ESP\", \"FRA\", \"GBR\", \"ITA\", \"NLD\", \"NOR\"),\n  Asia = c(\"ARE\", \"AZE\", \"CHN\", \"HKG\", \"IDN\", \"IND\", \"IRQ\", \"JPN\", \"KOR\", \"KWT\", \n           \"MYS\", \"OMN\", \"QAT\", \"RUS\", \"SAU\", \"THA\", \"TUR\"),\n  Africa = c(\"AGO\", \"DZA\", \"ZAF\"),\n  \"North America\" = c(\"CAN\", \"MEX\", \"USA\"),\n  \"South America\" = c(\"BRA\", \"CHL\", \"PER\"),\n  Australia = c(\"AUS\"),\n  Other = c(\"Nes\", \"NesA\"))\n\n# create color mapping for continents using IBM color-blind palette\ncontinent_colors <- c(\n  Europe = \"#648FFF\",        # vivid blue\n  Asia = \"#785EF0\",         # purple\n  Africa = \"#DC267F\",       # magenta\n  \"North America\" = \"#FE6100\", # orange\n  \"South America\" = \"#FFB000\", # gold\n  Australia = \"#24A608\",    # green\n  Other = \"#B4B4B4\")         # gray\n\n\n2. Network graphs\nFruchterman-Reingold\nThe Fruchterman-Reingold algorithm\nsimulates a physical system where the nodes push each other away, while the\nedges pull or attract connected nodes like springs. This algorithm helps us to\nidentify clusters or trading hubs.\n\n\n# prepare the data\ndata_2_filtered_clean <- data_2_filtered |> \n  mutate(\n    Exporter_ISO3 = case_when(\n      is.na(Exporter_ISO3) & Exporter == \"Areas, nes\" ~ \"Nes\",\n      is.na(Exporter_ISO3) & Exporter == \"Rest of America, nes\" ~ \"NesA\",\n      TRUE ~ Exporter_ISO3\n    ),\n    Importer_ISO3 = case_when(\n      is.na(Importer_ISO3) & Importer == \"Areas, nes\" ~ \"Nes\",\n      is.na(Importer_ISO3) & Importer == \"Rest of America, nes\" ~ \"NesA\",\n      TRUE ~ Importer_ISO3\n    )\n  )\n\n# create edge list with weights\nedges <- data_2_filtered_clean |> \n  select(Exporter_ISO3, Importer_ISO3, Total_Value) |> \n  rename(from = Exporter_ISO3, to = Importer_ISO3, weight = Total_Value)\n\n# create unique node list and graph\nnodes <- unique(c(edges$from, edges$to))\ng <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE)\n\n# calculate node strength and assign properties\nnode_strength <- strength(g, mode = \"total\", weights = E(g)$weight)\nV(g)$continent <- sapply(V(g)$name, function(x) {\n  for(cont in names(continent_mapping)) {\n    if(x %in% continent_mapping[[cont]]) return(cont)\n  }\n  return(\"Other\")\n})\nV(g)$color <- continent_colors[V(g)$continent]\n\n# assign edge colors based on source continent with alpha\nE(g)$color <- sapply(E(g), function(e) {\n  source_node <- V(g)[ends(g, e)[1]]\n  rgb(t(col2rgb(continent_colors[source_node$continent])/255), alpha = 0.4)\n})\n\n# set node sizes and edge widths\nV(g)$size <- 10 + 20 * (node_strength / max(node_strength))\nE(g)$width <- 0.5 + 24 * (E(g)$weight / max(E(g)$weight))^0.8\n\n# create basic layout\nset.seed(42)\nlayout_fr <- layout_with_fr(g, niter = 2500, weights = E(g)$weight^0.5)\n\n# normalize the layout\nlayout_normalized <- apply(layout_fr, 2, function(x) {\n  (x - min(x)) / (max(x) - min(x)) * 2 - 1\n})\nlayout_final <- layout_normalized * 5\n\n# plot\npar(bg = \"white\", mar = c(0.1, 0.1, 2, 12))\n\nplot(g, \n     layout = layout_final,\n     vertex.label = V(g)$name,\n     vertex.label.color = \"black\",\n     vertex.label.cex = 1.3,\n     vertex.label.font = 2,\n     vertex.frame.color = \"white\",\n     edge.arrow.size = 0.15,\n     edge.curved = 0.15,\n     asp = 1)\n\ntitle(\"Alternative visualisation - Fruchterman-Reingold\", line = 0, cex.main = 2.25)\nlegend(x = \"bottom\", \n       title = \"\",\n       legend = names(continent_colors),\n       fill = continent_colors,\n       cex = 1.2,\n       bty = \"n\",\n       xpd = TRUE,\n       horiz = TRUE)\n\n\n\nWe can see that there is quite a few nodes overlapping, especially around the\nkey trading hubs China and the US. This complicates readability. We can apply\njitter and use manual adjustments to re-position the nodes. We make sure that we\nare strict and systematic in shifting the nodes: they are shifted as little as\npossible and the shifts are either diagonal or to the left, right, bottom or top.\n\n\n# add jitter to layout\njitter_amount <- 0.05\nlayout_with_jitter <- layout_fr + matrix(runif(nrow(layout_fr) * 2, \n                                              -jitter_amount, jitter_amount), \n                                        ncol = 2)\n\n# normalize with jitter\nlayout_normalized <- apply(layout_with_jitter, 2, function(x) {\n  (x - min(x)) / (max(x) - min(x)) * 2 - 1\n})\n\nlayout_final <- layout_normalized * 5\n\n# manual Node adjustment: define adjustment rules for major trade hubs\nnode_adjustment_rules <- list(\n  # European cluster\n  europe_cluster = list(\n    nodes = c(\"ITA\", \"GBR\"),\n    adjustments = data.frame(\n      node = c(\"ITA\", \"GBR\"),\n      x_shift = c(0.2, 0.2),    # spread horizontally\n      y_shift = c(0, 0.2))),    # spread vertically\n  \n  # Asian cluster around China\n  asia_cluster = list(\n    nodes = c(\"HKG\", \"IRQ\", \"MYS\"),\n    adjustments = data.frame(\n      node = c(\"HKG\", \"IRQ\", \"MYS\"),\n      x_shift = c(0, -0.2, 0.2), # spread horizontally\n      y_shift = c(0.3, -0.2, 0))), # spread vertically\n  \n  # North America cluster\n  na_cluster = list(\n    nodes = c(\"CAN\", \"USA\", \"KOR\", \"RUS\", \"ARE\"),\n    adjustments = data.frame(\n      node = c(\"CAN\", \"USA\", \"KOR\", \"RUS\", \"ARE\"),\n      x_shift = c(-0.25, 0, 0.2, 0.3, 0.4), # spread horizontally\n      y_shift = c(0.25, -0.4, 0.2, -0.3, 0.4))), # spread vertically\n  \n  # other cluster\n  other_cluster = list(\n    nodes = c(\"MEX\"),\n    adjustments = data.frame(\n      node = c(\"MEX\"),\n      x_shift = c(-0.35), # spread horizontally\n      y_shift = c(-0.35)))) # spread vertically\n\n# custom function to apply adjustments\napply_node_adjustments <- function(layout, node_indices, adjustment_rules) {\n  adjusted_layout <- layout\n  \n  # record all adjustments for documentation\n  adjustment_log <- data.frame(\n    node = character(),\n    original_x = numeric(),\n    original_y = numeric(),\n    adjustment_x = numeric(),\n    adjustment_y = numeric(),\n    rule_applied = character(),\n    stringsAsFactors = FALSE)\n  \n  # apply each rule set\n  for(cluster_name in names(adjustment_rules)) {\n    rule_set <- adjustment_rules[[cluster_name]]\n    \n    for(i in 1:nrow(rule_set$adjustments)) {\n      node <- rule_set$adjustments$node[i]\n      if(node %in% names(node_indices)) {\n        idx <- node_indices[node]\n        \n        # record original position\n        orig_pos <- adjusted_layout[idx, ]\n        \n        # apply adjustment\n        adjusted_layout[idx, ] <- adjusted_layout[idx, ] + \n          c(rule_set$adjustments$x_shift[i], \n            rule_set$adjustments$y_shift[i])\n        \n        # log the adjustment\n        adjustment_log <- rbind(adjustment_log, data.frame(\n          node = node,\n          original_x = orig_pos[1],\n          original_y = orig_pos[2],\n          adjustment_x = rule_set$adjustments$x_shift[i],\n          adjustment_y = rule_set$adjustments$y_shift[i],\n          rule_applied = cluster_name\n        ))\n      }\n    }\n  }\n  \n  # return both adjusted layout and log\n  return(list(\n    layout = adjusted_layout,\n    log = adjustment_log\n  ))\n}\n\n# apply adjustments and get log\nnode_indices <- setNames(1:length(V(g)), V(g)$name)\nadjustment_result <- apply_node_adjustments(layout_final, node_indices, node_adjustment_rules)\nlayout_final <- adjustment_result$layout\n\n\n# create final plot with adjustments\npar(bg = \"white\", mar = c(0.1, 0.1, 2, 12))\nplot(g, \n     layout = layout_final,\n     vertex.label = V(g)$name,\n     vertex.label.color = \"black\",\n     vertex.label.cex = 1.3,\n     vertex.label.font = 2,\n     vertex.frame.color = \"white\",\n     edge.arrow.size = 0.15,\n     edge.curved = 0.15,\n     asp = 1)\n\ntitle(\"Alternative visualisation - Fruchterman-Reingold (improved)\", line = 0, cex.main = 2.25)\nlegend(x = \"bottom\", \n       title = \"\",\n       legend = names(continent_colors),\n       fill = continent_colors,\n       cex = 1.2,\n       bty = \"n\",\n       xpd = TRUE,\n       horiz = TRUE)\n\n\n\nThis network graph is more readable now. We can see the two key trading hubs\nChina and the US. The network also confirms strong intra-european trade.\nMoreover, this network also indicates the strong economic ties African and South\nAmerican countries have with China.\nKamada-Kawai\nAlternatively, we can use the Kamada-Kawai algorithm.\nThis algorithm attempts to match the visual distances between nodes to their\nactual network distances (how many “hops” it takes to get from one node to\nanother). It also uses a spring system where nodes that are too close or too far\nfrom each other compared to their network distance push apart or pull together.\n\n\n# start with the new layout\nlayout_kk <- layout_with_kk(g)\n\n# assign edge colors based on source (exporter) continent\nE(g)$color <- sapply(E(g), function(e) {\n  source_node <- V(g)[ends(g, e)[1]]\n  continent_colors[source_node$continent]\n})\n\n# add alpha to edge colors for better visibility\nE(g)$color <- sapply(E(g)$color, function(x) {\n  rgb(t(col2rgb(x)/255), alpha = 0.4)\n})\n\n# adjust node sizes to make them smaller if necessary\nV(g)$size <- 10 + 12 * (node_strength / max(node_strength)) \n\n# set up the plot\npar(bg = \"white\", mar = c(0.1, 0.1, 2, 8))\n\nplot(g, \n     layout = layout_kk,\n     vertex.label = V(g)$name,\n     vertex.label.color = \"black\",\n     vertex.label.cex = 1.3,\n     vertex.label.font = 2,  # Added bold font\n     vertex.frame.color = \"white\",\n     edge.arrow.size = 0.15,\n     edge.curved = 0.15,\n     asp = 1)  # Removed edge.color as it's now set explicitly\n\n# add title\ntitle(\"Alternative visualisation - Kamada-Kawai\", \n      line = 0, cex.main = 2.25)\n\n# add the same legend, again at the bottom\nlegend(x = \"bottom\",  \n       title = \"\",\n       legend = names(continent_colors),\n       fill = continent_colors,\n       cex = 1.2,  \n       bty = \"n\",\n       xpd = TRUE,\n       horiz = TRUE)  \n\n\n\nThis algorithm makes it even easier to identify the core-periphery structure\nthat is defining global trade in commodities, with major economies like China\nand the US forming the core and smaller economies like Austria, Thailand or\nAzerbaijan being part of the periphery.\nOverall, these networks are better than maps in handling bilateral trade data.\nThis is primarily because networks have (1) better scalability and (2) higher\ninformation density.\n\n\n\n",
    "preview": "projects/2024/100540594/100540594_files/figure-html5/unnamed-chunk-26-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100541134/",
    "title": "Life expectancy: females versus males",
    "description": "This chart compares the life expectancy of women and men at birth.",
    "author": [
      {
        "name": "Ekin Kizildas",
        "url": {}
      }
    ],
    "date": "2025-01-10",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\nData Cleaning Processes\nBuilding the Graph\n\nDeveloping the Graph\nData Cleaning Processes\nBuilding the Graph\n\n\nIntroduction\nThis chart compares the life expectancy of women and men at birth. The horizontal axis represents men’s life expectancy, while the vertical axis represents women’s life expectancy. All countries lie above the diagonal line, indicating that women live longer than men in every country. The countries are color-coded by continent, and the changes from 1950 to 2023 are shown. In 1950, life expectancy was lower worldwide, but by 2023, significant increases are observed in many countries. In countries like Japan and Germany, life expectancy is notably high, whereas it is much lower in countries like Chad and Nigeria.\nOriginal plotReplication\nFirst, I loaded the life_exp.csv file, which contains life expectancy data, into my project. I included the necessary libraries (tidyverse, etc.) for analysis and visualization. Then, I transformed the data into a data frame (data.df) by selecting the first 17,538 rows and the first 9 columns. This way, I made the data more manageable for analysis and visualization purposes.[Dattani and Rodés-Guirao (2023)](Dattani and Rodés-Guirao 2023)\n\n\nlibrary(tidyverse)\nlibrary(cowplot)\nlibrary(grid)\nlibrary(gridExtra)\n\nlife_exp <- read.csv(file=\"life_exp.csv\")\ndata.df <-data.frame(life_exp[1:17538,1:9])\n\n\nData Cleaning Processes\n\n\nnew_data <- data.df %>%\n  rename(\n    Country = Entity,\n    Year = Year,\n    LifeExp_Female = `Life.expectancy...Sex..female...Age..0...Variant..estimates`,\n    LifeExp_Male = `Life.expectancy...Sex..male...Age..0...Variant..estimates`\n  ) %>%\n  select(Country, Year, LifeExp_Female, LifeExp_Male, Continent) %>%  \n  filter(!is.na(LifeExp_Female) & !is.na(LifeExp_Male))\n\nfiltered_data <- new_data |> \n  filter(Year == 1950 | Year == 2023)\n\narrows_data <- filtered_data %>%\n  filter(Year %in% c(1950, 2023)) %>%\n  group_by(Country, Continent) %>%\n  summarize(\n    Start_LifeExp_Male = LifeExp_Male[Year == 1950],\n    Start_LifeExp_Female = LifeExp_Female[Year == 1950],\n    End_LifeExp_Male = LifeExp_Male[Year == 2023],\n    End_LifeExp_Female = LifeExp_Female[Year == 2023],\n    .groups = \"drop\"\n  )\n\n\n\nkey_countries <- c(\"Nigeria\", \"Japan\", \"India\", \"Germany\", \"Brazil\", \"Chile\",\n                   \"Chad\",\"Pakistan\",\"Nepal\",\"Afghanistan\",\"Kenya\",\n                   \"Sao Tome and Principe\",\"Democratic Republic of Congo\",\n                   \"Central African Republic\",\"Niger\",\"CÃ´te dâ€™Ivoire\",\n                   \"Bangladesh\",\"Dominican Republic\",\"Bosnia and Herzegovina\",\n                   \"Russia\",\"China\", \"North Korea\",\"South Korea\")\n\n\n\narrows_data <- arrows_data %>%\n  mutate(\n    Label = ifelse(Country %in% key_countries, Country, NA),\n    Label_X = (Start_LifeExp_Male + End_LifeExp_Male) / 2,   \n    Label_Y = (Start_LifeExp_Female + End_LifeExp_Female) / 2 \n  )\n\n\nData Rearrangement and Filtering:\nI created a new data frame (new_data) by renaming columns in data.df and selecting only the necessary ones.\nThese columns include: Country, Year , Female life expectancy, Male life expectancy, and Continent .\nRows with missing values in the female and male life expectancy columns were filtered out.\n\nFiltering for 1950 and 2023:\nI filtered the data to include only the years 1950 and 2023, creating a new data frame called filtered_data.\n\nCalculating Start and End Life Expectancy:\nIn the arrows_data data frame, I summarized the male and female life expectancy for each country in 1950 (start) and 2023 (end).\nThis was done by grouping the data by country and continent.\n\nIdentifying Key Countries:\nI created a list of key countries (key_countries) to highlight specific countries that are significant for the visualization.\n\nPositioning Labels:\nI added a Label column to the arrows_data data frame to label the key countries.\nTo position these labels in the visualization, I calculated the midpoint of the start and end values for male and female life expectancy, storing them in the Label_X and Label_Y columns.\n\nBuilding the Graph\n\n\nbase_plot <- ggplot(arrows_data, \n                    aes(x = Start_LifeExp_Male, y = Start_LifeExp_Female, \n                        color = Continent, group = Country))+ \n  geom_segment(\n    aes(xend = End_LifeExp_Male, yend = End_LifeExp_Female),\n    arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n    linewidth = 0.8, alpha = 0.7,\n    show.legend = FALSE\n  )\n\nprint(base_plot)\n\n\n\nI used this code to visualize the changes in life expectancy between males and females in different countries. Using the ggplot() function, I created the base plot, placing the starting life expectancy for males on the x-axis and for females on the y-axis. For each country, I draw arrows that connect the starting values to the ending values, representing the change in life expectancy. I use different colors to distinguish continents and group the data by country.\nWith the geom_segment() function, I design the arrows: they have closed tips, a length of 0.2 cm, a line thickness of 0.8, and 70% transparency. I also ensured that the arrows do not appear in the legend by setting show.legend = FALSE. Finally, I used print(base_plot) to render the plot.\n\n\nbase_plot <- ggplot(arrows_data,\n                    aes(x = Start_LifeExp_Male, y = Start_LifeExp_Female, \n                        color = Continent, group = Country)) +\n  geom_segment(\n    aes(xend = End_LifeExp_Male, yend = End_LifeExp_Female),\n    arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n    size = 0.8, alpha = 0.7,\n    show.legend = FALSE\n  ) +\n   geom_point(data = subset(arrows_data, Continent %in% c(\n     \"Africa\", \"Asia\", \"Europe\", \"North America\", \"Oceania\", \"South America\")), \n              size = 2, alpha = 0.8, show.legend = TRUE)\n\nbase_plot\n\n\n\nAdditionally, I added points for countries in Africa, Asia, Europe, North America, Oceania, and South America, representing their starting values. These points are sized at 2 units, have 80% transparency, and are included in the plot’s legend.\n\n\nbase_plot <- ggplot(arrows_data, \n                    aes(x = Start_LifeExp_Male, y = Start_LifeExp_Female, \n                        color = Continent, group = Country)) +\n  geom_segment(\n    aes(xend = End_LifeExp_Male, yend = End_LifeExp_Female),\n    arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n    size = 0.8, alpha = 0.7,\n    show.legend = FALSE\n  ) +\n   geom_point(data = subset(arrows_data, Continent %in% c(\n     \"Africa\", \"Asia\", \"Europe\", \"North America\", \"Oceania\", \"South America\")), \n              size = 2, alpha = 0.8, show.legend = TRUE) +\n  geom_text(data = subset(arrows_data, Country %in% Label), \n            aes(label = \"1950\"),\n    size = 3,\n    vjust = -0.2,\n    hjust = 0.5,\n    show.legend = FALSE\n  ) +  geom_text(\n    data = subset(arrows_data,  !is.na(Label)),\n    aes(x =Label_X , y = Label_Y, label = Label),\n    size = 5,\n    color = \"white\",  \n    hjust = 0.5, vjust = -0.5, show.legend = F\n  )+ geom_text(\n    data = subset(arrows_data, !is.na(Label)),\n    aes(x = Label_X, y = Label_Y, label = Label),\n    size = 4, show.legend = F,\n    hjust = 0.5, vjust = -0.5\n  )  +\n  scale_color_manual(\n    values = c(\n      \"Africa\" = \"#a2559c\", \n      \"Asia\" = \"#00847e\", \n      \"Europe\" = \"#4c6a9c\",\n      \"North America\" = \"#e56e5a\",\n      \"Oceania\" = \"#9a5129\",\n      \"South America\" = \"#883039\"\n    )\n  )\n\nprint(base_plot)\n\n\n\nFor the labels, I added the “1950” label for countries that are included in the Label list using geom_text(). The label is placed near the starting value with a size of 3 and is vertically adjusted slightly above the point (vjust = -0.2), and horizontally centered (hjust = 0.5). The legend for these labels was not shown (show.legend = FALSE).\nFor countries with Label values, I add additional labels using two geom_text() calls:\nThe first label was white with a size of 5, positioned based on Label_X and Label_Y, with the text vertically aligned slightly above the point (vjust = -0.5), and horizontally centered (hjust = 0.5).\nThe second label was smaller, with a size of 4, and is also aligned above the point with the same horizontal alignment.\nI also used scale_color_manual() to assign specific colors to each continent:\nAfrica: #a2559c\nAsia: #00847e\nEurope: #4c6a9c\nNorth America: #e56e5a\nOceania: #9a5129\nSouth America: #883039\nFinally, I used print(base_plot) to display the plot with all the elements added.\n\n\nbase_plot <- ggplot(arrows_data, \n                    aes(x = Start_LifeExp_Male, y = Start_LifeExp_Female, \n                        color = Continent, group = Country)) +\n  geom_segment(\n    aes(xend = End_LifeExp_Male, yend = End_LifeExp_Female),\n    arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n    size = 0.8, alpha = 0.7,\n    show.legend = FALSE\n  ) +\n   geom_point(data = subset(arrows_data, Continent %in% c(\n     \"Africa\", \"Asia\", \"Europe\", \"North America\", \"Oceania\", \"South America\")), \n              size = 2, alpha = 0.8, show.legend = TRUE) +\n  geom_text(data = subset(arrows_data, Country %in% Label), \n            aes(label = \"1950\"),\n    size = 3,\n    vjust = -0.2,\n    hjust = 0.5,\n    show.legend = FALSE\n  ) +  geom_text(\n    data = subset(arrows_data,  !is.na(Label)),\n    aes(x =Label_X , y = Label_Y, label = Label),\n    size = 5,\n    color = \"white\",  \n    hjust = 0.5, vjust = -0.5, show.legend = F\n  ) +\n  geom_text(\n    data = subset(arrows_data, !is.na(Label)),\n    aes(x = Label_X, y = Label_Y, label = Label),\n    size = 4, show.legend = F,\n    hjust = 0.5, vjust = -0.5\n  )  +\n  scale_color_manual(\n    values = c(\n      \"Africa\" = \"#a2559c\", \n      \"Asia\" = \"#00847e\", \n      \"Europe\" = \"#4c6a9c\",\n      \"North America\" = \"#e56e5a\",\n      \"Oceania\" = \"#9a5129\",\n      \"South America\" = \"#883039\"\n    )\n  ) + \n    scale_x_continuous(\n    name = \"Life expectancy of men\",\n    breaks = seq(20, 80, 10),\n    labels = paste0(seq(20, 80, 10), \" years\")\n  )+ \n  scale_y_continuous(\n    name = \"Life expectancy of women\",\n    breaks = seq(20, 80, 10),\n    labels = paste0(seq(20, 80, 10), \" years\")\n  )+\n  labs(\n    title = \"Life expectancy: females versus males, 1950 to 2023\",\n    subtitle = \"The period life expectancy at birth, in a given year.\",\n    caption = \"Data source: UN, World Population Prospects (2024)               OurWorldInData.org/life-expectancy|CC BY\"\n  )+ theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = \"white\", color = NA),\n    panel.grid.major = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 15, face = \"plain\", hjust = 0, color = \"black\"),\n    plot.subtitle = element_text(size = 8, face = \"plain\", hjust = 0, color = \"black\"),\n    plot.title.position = \"plot\",\n    axis.title = element_text(size = 8, color = \"black\"),\n    axis.text = element_text(size = 8, color = \"black\"),\n    plot.caption = element_text(size = 8, hjust = 0, color = \"grey30\"),\n    legend.title = element_blank(),\n    legend.text = element_text(family = \"sans\",size = 10),\n    legend.position = \"right\",\n    plot.margin = margin(t=20, r=20, b=40, l=20)\n  ) +\n  guides(\n    color = guide_legend( \n        override.aes = list(shape = 15, size = 3)\n    )\n  )\n\n\nprint(base_plot)\n\n\n\nI used this code to customize the axis labels, titles, subtitles, gridlines, theme settings, and color guides for the plot. First, with the scale_x_continuous() function, I added the label “Life expectancy of men” to the x-axis and divide the range from 20 to 80 into intervals of 10 years. Similarly, with the scale_y_continuous() function, I added the label “Life expectancy of women” to the y-axis and define the labels with similar intervals. Then, using the labs() function, I added the title, subtitle, and data source. The title is “Life expectancy: females versus males, 1950 to 2023”, and the subtitle is “The period life expectancy at birth, in a given year.” The data source is stated as “Data source: UN, World Population Prospects (2024) OurWorldInData.org/life-expectancy|CC BY”. I applied the theme_minimal() function to give the plot a clean look and customize theme elements. I setted the background of the plot area to white, adjust the major gridlines to a grey color, and remove the minor gridlines. I removed axis ticks, and customize the titles, labels, and caption. The plot title was adjusted in terms of size, font, and position. The axis titles and texts were made black and set to a specific size. The caption was aligned to the left and colored grey. I removed the legend title, customize the font, and position the legend on the right. Finally, using the guides() function, I adjusted the legend symbols to be squares and set their size to 3. After making all these customizations, I displayed the plot with the print(base_plot) function.\n\n\nbase_plot <- ggplot(arrows_data, \n                    aes(x = Start_LifeExp_Male, y = Start_LifeExp_Female, \n                        color = Continent, group = Country)) +\n  geom_segment(\n    aes(xend = End_LifeExp_Male, yend = End_LifeExp_Female),\n    arrow = arrow(type = \"closed\", length = unit(0.2, \"cm\")),\n    size = 0.8, alpha = 0.7,\n    show.legend = FALSE\n  ) +\n   geom_point(data = subset(arrows_data, Continent %in% c(\n     \"Africa\", \"Asia\", \"Europe\", \"North America\", \"Oceania\", \"South America\")), \n              size = 2, alpha = 0.8, show.legend = TRUE) +\n  geom_text(data = subset(arrows_data, Country %in% Label), \n            aes(label = \"1950\"),\n    size = 3,\n    vjust = -0.2,\n    hjust = 0.5,\n    show.legend = FALSE\n  ) +  geom_text(\n    data = subset(arrows_data,  !is.na(Label)),\n    aes(x =Label_X , y = Label_Y, label = Label),\n    size = 5,\n    color = \"white\",  \n    hjust = 0.5, vjust = -0.5, show.legend = F\n  ) +\n  geom_text(\n    data = subset(arrows_data, !is.na(Label)),\n    aes(x = Label_X, y = Label_Y, label = Label),\n    size = 4, show.legend = F,\n    hjust = 0.5, vjust = -0.5\n  )  +\n  scale_color_manual(\n    values = c(\n      \"Africa\" = \"#a2559c\", \n      \"Asia\" = \"#00847e\", \n      \"Europe\" = \"#4c6a9c\",\n      \"North America\" = \"#e56e5a\",\n      \"Oceania\" = \"#9a5129\",\n      \"South America\" = \"#883039\"\n    )\n  ) + \n    scale_x_continuous(\n    name = \"Life expectancy of men\",\n    breaks = seq(20, 80, 10),\n    labels = paste0(seq(20, 80, 10), \" years\")\n  )+ \n  scale_y_continuous(\n    name = \"Life expectancy of women\",\n    breaks = seq(20, 80, 10),\n    labels = paste0(seq(20, 80, 10), \" years\")\n  )+\n  labs(\n    title = \"Life expectancy: females versus males, 1950 to 2023\",\n    subtitle = \"The period life expectancy at birth, in a given year.\",\n    caption = \"Data source: UN, World Population Prospects (2024)               OurWorldInData.org/life-expectancy|CC BY\"\n  ) +\n  theme_minimal() +\n  theme(\n    panel.background = element_rect(fill = \"white\", color = NA),\n    panel.grid.major = element_line(color = \"grey90\"),\n    panel.grid.minor = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 15, face = \"plain\", hjust = 0, color = \"black\"),\n    plot.subtitle = element_text(size = 8, face = \"plain\", hjust = 0, color = \"black\"),\n    plot.title.position = \"plot\",\n    axis.title = element_text(size = 8, color = \"black\"),\n    axis.text = element_text(size = 8, color = \"black\"),\n    plot.caption = element_text(size = 8, hjust = 0, color = \"grey30\"),\n    legend.title = element_blank(),\n    legend.text = element_text(family = \"sans\",size = 10),\n    legend.position = \"right\",\n    plot.margin = margin(t=20, r=20, b=40, l=20)\n  ) +\n  guides(\n    color = guide_legend( \n        override.aes = list(shape = 15, size = 3)\n    )\n  )\n\nline_and_year <- grobTree(\n  linesGrob(x = unit(c(0.2, 0.8), \"npc\"), y = unit(3, \"npc\"), gp = gpar(col = \"black\", lwd = 1.5, alpha =0.5)), # Line\n  textGrob(\"1950 -> 2023\", x = 0.5, y = 2.8, gp = gpar(fontsize = 8, col = \"black\")))\n\nlegend_with_text <- arrangeGrob(\n  grobs = list(\n    get_legend(base_plot +theme(legend.position = \"right\")),\n    line_and_year\n  ),\n  ncol = 1,\n  heights = c(10, 1.5)\n)\n\nlegend_with_text <- arrangeGrob(\n  grobs = list(\n    get_legend(base_plot +theme(legend.position = \"right\")),\n    line_and_year\n  ),\n  ncol = 1,\n  heights = c(10, 1.5)\n)\n\nfinal_plot <- grid.arrange(\n  base_plot + theme(legend.position = \"none\"),\n  legend_with_text,\n  ncol = 2,\n  widths = c(4, 1)\n)\n\n\nline_grob <- linesGrob(\n  x = unit(c(0,1), \"npc\"),  \n  y = unit(0.1, \"npc\"),           \n  gp = gpar(col = \"black\", lwd = 1, alpha= 0.5)  \n)\n\ntitle_caption_grob <- ggdraw(final_plot) +\n  draw_label(\n    \"1. Period life expectancy: Period life expectancy is a metric that summarizes death rates across all age groups in one particular year.\\nFor a given year, it represents the average lifespan for a hypothetical group of people if they experienced the same age-specific death rates throughout their whole lives as in that particular year.\\nLearn more in our articles: 'Life expectancy' â€“ What does this actually mean? and 'Period versus cohort measures: what's the difference?'\",\n    x = 0.01, y = 0.03, hjust = 0, vjust = 0, color = \"grey30\", size = 6, lineheight = 1.1\n  ) +\n  draw_grob(line_grob, x = 0.5, y = 0.10, width = 1, height = 0.01)\n\n\nlogo_grob <- rasterGrob(png::readPNG(\"logo.png\"), interpolate = TRUE)\n\nfinal_with_logo <- ggdraw(title_caption_grob) +\n  draw_grob(logo_grob, x = 0.99, y = 0.99, width = 0.08, height = 0.07, hjust = 1, vjust = 1)\n\nprint(final_with_logo)\n\n\n\nI used this code to combine several graphical elements and create a final plot. First, I drew a horizontal line with the label “1950 -› 2023” positioned above it to represent the time span. Then, I extracted the legend from the base plot and placed it vertically, adding the year information below it. I placed the base plot, without the legend, next to the legend and year, creating a two-column layout. I added a horizontal line at the bottom of the plot, followed by an explanatory caption about period life expectancy. This caption explained how period life expectancy is calculated and referred to additional articles for further reading. Finally, I added a logo to the top-right corner of the final plot, completing the visual. The logo and caption, along with the main plot and legend, were combined into one comprehensive visual output.\nDeveloping the Graph\nData Cleaning Processes\n\n\ngdp_data <-read_delim(\"gdp.csv\", show_col_types = FALSE)\n\ncolnames(gdp_data) <- c(\"Country\", \"Year\", \"Item\", \"GDP_Billion_USD\")\n\nmerged_data <- left_join(new_data, gdp_data, by = c(\"Country\", \"Year\"))\n\nmerged_data <- merged_data |> \n  drop_na()\n\n\narrow_data_Gdp <- merged_data %>%\n  filter(Year %in% c(1970, 2022)) %>%\n  group_by(Country) %>%\n  reframe(\n    GDP_2022 = GDP_Billion_USD[Year == 2022],\n    LifeExp_Female_1970 = LifeExp_Female[Year == 1970],\n    LifeExp_Male_1970 = LifeExp_Male[Year == 1970],\n    LifeExp_Female_2022 = LifeExp_Female[Year == 2022],\n    LifeExp_Male_2022 = LifeExp_Male[Year == 2022],\n    Continent = unique(Continent)\n  )\n\narrow_data_Gdp <- merged_data %>%\n  filter(Year %in% c(1970, 2022)) %>%\n  group_by(Country) %>%\n  drop_na() |> \n  reframe(\n    GDP_1970 = GDP_Billion_USD[Year == 1970],\n    GDP_2022 = GDP_Billion_USD[Year == 2022],\n    GDP_Change = GDP_2022 - GDP_1970,  # GDP farkını hesapla\n    LifeExp_Female_1970 = LifeExp_Female[Year == 1970],\n    LifeExp_Male_1970 = LifeExp_Male[Year == 1970],\n    LifeExp_Female_2022 = LifeExp_Female[Year == 2022],\n    LifeExp_Male_2022 = LifeExp_Male[Year == 2022],\n    Continent = unique(Continent)\n  ) %>%\n  drop_na()\n\narrow_data_Gdp <- arrow_data_Gdp |> \n  mutate(\n    GDP_Category = case_when(\n      GDP_Change < 1000 ~ \"Low GDP (<1K)\",\n      GDP_Change >= 1000 & GDP_Change < 10000 ~ \"Mid GDP (1K-10K)\",\n      GDP_Change >= 10000 & GDP_Change < 50000 ~ \"High GDP (10K-50K)\",\n      GDP_Change >= 50000 ~ \"Very High GDP (>50K)\"\n    )\n  )\n\n\narrow_data_Gdp <- arrow_data_Gdp%>%\n  mutate(\n    LabelX_GDP = (LifeExp_Female_1970+ LifeExp_Female_2022) / 2,    \n    LabelY_GDP = (LifeExp_Male_1970 + LifeExp_Male_2022) / 2 \n  )\n\n\nI wrote this code to process and prepare a dataset that combines GDP and life expectancy data for analysis and visualization. First, I loaded the GDP data from a CSV file and renamed the columns for clarity: Country, Year, Item, and GDP_Billion_USD. Then, I merged the GDP data with an existing dataset, aligning the entries by country and year. To ensure consistency, I cleaned the merged dataset by removing rows with missing values. Next, I focused on the years 1970 and 2022 to analyze trends over this significant time span. I grouped the data by country and extracted key metrics, including GDP for 2022, life expectancy for females and males in both years, and each country’s continent information. I also performed a more detailed transformation by calculating GDP for 1970 and 2022, along with the change over time (GDP_Change). This transformation retained the life expectancy data for both genders and ensured that continent information was preserved. To enhance the dataset’s interpretability, I categorized countries based on their GDP change into groups such as “Low GDP (<1K)”, “Mid GDP (1K-10K)”, “High GDP (10K-50K)”, and “Very High GDP (>50K)”. These categories made it easier to compare economic growth across countries. Finally, I added two labeling columns to assist with visualizations. LabelX_GDP represents the average female life expectancy between 1970 and 2022, while LabelY_GDP reflects the same for males. These labels provide anchor points for creating meaningful visual plots. By integrating economic and demographic data, I successfully prepared a comprehensive dataset ready for detailed analysis and impactful visualizations.\nBuilding the Graph\n\n\narrow_data_Gdp$GDP_Category <- factor(\n  arrow_data_Gdp$GDP_Category,\n  levels = c(\"Low GDP (<1K)\", \"Mid GDP (1K-10K)\", \"High GDP (10K-50K)\", \"Very High GDP (>50K)\")\n)\n\ngdp_lifeexp_plot <- ggplot(arrow_data_Gdp, \n                           aes(x = LabelX_GDP, \n                               y = LabelY_GDP, \n                               size = GDP_Change,\n                               color = Continent)) +\n  geom_point(alpha = 0.7) +  \n  scale_size_continuous(\n    range = c(2, 5),  \n    breaks = c(50000, 100000, 150000, 200000),  \n    labels = c(\"50K\", \"100K\", \"150K\", \"200K\"),  \n    name = \"GDP (Billion USD)\"\n  ) +\n  scale_x_continuous(\n    breaks = seq(30, 100, 20), \n    name = \"Life Expectancy of Men\"\n  ) +\n  scale_y_continuous(\n    breaks = seq(30, 100, 20),  \n    name = \"Life Expectancy of Women\"\n  ) +\n  scale_color_manual(values = c(\n    \"Africa\" = \"#E41A1C\", \n    \"Asia\" = \"#377EB8\", \n    \"Europe\" = \"#4DAF4A\", \n    \"North America\" = \"#984EA3\", \n    \"Oceania\" = \"#FF7F00\", \n    \"South America\" = \"#A65628\"\n  ), name = \"Continent\"\n  ) + guides(\n    size = guide_legend(\n      override.aes = list(color = c(\"dark blue\"))))+\n    \n  facet_wrap(~ GDP_Category, scales = \"fixed\", labeller = \"label_both\", ncol = 2) + \n  labs(\n    title = \"Life Expectancy Comparison\"\n  ) +\n  theme_minimal(base_size = 10) +\n  theme(\n    legend.position = \"right\",  \n    legend.title = element_text(size = 8),\n    legend.text = element_text(size = 8)\n  )\n\nprint(gdp_lifeexp_plot)\n\n\n\nI wrote this code to create a detailed graph that compares life expectancy for men and women across different GDP categories and continents. Using the arrow_data_Gdp data set, I aimed to visualize the relationships between these variables in a clear and engaging way. First, I converted the GDP_Category column into a factor with a specific order to ensure the categoriese Low GDP (<1K)“,”Mid GDP (1K-10K)“,”High GDP (10K-50K)“, and”Very High GDP (>50K)appear consistently in the plot. For the base plot, I used LabelX_GDP (average life expectancy of men) on the x-axis and LabelY_GDP (average life expectancy of women) on the y-axis. The size of the points represents GDP change (GDP_Change), while their colors indicate different continents. To make the plot visually appealing, I added semi-transparent points with an alpha value of 0.7, ensuring overlapping points remain distinguishable. I also scaled the point sizes from 2 to 5, labeling GDP changes in billions. For the axes, I set tick marks every 20 units within a range of 30 to 100, labeling them as “Life Expectancy of Men” and “Life Expectancy of Women” to make the plot easy to interpret. I manually assigned colors to each continent for better visual distinction, ensuring that the differences between regions are immediately noticeable. Then, I faceted the plot by GDP_Category, arranging it in a two-column layout so each category has its own space, making it easier to compare patterns within and across GDP groups. I customized the legend make the size labels more intuitive and even added an override for the default color settings in the size legend to improve clarity. To keep the design clean, I used the theme_minimal style, repositioned the legend to the right, and adjusted the font sizes for both the legend title and text. I also added a title, “Life Expectancy Comparison,” to give the plot more context. Finally, I printed the plot, which effectively shows how GDP changes relate to life expectancy for men and women across different continents and GDP categories. This visualization pulls together all these elements into a cohesive and visually engaging way to present complex relationships in the data.\n\n\n\nDattani, Saloni, and Lucas Rodés-Guirao. 2023. “Why Do Women Live Longer Than Men?” Our World in Data. https://ourworldindata.org/why-do-women-live-longer-than-men.\n\n\n\n\n",
    "preview": "projects/2024/100541134/100541134_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2025-01-17T11:48:24+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2024/100554973/",
    "title": "Democratic backsliding in Europe",
    "description": "A visual representation of the weakening of European democracies in recent years",
    "author": [
      {
        "name": "Diego Paroli",
        "url": {}
      }
    ],
    "date": "2025-01-03",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nOriginal graph\nReplication\nLoading libraries, fonts and data\nPre-processing the data\nBacksliding line graph\nImproving line graph\nPutting the graphs together\nAdding title, subtitle and captions\n\nAlternative Visualization\nPreparing the data\nBase graph\nOrganizing the graph\nInserting arrow legend\nAdding annotations\n\nConclusions\n\nIntroduction\nDemocratic backsliding refers to the gradual erosion of democratic norms,\ninstitutions and freedoms. This phenomena often entails the weakening of\njudicial independence, restrictions on press freedom and civil liberties and\nthe concentration of power in the executive branch.\nDemocratic backsliding has been, and continues to be a global trend, affecting\neven European countries and key EU member states. Orbán’s Hungary, Erdoğan’s\nTurkey and Morawiecki’s Poland are perfect examples of what have often been\ncalled “illiberal democracies”. However, during the 2010s democracy has\ndeteriorated significantly also in Greece and Serbia and has been worsening\nacross most European countries. Notable exceptions to this trend of the last\ndecade include potential EU candidates Armenia and Kosovo and EU candidate\nGeorgia (although as this article is being written Georgia is experiencing\nserious threats to its democratic apparatus).\nThe graph I chose for my project does a great job in visualizing this trend in a\nclear way by using the liberal democracy index calculated by\nV-Dem Institute. Specifically, as democracy is a complex\nconcept that can be defined in many ways, V-Dem’s liberal democracy index\n“emphasizes the importance of protecting individual and minority rights against\nthe tyranny of the state and the tyranny of the majority […] thus judging the\nquality of democracy by the limits placed on government via constitutionally\nprotected civil liberties, strong rule of law, an independent judiciary,\nand effective checks and balances that, together, limit the exercise of executive\npower.” 1\nIn this article, after replicating the original graph, I propose an alternative\nvisualization of the graph using the same data.\n\nOriginal graph\nThe original graph chosen for this project was created by explained.media,\na Swedish data visualization studio and it can be found in one of their article titled:\n“Democratic erosion and rising authoritarianism in Europe”.\nIt is made up of 2 line graphs, one for the countries whose democracy has worsened\nand another for the countries whose democracy has improve. On the x-axis are depicted\nthe years of the analysis (2012 and 2022) and on the y-axis the liberal democracy\nscore for those years. In addition to that, some countries are highlighted and\n2 of them also have special text annotations.\nOriginal graph. Figure from explained.mediaThe data I used to replicate this graph is the 13th version of the V-Dem Dataset\navailable for download in V-Dem’s Dataset Archive.\n\nReplication\nLoading libraries, fonts and data\n\n\nlibrary(tidyverse)\nlibrary(grid)\nlibrary(gridtext)\nlibrary(patchwork)\nlibrary(ggforce)\nlibrary(ggrepel)\n\nsysfonts::font_add_google(\"Noto Serif\", family=\"noto_serif\",\n                          regular.wt = 700, bold.wt = 900)\nsysfonts::font_add_google(\"Noto Sans Display\", family=\"noto_sans\",\n                          regular.wt = 500, bold.wt = 700)\nsysfonts::font_add_google(\"Poppins\", family=\"poppins\",\n                          regular.wt = 500, bold.wt = 700)\n\nfull_df23 <- read_rds(file=\"V-Dem-CY-Full+Others-v13.rds\")\n#retrieved from https://www.v-dem.net/data/dataset-archive/\ndim(full_df23)\n\n[1] 27555  4602\n\nThe full dataset contains thousands of variables observed for different countries\nand several years, making it necessary to filter only the relevant data for the\nintended purpose.\n\nPre-processing the data\nI first select only the variables that are needed for the project and filter only\nthe observations of the two years depicted. I then make use of the variable\ne_regiongeo to filter only those countries located in Europe.\n\n\n#Selecting only relevant variables\ndf23 <- full_df23 |> \n  select(c(\"country_name\", \"country_text_id\", \"e_regiongeo\", \"year\", \"v2x_libdem\")) |> \n  filter(year == 2012 | year == 2022) |> \n  filter(e_regiongeo %in% 1:4) \n  # 1=Western Europe, 2=Northern Europe, 3=Southern Europe, 4=Eastern Europe\n\n\n\nAt this point, however, I still have only 40 countries compared to the 43 present\nin the original graph. The missing countries are Turkey, Armenia and Georgia\nwhich are not coded in any of the geographical regions for which we have filtered\nbefore, because they are located at the boundaries between Europe and Asia.\nTherefore in the second pipeline I add them to the previously selected countries\nand transform every country name to uppercase.\n\n\n#Adding Turkey, Georgia and Armenia\ndf23 <- full_df23 |> \n  select(c(\"country_name\", \"country_text_id\", \"e_regiongeo\", \"year\", \"v2x_libdem\")) |> \n  filter(year == 2012 | year == 2022) |> \n  filter(country_text_id %in% c(\"TUR\", \"ARM\", \"GEO\")) |> \n  bind_rows(df23) |>\n  arrange(country_name) |> \n  mutate(country_name = toupper(country_name))\nstr(df23)\n\n'data.frame':   86 obs. of  5 variables:\n $ country_name   : chr  \"ALBANIA\" \"ALBANIA\" \"ARMENIA\" \"ARMENIA\" ...\n $ country_text_id: chr  \"ALB\" \"ALB\" \"ARM\" \"ARM\" ...\n $ e_regiongeo    : num  3 3 10 10 1 1 4 4 1 1 ...\n $ year           : num  2012 2022 2012 2022 2012 ...\n $ v2x_libdem     : num  0.435 0.409 0.203 0.445 0.797 0.7 0.096 0.042 0.835 0.825 ...\n\n\nSince I will need to create two separate graphs based on whether a country’s\ndemocracy has been faring better or worse, I need to split this initial dataframe\nin two by that criteria. I do this by creating another variable called\ndifference which stores the difference between the 2022 and the 2012 values\nof the democracy index and then split the data based on positive or negative\nvalues of that variable.\n\n\n#Creating the column difference\ndf23 <- df23 |> \n  pivot_wider(names_from = \"year\", \n              values_from = \"v2x_libdem\", \n              names_prefix = \"year_\") |>\n  mutate(difference = year_2022 - year_2012) |> \n  pivot_longer(cols=c(\"year_2012\",\"year_2022\"), \n               names_to = \"year\", \n               values_to = \"v2x_libdem\", \n               names_prefix = \"year_\") \n\n#Creating two separate df\ndf_backsliding <- df23 |> \n  filter(difference < 0)\ndf_improving <- df23 |> \n  filter(difference > 0)\n\n\n\nThe dataframes are now ready to be used for creating the graph.\n\nBacksliding line graph\nI start from the basic aesthetics of the line graph, plotting the 2 years on\nthe x-axis and the democracy score on the y-axis. Using various arguments of\ngeom_line I set the width of the lines, their color and their opacity.\n\n\nbasic_bcks <- ggplot(df_backsliding) +\n  aes(x=year, y=v2x_libdem) +\n  #Plotting all the lines\n  geom_line(aes(group = country_name), \n            linewidth = 0.5, \n            colour = \"#db051d\", \n            alpha = 0.4)\nbasic_bcks\n\n\n\n\nFrom the basic graph I highlight selected countries by drawing bigger lines for\nthem and adding their start and end point and their names. In particular,\nwhen drawing the points I carefully add an outline to them using the\nstroke argument of geom_point, while for the countries’ names I slightly\ntweak their position for consistency with the original graph and set the closest\npossible font, font-size and color.\n\n\nhighlighted_bcks <- basic_bcks +\n  #Highlighting relevant countries by drawing bigger lines\n  geom_line(data = df_backsliding %>% \n              filter(country_text_id %in% c(\"POL\", \"HUN\", \"SRB\", \"TUR\")),\n            aes(group = country_name), \n            color = \"#db051d\", \n            linewidth = 1.3) +\n  #Adding start and end point\n  geom_point(data = df_backsliding %>% \n               filter(country_text_id %in% c(\"POL\", \"HUN\", \"SRB\", \"TUR\")),\n             shape = 21, \n             size = 3.5, \n             colour = \"white\", \n             fill = \"#db051d\", \n             stroke = 2) +\n  #Showing countries' names\n  geom_text(data = df_backsliding %>% \n              filter(country_text_id %in% c(\"POL\", \"HUN\", \"SRB\", \"TUR\") \n                     & year == 2022),\n            aes(label = country_name), \n            nudge_x = 0.1,\n            hjust = 0,\n            size = 10,\n            size.unit = \"pt\",\n            colour = \"#242424\",\n            family = \"poppins\")\nhighlighted_bcks\n\n\n\n\nI then proceed to modify the aspect of the x and the y axis by setting their names,\ntheir length etc. Finally I fix the ratio of the y-axis’s length to the x-axis’s\nlength.\n\n\naxed_bcks <- highlighted_bcks +\n  #Setting appropriate axis\n  scale_y_continuous(limits = c(0.03, 0.97), \n                     name = \"\\u2190 less democratic\",\n                     breaks = NULL) + \n  scale_x_discrete(limits = c(\"2012\", \"2022\"),\n                   name = NULL,\n                   expand = expansion(mult = c(0.05, 0.65))) +\n  #Fixing ratio of y-axis length to x-axis length\n  coord_fixed(ratio = 7/3, clip=\"off\")\naxed_bcks\n\n\n\n\nAfter I have modified the aspect of the axis I modify the whole theme of the\nplot. I set a transparent background consistent with the original graph. I add a\nmargin above, below and on the left of my backsliding line graph so as to\nreflect the proportions of the original graph. I then set the font, the fontsize,\ncolor and position of the y-axis name and of the labels on the x-axis. Finally,\nI set the color of the x-axis grid lines.\n\nNote that I cannot set the desired font for the y-axis title because the\ntitle contains a special character that the font does not support.\n\n\n\nthemed_bcks <- axed_bcks +\n  #Modifying theme\n  theme_minimal() +\n  theme(panel.background = element_rect(fill = \"transparent\", \n                                        colour = NA),\n        plot.background = element_rect(fill = \"transparent\", \n                                       colour = NA),\n        plot.margin = unit(c(4, 0, 1.5, 1.5), \"cm\"),\n        axis.title.y = element_text(colour = \"black\", \n                                    face = \"bold\",\n                                    size = 8,\n                                    #family = \"noto_sans\",\n                                    hjust = 0.03,\n                                    margin = margin(t = 0, r = 0, b = 0, l = 0, \n                                                    unit=\"pt\")),\n        axis.text.x = element_text(colour = \"#242424\",\n                                   size = 12,\n                                   family = \"noto_sans\",\n                                   margin = margin(t = 2, r = 0, b = 0, l = 0, \n                                                   unit=\"pt\")),\n        panel.grid.major.x = element_line(colour = \"grey\"))\nthemed_bcks\n\n\n\n\nAs the last step for the first line graph, I add the annotation for Poland. I\ncreate a text annotation placing it in the correct position and adjusting, as\nalways, its font, fontsize and color. I then add a curve to link this annotation\nto Poland’s line in the main graph.\n\nNote that here it would be better to use geom_bezier, instead of geom_curve to\nhave a more similar curvature to the original graph. However, when attempting\nto use bezier, I am unable to extend the curve correctly until the top of the\ngraph, as the function seems to confuse normal coordinates and npc units.\n\n\n\n# bezier_data_bcks <- data.frame(\n#   x = c(1.68, 1.75, 1.75, 1.5),\n#   y = c(1, 0.81, 0.83, 0.63))\n\nfinal_bcks <- themed_bcks +\n  #Annotating for Poland\n  annotation_custom(grob = textGrob(\n    label = \"Poland lost 62 places in global\\ndemocracy rankings\",\n    x = unit(0.1, \"npc\"),\n    y = unit(1, \"npc\"),\n    just = c(\"left\", \"bottom\"),\n    gp = gpar(colour = \"#242424\",\n              fontsize = 9.5, \n              fontfamily = \"noto_sans\",\n              lineheight = 1))) +\n  # geom_bezier2(data = bezier_data_bcks, aes(x = x, y = y),\n  #              colour = \"#242424\", linewidth = 0.5) +\n  geom_curve(x = 1.68, y = 1, xend = 1.5, yend = 0.63,\n             curvature = -0.4,\n             colour = \"#242424\",\n             linewidth = 0.5)\nfinal_bcks\n\n\n\n\nThe first part of the graph is now completed. I can now create the other line graph\nand then finally put them together and annotate the general graph with its title,\nsubtitle and captions.\n\nImproving line graph\nTo construct the second line graph I use the same elements of the backsliding\ngraph adjusted accordingly. The main difference is that here I am able to use\ngeom_bezier for the curve from the text annotation to Armenia’s line,\ncreating a curve that resembles much more that of the original graph.\n\n\nbezier_data_impr <- data.frame(\n  x = c(1.5, 1.70, 1.70, 1.5),\n  y = c(0.15, 0.23, 0.24, 0.32))\n\nfinal_imprv <- ggplot(df_improving)+\n  aes(x=year, y=v2x_libdem) +\n  geom_line(aes(group = country_name), \n            linewidth = 0.5, \n            colour = \"#04046e\", \n            alpha = 0.4) +\n  geom_line(data = df_improving %>% filter(country_text_id %in% c(\"ARM\")),\n            aes(group = country_name), \n            color = \"#04046e\", \n            linewidth = 1.3) +\n  geom_point(data = df_improving %>% filter(country_text_id %in% c(\"ARM\")),\n             shape = 21, \n             size = 3.5, \n             colour = \"white\", \n             fill = \"#04046e\", \n             stroke= 2) +\n  geom_text(data = df_improving %>% filter(country_text_id %in% c(\"ARM\") \n                                           & year == 2022),\n            aes(label = country_name), \n            nudge_x = 0.1,\n            hjust = 0,\n            size = 10,\n            size.unit = \"pt\",\n            colour = \"#242424\",\n            family = \"poppins\") + \n  scale_y_continuous(breaks = NULL, \n                     limits = c(0.03,0.97), \n                     name= \"more democratic \\u2192\") + \n  scale_x_discrete(limits = c(\"2012\", \"2022\"),\n                   expand = expansion(mult = c(0.05,0.9)), \n                   name=NULL) +\n  theme_minimal() +\n  theme(panel.background = element_rect(fill = \"transparent\", colour = NA),\n        plot.background = element_rect(fill = \"transparent\", colour = NA),\n        plot.margin = unit(c(4, 0, 1.5, 0), \"cm\"), \n        axis.title.y = element_text(colour = \"black\", \n                                    face = \"bold\",\n                                    size = 8,\n                                    #family = \"noto_sans\",\n                                    hjust = 0.97,\n                                    margin = margin(t = 0, r = 0, b = 0, l = 0, \n                                                    unit=\"pt\")),\n        axis.text.x = element_text(colour = \"#242424\",\n                                   size = 12,\n                                   family = \"noto_sans\",\n                                   margin = margin(t = 2, r = 0, b = 0, l = 0, \n                                                   unit=\"pt\")),\n        panel.grid.major.x = element_line(colour=\"grey\")) +\n  coord_fixed(ratio = 7/3, clip=\"off\") +\n  annotation_custom(grob = textGrob(\n    label = \"Armenia is one of the\\nworld's top ten\\ndemocratizers\",\n    x = unit(0.1, \"npc\"), \n    y = unit(0.1, \"npc\"),\n    just = c(\"left\", \"center\"),\n    gp = gpar(colour = \"#242424\",\n              fontsize = 9.5, \n              fontfamily = \"noto_sans\",\n              lineheight = 1))) +\n  geom_bezier2(data = bezier_data_impr, aes(x = x, y = y),\n               colour = \"#242424\", linewidth = 0.5)\nfinal_imprv\n\n\n\n\nEven for the improving graph I set appropriate margins so as to be able to\nkeep the proportions of the original graph when I join it, in the next step,\nwith the backsliding graph.\n\nPutting the graphs together\n\n\ngeneral <- final_bcks + final_imprv\ngeneral\n\n\n\n\nUsing patchwork I put the two graphs together side by side and I will now\nannotate this general graph with its title, subtitle and the 2 captions.\n\nAdding title, subtitle and captions\nI first create the textGrob for the title, subtitle and captions, making sure\nI accurately try to replicate their font, dimension and color.\n\n\n# Create text grobs for the title, subtitle and caption\ntitle_grob <- grid::textGrob(\n  label = \"Europe's democratic backsliding\",\n  x = 0, y = 1, \n  just = c(\"left\",\"top\"),\n  gp = gpar(col = \"#242424\",\n            fontsize = 21, \n            fontface = \"bold\", \n            fontfamily = \"noto_serif\"))\n\nsubtitle_grob <- gridtext::richtext_grob(\n  text = \"The last 10 years have seen 32 countries \n  **<span style='color:#db051d;'>backsliding<\/span>** \n  and just<br> 11 countries \n  **<span style='color:#04046e;'>improving<\/span>** \n  their liberal democracy score\",\n  x = 0, y = 1,\n  hjust = 0, vjust = 1,\n  gp = gpar(col = \"#444444\",\n            fontsize = 13, \n            fontfamily = \"poppins\",\n            lineheight = 1.5))\n\ncaption_grob <- grid::textGrob(\n  label = \"Source: V-Dem\",\n  x = 0, y = 0,\n  just = c(\"left\",\"center\"),\n  gp = gpar(col = \"#707070\",\n            fontsize = 11,\n            fontfamily = \"poppins\"))\n\ncaption2_grob <- grid::textGrob(\n  label = \"Graphics: explained.media\",\n  x = 0, y = 0,\n  just = c(\"left\",\"center\"),\n  gp = gpar(col = \"#707070\",\n            fontsize = 11,\n            fontface = \"italic\",\n            fontfamily = \"poppins\"))\n\n\n\nI then use inset_element to to position and insert the text objects in the\ndesired locations.\n\n\n# Add them with inset elements\ngeneral + \n  inset_element(title_grob, \n                left = -1, \n                right = 1, \n                bottom = 0.85, \n                top = 0.975, \n                align_to = \"full\", \n                on_top= FALSE) +\n  inset_element(subtitle_grob, \n                left = -1, \n                right = 1, \n                bottom = 0.85, \n                top = 0.9, \n                align_to = \"full\", \n                on_top = FALSE) +\n  inset_element(caption_grob,\n                left = -1,\n                right = 0,\n                bottom = 0.04,\n                top = 0.09,\n                align_to = \"full\", \n                on_top = FALSE) +\n  inset_element(caption2_grob,\n                left = 0.05, \n                right = 1,\n                bottom = 0.04,\n                top = 0.09,\n                align_to = \"full\", \n                on_top = FALSE)\n\n\n\n\nThis is the final version of my replica which I think comes quite close to the\noriginal graph.\n\nAlternative Visualization\nUsing the same data as before, I try to propose an alternative visualization\nthat adds some information to the previous graph. In particular I thought it\nwould be helpful to add the labels for each country so as to allow readers to\neasily identify the countries they are interested in. By doing this, I would also\nbe able to show the ranking of the most to the least democratic country.\nTo do this I’ll produce a horizontal lollipop using arrows instead of points to\nindicate the values for 2012 and 2022.\n\nPreparing the data\n\n\n#Prepare the data\ndf_lollipop <- df23 |> \n  pivot_wider(names_from = year, \n              values_from = v2x_libdem, \n              names_prefix = \"v2x_libdem\") |> \n  arrange(desc(v2x_libdem2022))\n\n#Reduce some countries' names\ndf_lollipop <- df_lollipop |> \n  mutate(country_name = case_when(\n    country_name == \"BOSNIA AND HERZEGOVINA\" ~ \"BOSNIA H.\",\n    country_name == \"UNITED KINGDOM\" ~ \"U.K.\",\n    country_name == \"NORTH MACEDONIA\" ~ \"N. MACEDONIA\",\n    TRUE ~ country_name\n  ))\nstr(df_lollipop)\n\ntibble [43 × 6] (S3: tbl_df/tbl/data.frame)\n $ country_name   : chr [1:43] \"DENMARK\" \"SWEDEN\" \"NORWAY\" \"SWITZERLAND\" ...\n $ country_text_id: chr [1:43] \"DNK\" \"SWE\" \"NOR\" \"CHE\" ...\n $ e_regiongeo    : num [1:43] 2 2 2 1 2 1 2 2 1 1 ...\n $ difference     : num [1:43] -0.009 -0.024 -0.013 -0.016 0.02 ...\n $ v2x_libdem2012 : num [1:43] 0.898 0.894 0.87 0.867 0.827 0.835 0.827 0.844 0.869 0.823 ...\n $ v2x_libdem2022 : num [1:43] 0.889 0.87 0.857 0.851 0.847 0.825 0.824 0.816 0.807 0.803 ...\n\n\nStarting from the dataframe with all the relevant filtered data, I re-arrange it\nin order to be able to use it for my purpose and I abbreviate some countries’ names\nso as not to have labels that are too long.\n\nBase graph\n\n\n#Plot the vertical lollipop chart\nimprovements_v1 <- ggplot(df_lollipop) +\n  geom_segment(aes(x = reorder(country_name, v2x_libdem2022),\n                   xend = reorder(country_name, v2x_libdem2022),\n                   y = v2x_libdem2012, \n                   yend = v2x_libdem2022,\n                   colour = ifelse(difference <=0, \"#db051d\", \"#04046e\")),\n               linewidth = 1.2,\n               arrow = arrow(length = unit(0.01, \"npc\"))) \nimprovements_v1\n\n\n\n\nI’ve decided to start from a basic vertical lollipop, drawing for each country\nan arrow connecting the 2012 value of the democracy score with the 2022 score. I\ngive to the arrows different colors depending on whether, over that period,\nthat country has experienced a democratic erosion or it has improved its democratic\nstatus. I also make sure to order the countries based on their 2022 democracy\nscore.\n\nOrganizing the graph\n\n\nimprovements_v2 <- improvements_v1 +\n  #Modifying scales\n  scale_color_identity() +\n  scale_y_continuous(\n    breaks = c(0,0.2,0.4,0.6,0.8,1), \n    limits = c(0,1),\n    expand = expansion(add = 0),\n    name = paste(\"\\u2190 less democratic\", \n                 strrep(\" \", 75), \n                 \"more democratic \\u2192\")) +\n  #Flip the chart horizontally\n  coord_flip() +\n  #Theme adjustments\n  theme_minimal() +\n  theme(legend.position = \"none\",\n        axis.text.y = element_text(colour = \"#242424\",\n                                   size = 9,\n                                   family = \"noto_sans\"),\n        axis.title.y = element_blank(),\n        axis.text.x = element_text(colour = \"#242424\",\n                                   size = 9,\n                                   family = \"noto_sans\"),\n        axis.title.x = element_text(size = 15),\n        panel.grid.minor = element_blank(),\n        plot.margin = unit(c(4.5, 0.1, 0, 0), \"cm\"))\nimprovements_v2\n\n\n\n\nIn this pipeline I flip the vertical lollipop to make it horizontal. I also\nadjust the scales to make the colors appear as wanted, and to set an appropriate\nnumber of breaks for the democracy index score. Additionally I label the\ndemocracy index axis in a way that clearly shows its meaning. Finally, I\nadjust the theme of the plot, getting rid of the automatic legend, the minor\ngrid lines, and setting appropriate margins. I try to keep the general style of\nthe plot, the fonts as similar as possible to the previous graph.\n\nInserting arrow legend\n\n\nimprovements_v3 <- improvements_v2 +\n  #Adding the custom legend\n  geom_rect(aes(xmin = 32.5, xmax = 41.5, ymin = 0.1, ymax = 0.5), \n            fill = \"white\", color = \"#242424\") +\n  geom_segment(aes(x = 39.5, y = 0.2, xend = 39.5, yend = 0.4),\n               arrow = arrow(length = unit(0.01, \"npc\")),\n               linewidth = 1.2,\n               color = \"#04046e\") +\n  geom_point(aes(x = 39.5, y = 0.2), \n             shape = 1, size = 9, stroke = 1.2, color = \"#242424\") +\n  geom_point(aes(x = 39.5, y = 0.3965), \n             shape = 1, size = 9, stroke = 1.2, color = \"#242424\") +\n  geom_label_repel(aes(x = 39.5, y = 0.2),\n                   stat = \"unique\",\n                   label = \"Arrow tail = 2012\",\n                   color = \"#242424\",\n                   size = 6,\n                   direction = \"x\", \n                   nudge_x = -4.5,\n                   point.padding = 1.8,\n                   label.padding = 0.5,\n                   label.r = 0.5,\n                   label.size = 0.7,\n                   segment.size = 0.7) +\n  geom_label_repel(aes(x = 39.5, y = 0.3965),\n                   stat = \"unique\",\n                   label = \"Arrow head = 2022\",\n                   color = \"#242424\",\n                   size = 6,\n                   direction = \"x\", \n                   nudge_x = -4.5,\n                   point.padding = 1.8,\n                   label.padding = 0.5,\n                   label.r = 0.5,\n                   label.size = 0.7,\n                   segment.size = 0.7)\nimprovements_v3\n\n\n\n\nI then add a custom legend to make sure to explain the functioning of the arrows\nand place it an empty place of my panel. I use geom_rect to create a bordered,\nwhite space in which to place the legend in. Then I draw an arrow and annotate\nthis arrow by circling its tail and head and labeling their meaning.\n\nAdding annotations\n\n\ntitle_grob_plot2 <- gridtext::richtext_grob(\n  text = \"Changes in Liberal Democracy Scores (2012 \n  <span style='font-size:50px;'>&#8594;<\/span>2022)\",\n  x = 0, y = 1,\n  hjust = 0, vjust = 1,\n  gp = gpar(col = \"#242424\",\n            fontsize = 32, \n            fontface = \"bold\", \n            fontfamily = \"noto_serif\"))\n\nsubtitle_grob_plot2 <- gridtext::richtext_grob(\n  text = \n  \"<span style='font-size:30px;'>Is there a democratic backsliding in Europe?<\/span><br>\n  75% of European countries are now \n  **<span style='color:#db051d;'>less democratic<\/span>** \n  than they were in 2012.<br>\n  Only 25% of European countries are \n  **<span style='color:#04046e;'>more democratic<\/span>** \n  now than in 2012\",\n  x = 0, y = 1,\n  hjust = 0, vjust = 1,\n  gp = gpar(col = \"#444444\",\n            fontsize = 18, \n            fontfamily = \"poppins\",\n            lineheight = 1.5))\n\nimprovements_v3 +\n  #Adding annotations for Poland and Armenia\n  annotation_custom(grob = textGrob(\n    label = \"Poland lost 62 places in global\\ndemocracy rankings\",\n    x = unit(0.85, \"npc\"),\n    y = unit(0.175, \"npc\"),\n    just = c(\"center\", \"top\"),\n    gp = gpar(colour = \"#242424\",\n              fontsize = 13, \n              fontfamily = \"noto_sans\",\n              lineheight = 1))) +\n  geom_curve(x = 11, y = 0.7, xend = 7, yend = 0.76,\n             curvature = 0.5,\n             colour = \"#242424\",\n             linewidth = 0.5) +\n  annotation_custom(grob = textGrob(\n    label = \"Armenia is one of the\\nworld's top ten\\ndemocratizers\",\n    x = unit(0.19, \"npc\"),\n    y = unit(0.5, \"npc\"),\n    just = c(\"center\", \"top\"),\n    gp = gpar(colour = \"#242424\",\n              fontsize = 13, \n              fontfamily = \"noto_sans\",\n              lineheight = 1))) +\n  geom_curve(x = 12, y = 0.275, xend = 19, yend = 0.19,\n             curvature = -0.2,\n             colour = \"#242424\",\n             linewidth = 0.5) +\n  #Adding caption\n  labs(caption = paste(\"Paroli (2025)'s reinterpretation of a graph by explained.media\",\n                       strrep(\" \", 325),\n                       \"Source: V-Dem Dataset\")) +\n  theme(plot.caption = element_text(color = \"#707070\",\n                                    size = 8,\n                                    family = \"poppins\",\n                                    margin = margin(t = 5))) +\n  #Inserting title and subtitle\n  inset_element(title_grob_plot2,\n                left = 0,\n                right = 1,\n                bottom = 0.95,\n                top = 1,\n                align_to = \"full\",\n                on_top= FALSE) +\n  inset_element(subtitle_grob_plot2,\n                left = 0,\n                right = 1,\n                bottom = 0.85,\n                top = 0.95,\n                align_to = \"full\",\n                on_top = FALSE)\n\n\n\n\nFor the final version of my alternative visualization graph, I add several\nannotations. I add the same in-graph annotations for Poland and Armenia present\nin the previous graph. I create and insert the title and subtitle as Grobs and\nI add the captions. Again, I try to keep the style and formatting similar to the\nprevious graph.\n\nConclusions\nAs mentioned before, the main advantage of the alternative visualization compared\nto the replica is the fact that each European country is labelled, allowing the\nreaders to see the democracy score for each country. Ordering them by their 2022\nscore improves the visualization and adds another piece of information. Another\naddition compared to the replica is the explicit scale that makes it clear that\nthe democracy score goes from 0 to 1, helping to understand how democratic a\ncountry is. Including these additional pieces of information, however, reduces the\nintuitiveness and simplicity of the graph, making it more complex to read.\nI also think the alternative visualization lacks a bit of the visual impact\nof the original. Since in the original graph, countries with worsening and\nimproving democracies are displayed on two separate graphs, it makes the\nbacksliding trend immediately apparent by comparing the number of lines in each\ngraph. In contrast, the alternative visualization requires more time to make\nthis comparison.\nThe main drawback of the alternative visualization, though, is that some data\npoints appear “ugly”. This occurs for those countries whose democracy index\nchanged little between 2012 and 2022, resulting in arrows that are barely visible.\nOverall, I believe the original graph does a better job of communicating the\ngeneral trend of weakening of democratic institutions in Europe in recent\nyears. The second graph, instead, offers a more nuanced perspective by\nincorporating additional details. While the trend of democratic\nbacksliding is real and concerning—evident in the graph by the larger number of\ncountries experiencing significant declines in democratic conditions compared to\nthose showing meaningful improvements—the concentration of red lines in the\noriginal graph can mislead readers into overestimating its severity. Although, some\ncountries (as the ones mentioned in the introduction) have experienced a\nworrisome, sharp decline in the health of their democracies, other red lines\nrepresent nations where the democracy index has only slightly worsened. This\ndistinction is harder to discern in the first graph, whereas in the\nsecond, the fact that the length of each arrow reflects the magnitude of change\nhelps to improve the visual understanding of the nuances of this phenomenon.\n\nDefinition from the V-Dem Dataset codebook available at\nhttps://v-dem.net/data/reference-documents/↩︎\n",
    "preview": "projects/2024/100554973/100554973_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2025-01-17T11:48:24+01:00",
    "input_file": {},
    "preview_width": 6900,
    "preview_height": 6900
  },
  {
    "path": "projects/2024/100529006/",
    "title": "Exploring the Global Link Between CO2 Consumption and GDP: A Visual Journey",
    "description": "This work explores the relationship between CO2 consumption per capita and GDP per capita worldwide, through a series of visualizations created using mainly the ggplot2 package in R. Starting with an original graph from Our World In Data, we replicate and enhance it. These improvements range from adjustments to labels and colors to the addition of reference lines to highlight trends and patterns. Throughout the process, key improvements are made to increase clarity, visual accessibility, and inclusivity, ensuring the graphics are easily interpretable by a diverse audience, including those with visual impairments. Lastly various types of plots such as other scatter plots, box plots, bar plots, and area plots are made with the same data base.",
    "author": [
      {
        "name": "Pablo Romero",
        "url": {}
      }
    ],
    "date": "2024-12-28",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nIntroduction\nGetting started\nPackages\nPreparing the data and the graph\n\nReplica\nSetting Up the Base Plot\nCustomizing the Axes\nAdjusting Point Size and Color\nAdding Country Labels\nHighlighting Key Insights with Annotations\nVisual Markers for Key Thresholds\nHighlighting Groups of Countries with Ellipses\nAdding Curves to Represent Trends\nFinal Adjustments and Aesthetic Choices\nAdding Logo and Source Information\nReplica code and graph\n\nEnhancement\nAlternative Visualization\nScatter plot divided by continent\nBox plot\nBar plot\nArea plot\n\nFinal considerations\n\nIntroduction\nFor my final Data Visualization task, I have chosen as a graph to replicate and, subsequently improve, one from the Our World In Data web repository. This website is in charge of using all the reliable information available on the internet and making relevant reports and visualizations about it. This is done with the goal of making the knowledge on the big problems accessible and understandable.\nThere are two reasons why we have chosen to replicate and improve this graph: first, the idea offered by Our World In Data of visualizing different information with standardized graphs seems to me especially interesting and challenging, especially knowing that they use their own data visualization tool to do so. Secondly, the subject matter is particularly relevant, especially due to the unprecedented climate emergency we are facing, which is one of the great problems of the 21st century.\nAs can be seen, the graph shown is a scatter plot visualizing the relationship between GDP per capita (x-axis) and co2 emissions, also per capita (y-axis).\nScatter plot measuring the relation between CO2 emmisions and GDP (per capita). Source: [Our World In Data] (https://ourworldindata.org/).If we start to break down this chart, we observe that it is composed first of all, as we have already mentioned, of a scatter plot. The values that make up the scatter plot are in the shape of a sphere, which change size according to the country’s population and color according to the continent in which it is located. Two purple and blue ellipses are added to this scatter plot, representing the countries with energy poverty and those with too high C02 emissions respectively. On the right side, in a greenish blue color, we can see those countries that, in terms of gdp per capita, could have energy access with net-zero COz emissions.\nAnother relevant aspect of this, which escapes the traditional aspects of a scatter plot, are the two arrows in the footer of the graph, which provide relevant information on the subject that simplifies and visualizes. Thus, and after this first introductory section, we proceed to prepare the data to be able to replicate the aforementioned graph.\nGetting started\nPackages\n\n\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(countrycode)\nlibrary(reprex)\nlibrary(DataExplorer)\nlibrary(grid)\nlibrary(png)\nlibrary(cowplot)\nlibrary(ggforce)\nlibrary(RColorBrewer)\nlibrary(scales)\n\n\nPreparing the data and the graph\nFirst, we have to load the database we are going to work with. Fortunately, Our World In Data has the data it uses in its graphs available free of charge and without the need to ask for permissions to work with them. So, we download them from Our World In Data’s own repository.\n\n\nowid_co2_data <- read_csv(file = \"owid-co2-data.csv\")\n\n\nIf we visualize the table it generates, we observe a tibble of 47415 x 79 in which we find a relevant battery of information about COVID-19. Returning to the graph we proceed to replicate, secondly, we will perform a series of transformations and filtering steps on the CO2 consumption per capita dataset for the year 2020. The goal is to create a subset of countries based on their GDP per capita and CO2 consumption, with specific conditions derived from the data of Malawi and Singapore. The Malawi and Singapore situation is because, later, for the creation of the ellipses, we will need to take those countries as the limit for a correct visualization. Thus, the steps to be performed are as follows:\nFilter the dataset for the year 2020.\nSelect relevant columns: we will then select the necessary columns from the original dataset: country, iso_code, year, population, gdp, and consumption_co2_per_capita. These are the key variables needed to replicate the chart.\nCalculate GDP per capita: After that, we will create a new variable called gdp_per_capita. This will be calculated by dividing the GDP of each country by its population, allowing for comparisons of economic output per person.\nAdd a continent variable: we will use the countrycode function to add a new column called continent. This function will map the country’s ISO code to its corresponding continent, providing a geographic categorization for the countries in the dataset.\nRemove rows with missing continent data: To ensure the dataset is clean, we will filter out any rows where the continent variable is NA, as these countries do not have a continent classification.\nExtract values for Malawi and Singapore: Next, we will extract the GDP per capita and CO2 consumption per capita for Malawi and Singapore. These values will be used as reference points for the filtering criteria in the ellipses. Specifically, we will extract Malawi’s GDP per capita (malawi_gdp), Malawi’s CO2 consumption per capita (malawi_co2), and Singapore’s CO2 consumption per capita (singapore_co2).\nFilter countries based on GDP and CO2 consumption: Finally, we will filter the dataset to include only those countries that meet the following conditions: The country’s gdp_per_capita is greater than or equal to Malawi’s gdp_per_capita and the country’s consumption_co2_per_capita is greater than or equal to Malawi’s consumption_co2_per_capita, but less than or equal to Singapore’s consumption_co2_per_capita.\nThis will create a subset of countries with economic and environmental characteristics within the specified range of Malawi and Singapore. This is so that the points that appear in my graph are exactly the same as those presented in the original OWID graph.\n\n\nco2data <- owid_co2_data |> \n  filter(year == 2020) |> \n  select(country, iso_code, year, population, gdp, consumption_co2_per_capita) |> \n  mutate(gdp_per_capita = gdp / population) |> \n  mutate(continent = countrycode(sourcevar = iso_code,\n                                 origin = \"iso3c\", destination = \"continent\")) |> \n  filter(!is.na(continent))\n\nmalawi_gdp <- co2data |> \n  filter(country == \"Malawi\") |> \n  pull(gdp_per_capita)\n\nmalawi_co2 <- co2data |> \n  filter(country == \"Malawi\") |> \n  pull(consumption_co2_per_capita)\n\nsingapore_co2 <- co2data |> \n  filter(country == \"Singapore\") |> \n  pull(consumption_co2_per_capita)\n\nco2data <- co2data |> \n  filter(\n    gdp_per_capita >= malawi_gdp,                          \n    consumption_co2_per_capita >= malawi_co2,              \n    consumption_co2_per_capita <= singapore_co2 \n  )\n\n\nTo continue replicating the original chart accurately, thirdly, we will use the specific color scheme for each continent, which matches the original chart’s color assignments. This ensures that our visualization maintains the same visual appearance, including the use of colors for the continents.\nIn the original chart, each continent is assigned a particular color. By defining the continent_colors vector, we are directly applying these colors to the relevant continents in our dataset. This approach will ensure that when we visualize the data, the continents will be represented using the same color scheme as the original chart.\n\n\ncontinent_colors <- c(\n  \"Africa\" = \"#a561a0\",       \n  \"Americas\" = \"#e16e6d\",      \n  \"Asia\" = \"#529a9d\",         \n  \"Europe\" = \"#6a778f\",        \n  \"Oceania\" = \"#a64f5a\"       \n)\n\n\nAlso, in the original chart from Our World In Data (OWID), certain countries are labeled to highlight their specific data points, making them stand out in the visualization. To replicate this feature in our own plot, we select the same countries that were labeled in the OWID chart. This allows us to ensure that the labeled countries in our plot match the ones in the original chart, maintaining consistency and accuracy in our replication.The process:\nSelection of countries: We begin by defining a vector called selected_countries, which contains the list of countries that were labeled in the original OWID chart. These countries are selected because they are the ones that the original chart focused on, either due to their notable data points or for visual clarity. By selecting these countries, we are replicating the choice made by the original chart.\nLabeling the countries in the dataset: After selecting the countries, we create a new variable label_country in our dataset (co2data). This variable is generated using the ifelse function. It checks if each country in the dataset is in the selected_countries list: If the country is in the list, it will be labeled with its name in the label_country column. If the country is not, the value will be NA (not applicable).\nThis allows us to focus only on the countries that need to be labeled, while other countries remain unlabelled, just like in the original chart.\n\n\nselected_countries <- c(\n  \"Malawi\", \"Ethiopia\", \"Tanzania\", \"Pakistan\", \"India\", \"Guatemala\",\n  \"Ukraine\", \"Namibia\", \"Indonesia\", \"Singapore\", \"China\", \"Mexico\",\n  \"Turkey\", \"Spain\", \"France\",\"Sweden\", \"Poland\", \"Russia\",\n  \"United Kingdom\", \"Israel\", \"Japan\", \"South Korea\", \"Switzerland\",\n  \"Canada\", \"United States\")\n\nco2data$label_country <- ifelse(co2data$country %in% selected_countries,\n                                co2data$country, NA)\n\n\nIn the step, we will define two separate groups of countries for which we want to create ellipses on the plot. These groups are based on the original OWID dataset, which highlights certain countries in different colors (blue and purple). To ensure we are using the correct countries for each color, we will filter the dataset to include only those countries that belong to the blue and purple groups.\nThe blue group will consist of countries like the United States, Singapore, Canada, Switzerland, and others with higher GDP and CO2 consumption.\nThe purple group will include countries like China, Mexico, India, Pakistan, and others that typically have lower GDP and CO2 consumption.\nWe need to select these countries first so that we can draw the ellipses for each group accurately, based on their GDP and CO2 consumption per capita. Next, we will apply filters on the gdp_per_capita and consumption_co2_per_capita variables to ensure that the data points for the countries in each group (blue and purple) fall within a relevant range. This step is essential for drawing the ellipses correctly. The filtering will allow us to focus on countries with:\nGDP per capita greater than or equal to Malawi’s GDP and less than or equal to 150,000.\nCO2 consumption per capita between 0 and 22.\nBy applying these filters, we ensure that the ellipses we create will be well-defined and represent the correct regions of the original plot.\n\n\nbluevalues <- co2data |> \n  filter(country %in% c(\"United States\", \"Singapore\", \"Canada\",\n                        \"Switzerland\", \"South Korea\", \"Japan\", \"Israel\",\n                        \"Russia\", \"Poland\", \"United Kingdom\", \"Sweden\",\n                        \"France\", \"Spain\", \"Turkey\", \"China\", \"Mexico\",\n                        \"Ukraine\", \"Namibia\")) |> \n  select(country, gdp_per_capita, consumption_co2_per_capita)  \n\nfiltered_bluevalues <- bluevalues |> \n  filter(\n    gdp_per_capita >= malawi_gdp & gdp_per_capita <= 150000,\n    consumption_co2_per_capita >= 0 & consumption_co2_per_capita <= 22\n  )\n\npurplevalues <- co2data |> \n  filter(country %in% c(\"China\", \"Mexico\", \"Ukraine\", \"Namibia\", \"India\", \n                        \"Pakistan\", \"Guatemala\", \"Indonesia\", \"Tanzania\", \n                        \"Ethiopia\", \"Malawi\")) |> \n  select(country, gdp_per_capita, consumption_co2_per_capita)  \n\nfiltered_purplevalues <- purplevalues |> \n  filter(\n    gdp_per_capita >= malawi_gdp & gdp_per_capita <= 150000,\n    consumption_co2_per_capita >= 0 & consumption_co2_per_capita <= 22\n  )\n\nco2data <- co2data |> \n  mutate(consumption_co2_per_capita = ifelse(country == \"Singapore\",\n                                             21, consumption_co2_per_capita))\n\n\nLastly, in the final step of this part, we will load the Our World In Data (OWID) logo image to include it in the plot. This is essential for replicating the original graphic, as it features the OWID logo prominently. To load the image, we use the readPNG() function to read the PNG file, and then we create a graphical object using rasterGrob() from the grid package. This object will allow us to position the logo on the plot later.\n\n\nlogo <- readPNG(\"logo_owid.png\")\nlogo_grob <- rasterGrob(logo, interpolate = TRUE)\n\n\nReplica\nIn this explanation, we will describe how we are replicating a plot from Our World In Data that visualizes the relationship between CO2 emissions per capita and GDP per capita. Our goal is to create a faithful reproduction of this original chart, with attention to detail in aspects like data representation, color schemes, annotations, and visual markers.\nSetting Up the Base Plot\nTo begin, we will load the data from the original dataset, which contains information on countries’ per capita GDP, per capita CO2 emissions, population, and continent. We will set up the base plot using the ggplot(co2data, aes(…)) function, where we map gdp_per_capita to the x-axis and consumption_co2_per_capita to the y-axis. We will size the points according to the population of each country and color the points based on the continent, using the continent variable for both the color and fill aesthetics. This setup reflects the structure of the original plot, which uses similar variables to communicate the relationship between economic output and environmental impact.\nCustomizing the Axes\nThen, in the original plot, the x-axis is presented on a logarithmic scale to better visualize the wide range of GDP per capita values. We will replicate this approach by applying scale_x_log10() to our plot. This will allow us to display countries with both low and high GDPs in a way that maintains the clarity of the data. We will set the axis breaks at values like 2000, 5000, 10000, and so on, and format these labels to show the GDP values in dollars using scales::dollar_format(). For the y-axis, we will use scale_y_continuous() to display CO2 emissions in a way that matches the original plot’s scale, with labels such as “0 t”, “2.5 t”, “5 t”, and “20 t” to help viewers interpret the emissions data more easily.\nAdjusting Point Size and Color\nFollowing with the graph replica, to mimic the visual structure of the original plot, we will adjust the size of each data point based on the population of the country. Using the scale_size_area() function, we will size the points accordingly, setting a maximum point size and defining population ranges such as “10M”, “100M”, and “1B”. Additionally, we will color the points by continent, applying a custom color palette (continent_colors) to ensure that the countries are distinguishable by their geographic regions, just as in the original plot. This color scheme will be consistent with the one used in the Our World In Data chart to visually separate different continents.\nAdding Country Labels\nKnow, as you can see, country labels are placed near the corresponding data points to indicate which countries are represented. We will replicate this by adding text labels for each country using geom_text_repel(). This function will automatically adjust the positions of the labels to avoid overlap and ensure that all countries are labeled clearly. We will assign the text labels based on the label_country variable, which holds the names of the countries that appear in the original graph, and color the labels according to the continent.\nHighlighting Key Insights with Annotations\nA major feature of the original plot is the use of annotations to highlight specific trends and key insights. We will replicate this by adding static text annotations to our plot. For example, we will add a label that reads “CO2 emissions are too high” in a prominent location on the graph. We will also add text annotations near the origin of the plot to explain the concepts of energy poverty and the goal of achieving net-zero emissions. These annotations will be carefully placed, ensuring that they don’t obstruct important data points but still convey essential messages to the viewer.\nVisual Markers for Key Thresholds\nIn the original plot, several lines and segments are used to visually represent key thresholds, such as the baseline for CO2 emissions and significant GDP per capita values. We will add a horizontal line at y = 0 using geom_hline() to indicate the baseline for CO2 emissions. Additionally, we will use geom_segment() to draw vertical lines at specific GDP per capita values, emphasizing key economic thresholds, just like in the original plot. These visual markers will help viewers focus on significant points in the data and better understand the relationship between economic development and environmental impact.\nHighlighting Groups of Countries with Ellipses\nThe original plot also uses ellipses to highlight specific groups of countries that share similar characteristics, such as those with relatively high or low CO2 emissions and GDP per capita. We will replicate this by using geom_mark_ellipse() to draw ellipses around specific sets of countries, identified by the bluevalues and filtered_purplevalues datasets. These ellipses will be semi-transparent, drawing attention to the countries within each group without obscuring the rest of the plot. This visual technique is consistent with the original chart, where ellipses help to illustrate clusters of countries with similar environmental and economic profiles.\nAdding Curves to Represent Trends\nTo further enhance the narrative of the plot, we will add curved arrows that represent the path toward sustainability. In the original plot, these arrows help communicate the idea that to end climate change, emissions must eventually reach zero. We will use geom_curve() to draw these arrows, illustrating the need to reduce emissions to a sustainable level. Along these curves, we will add text annotations to explain the significance of these trends, such as halving emissions to 2.4 tonnes per person. This will reinforce the message conveyed in the original plot and provide context for viewers.\nFinal Adjustments and Aesthetic Choices\nFinally, we will make several adjustments to the plot’s appearance to ensure that it closely matches the original. We will use coord_cartesian() to adjust the plot’s limits, ensuring that all data points and annotations are visible and properly positioned. The plot will be styled using theme_minimal(), which gives the chart a clean and modern look. We will further customize the fonts, axis labels, grid lines, and margins to match the original chart’s design. Special attention will be given to the title and subtitle, ensuring that the font, size, and alignment are consistent with the original plot’s aesthetics.\nAdding Logo and Source Information\nIn the final step, we will add the logo and source information to the plot, just as it appears in the original chart. Using ggdraw(), we will position the logo in the top-right corner of the plot and add text labels at the bottom to provide details about the data sources and licensing. This step will help give proper attribution to the data providers and maintain consistency with the visual style of the original plot.\nReplica code and graph\n\n\nmain_plot <- ggplot(co2data, aes(\n  x = gdp_per_capita,\n  y = consumption_co2_per_capita,\n  size = population,\n  color = continent,\n  fill = continent\n)) +\n  geom_point(\n    alpha = 0.9,\n    shape = 21,\n    color = \"black\",\n    stroke = 0.7\n  ) +\n  scale_x_log10(\n    breaks = c(2000, 5000, 10000, 20000, 50000, 100000),\n    labels = scales::dollar_format(accuracy = 1)\n  ) +\n  scale_y_continuous(\n    breaks = c(0, 2.5, 5, 10, 15, 20, 22),\n    labels = c(\"0 t\", \"2.5 t\", \"5 t\", \"10 t\", \"15 t\", \"20 t\", \" \")\n  ) +\n  scale_size_area(\n    max_size = 20,\n    breaks = c(1e7, 1e8, 1e9),\n    labels = c(\"10M\", \"100M\", \"1B\"),\n    guide = \"none\"\n  ) +\n  scale_color_manual(\n    values = continent_colors,\n    guide = \"none\"\n  ) +\n  scale_fill_manual(values = continent_colors) +\n  geom_text_repel(\n    aes(label = label_country, color = continent),  \n    size = 5,  \n    family = \"Verdana\",\n    box.padding = 0.1,\n    point.padding = 0.05,\n    force = 0.3,\n    max.overlaps = 40,\n    segment.color = NA,\n    segment.size = 0.2,\n    nudge_x = 0.1,\n    nudge_y = 0.1,\n  ) +\n  labs(\n    title = \"CO2 Emissions per Capita vs GDP per Capita\", \n    subtitle = \"Per capita consumption-based CO2 emissions\", \n    x = \"GDP per capita (int. -$)\",\n    y = NULL,\n    size = \"Population\"\n  ) +\n  geom_text(\n    aes(x = 25000, y = 17, label = \"CO2 emissions\\nare too high\"),\n    family = \"Verdana\", \n    size = 10, \n    color = \"#326495\",\n    hjust = 1\n  ) +\n  geom_text(\n    aes(x = 30000, y = 2.5,\n        label = \"Energy access with\\nnet-zero CO2 emissions\"),\n    family = \"Verdana\",\n    size = 9,\n    color = \"#0f8b85\",\n    hjust = 0\n  ) +\n  annotate(\"text\", x = 2500, y = 7.5,\n           label = \"Energy poverty\",\n           family = \"Verdana\",\n           size = 10, color = \"#b04b98\") +\n  geom_hline(yintercept = 0, color = \"#7f223f\", size = 0.5) +\n  geom_segment(\n    aes(x = 25000, xend = Inf,\n        y = 0, yend = 0),\n    color = \"#0e8c4f\", size = 5\n  ) +\n  geom_segment(\n    aes(x = 25000, xend = Inf,\n        y = 0, yend = 0),\n    color = \"#72ddd5\", size = 3\n  ) +\n  geom_mark_ellipse(\n    data = bluevalues, \n    aes(x = gdp_per_capita, y = consumption_co2_per_capita),\n    fill = \"#006DBC\", \n    color = NA, size = 0.1, alpha = 0.2\n  ) +\n  geom_mark_ellipse(\n    data = filtered_purplevalues, \n    aes(x = gdp_per_capita, y = consumption_co2_per_capita),\n    fill = \"#BF98C7\", \n    color = NA, size = 0.1, alpha = 0.2\n  ) +\n  geom_curve(\n    aes(x = 0, xend = 0,\n        y = -4, yend = 0), \n    arrow = arrow(type = \"closed\",\n                  length = unit(0.15, \"inches\")), \n    color = \"#3ba09c\", size = 0.5,\n    curvature = -0.5\n  ) +\n  geom_curve(\n    aes(x = 0, xend = 0,\n        y = -5, yend = 2.4),\n    arrow = arrow(type = \"closed\",\n                  length = unit(0.15, \"inches\")),\n    color = \"#95d8c3\",\n    size = 0.5,       \n    curvature = -0.5    \n  ) +\n  annotate(\"text\", x = 0, y = -4,\n           label = \"To end climate change the long-run goal is that net-emissions decline to zero.\",\n           family = \"Verdana\",\n           size = 5.2, color = \"#4b4b4b\", hjust = 0) +\n  annotate(\"text\", x = 0, y = -5,\n           label = \"Bringing emissions down to 2.4 tonnes per person would mean we have halved emissions from their current level (4.8t), a big milestone.\",\n           family = \"Verdana\",\n           size = 5.2, color = \"#4b4b4b\", hjust = 0) +\n  coord_cartesian(\n    xlim = c(malawi_gdp, 150000),\n    ylim = c(0, 22),\n    clip = \"off\"\n  ) +\n  theme_minimal(base_family = \"Arial\") +\n  theme(\n    plot.title = element_text(\n      family = \"Times New Roman\", \n      hjust = 0, \n      size = 51, \n      margin = margin(t = 0, r = 1, b = 20, l = 0),\n      color = \"#555555\"\n    ),\n    plot.subtitle = element_text(\n      family = \"Verdana\", \n      hjust = 0,         \n      size = 18, \n      margin = margin(t = 15, r =0,b = 0, l = 0),  \n      color = \"#7f223f\"\n    ),\n    axis.title.x = element_text(\n      family = \"Verdana\",\n      color = \"gray50\",\n      size = 15\n    ),\n    axis.text = element_text(\n      color = \"gray50\",\n      size = 20\n    ),\n    axis.text.y = element_text(color = \"#7f223f\", size = 20),\n    legend.position = \"none\",\n    panel.grid.major = element_line(\n      color = \"gray80\",\n      linetype = \"dashed\"\n    ),\n    panel.grid.minor = element_line(\n      color = \"gray90\",\n      linetype = \"dotted\"\n    ),\n    plot.margin = margin(t = 15, r = 35, b = 100, l = 35) \n  )\n\nfinal_plot1 <- ggdraw(main_plot) +\n  draw_grob(logo_grob, x = 0.85, y = 0.89,\n            width = 0.18, height = 0.1)\n\nfinal_plot2 <- ggdraw() +\n  draw_plot(final_plot1) +\n  draw_label(\n    \"Data: Global Carbon Project, UN Population, and World Bank.\",\n    x = 0.02, y = 0.04, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"gray50\"\n  ) +\n  draw_label(\n    \"OurWorldinData.org\",\n    x = 0.02, y = 0.02, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"#326495\" \n  ) +\n  draw_label(\n    \"- Research and data to make progress against the world's largest problems.\",\n    x = 0.13, y = 0.02, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"gray50\" \n  ) +\n  draw_label(\n    \"Licensed under CC-BY by the author Max Roser.\",\n    x = 0.48, y = 0.02, \n    hjust = -1, fontfamily = \"Verdana\", size = 12, color = \"gray50\"\n  )\n\nprint(final_plot2)\n\n\n\nAs can be seen, an almost 100% faithful replica of the original has been achieved. The biggest problem has been found with the aspect related to the ellipses, since from R itself there is no option to make an ellipse like the one shown in the original graph. In the same way, we have tried to show the closest option to it. Thus, linking with what we have just commented, we want to refer that this section of the ellipses, and the one related to the arrows, has been the most difficult to replicate. This is due to the fact that, by default, when you try to draw things outside your x and y axis limits in a graphic, they are automatically eliminated. Luckily, there is coord_cartesian (clip = “off”), which solves this. The dilemma is that how this is solved is not entirely correct.\nEnhancement\nBased on this original graph, we now proceed to make a series of modifications to it as our own proposal for improvement. We must recognize that OWID does an excellent job with its standardized graphs, but the task requires us to make a number of improvements. These have been grouped into four major groups:\nMinor Changes in Labels: The label text is going to be adjusted in the second plot for clarity and readability. For instance, the labels related to CO2 emissions are going to be changed to “High CO2 emissions remain a challenge” and “Achieving energy access with minimal CO2 emissions.” These revisions will make the language more concise and directly convey the issues being discussed. Additionally, the new labels will be more aligned with a visual storytelling approach, highlighting the challenge of high emissions and the goal of achieving energy access with minimal CO2 emissions. Furthermore, the second plot is going to introduce annotations and labels with more thought-out positioning and font choices to improve readability and the overall flow of information.\nColor-Blind Friendly Colors: In this second plot, the color palette for continents is going to be modified by using the Dark2 palette from the RColorBrewer package. This change will aim to make the visualization more accessible to individuals with color vision deficiencies. The original plot, which used a custom palette defined by continent_colors, might have contained colors that are harder to distinguish for color-blind users. The new color scheme is going to ensure better differentiation between continents, making the data clearer for a wider range of viewers.\nVisual Accessibility: The second plot is also going to improve the overall visual accessibility by adjusting font sizes and colors to provide better contrast. For example, the title and subtitle will be larger and more distinguishable, with the subtitle receiving a bolder color to create a clearer visual hierarchy. The axis titles and text are going to be resized, and the y-axis text will be in a more contrasting color to ensure it stands out against the background. These visual tweaks are going to enhance readability for users with visual impairments or those viewing the plot on smaller screens. Additionally, more attention is going to be paid to the size of the point labels, which will be slightly reduced in the second plot (from size 5 to 3.5). This minor change is going to help avoid overcrowding and make the labels more legible without overwhelming the plot’s data points.\nIntroduction of Reference Lines: Another key improvement in the second plot is going to be the addition of reference lines. These lines will serve as helpful indicators for viewers to understand the average trends of the dataset: A dashed horizontal line indicating the mean CO2 emissions per capita and a vertical one indicating the mean GDP per capita. Each of these reference lines will be paired with an annotation that clearly labels the lines’ meanings, enhancing the interpretability of the plot. The colors of the reference lines are going to be chosen for high contrast and visibility. These adjustments are going to not only improve the clarity of the plot but also make it easier for the audience to understand key data trends.\nIn summary, the second plot is going to introduce several crucial improvements: clearer and more concise labels, a color palette that is friendly to color-blind users, visual enhancements for accessibility, and informative reference lines. These changes will elevate the plot’s clarity, interpretability, and inclusiveness, ensuring that it reaches a broader and more diverse audience while effectively conveying the key messages.\n\n\ncontinent_colors <- brewer.pal(n = 8, name = \"Dark2\")\n\nbetter_plot <- ggplot(co2data, aes(\n  x = gdp_per_capita,\n  y = consumption_co2_per_capita,\n  size = population,\n  color = continent,\n  fill = continent\n)) +\n  geom_point(\n    alpha = 0.9,\n    shape = 21,\n    color = \"black\",\n    stroke = 0.7\n  ) +\n  scale_x_log10(\n    breaks = c(2000, 5000, 10000, 20000, 50000, 100000),\n    labels = scales::dollar_format(accuracy = 1)\n  ) +\n  scale_y_continuous(\n    breaks = c(0, 2.5, 5, 10, 15, 20, 22),\n    labels = c(\"0 t\", \"2.5 t\", \"5 t\", \"10 t\", \"15 t\", \"20 t\", \" \")\n  ) +\n  scale_size_area(\n    max_size = 20,\n    breaks = c(1e7, 1e8, 1e9),\n    labels = c(\"10M\", \"100M\", \"1B\"),\n    guide = \"none\"\n  ) +\n  scale_color_manual(\n    values = continent_colors, \n    guide = \"none\"\n  ) +\n  scale_fill_manual(values = continent_colors) +\n  geom_text_repel(\n    aes(label = label_country, color = continent),\n    size = 3.5,\n    family = \"Verdana\",\n    box.padding = 0.1,\n    point.padding = 0.05,\n    force = 0.3,\n    max.overlaps = 40,\n    segment.color = NA,\n    segment.size = 0.2,\n    nudge_x = 0.1,\n    nudge_y = 0.1\n  ) +\n  labs(\n    title = \"CO2 Emissions per Capita vs GDP per Capita\",\n    subtitle = \"Per capita consumption-based CO2 emissions\", \n    x = \"GDP per capita (int. -$)\",\n    y = NULL,\n    size = \"Population\"\n  ) +\n  geom_text(\n    aes(x = 20000, y = 17, label = \"High CO2 emissions\\nremain a challenge.\"),\n    family = \"Verdana\", \n    size = 10, \n    color = \"#332288\",\n    hjust = 1\n  ) +\n  geom_text(\n    aes(x = 25000, y = 2.5,\n        label = \"Achieving energy access\\nwith minimal CO2 emissions.\"),\n    family = \"Verdana\",\n    size = 10,\n    color = \"#117733\",\n    hjust = 0\n  ) +\n  annotate(\"text\", x = 2500, y = 7.5,\n           label = \"Energy poverty\",\n           family = \"Verdana\",\n           size = 10, color = \"#AA4499\") +\n  geom_segment(\n    aes(x = 25000, xend = Inf,\n        y = 0, yend = 0),\n    color = \"#117733\", size = 5\n  ) +\n  geom_segment(\n    aes(x = 25000, xend = Inf,\n        y = 0, yend = 0),\n    color = \"#44AA99\", size = 3\n  ) +\n  geom_hline(\n  yintercept = mean(co2data$consumption_co2_per_capita, na.rm = TRUE),\n  linetype = \"dashed\",\n  color = \"#F0E442\",\n  size = 0.8\n  ) +\n  annotate(\n    \"text\", \n    x = 11500, \n    y = 6.5, \n    label = \"Mean CO2 per capita\",\n    color = \"#F0E442\",\n    hjust = 1.2, \n    size = 5,\n    fontface = \"bold\"\n  ) +\n  geom_vline(\n    xintercept = mean(co2data$gdp_per_capita, na.rm = TRUE),\n    linetype = \"dashed\",\n    color = \"#D55E00\", \n    size = 0.8\n  ) +\n  annotate(\n    \"text\", \n    x = mean(co2data$gdp_per_capita, na.rm = TRUE),\n    y = 20, \n    label = \"Mean GDP per capita\",\n    color = \"#D55E00\",\n    hjust = -0.2, \n    size = 5,\n    fontface = \"bold\"\n  ) +\n  geom_mark_ellipse(\n    data = bluevalues, \n    aes(x = gdp_per_capita, y = consumption_co2_per_capita),\n    fill = \"#88CCEE\", \n    color = NA, size = 1, alpha = 0.1\n  ) +\n  geom_mark_ellipse(\n    data = purplevalues, \n    aes(x = gdp_per_capita, y = consumption_co2_per_capita),\n    fill = \"#BF98C7\", \n    color = NA, size = 1, alpha = 0.1\n  ) +\n  coord_cartesian(\n    xlim = c(malawi_gdp, 150000),\n    ylim = c(0, 22),\n    clip = \"off\"\n  ) +\n  geom_curve(\n    aes(x = 0, xend = 0,\n        y = -5, yend = 0), \n    arrow = arrow(type = \"closed\",\n                  length = unit(0.15, \"inches\")), \n    color = \"#CC6677\", size = 1,\n    curvature = -0.5\n  ) +\n  geom_curve(\n    aes(x = 0, xend = 0,\n        y = -6, yend = 2.4),\n    arrow = arrow(type = \"closed\",\n                  length = unit(0.15, \"inches\")),\n    color = \"#E69F9C\",\n    size = 1,       \n    curvature = -0.5    \n  ) +\n  annotate(\"text\", x = 0, y = -5,\n           label = \"The goal to end climate change is to reduce net emissions to zero.\",\n           family = \"Verdana\",\n           size = 5.2, color = \"#4b4b4b\", hjust = 0) +\n  annotate(\"text\", x = 0, y = -6,\n           label = \"Reducing emissions to 2.4 tonnes per person would halve current levels (4.8t), a major milestone.\",\n           family = \"Verdana\",\n           size = 5.2, color = \"#4b4b4b\", hjust = 0) +\n  theme_minimal(base_family = \"Arial\") +\n  theme(\n    plot.title = element_text(\n      family = \"Times New Roman\", \n      hjust = 0, \n      size = 50, \n      margin = margin(t = 0, r = 1, b = 20, l = 0),\n      color = \"#555555\"\n    ),\n    plot.subtitle = element_text(\n      family = \"Verdana\", \n      hjust = 0,         \n      size = 30, \n      margin = margin(t = 15, r =0,b = 0, l = 0),  \n      color = \"#AA4499\"\n    ),\n    axis.title.x = element_text(\n      family = \"Verdana\",\n      color = \"gray50\",\n      size = 25\n    ),\n    axis.text = element_text(\n      color = \"gray50\",\n      size = 20\n    ),\n    axis.text.y = element_text(\n      color = \"#AA4499\",\n      size = 25\n    ),\n    legend.position = \"none\",\n    panel.grid.major = element_line(\n      color = \"gray80\",\n      linetype = \"dashed\"\n    ),\n    panel.grid.minor = element_line(\n      color = \"gray90\",\n      linetype = \"dotted\"\n    ),\n    plot.margin = margin(t = 15, r = 35, b = 100, l = 35)\n  )\n\nbetter_plot1 <- ggdraw(better_plot) +\n  draw_grob(logo_grob, x = 0.85, y = 0.89,\n            width = 0.18, height = 0.1)\n\nbetter_plot2 <- ggdraw() +\n  draw_plot(better_plot1) +\n  draw_label(\n    \"Data: Global Carbon Project, UN Population, and World Bank.\",\n    x = 0.02, y = 0.04, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"gray50\"\n  ) +\n  draw_label(\n    \"OurWorldinData.org\",\n    x = 0.02, y = 0.02, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"#326495\" \n  ) +\n  draw_label(\n    \"- Research and data to make progress against the world's largest problems.\",\n    x = 0.13, y = 0.02, \n    hjust = 0, fontfamily = \"Verdana\", size = 12, color = \"gray50\" \n  ) +\n  draw_label(\n    \"Licensed under CC-BY by the author Max Roser.\",\n    x = 0.48, y = 0.02, \n    hjust = -1, fontfamily = \"Verdana\", size = 12, color = \"gray50\"\n  )\n\nprint(better_plot2)\n\n\n\nAlthough the original plot was already a strong visual representation, several key improvements were made to enhance its effectiveness further. The adjustments focus on optimizing the clarity and accessibility of the chart without compromising its initial strengths. By refining label language, using a more color-blind friendly palette, and fine-tuning font sizes and contrasts, the plot becomes even more inclusive and easier to interpret for a wider audience. Additionally, the inclusion of reference lines provides clearer context for the data, helping viewers grasp key trends with greater ease. These enhancements ensure the chart is not only visually appealing but also more informative and accessible, making it a more powerful tool for communicating insights.\nAlternative Visualization\nFinally, as the third and last section related to the elaboration of graphs, we present a series of alternative visualizations in which, from the same data, we can generate attractive visualizations from another approach to the one proposed by OWID.\nScatter plot divided by continent\n\n\nggplot(co2data, aes(x = gdp_per_capita, y = consumption_co2_per_capita,\n                    color = continent)) +\n  geom_point(\n    alpha = 0.8, size = 5, shape = 21,  \n    fill = \"white\", stroke = 1.5\n  ) + \n  scale_x_log10(labels = scales::label_comma()) + \n  scale_y_continuous(labels = scales::comma_format()) +  \n  scale_color_manual(values = c(\n    \"Africa\" = \"#8e44ad\",       \n    \"Americas\" = \"#e74c3c\",      \n    \"Asia\" = \"#1abc9c\",         \n    \"Europe\" = \"#3498db\",        \n    \"Oceania\" = \"#f39c12\"\n  )) +  \n  facet_wrap(~ continent, scales = \"free_y\") +  \n  theme_minimal(base_family = \"Arial\") +  \n  theme(\n    plot.title = element_text(size = 30, face = \"bold\", color = \"#2c3e50\",\n                              hjust = 0.5, margin = margin(b = 20)),\n    axis.title.x = element_text(size = 17, color = \"#2c3e50\",\n                                face = \"bold\"),\n    axis.title.y = element_text(size = 17, color = \"#2c3e50\",\n                                face = \"bold\"),\n    axis.text = element_text(size = 12, color = \"#34495e\"),\n    axis.text.x = element_text(angle = 45, hjust = 1),  \n    strip.text = element_text(size = 16, face = \"bold\", color = \"#2c3e50\"),\n    legend.position = \"none\",  \n    panel.grid.major = element_line(color = \"gray80\", size = 0.5,\n                                    linetype = \"solid\"),  \n    panel.grid.minor = element_line(color = \"gray85\", size = 0.3,\n                                    linetype = \"dotted\"),\n    plot.margin = margin(t = 30, r = 20, b = 40, l = 20),  \n    panel.background = element_rect(fill = \"white\", color = \"white\"),\n    plot.caption = element_text(size = 15, face = \"bold\", color = \"#2c3e50\",\n                                hjust = 1, margin = margin(t = 20))\n  ) +\n  labs(\n    title = \"Relationship Between GDP per Capita and CO2 Consumption per Capita\",\n    x = \"GDP per Capita (log scale)\",\n    y = \"CO2 Consumption per Capita (tons)\",\n    caption = \"Source: UN and World Bank data compiled by Our World In Data.\"\n  ) +\n  geom_hline(\n    yintercept = mean(co2data$consumption_co2_per_capita, na.rm = TRUE), \n    color = \"#FF69B4\", linetype = \"longdash\"\n  ) +\n  geom_vline(\n    xintercept = mean(co2data$gdp_per_capita, na.rm = TRUE), \n    color = \"#32CD32\", linetype = \"longdash\"\n  ) +\n  geom_text_repel(\n    aes(label = country), \n    size = 5, box.padding = 0.5, max.overlaps = 10\n  )\n\n\n\nWhen comparing this scatter plot to the original plot from Our World in Data (OWID), it’s clear that while both visualizations share the basic concept of illustrating the relationship between GDP per capita and CO2 consumption per capita, there are notable differences in design and approach that significantly impact the clarity and interpretability of the data.\nThe OWID plot is a straightforward scatter plot with countries represented as points, but it does not incorporate the same level of information. One of the main differences lies in how the continents are handled. The OWID plot uses a global color palette that does not distinctly differentiate between continents, making it harder for viewers to quickly identify regional patterns. In contrast, the current plot employs a unique color for each continent, allowing for an immediate understanding of how each region performs in terms of GDP and CO2 consumption. This feature makes the current plot more user-friendly, especially for audiences trying to analyze continent-specific trends.\nAnother key difference is in the use of reference lines. The OWID scatter plot might include a general trend or average lines, but the current plot goes a step further by adding both vertical and horizontal dashed lines to indicate the mean GDP per capita and CO2 consumption per capita. These lines help contextualize the data, providing clear benchmarks for comparison across countries. In addition, the inclusion of labels for countries with geom_text_repel in the current plot ensures that individual countries are easily identifiable without overlapping labels, which is a common issue in crowded scatter plots.\nFrom a design perspective, the current plot also focuses on visual accessibility more than the OWID plot. The use of a logarithmic scale for GDP on the x-axis and a linear scale for CO2 consumption on the y-axis helps improve the readability of the data, particularly when dealing with large discrepancies in values. Additionally, adjustments to font size, color contrast, and grid lines enhance the plot’s visual hierarchy, ensuring that the information is accessible to a wider range of viewers, including those with visual impairments.\nIn summary, while the original OWID plot provides a solid foundation for visualizing the relationship between GDP and CO2 consumption, the current plot refines this concept by introducing key enhancements that improve its clarity, accessibility, and interpretability. These improvements make the plot not only more visually appealing but also more informative, ensuring that it effectively communicates the complex relationship between economic development and environmental impact across different continents.\nBox plot\n\n\nggplot(co2data, aes(x = continent, y = consumption_co2_per_capita,\n                    fill = continent)) +\n  geom_boxplot(\n    color = \"black\", \n    size = 1,      \n    outlier.colour = \"#e74c3c\", \n    outlier.size = 4,        \n    outlier.shape = 16,    \n    alpha = 0.8           \n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Africa\" = \"#a561a0\",       \n      \"Americas\" = \"#e16e6d\",      \n      \"Asia\" = \"#529a9d\",         \n      \"Europe\" = \"#6a778f\",        \n      \"Oceania\" = \"#a64f5a\"\n    )\n  ) +\n  theme_minimal(base_family = \"Verdana\") +  \n  theme(\n    plot.title = element_text(size = 24, face = \"bold\", color = \"#333333\",\n                              hjust = 0.5, margin = margin(b = 20)),\n    axis.title.x = element_text(size = 14, color = \"#555555\",\n                                face = \"bold\"),\n    axis.title.y = element_text(size = 14, color = \"#555555\",\n                                face = \"bold\"),\n    axis.text = element_text(size = 12, color = \"#555555\"),\n    axis.text.x = element_text(angle = 45, hjust = 1),  \n    legend.position = \"none\", \n    panel.grid.major = element_line(color = \"gray90\", size = 0.5,\n                                    linetype = \"dotted\"),\n    panel.grid.minor = element_line(color = \"gray95\", size = 0.3,\n                                    linetype = \"dotted\"),\n    plot.margin = margin(t = 30, r = 20, b = 40, l = 20),\n    plot.caption = element_text(size = 10, face = \"bold\", color = \"#2c3e50\",\n                                hjust = 1, margin = margin(t = 20))\n  ) +\n  labs(\n    title = \"Distribution of CO2 Consumption per Capita by Continent\",\n    x = \"Continent\",\n    y = \"CO2 Consumption per Capita (tons)\",\n    caption = \"Source: UN and World Bank data compiled by Our World In Data.\"\n  )\n\n\n\nThe box plot is another important visualization that will help to further explore the distribution of CO2 consumption per capita across continents. Unlike the scatter plot, which illustrates the relationship between GDP and CO2 consumption, the box plot will allow us to assess the spread, central tendency, and outliers of CO2 consumption within each continent.\nThis plot improves upon the simplicity of the OWID visualization by enhancing the visual clarity and providing more detailed information. The box plot will show the median, quartiles, and outliers for each continent, offering a clear view of how CO2 consumption is distributed within each region. By using distinct colors for each continent, we can easily compare the distribution patterns across different regions. The inclusion of outlier points—highlighted in red—will also help to emphasize countries that significantly deviate from the average CO2 consumption, making these outliers easier to identify at a glance.\nMoreover, the use of a clean, minimalist theme and appropriate font sizes and contrasts will ensure the box plot is visually accessible. This will make it easier for viewers to interpret the data, whether they are looking for general trends or specific country comparisons. The upcoming box plot will offer a clearer and more nuanced understanding of CO2 consumption per capita by continent, providing an important complement to the scatter plot.\nBar plot\n\n\nggplot(co2data, aes(x = continent, y = consumption_co2_per_capita,\n                    fill = continent)) +\n  geom_bar(\n    stat = \"identity\", position = \"stack\", color = \"white\", size = 1, \n    alpha = 0.9\n  ) +  \n  scale_fill_manual(values = c(\n    \"Africa\" = \"#a561a0\",       \n    \"Americas\" = \"#e16e6d\",      \n    \"Asia\" = \"#529a9d\",         \n    \"Europe\" = \"#6a778f\",        \n    \"Oceania\" = \"#a64f5a\"\n  )) +  \n  theme_minimal(base_family = \"Verdana\") +  \n  theme(\n    plot.title = element_text(size = 24, face = \"bold\", color = \"#333333\",\n                              hjust = 0.5, margin = margin(b = 20)),\n    axis.title.x = element_text(size = 14, color = \"#555555\",\n                                face = \"bold\"),\n    axis.title.y = element_text(size = 14, color = \"#555555\",\n                                face = \"bold\"),\n    axis.text = element_text(size = 10, color = \"#555555\"),\n    axis.text.x = element_text(angle = 45, hjust = 1),  \n    legend.title = element_text(size = 14, face = \"bold\",\n                                color = \"#333333\"),\n    legend.text = element_text(size = 12, color = \"#555555\"),\n    legend.position = \"none\",  \n    strip.text = element_text(size = 14, face = \"bold\", color = \"#333333\"),\n    panel.grid.major = element_line(color = \"gray90\", size = 0.5,\n                                    linetype = \"dotted\"),\n    panel.grid.minor = element_line(color = \"gray95\", size = 0.3,\n                                    linetype = \"dotted\"),\n    plot.margin = margin(t = 30, r = 20, b = 40, l = 20),\n    panel.background = element_rect(fill = \"white\", color = \"white\"),\n    plot.caption = element_text(size = 10, face = \"bold\", color = \"#2c3e50\",\n                                hjust = 1, margin = margin(t = 20))\n  ) +\n  labs(\n    title = \"Distribution of CO2 Consumption per Capita by Continent\",\n    x = \"Continent\",\n    y = \"CO2 Consumption per Capita (tons)\",\n    caption = \"Source: UN and World Bank data compiled by Our World In Data.\"\n  )\n\n\n\nThe bar plot serves as a powerful tool to provide a straightforward comparison of CO2 consumption per capita across continents. While the scatter and box plots give insight into relationships and distributions, the bar plot focuses on aggregating the data by continent, showing the average CO2 consumption per person in a more digestible format. By stacking the bars according to the continents and filling them with distinct colors, this visualization provides an immediate sense of which continents are leading or lagging in terms of CO2 consumption.\nThis plot improves upon the OWID visualization by presenting a more accessible summary of the data. The bar plot format allows for easy comparison between continents, and the consistent color scheme ensures that viewers can quickly distinguish each continent. The plot’s minimalist design, with its clear labels and organized legend, enhances readability, making it suitable for a broad audience, regardless of their familiarity with the dataset. By focusing on the aggregate CO2 consumption, this plot provides a quick overview of the data and complements the more granular insights from the scatter and box plots, ultimately helping to paint a fuller picture of global CO2 consumption trends.\nArea plot\n\n\nggplot(co2data, aes(x = gdp_per_capita, y = consumption_co2_per_capita,\n                    fill = continent)) +\n  geom_area(\n    alpha = 0.6,               \n    color = \"black\",           \n    size = 0.8                 \n  ) +\n  scale_x_log10(\n    breaks = c(2000, 5000, 10000, 20000, 50000, 100000),\n    labels = scales::dollar_format(accuracy = 1)\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Africa\" = \"#9b59b6\",       \n      \"Americas\" = \"#e74c3c\",      \n      \"Asia\" = \"#2ecc71\",         \n      \"Europe\" = \"#3498db\",        \n      \"Oceania\" = \"#f39c12\"\n    )\n  ) +\n  theme_minimal(base_family = \"Verdana\") +  \n  theme(\n    plot.title = element_text(\n      size = 26, face = \"bold\", color = \"#333333\", hjust = 0.5,\n      margin = margin(b = 20)\n    ),\n    axis.title.x = element_text(\n      size = 16, color = \"#555555\", face = \"bold\", margin = margin(t = 10)\n    ),\n    axis.title.y = element_text(\n      size = 16, color = \"#555555\", face = \"bold\", margin = margin(r = 10)\n    ),\n    axis.text = element_text(size = 14, color = \"#555555\"),\n    axis.text.x = element_text(angle = 45, hjust = 1),  \n    legend.title = element_blank(),  \n    legend.text = element_text(size = 14, color = \"#555555\"),  \n    legend.position = \"right\",  \n    panel.grid.major = element_line(color = \"gray90\", size = 0.5,\n                                    linetype = \"dotted\"),\n    panel.grid.minor = element_line(color = \"gray95\", size = 0.3,\n                                    linetype = \"dotted\"),\n    plot.margin = margin(t = 30, r = 20, b = 40, l = 20),\n    plot.caption = element_text(size = 12, face = \"bold\", color = \"#2c3e50\",\n                                hjust = 1, margin = margin(t = 20))\n  ) +\n  labs(\n    title = \"Comparing the distribution of CO2 consumption per capita across continents\",\n    x = \"GDP per Capita (int. -$)\",\n    y = \"CO2 Consumption per Capita (tons)\",\n    caption = \"Source: UN and World Bank data compiled by Our World In Data.\"\n  ) +\n  geom_hline(\n    yintercept = 0, color = \"black\", size = 0.8  \n  ) +\n  geom_smooth(\n    aes(group = continent), \n    method = \"loess\", \n    color = \"white\", \n    size = 1, \n    linetype = \"dashed\"  \n  )\n\n\n\nThe area plot presents a compelling visual representation of the relationship between GDP per capita and CO2 consumption per capita across continents. By using a smooth, continuous area chart, it effectively captures the overall distribution and trend, while providing a clear distinction between continents with the use of different fill colors. This plot not only showcases the differences between continents in terms of CO2 consumption but also highlights the trends within each continent with the added smoothed line, which helps identify patterns more easily.\nThe area plot stands out from other visualizations, such as scatter and box plots, by combining the advantages of displaying cumulative data and emphasizing trends. It offers a clear overview of how CO2 consumption varies with GDP per capita across regions, and it’s easier to interpret for audiences interested in understanding the broad, underlying patterns rather than focusing on individual data points or specific statistical measures.\nAmong all the visualizations, the area plot is arguably the best choice for this dataset. It effectively balances clarity and depth, making it an ideal choice for presenting the relationship between GDP and CO2 consumption in a visually engaging way. The smooth curves allow for a better understanding of the broader trends and distributions, while the area beneath the curve highlights the volume of CO2 consumption for each continent. The clear, distinct coloring by continent and the ability to compare multiple trends within one plot make it a powerful tool for both high-level analysis and deeper insights into the data. The design is aesthetically pleasing, and the use of a logarithmic scale for GDP per capita allows for a better understanding of how countries at different income levels relate to CO2 consumption.\nIn summary, the area plot excels in conveying the relationship between GDP and CO2 consumption per capita across continents in an intuitive, easy-to-understand format. Its ability to showcase trends, distributions, and variations makes it the most effective visualization option for this data.\nFinal considerations\nThis project of replicating and improving upon the original visualizations from Our World In Data has highlighted the immense value of effective data visualization in conveying complex datasets in an accessible and meaningful way. Data visualization plays a crucial role in transforming raw data into stories that are not only understandable but also insightful. Whether for an academic audience, policymakers, or the general public, the power of a well-constructed visual is unmatched in terms of both engagement and comprehension. The work done here, from the replication of the original scatter plot to the creation of alternative visualizations, underscores how visual design can make data more interpretable and persuasive.\nUsing ggplot2 as the primary tool for creating these visualizations has been instrumental in enhancing the overall quality of the work. ggplot2, part of the tidyverse in R, is an exceptional package for creating aesthetically pleasing and highly customizable graphics. The ease of integration with other tools and libraries within the R ecosystem has further enriched the overall workflow, ensuring that the visualizations were not only informative but also visually appealing and professional.\nThe process of improving the initial scatter plot and generating alternative visualizations, such as the box plot, bar plot, and area plot, has reinforced the idea that there is no one-size-fits-all solution in data visualization. Different types of plots serve different purposes, and their choice must be guided by the specific objectives of the analysis and the intended audience. The scatter plot provided a clear, precise look at the relationship between GDP per capita and CO2 consumption, but it lacked certain elements that could enhance clarity and accessibility. The introduction of custom labels, color-blind friendly palettes, reference lines, and annotations significantly improved the plot’s effectiveness. On the other hand, alternative visualizations like the area plot provided a clearer picture of the cumulative data and trends across continents, making it the best choice for a broader, more general audience.\nHowever, this work is not without areas for improvement. While the plots have been enhanced in terms of readability, accessibility, and visual appeal, future iterations could benefit from more interactivity. Adding interactive features through libraries like plotly would allow users to engage with the data, explore different regions, and zoom in on particular areas of interest. This would elevate the visualizations beyond static images and offer a richer, more immersive experience for the user. Furthermore, the addition of more explanatory elements, such as tooltips or legends that offer detailed context on the data points or trends, would make the visualizations even more informative.\nLooking ahead, there are several opportunities to build upon the work completed here. One potential direction is the integration of additional variables or datasets, such as energy consumption or population data, to deepen the analysis and explore how other factors might influence CO2 consumption. Additionally, comparing trends over time could provide an interesting dynamic, especially when considering global efforts to reduce emissions and transition to sustainable energy systems. Another avenue for future work would involve conducting more sophisticated statistical analyses, such as regression modeling or clustering, to uncover deeper insights from the data and visualize these findings in new ways.\nIn conclusion, the journey of replicating, improving, and expanding upon the original Our World In Data visualizations has been a highly valuable exercise. It has reinforced the importance of thoughtful and purposeful data visualization in enhancing comprehension and decision-making. The use of ggplot2 has been instrumental in bringing these visualizations to life, and the iterative process of improving upon the original plots has emphasized the significance of continuous refinement and thoughtful design.\n\n\n\n",
    "preview": "projects/2024/100529006/100529006_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 3072,
    "preview_height": 1920
  },
  {
    "path": "projects/2024/100535712/",
    "title": "Income inequality: Gini coefficient before and after tax",
    "description": "This project explains how to replicate and create an alternative version of a chart from Our World in Data about the difference in the Gini coefficient before and after the redistribution of taxes.",
    "author": [
      {
        "name": "David Pereiro-Pol",
        "url": {}
      }
    ],
    "date": "2024-12-27",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nOriginal chart\nGetting started\nPackages and fonts\nGetting the data\nCleaning the data\n\nReplicating the chart\nCoordinates and axes\nDiagonal lines\nPoints and legends\nLabels\nPopulation legend, line and logo\nTitle and annotations\nFinal result\n\nAlternative version\nOriginal chart problems\n\n\nOriginal chart\nEach year Our World in Data updates the graph that is being used as the principal inspiration for this project. This visualization shows the difference caused by the redistribution of taxes in the Gini coefficient which is a measure of statistical dispersion that represents the income inequality within a nation. After applying taxes and transfers, the Gini coefficient tends to be reduced since redistribution is usually progressive, resources flow from rich to poor people.\nIn this graph, the Gini coefficient before taxes is represented in the x-axis and after taxes in the y-axis. Each country is shown as a point that changes its size depending on the population and its color depending on its continent. Those countries that are closer to the coordinates (0, 0) are in a better situation in terms of income inequality. Moreover, the reduction caused by taxes can be seen in this chart thanks to the inclusion of different lines that indicate how much the Gini coefficient have been reduced due to the redistribution system.\nGini graph. Source: Our World in Data.Getting started\nPackages and fonts\nFirstly, we have to upload all the packages needed to replicate this graph and also the fonts that will be used. For the font part we will be using sysfonts package to retrieve them from Google Fonts and showtext to activate them.\n\n\nlibrary(tidyverse)\nlibrary(readr)\nlibrary(ggtext)\nlibrary(geomtextpath)\nlibrary(scales)\nlibrary(ggrepel)\nlibrary(ggnewscale)\nlibrary(ggthemes)\nlibrary(ggiraph)\nlibrary(grid)\nlibrary(patchwork)\nlibrary(glue)\n\n\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair\")\nsysfonts::font_add_google(\"Lato\", family=\"lato\")\nsysfonts::font_add_google(\"Roboto\", family=\"roboto\")\nshowtext::showtext_auto() \n\n\nGetting the data\nThe data needed to replicate the graph can be downloaded from the graph page. By analyzing its structure we can see that the data set is conformed by 78936 observations and 7 variables. This huge amount of observations, taken into account that we are working with country data, is due to the fact that for each country the year variable takes values from -10000 to 2100. Besides the variable year, we have a variable for the name of the country and other for the code of each country, two variables for the Gini coefficient, one for the population and another for the continent.\n\n\ngini <- read_csv(file = \"data/gini_data.csv\")\n\n# Cleaning the names\n\ngini <- gini |>\n  rename(\n    \"pre_tax_gini\" = paste(\"10.4.2 - Redistributive impact of\",\n    \"fiscal policy, Gini index (%) - SI_DST_FISP - Prefiscal income\"),\n    \"post_tax_gini\" = paste(\"10.4.2 - Redistributive impact of\",\n     \"fiscal policy, Gini index (%) - SI_DST_FISP - Postfiscal\",\n     \"disposable income\")\n  ) |>\n  janitor::clean_names()\n\ngini\n\n# A tibble: 78,936 × 7\n   entity code    year post_tax_gini pre_tax_gini population continent\n   <chr>  <chr>  <dbl>         <dbl>        <dbl>      <dbl> <chr>\n 1 Abkha… OWID…   2015            NA           NA         NA Asia\n 2 Afgha… AFG   -10000            NA           NA      14737 <NA>\n 3 Afgha… AFG    -9000            NA           NA      20405 <NA>\n 4 Afgha… AFG    -8000            NA           NA      28253 <NA>\n 5 Afgha… AFG    -7000            NA           NA      39120 <NA>\n 6 Afgha… AFG    -6000            NA           NA      54166 <NA>\n 7 Afgha… AFG    -5000            NA           NA      75000 <NA>\n 8 Afgha… AFG    -4000            NA           NA     306250 <NA>\n 9 Afgha… AFG    -3000            NA           NA     537500 <NA>\n10 Afgha… AFG    -2000            NA           NA     768750 <NA>\n# ℹ 78,926 more rows\n\nCleaning the data\nDuring the data cleaning process, we have encountered two significant challenges. The first issue was the limited availability of Gini coefficient data for many countries, with data often being provided for only one or a few years. To address this, the creators of the graph chose to include countries with sparse Gini data in charts spanning five years before and five years after the available data point. For example, a country with data available only for 2013 would be represented in the graphs from 2008 to 2018. The “solution” that they did was not included in the data set, so to address this problem and imitate the distribution of the graphs we created a function that replicate the Gini values five years in the past and five years in the future.\n\n\nreplicate_values <- function(x) {\n  j <- 0 # We initialize this variable here to verify the first\n  # condition in the beginning of the for loop\n  for (i in 1:length(x)) {\n    if (!is.na(x[i]) & i >= j) {  # We check if there is a\n      # NA and we put i >= j to continue in the point in which\n      # the while loop ended\n      j <- i + 1 # We change the value of j to start the while\n      # loop in the following iteration\n      count <- 0 # To count the next 5 positions\n      while (j <= length(x) && count < 5 && is.na(x[j])) { # To change\n        #possible NA\n\n        if (!is.na(x[j])) break # If there is not a NA break\n\n        x[j] <- x[i] # Change the NA with the previous value\n\n        j <- j + 1\n\n        count <- count + 1\n      }\n    }\n  }\n\n  j <- length(x) + 1 # We do the same but backwards\n  for (i in length(x):1) {\n    if (!is.na(x[i]) & i <= j) {\n      j <- i - 1\n      count <- 0\n      while (j >= 1 && count < 5 && is.na(x[j])) {\n        if (!is.na(x[j])) break\n        x[j] <- x[i]\n        j <- j - 1\n        count <- count + 1\n      }\n    }\n  }\n  return(x)\n}\n\n## Replication of data to simulate the original distribution of the data\ngini_w_replicate <- gini |>\n  group_by(entity) |>\n  mutate(\n    pre_tax_gini = replicate_values(pre_tax_gini),\n    post_tax_gini = replicate_values(post_tax_gini)\n  ) |>\n  ungroup()  \n\n\nThe second one was that the name of the continent of each country only was in the year 2015 observation, so we had to expand that variable for each country. We also deleted the observations that did not have any Gini data.\n\n\n## Replicate the continent and drop NA\n\ngini_tidy <- gini_w_replicate |>\n  group_by(entity) |>\n  fill(continent, .direction = \"downup\") |>\n  ungroup() |>\n  drop_na(post_tax_gini, pre_tax_gini)\n\n\nSince the graph that we are replicating is the one from the 2020, we filtered the data for that year.\n\n\n# Gini 2020\n\ngini_tidy_2020 <- gini_tidy |>\n  filter(year == 2020)\n\ngini_tidy_2020\n\n# A tibble: 87 × 7\n   entity  code   year post_tax_gini pre_tax_gini population continent\n   <chr>   <chr> <dbl>         <dbl>        <dbl>      <dbl> <chr>\n 1 Argent… ARG    2020         0.418        0.477   45191960 South Am…\n 2 Armenia ARM    2020         0.287        0.333    2890894 Asia\n 3 Austra… AUS    2020         0.309        0.403   25743787 Oceania\n 4 Austria AUT    2020         0.274        0.418    8921402 Europe\n 5 Belarus BLR    2020         0.267        0.292    9350943 Europe\n 6 Belgium BEL    2020         0.261        0.412   11540103 Europe\n 7 Bolivia BOL    2020         0.451        0.462   11816300 South Am…\n 8 Brazil  BRA    2020         0.521        0.585  208660845 South Am…\n 9 Bulgar… BGR    2020         0.410        0.451    6933654 Europe\n10 Cambod… KHM    2020         0.322        0.324   16725482 Asia\n# ℹ 77 more rows\n\nReplicating the chart\nCoordinates and axes\nOnce that we have cleaned the data, the first step is to set the axis and the skeleton of our graph. For this we have to set the x-axis for the pre tax Gini and the y-axis for the post tax Gini.\n\n\n## Structure\n\np <- ggplot(gini_tidy_2020) +\n  aes(x = pre_tax_gini, y = post_tax_gini)\n\np\n\n\n\nNow we have to adjust the coordinates. Note that in the original graph the origin of the chart was set in (0.2, 0.2) and without any expansion, so we have to set the limits correctly and we have to delete the default expansion that ggplot sets. Besides, we have to eliminate the minor grid since it is not displayed in the original chart.\n\n\np <- p +\n  scale_x_continuous(limits = c(0.2,0.749),\n                            minor_breaks = NULL,\n                            expand = expansion(0)) +\n  scale_y_continuous(limits = c(0.2, 0.660),\n                     minor_breaks = NULL,\n                     expand = expansion(0))\np\n\n\n\nNow we have to change the appearance of the axis to simulate the original one. For that, we will set theme_minimal because it provides us a similar background and we will change the type and color of the major grid.\n\n\np <- p + theme_minimal() +\n  theme(\n        panel.grid.major = element_line(color = \"#dddddd\",\n                                        linetype = \"dashed\",\n                                        linewidth = 0.3\n                                        ),\n        plot.margin = margin(7,2,7,7),\n        plot.background = element_rect(fill = \"white\", color = NA)\n        )\n\np\n\n\n\nDiagonal lines\nThe next step will be to add the diagonal lines that indicate the level of reduction of the Gini coefficient. This one was a problem during the replication process. Initially, the lines were added with geom_abline and to include the text we were going to use annotate changing the angle argument, but the text did not correctly match the line. After some research, we found a package called geom_textpath that include the function geom_textabline, this function includes both the text and the line, but because of the different colors between the text and the line we have to include both functions, geom_abline and geom_textabline to obtain a better result. However, by using geom_abline we could not set clip = “off” in coord_cartesian to include the logo and the population legend, so, at the end we used annotate to create a finite segment and geaom_textabline.\n\n\nxmax <- 0.749\nymax <- 0.660\n\np <- p  + \n  annotate(\"segment\", \n           x = 0.2, y = 0.2, \n           xend = min(xmax, 0.2 + (ymax - 0.2)), \n           yend = min(ymax, 0.2 + (xmax - 0.2)), \n           color = \"#dddddd\", \n           linetype = \"dashed\", \n           linewidth = 0.3) +\n  annotate(\"segment\", \n           x = 0.3, y = 0.2, \n           xend = min(xmax, 0.3 + (ymax - 0.2) / (2/3)), \n           yend = min(ymax, 0.2 + (xmax - 0.3) * (2/3)), \n           color = \"#dddddd\", \n           linetype = \"dashed\", \n           linewidth = 0.3) +\n  annotate(\"segment\", \n           x = 0.4, y = 0.2, \n           xend = min(xmax, 0.4 + (ymax - 0.2) / (1/2)), \n           yend = min(ymax, 0.2 + (xmax - 0.4) * (1/2)), \n           color = \"#dddddd\", \n           linetype = \"dashed\", \n           linewidth = 0.3) + \n  geom_textabline(slope = 1, intercept = 0,\n                  label = \"No reduction\",\n                  linetype = \"blank\",\n                  size = 2.5, \n                  family = \"sans\",\n                  hjust = 0.83,\n                  color = \"grey70\") +\n  geom_textabline(slope = 1 / 2, intercept = 0,\n                  label = \"Reduce by a half\",\n                  linetype = \"blank\",\n                  size = 2.5, \n                  family = \"sans\",\n                  hjust = 0.82,\n                  color = \"grey70\") +\n  geom_textabline(slope = 2 / 3, intercept = 0,\n                  label = \"Reduce by a third\",\n                  linetype = \"blank\",\n                  size = 2.5, \n                  family = \"sans\",\n                  hjust = 0.86,\n                  color = \"grey70\") \n\np\n\n\n\nPoints and legends\nSince we have already set the background of the chart, now we can add the points, we have to put the variables population and continent to the size and fill aesthetics, respectively. The colors were obtained by using the ImageColor Picker site.\n\n\ncon_colors <- c(\"#a2559c\", \"#00847e\",\n                \"#4c6a9c\", \"#e56e5a\",\n                \"#9a5129\", \"#883039\")\n\np <- p + geom_point(aes(size = population,\n                        fill = continent),\n                        alpha = 0.75,\n                        shape = 21, stroke = 0.5)  +\n  scale_fill_manual(values = con_colors) \n\np\n\n\n\nTo change the format of the two legends we have to use the function guides in combination with the argument override.aes, by doing so we are able to change both legends independently. We deleted the size legend to later add the custom population legend. In this step, besides changing the legends, we are also adjusting the size of the points to better fit the original one.\n\n\np <- p + guides(fill = guide_legend(order = 1, \n                                    theme = theme(\n        legend.title = element_blank(),\n        legend.key.height = unit(0.3, \"cm\"),\n        legend.text = element_text(family = \"lato\",\n                                   size = 8, \n                                   margin = margin(l = 0))),\n        override.aes = list(shape = 15, \n                            size = 2,\n                            color = con_colors\n                            )),\n        size = \"none\") + \n  theme(legend.justification = c(\"right\", \"top\"),\n        legend.box = \"vertical\",\n        legend.spacing.y = unit(0.1, \"cm\")) +\n  scale_size(breaks = c(1e08, 3e08), \n             labels = label_number(scale = 1e-6, suffix = \"M\"), \n             range = c(0.5, 9))\n        \np\n\n\n\nLabels\nTo add the country labels, we are going to create an additional table in which we will reduce the number of countries per continent to minimize the overlaps. If we do not add this step, we will not see any names in the middle part of the graph since there are a lot of European countries and because of the huge amount of overlaps those labels will not appear.\n\n\ngini_labels <- gini_tidy_2020 |>\n  slice_sample(prop = -0.5, by = continent) \n\n\nIn the original chart the labels also vary their size depending on the population, so, since we have already set an scale for the size before, we will be using the function new_scale from the package ggnewscale that allow us to introduce new values for the labels’ scale. In addition, to better control the overlapping we have to use geom_text_repel, the segment.color argument let us erase the segment between the label and the point and the bg.color and the bg.r arguments allow us to add some white padding behind the letters.\n\n\np <- p + \n  new_scale(\"size\") + \n  geom_text_repel(aes(label = entity,\n                              color = continent,\n                              size = population),\n                          segment.color = NA,\n                          max.overlaps = 7,\n                          show.legend = FALSE, \n                          nudge_x = 0.01,\n                          bg.color = \"white\",\n                          bg.r = 0.15,\n                          data = gini_labels) +\n  scale_size(range = c(2.5, 3.5)) +\n  scale_color_manual(values = con_colors)\n\np\n\n\n\nPopulation legend, line and logo\nIf we check the original plot we can observe that there are a line, that is between the two legends, the logo of Our World in Data and a particular legend for the population. For the line and the logo, we combine some functions of the grid package such as rasterGrob and linesGrob with annotation_custom and for the population legend, we created an additional graph and we used inset_element from patchwork to include it. The legend will be included in the last step.\n\n\nimage_grob <- rasterGrob(png::readPNG(\"Our_World_in_Data_logo.png\"), \n                         x = 1, y = 1,  \n                         hjust = 1, vjust = 1, \n                         width = unit(0.2, \"npc\"))\nlegend <- ggplot() +\n  lims(y = c(0.9, 1)) +\n  annotate(\"point\", x = 1, y = 0.95, \n           size = 10, color = \"grey80\", \n           shape = 21) +\n  annotate(\"point\", x = 1, y = 0.9561,\n           size = 5, color = \"grey80\",\n           shape = 21) +\n  annotate(\"text\",  \n           x = 1, y = 0.94, size = 2.5,\n           color = \"grey30\",\n           family = \"sans\",\n           label=\"300M\") + \n  annotate(\"text\",  \n           x = 1, y = 0.95, size = 2,\n           color = \"grey30\",\n           family = \"sans\",\n           label=\"100M\") + \n  annotate(\"richtext\",\n           x = 1, y = 0.962, \n           label = \"Circles sized by <br>**Population**\",\n           hjust = 0.5, \n           vjust = 1, \n           family = \"lato\",\n           size = 2.5, \n           color = \"#636363\",\n           fill = NA, \n           label.color = NA) +\n  theme_void() +\n  theme(plot.margin = margin(50, 50, 50, 50)) \n\np <- p + \n  annotation_custom(image_grob, \n                      xmin = 0.59, xmax = 0.89,\n                      ymin = 0.62, ymax = 0.74) +\n  annotation_custom(grob = linesGrob(gp = gpar(col = \"grey90\", lwd = 1)),  \n    xmin = 0.785, xmax = 0.89, \n    ymin = 0.53, ymax = 0.53) + \n  coord_cartesian(clip = \"off\") \np\n\n\n\nTitle and annotations\nLastly, we have to put the title, the subtitle and the caption using the proper fonts and size. We have obtained the family font by using the MyFonts site.\n\n\ntitle_rep <- \"Income inequality: Gini coefficient before and after tax, 2020\"\n\nsubtitle_rep <- \n  paste(\"Inequality is measured in terms of the Gini coefficient of\",\n        \"income before taxes on the horizontal axis and after<br>taxes on the\",\n        \"vertical axis\")\n\ncaption_rep <- \"**Data source** : World Bank\"\n\ntag_rep <- \"OurWorldinData.org/economic-inequality | CC BY\"\n\np <- p + labs(title = title_rep,\n              subtitle = subtitle_rep,\n              caption = caption_rep,\n              tag = tag_rep,\n              x = \"Before tax\",\n              y = \"After tax\") +\n  theme(plot.title = element_text(face = \"bold\",\n                                  family = \"playfair\",\n                                  size = 14,\n                                  color = \"#636363\"),\n        plot.title.position = \"plot\",\n        plot.subtitle = element_markdown(size = 8.5,\n                                                 color = \"#636363\",\n                                                 family = \"lato\"),\n        axis.title = element_text(size = 7.5,\n                                  color = \"#636363\",\n                                  family = \"lato\"),\n        axis.text = element_text(size = 7.5,\n                                 color = \"#636363\",\n                                 family = \"lato\"),\n        plot.caption = element_markdown(size = 7.5,\n                                        color = \"#636363\",\n                                        hjust = 0,\n                                        family = \"lato\"),\n        plot.caption.position = \"plot\",\n        plot.tag = element_markdown(size = 7.5,\n                                    color = \"#636363\",\n                                    hjust = 1,\n                                    family = \"lato\"),\n        plot.tag.position = c(1,0.012)) +\n  inset_element(legend, align_to = \"plot\", left = 1.15, bottom = 0.66,\n                  right = 1.15, top = 0.66)\n\n\nFinal result\nHere we can observe the final result of the replication.\n\n\n\nAlternative version\nOriginal chart problems\nThe original graph provides a good visualization of the differences in the Gini coefficient. However, if we want to compare one country to others or examine the extent of the reduction in the Gini coefficient, the original representation is not the most effective choice.\nFor these reasons, a lollipop chart offers a clearer way to visualize differences across countries. It also allows us to observe each country’s position after tax redistribution.\nIn this alternative version, we have labeled the thirty countries with the most significant reductions in their Gini coefficients to emphasize that tax redistribution has a substantial impact on reducing inequality in Europe. Additionally, by leveraging the ggiraph package, we have added an interactive feature to this graph. This allows users to explore and identify the names, the population and the Gini reduction of other countries displayed.\n\n\ngini_lollipop <- gini_tidy_2020 |> \n  mutate(entity = fct_reorder(entity, desc(post_tax_gini))) |> \n  mutate(difference = pre_tax_gini - post_tax_gini) |> \n  mutate(tooltip = glue(\n      \"Country: {entity}<br>\n      Population: {population}<br>\n      Gini reduction: {round(difference, 4)}\"))\n\nhigh_difference <- gini_lollipop |> \n  slice_max(difference, n = 30)\n\nglobal_mean_pre <- mean(gini_lollipop$pre_tax_gini)\nglobal_mean_post <- mean(gini_lollipop$post_tax_gini)\n\ntitle_alt <- \"Tax redistribution notably <b>reduces<\/b> income inequality\"\nsubtitle_alt <- \n  paste(\"Country data available from  <span\",\"style='color:#E69F00'>\",\n        \"Asia<\/span>, <span style='color:#000000'>Africa<\/span>,\",\n        \"<span style='color:#56B4E9'>Europe<\/span>,\",\n        \"<span style='color:#009E73'>North America<\/span>,\",\n        \"<span style='color:#CC79A7'>Oceania<\/span>,\",\n        \"and <span style='color:#0072B2'>South America<\/span>\", \n        \"<br>shows that taxes reduce the Gini coefficient in all of them.\")\ny_alt <- paste(\"Gini coefficient <span style='color:#7570B3'>\",\n              \"post taxes<\/span> and <span style='color\", \n              \":#aeb370'> pre taxes<\/span>\")\ncaption_alt <- \"**Data source** : World Bank\"\nlabel_alt <- paste(\"Labeled points show <br>the 30 countries\", \n                   \"<br>with bigger reductions <br>of their\", \n                   \"Gini coefficients. <br>Note the the majority\",\n                   \"of <br>them are from <span\",\n                   \"style='color:#56B4E9;'>Europe<\/span>\")\n\n\n\n\nlolli <- gini_lollipop |> \n  ggplot() + \n  geom_segment_interactive( aes(x = entity, xend = entity,y = post_tax_gini,\n                      yend = pre_tax_gini, color = continent, tooltip = tooltip), \n                linewidth  = 1.5,\n                alpha = 0.6) +\n  geom_point_interactive(aes(x=entity, y=pre_tax_gini, tooltip = tooltip), \n             size=2, \n             color=\"#aeb370\") +\n  geom_point_interactive(aes(x=entity, y=post_tax_gini, tooltip = tooltip), \n             size=2, \n             color=\"#7570B3\") +\n  coord_flip() +\n  theme_minimal() +\n  scale_y_continuous(sec.axis = dup_axis()) +\n  theme(axis.text.y  = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"none\") +\n  geom_hline(yintercept = global_mean_pre,\n             linetype = \"dotted\",\n             alpha = 0.6,\n             color = \"#aeb370\") +\n  geom_hline(yintercept = global_mean_post,\n             linetype = \"dotted\",\n             alpha = 0.6,\n             color = \"#7570B3\") + \n  geom_hline(yintercept = 0,\n             linetype = \"dotted\",\n             alpha = 0.6) +\n  scale_color_manual(values = c(\n    \"Asia\" = \"#E69F00\",\n    \"Africa\" = \"#000000\",\n    \"Europe\" = \"#56B4E9\",\n    \"North America\" = \"#009E73\",\n    \"Oceania\" = \"#CC79A7\",  \n    \"South America\" = \"#0072B2\"\n  )) + \n  annotate(\"text\",  \n           x = 8, y = global_mean_post - 0.01, angle = 90, \n           size = 3, family = \"sans\",\n           label=\"Global mean post taxes\") + \n  annotate(\"text\",  \n           x = 8, y=global_mean_pre - 0.01, angle = 90,\n           size = 3, family = \"sans\",\n           label=\"Global mean pre taxes\") + \n  annotate(\"text\",  \n           x = 43, y = -0.01, angle = 90, size = 3,\n           family = \"sans\",\n           label=\"Perfect income equality\") + \n  geom_text(aes(x = entity, \n                      y = post_tax_gini, \n                      label = entity,\n                      color = continent), \n                  size = 2,\n                  family = \"sans\",\n                  hjust = 0.75,\n                  nudge_y = -0.025,\n                  data = high_difference) +\n  annotate(\"segment\", \n           x = 43, xend = 43, \n           y = 0.2 , yend = 0.1, \n           linewidth=0.3, \n           arrow = arrow(length = unit(0.3, \"cm\"), type = \"open\")) +\n  annotate(\"segment\", \n           x = 43, xend = 43, \n           y = 0.6 , yend = 0.7,  \n           linewidth=0.3, \n           arrow = arrow(length = unit(0.3, \"cm\"), type = \"open\")) +\n  annotate(\"text\",  \n           x = 41, y = 0.65,  \n           size = 3, family = \"sans\",\n           label=\"More \\ninequality\") +\n  annotate(\"text\",  \n           x = 41, y = 0.15,  \n           size = 3, family = \"sans\",\n           label=\"Less \\ninequality\") +\n  annotate(\"richtext\",\n           x = 75, y = 0.65, \n           label = label_alt,\n           hjust = 0.5, \n           vjust = 1, \n           family = \"sans\",\n           size = 3, \n           fill = NA, \n           label.color = NA ) + \n  labs(title = title_alt,\n       subtitle = subtitle_alt,\n       y = y_alt,\n       caption = caption_alt) +\n  theme(plot.title = element_markdown(,\n                                  family = \"sans\",\n                                  size = 15),\n        plot.subtitle = element_markdown(size = 10,\n                                                 family = \"sans\"),\n        axis.title = element_markdown(size = 8,\n                                                 family = \"sans\"),\n        axis.title.y = element_blank(),\n        plot.caption = element_markdown(size = 7.5,\n                                                hjust = 0,\n                                                family = \"sans\"),\n        plot.title.position = \"plot\",\n        plot.caption.position = \"plot\",\n        legend.position = \"none\")\n\ninteractive_plot <- girafe(ggobj = lolli, height_svg = 10)\n\ntooltip_css <- glue(\"background-color: #2C3E50;\n  color: #ECF0F1;\n  padding: 10px;\n  border-radius: 5px;\n  font-family: 'Arial', sans-serif;\n  font-size: 14px;\n  box-shadow: 0px 0px 10px rgba(0,0,0,0.5);\")\n\ninteractive_plot <- girafe_options(\n  interactive_plot,\n  opts_tooltip(css = tooltip_css, use_fill = FALSE),\n  opts_selection(type = \"multiple\", only_shiny = FALSE),\n  opts_zoom(min = 0.5, max = 2),\n  opts_sizing(rescale = TRUE))\n\ninteractive_plot\n\n\n\n\n\n\n",
    "preview": "projects/2024/100535712/100535712_files/figure-html5/unnamed-chunk-17-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 2100,
    "preview_height": 1365
  },
  {
    "path": "projects/2024/100536195/",
    "title": "The economic balance of the Olympic Games",
    "description": "This project aims at the reproduction of a graph displaying the costs and revenues of each summer and winter Olympic Games from 1964 to 2022.",
    "author": [
      {
        "name": "Irene García-Espantaleón",
        "url": {}
      }
    ],
    "date": "2024-12-24",
    "categories": [
      "2024"
    ],
    "contents": "\n\nContents\nDisclaimer\nOriginal graphs\nUpload\nPreparing the dataset\nPlot functions\nAlternative visualizations\nFaceted plots\nInteractive plot\nGeom path\n\n\nDisclaimer\nThis is a preliminary version of my project for the course on Data Visualization. While the main aspects of the analysis have been addressed, the accompanying text is not fully developed, as most explanations and observations are currently embedded within the code chunks. This version is intended to gather feedback and will have to be revised based on comments or suggestions. Despite these limitations, the key elements of the project have been included to demonstrate its structure and primary insights.\nOriginal graphs\nThe original graphs that will be the focus of this project were retrieved from an article by El Orden Mundial. They represent different categories of costs and revenues for each edition of summer and winter Olympic Games from 1964 to 2022 through stacked bars. The balance of each of these games is represented through yellow points, with the actual values printed next to them.\n\n\nUpload\nThe first step is to upload all the libraries that will be used for the representation and alternative visualization of the graph.\n\n\nlibrary(tidyr)\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(shadowtext)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(scales)\nlibrary(ggnewscale)\nlibrary(readxl)\nlibrary(ggrepel)\nlibrary(ggpubr)\n\n\nThe next step is importing the database, which was available at Harvard Dataverse (https://doi.org/10.7910/DVN/CPQEHN). The original Excel file was explored to check what rows and columns were needed. With this step, the last part of the data set, containing information on Football World Cups, was excluded.\n\n\ndata <- read_excel(\n  path = \"olympicgames.xlsx\",\n  range = \"A1:AC31\", skip = 2)\n\n\nThe google fonts that will be used are then included.\n\n\nsysfonts::font_add_google(\"Fira Sans Condensed\", family = \"fira_sans_condensed\")\nsysfonts::font_add_google(\"Lato\", family = \"lato\")\n\nshowtext_auto()\n\n\nThe following code allows to upload the El Orden Mundial logo which will be printed in the reproduced plots.\n\n\nlibrary(png)\nlibrary(grid)\nget_png <- function(filename) {\n  grid::rasterGrob(png::readPNG(filename), interpolate = TRUE)\n}\n\nlogo <- get_png(\"logo_eom.png\")\n\n\nPreparing the dataset\nThe original Excel file was far from clean, so it required considerable preprocessing.\n\n\ndf <- data |>\n  rename(city_year = 3) |> # this column has a very long name from the original excel\n  select(city_year, ends_with(\"2018)\")) |> # these are all the columns we need\n  drop_na() # the first row is all NAs from the excel's format,\n#I drop them here bc before selecting the right columns, there were NAs in every row.\n\ndf <- df |> \n  separate(city_year, into = c(\"year\", \"city\"), sep = \" \", extra = \"merge\")\n\ndf[1, \"year\"] <- \"1964\"\ndf[1, \"city\"] <- \"Tokyo\" # these two were misnamed from the original excel\n\n# renaming the columns, using the positions because they have long and complicated names\ndf <- df |> \n  rename(ticketing_revenue = 3, broadcast_revenue = 4, international_spons_revenue = 5, \n         domestic_spons_revenue = 6, venues_cost = 7, organisation_cost = 8)\n\n# changing the cells from \"No domestic sponsorship\" to zero, so we can add international and domestic\n# sponsorship revenues, which are not separated in the original graph,\n# then making it numeric because it was stored as character\n\ndf <- df |> \n  mutate(\n    domestic_spons_revenue = as.numeric(ifelse(domestic_spons_revenue == \"No domestic sponsorship\",\n                                    0, domestic_spons_revenue)))\n\n# converting it all to millions of USD to make reading easier   \n\ndf <- df |> \n  mutate(\n    across(\n      c(\"ticketing_revenue\":\"organisation_cost\"),\n      ~ . / 1e6\n    ))\n \n# making costs negative\n\ndf <- df |> \n  mutate(\n    venues_cost = -venues_cost,\n    organisation_cost = -organisation_cost\n  )\n\n# creating a variable for the total sponsorship revenues and relocating it after international\n# and domestic, then dropping international and domestic columns\n\ndf <- df |>\n  mutate(\n    sponsorship_revenue = international_spons_revenue + domestic_spons_revenue\n  ) |>\n  relocate(sponsorship_revenue, .before = venues_cost) \n\ndf <- df |> \n  select(-c(international_spons_revenue, domestic_spons_revenue))\n\n# creating a variable for the balance:\n\ndf <- df |> mutate(balance = rowSums(across(c(\"ticketing_revenue\":\"organisation_cost\"))))\n\n\n# translating the names to Spanish for the replication\n\ndf <- df |>\n  mutate(city = case_when(\n    city == \"Tokyo\" ~ \"Tokio\",\n    city == \"Mexico City\" ~ \"Cdad. México\",\n    city == \"Munich\" ~ \"Múnich\",\n    city == \"Moscow\" ~ \"Moscú\",\n    city == \"Los Angeles\" ~ \"Los Ángeles\",\n    city == \"Seoul\" ~ \"Seúl\",\n    str_starts(city, \"Barcelona\") ~ \"Barcelona\", # some rows still have long names\n    city == \"Sydney\" ~ \"Sídney\",\n    city == \"Athens\" ~ \"Atenas\",\n    city == \"Beijing\" ~ \"Pekín\",\n    city == \"London\" ~ \"Londres\",\n    str_starts(city, \"Rio\") ~ \"Río de Janeiro\",\n    city == \"Turin\" ~ \"Turín\",\n    str_starts(city, \"PyeongChang\") ~ \"Pyeongchang\", \n    TRUE ~ city\n  ))\n\n# adding the data for Tokyo 2020 and Beijing 2022 manually from a different dataset, because they were missing in the main one\n\ndf <- df |> add_row(\n  year = \"2020\", city = \"Tokio\", ticketing_revenue = 0, broadcast_revenue = 2800, sponsorship_revenue = 3600, \n  venues_cost = -7200, organisation_cost = -6600, balance = -6814, .after = 14)\n\ndf <- df |> add_row(\n  year = \"2022\", city = \"Pekín\", ticketing_revenue = 0,\n  broadcast_revenue = 1146, sponsorship_revenue = 1910,\n  venues_cost = -2920, organisation_cost = -3256, balance = -3120,\n  .after = 30)\n\n\n# pivoting to make it tidy data\n\ntidydf <- df |> \n  pivot_longer(cols = c(\"ticketing_revenue\":\"balance\"),\n               names_to = \"type\", values_to = \"value\")\n\n# creating the season variable\n\ntidydf <- tidydf |> \n  mutate(\n    season = case_when(\n      row_number() <= 90 ~ \"summer\",  # rows 1 to 90 are summer games\n      row_number() > 90 ~ \"winter\"    # rows 91 onwards are winter games\n    ))\n\n# adding a new variable to categorize as \"Gastos\" or \"Ingresos\" in the legend\ntidydf <- tidydf |> \n    mutate(\n         category = case_when(\n         type %in% c(\"organisation_cost\", \"venues_cost\") ~ \"Gastos\",\n         type %in% c(\"ticketing_revenue\", \"broadcast_revenue\", \"sponsorship_revenue\") ~ \"Ingresos\",\n         type %in% \"balance\" ~ \"Balance\",\n         TRUE ~ NA_character_))\n\n# converting the type variable to factor to be able to order the stacked areas\n\ntidydf <- tidydf |> \n  mutate(type = factor(type, \n                       levels = c(\"sponsorship_revenue\",  # Topmost\n                                  \"broadcast_revenue\", \n                                  \"ticketing_revenue\", \n                                  \"organisation_cost\",\n                                  \"venues_cost\", # Bottommost\n                                  \"balance\")))\n\n# making the years numeric because they were stored as character\n\ntidydf$year <- as.numeric(tidydf$year)\n\n# setting the hjust and vjust aesthetics directly in the dataset\n\ntidydf <- tidydf |> \n  mutate(city_year = paste(city, \" (\", year, \")\", sep = \"\"))\n\n\ntidydf <- tidydf |> \n  mutate(\n    hjust_balance = case_when(\n      city %in% c(\"Los Ángeles\", \"Atlanta\", \"Sídney\", \"Sarajevo\", \"Vancouver\") ~ -0.35, # Right of positive balances\n      city %in% c(\"Atenas\", \"Londres\", \"Sochi\") ~ 0.5, # Centered\n      city %in% c(\"Montreal\", \"Seúl\", \"Turín\") ~ 0.8,\n      city_year %in% c(\"Tokio (2020)\", \"Pekín (2022)\") ~ 0.5,\n      TRUE ~ 1.3 # Left of negative balances\n    ),\n    vjust_balance = case_when(\n      city %in% c(\"Seúl\", \"Atenas\", \"Londres\", \"Sochi\", \"Turín\") ~ -1.3, # Above the point\n      city == \"Montreal\" ~ 2.1, # Below the point\n      city_year %in% c(\"Tokio (2020)\", \"Pekín (2022)\") ~ -1.3,\n      TRUE ~ 0.45)) # Aligned with the point\n\n\nPlot functions\nThe first graph contains information on summer olympics, so the dataset must be filtered in order to plot just that data.\n\n\nplot <-\n  ggplot(tidydf |> filter(season == \"summer\")) +\n  # Stacked bars for revenues and costs\n      geom_bar(\n    data = tidydf |>  filter(season == \"summer\" & type != \"balance\" & category == \"Gastos\"),\n    aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = type),\n    stat = \"identity\",\n    width = 0.32) +\n    scale_fill_manual(\n      values = c(\n      \"organisation_cost\" = \"#b5251e\",\n      \"venues_cost\" = \"#f1a47e\"\n    ),\n      labels = c(\n      \"organisation_cost\" = \"Organización\",\n      \"venues_cost\" = \"Sedes\"\n    ),\n      name = \"Gastos\",\n      guide = guide_legend(order = 2, byrow = TRUE)\n    ) +\n         new_scale_fill() +\n       geom_bar(\n        data = tidydf |>  filter(season == \"summer\" & type != \"balance\" & category == \"Ingresos\"),\n        aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = type),\n        stat = \"identity\",\n        width = 0.32) +\n        scale_fill_manual(\n          values = c(\n          \"ticketing_revenue\" = \"#b1e2e8\",\n          \"broadcast_revenue\" = \"#7cbece\",\n          \"sponsorship_revenue\" = \"#2d8eae\"),\n          labels = c(\n          \"ticketing_revenue\" = \"Entradas\",\n          \"broadcast_revenue\" = \"Derechos de emisión\",\n          \"sponsorship_revenue\" = \"Publicidad\"\n        ),\n          name = \"Ingresos\",\n      guide = guide_legend(order = 3, byrow = TRUE)\n        ) +\n  # The new scale ensures that the balance is included in the legend\n    new_scale_fill() + \n  # Add the balance as a yellow dot\n  geom_point(data = tidydf |> filter(season == \"summer\" & category == \"Balance\"), \n             aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = category),\n             color = \"black\", size = 2.9, stroke = 0.55, shape = 21) +\n    scale_fill_manual(\n    values = c(\"Balance\" =\"#fec90c\"),\n      guide = guide_legend(order = 1)  # Control the order of the legend\n  ) +\n  # City names\n  geom_text(\n    data = tidydf |> filter(season == \"summer\"),\n    aes(\n      x = 0, \n      y = reorder(city_year, year, decreasing = TRUE), \n      label = city_year,\n      hjust = 0.5,  \n      vjust = -1.52\n    ),\n    family = \"lato\",\n    size = 6.5,\n      color = \"#4f4f4f\",\n    fontface = \"plain\",\n    show.legend = FALSE\n  ) +\n  # Add the balance next to the yellow point\n  geom_shadowtext(\n    data = tidydf |> filter(season == \"summer\" & type == \"balance\"),\n    aes(x = value, y = reorder(city_year, year, decreasing = TRUE),\n        label = scales::label_number(big.mark = \".\", decimal.mark = \",\")(round(value, 0)),\n        family = \"lato\",\n        hjust = hjust_balance,\n        vjust = vjust_balance),\n    size = 6.2,\n    fontface = \"italic\",\n    color = \"#918e8e\",\n    bg.colour = \"white\",\n    bg.r = 0.18\n ) + \n  # Title, subtitle and caption\n    labs(\n    title = \"El balance económico de los Juegos Olímpicos de verano\",\n    subtitle = \"Millones de dólares de 2018\",\n    x = NULL,\n    y = NULL,\n    fill = NULL,\n    caption = \"Autor: Álvaro Merino (2024) | Fuente: Harvard Dataverse (2022) y COI (2024)\"\n  ) +\n    \n  # Theme adjustments\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title = element_text(\n      family = \"fira_sans_condensed\",\n      size = 23,  \n      color = \"#1c1c1c\",\n      margin = margin(t = 2.5, b = 0.5)\n      ),\n    plot.subtitle = element_text(family = \"fira_sans_condensed\",\n     size = 21, \n     color = \"#757372\", \n     margin = margin(t = 2, b = 0)\n     ),\n    legend.title = element_text(family = \"lato\", size = 19, face = \"bold\", margin = margin(b = 3)),\n    legend.text = element_text(family = \"lato\", size = 19, margin = margin(b = 0, l = 3.5)),\n    legend.position = c(0, 1),\n    legend.justification = c(0, 1),  \n    legend.margin = margin(c(6.5, 1, 0, 7)),\n    legend.spacing = unit(0, \"cm\"),\n    legend.key.spacing.y = unit(0.07, \"cm\"),\n    legend.key.height = unit(0.25, \"cm\"),  \n    legend.key.width = unit(0.28, \"cm\"),\n    legend.box.spacing = unit(0, \"cm\"),\n    legend.box.margin = margin(c(12, 0, 0, 5)),\n    plot.caption = element_text(family = \"lato\", hjust = 0, size = 16.5, margin = margin(t = 14)),\n    plot.margin = margin(t = 5, b = 7, l = 5, r = 5),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_text(family = \"lato\", color = \"#918e8e\",\n                               face = \"italic\", size = 21, margin = margin(t = 3.5)),\n    axis.ticks.x = element_line(color = \"#7d7d7d\"),\n    axis.ticks.length.x = unit(0.22, \"cm\")\n    \n  ) +\n  # Set x-axis scale to go from -15000 to 10000\n  scale_x_continuous(\n    limits = c(-15000, 15000),\n    breaks = seq(-15000, 10000, by = 5000),\n  # Remove minus signs only for negative values\n    labels = function(x) {\n      ifelse(x == 15000, \"\", \n             scales::label_number(big.mark = \".\", decimal.mark = \",\")(ifelse(x < 0, abs(x), x)))  \n    }\n  ) +\n  scale_y_discrete(expand = expansion(mult = c(0.025, 0.05)))\n\n\nOnce the plot is stored as an object, it can be printed alongside the logo.\n\n\nplot +\n  annotation_custom(logo, xmin = 11000, xmax = 16850, ymin = 15.3, ymax = 16.85) +\n  coord_cartesian(clip = \"off\")\n\n\n\nThe next code is practically identical to the previous one, but filtering out the summer games and leaving only the winter editions.\n\n\nplot_winter <-\n  ggplot(tidydf |> filter(season == \"winter\")) +\n  geom_bar(\n    data = tidydf |>  filter(season == \"winter\" & type != \"balance\" & category == \"Gastos\"),\n    aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = type),\n    stat = \"identity\",\n    width = 0.33) +\n  scale_fill_manual(\n    values = c(\n      \"organisation_cost\" = \"#b5251e\",\n      \"venues_cost\" = \"#f1a47e\"\n    ),\n    labels = c(\n      \"organisation_cost\" = \"Organización\",\n      \"venues_cost\" = \"Sedes\"\n    ),\n    name = \"Gastos\",\n    guide = guide_legend(order = 2, byrow = TRUE)\n  ) +\n  new_scale_fill() +\n  geom_bar(\n    data = tidydf |>  filter(season == \"winter\" & type != \"balance\" & category == \"Ingresos\"),\n    aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = type),\n    stat = \"identity\",\n    width = 0.33) +\n  scale_fill_manual(\n    values = c(\n      \"ticketing_revenue\" = \"#b1e2e8\",\n      \"broadcast_revenue\" = \"#7cbece\",\n      \"sponsorship_revenue\" = \"#2d8eae\"),\n    labels = c(\n      \"ticketing_revenue\" = \"Entradas\",\n      \"broadcast_revenue\" = \"Derechos de emisión\",\n      \"sponsorship_revenue\" = \"Publicidad\"\n    ),\n    name = \"Ingresos\",\n    guide = guide_legend(order = 3, byrow = TRUE)\n  ) +\n  \n  new_scale_fill() +\n  geom_point(data = tidydf |> filter(season == \"winter\" & category == \"Balance\"), \n             aes(x = value, y = reorder(city_year, year, decreasing = TRUE), fill = category),\n             color = \"black\", size = 3.1, stroke = 0.7, shape = 21) +\n  scale_fill_manual(\n    values = c(\"Balance\" =\"#fec90c\"),\n    guide = guide_legend(order = 1)  \n  ) +\n  geom_text(\n    data = tidydf |> filter(season == \"winter\"),\n    aes(\n      x = 0, \n      y = reorder(city_year, year, decreasing = TRUE), \n      label = city_year,\n      hjust = 0.5,  \n      vjust = -1.66\n    ),\n    family = \"lato\",\n    size = 7.7,\n    color = \"#4f4f4f\",\n    fontface = \"plain\",\n    show.legend = FALSE\n  ) +\ngeom_shadowtext(\n    data = tidydf |> filter(season == \"winter\" & type == \"balance\"),\n    aes(x = value, y = reorder(city_year, year, decreasing = TRUE),\n        label = scales::label_number(big.mark = \".\", decimal.mark = \",\")(round(value, 0)),\n        family = \"lato\",\n        hjust = hjust_balance,\n        vjust = vjust_balance),\n    size = 7.2,\n    fontface = \"italic\",\n    color = \"#918e8e\",\n    bg.colour = \"white\",\n    bg.r = 0.16\n  ) +\n  labs(\n    title = \"El balance económico de los Juegos Olímpicos de invierno\",\n    subtitle = \"Millones de dólares de 2018\",\n    x = NULL,\n    y = NULL,\n    fill = NULL,\n    caption = \"Autor: Álvaro Merino (2024) | Fuente: Harvard Dataverse (2022) y COI (2024)\"\n  ) +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title = element_text(\n      family = \"fira_sans_condensed\",\n      size = 27,  \n      color = \"black\",\n      margin = margin(t = 3, b = 0.5) \n    ),\n    plot.subtitle = element_text(family = \"fira_sans_condensed\",\n                                 size = 25,  \n                                 color = \"#757372\",\n                                 margin = margin(t = 2, b = 0)\n    ),\n    legend.title = element_text(family = \"lato\", size = 23, face = \"bold\", margin = margin(b = 3)),\n    legend.text = element_text(family = \"lato\", size = 23, margin = margin(b = 0, l = 3.5)),\n    legend.position = c(0, 1),\n    legend.justification = c(0, 1),\n    legend.margin = margin(c(6.5, 1, 0, 7)),\n    legend.spacing = unit(0.1, \"cm\"),\n    legend.key.spacing.y = unit(0.07, \"cm\"),\n    legend.key.height = unit(0.17, \"cm\"),\n    legend.key.width = unit(0.3, \"cm\"),\n    legend.box.spacing = unit(0.08, \"cm\"),\n    legend.box.margin = margin(c(13, 0, 0, 5)),\n    plot.caption = element_text(family = \"lato\", hjust = 0, size = 19, margin = margin(t = 14)),\n    plot.margin = margin(t = 5, b = 7, l = 5, r = 5),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid = element_blank(),\n    axis.text.y = element_blank(),\n    axis.text.x = element_text(family = \"lato\", color = \"#918e8e\",\n                               face = \"italic\", size = 21, margin = margin(t = 3.5)),\n    axis.ticks.x = element_line(color = \"#918e8e\"),\n    axis.ticks.length.x = unit(0.22, \"cm\")\n  ) +\n  scale_x_continuous(\n    limits = c(-16000, 15000),\n    breaks = seq(-15000, 10000, by = 5000),\n    labels = function(x) {\n      ifelse(x == 15000, \"\", \n             scales::label_number(big.mark = \".\", decimal.mark = \",\")(ifelse(x < 0, abs(x), x))) \n      }\n  ) +\n  scale_y_discrete(expand = expansion(mult = c(0.03, 0.05)))\n\n\nThis code prints the winter plot with the EOM logo just as the summer one, but in a slightly different position.\n\n\nplot_winter +\n  annotation_custom(logo, xmin = 11000, xmax = 16850, ymin = 16, ymax = 18.2) +\n  coord_cartesian(clip = \"off\")\n\n\n\nThe shortcomings identified in these two replicas are:\nThe years of each edition between parentheses should be in italics. However, what is printed in the plot is not the actual text, but the values of the column “city_year”. Even if I pasted the values of “city” and “year” into the label, I could not figure out how to give each of them different formats.\nSome parts of the text printed in the original graphs have a lighter or semi-bold face that could not be achieved using Google fonts.\nAlternative visualizations\nFaceted plots\nFor the alternative visualization of the original graphs, I focused on the comparison between summer and winter Olympic Games, which would allow to combine the information of two independent plots in one. I also wanted to highlight the evolution of each type of cost and revenue, as well as the balance, which is ultimately a summary of them.\n\n\nalt_plot <-\n  tidydf |> filter(type == \"balance\") |> \nggplot(aes(\n      x = year, \n      y = value, \n      color = season,\n      group = season,\n      text = paste(\"Edition:\", city_year,\n                   \"\\nValue:\", round(value, 2),\n                   \"\\nSeason:\", season))) +\n  geom_hline(yintercept = 0, color = \"darkgray\", linetype = \"solid\", linewidth = 0.6) +\n  geom_line() +\n  geom_point() +\n    scale_color_manual(\n    values = c(\"summer\" = \"#e68211\", \"winter\" = \"#2b83ba\"),\n    labels = c(\"summer\" = \"Summer Games\", \"winter\" = \"Winter Games\"),\n    name = \"\"\n  ) +\n  geom_label_repel(\n    aes(label = paste0(city, \" '\", substr(year, 3, 4))),\n    # hjust = -0.1, # Adjust the position of the text horizontally\n    label.size = NA,\n    #  angle = 45,\n    show.legend = FALSE,\n    alpha = 0.8,\n    label.padding = 0.2,\n    size = 4,\n    force = 2,\n    force_pull = 4,\n    box.padding = 0.3\n  ) +\n  labs(\n    x = NULL,\n    y = \"Millions of 2018 USD\",\n    title = \"Economic evolution of the Summer and Winter Olympic Games\",\n    subtitle = \"Balance\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 20, face = \"bold\"),\n    plot.subtitle = element_text(size = 15, margin = margin(t = 5)),\n    axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5),\n    axis.text.y = element_text(size = 14),\n    axis.title.y = element_text(size = 14),\n    legend.position = c(0.2, 0.2),\n    legend.text = element_text(size = 14),\n    legend.spacing = unit(0.2, \"cm\"),\n    legend.spacing.y = unit(0, \"cm\"),\n    legend.spacing.x = unit(0, \"cm\"),\n    legend.key.size = unit(0.3, \"cm\"),\n    panel.grid.minor.y = element_blank()\n  )\n\n\n\n\n# rounding the value to show two decimals, making the costs positive again\ntidydf <- tidydf |> \n  mutate(value_rcd = round(abs(value), 2))\n\n# cleaning up the names of each type of cost or revenue for the plot facets\n\ntidydf <- tidydf |>\n  mutate(type_rcd = case_when(\n    type == \"ticketing_revenue\" ~ \"Ticketing revenues\",\n    type == \"broadcast_revenue\" ~ \"Broadcast revenues\",\n    type == \"sponsorship_revenue\" ~ \"Sponsorship revenues\",\n    type == \"organisation_cost\" ~ \"Organisation costs\",\n    type == \"venues_cost\" ~ \"Venues costs\",\n    TRUE ~ type\n  ))\n\n# reordering the type variable for the facets\n\ntidydf <- tidydf |> \n  mutate(type_rcd = factor(type_rcd, \n                     levels = c(\"Sponsorship revenues\",\n                                \"Broadcast revenues\", \n                                \"Ticketing revenues\", \n                                \"Organisation costs\",\n                                \"Venues costs\",\n                                \"balance\")))\n\n# plotting the facets\n\nalt_facet <- tidydf |> filter(type != \"balance\") |>\n  ggplot(\n    aes(\n      x = year,\n      y = value_rcd,\n      group = season,\n      color = season,\n      text = paste(\"Edition:\", city_year,\n                   \"\\nValue:\", value_rcd,\n                   \"\\nSeason:\", season))\n  ) +\n  geom_rect(aes(fill = category), xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf,\n            color = NA,\n            alpha = 0.05) +\n  geom_hline(yintercept = 0, color = \"darkgray\", linetype = \"solid\", linewidth = 0.4) +\n  geom_line(size = 0.5) +\n  geom_point(size = 1.4) +\n  scale_color_manual(\n    values = c(\"summer\" = \"#e68211\", \"winter\" = \"#2b83ba\"),\n    labels = c(\"summer\" = \"Summer Games\", \"winter\" = \"Winter Games\"),\n    name = \"\"\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Ingresos\" = \"#c8ffc2\",\n      \"Gastos\" = \"#fcdcca\",   \n      \"Balance\" = \"#d8eafd\"   \n    ),\n    name = \"Category\"\n  ) +\n  labs(\n    title = \"\",\n    x = NULL,\n    y = NULL,\n    fill = \"\"\n  ) +\n  facet_wrap(~type_rcd, nrow = 5, scales = \"free_y\") +\n  theme_minimal(base_size = 12) +\n  theme(\n    plot.title = element_blank(),\n    plot.subtitle = element_blank(),\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"#eeeeee\"),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid = element_blank(),\n    strip.text = element_text(size = 14),\n    axis.text.x = element_text(size = 14, hjust = 0.5),\n    axis.text.y = element_text( \n       size = 14,\n      face = \"plain\")\n    )\n\n\nWe can arrange these two plots together in a single graph.\n\n\nggarrange(alt_plot, alt_facet, widths = c(6, 2.5), common.legend = FALSE)\n\n\n\nI chose to position the labels around the points so as not to have a very crowded x-axis. However, there are many labels and in some cases they overlap or are confusingly identified with their data points.\nInteractive plot\nLastly, we can merge the last two graphs into an interactive plot. This involves some trade-offs: the legend is dropped, text labels are excluded, colored backgrounds disappear, as well as the plot’s subtitle, labels’ size is seriously distorted… The main payoff is that we can display the most relevant information about each data point without resulting in a very cluttered or messy graph.\n\n\nplotly::subplot(plotly::ggplotly(alt_plot, tooltip = \"text\"), \n                plotly::ggplotly(alt_facet, tooltip = \"text\"), \n                widths = c(0.6, 0.4))\n\n\n\nGeom path\nAnother alternative is to plot a path.\n\n\npath_df <- tidydf |> select(year, city, type, value, season)\n\npath_df <- path_df |> pivot_wider(\n  names_from = type,\n  values_from = value\n)\n\npath_df <- path_df |> mutate(\n    revenues = ticketing_revenue + broadcast_revenue + sponsorship_revenue,\n    costs = abs(venues_cost + organisation_cost)\n    ) |> \n  select(year, city, season, revenues, costs)\n\npath_df <- path_df |> \n  mutate(\n    city = case_when(\n      city == \"Tokio\" ~ \"Tokyo\",\n      city == \"Cdad. México\" ~ \"Mexico City\",\n      city == \"Múnich\" ~ \"Munich\",\n      city == \"Moscú\" ~ \"Moscow\",\n      city == \"Los Ángeles\" ~ \"Los Angeles\",\n      city == \"Seúl\" ~ \"Seoul\",\n      city == \"Sídney\" ~ \"Sydney\",\n      city == \"Atenas\" ~ \"Athens\",\n      city == \"Pekín\" ~ \"Beijing\",\n      city == \"Londres\" ~ \"London\",\n      city == \"Río de Janeiro\" ~ \"Rio de Janeiro\",\n      city == \"Turín\" ~ \"Turin\",\n      TRUE ~ city \n      )\n  )\n\npath_df <- path_df |> mutate(\n  vjust_city = case_when(\n      city == \"Tokyo\" & year == 2020 ~ -0.6,\n      city %in% c(\"Montreal\", \"Seoul\", \"Athens\", \"Mexico City\", \"Moscow\") ~ -0.6,\n      city %in% c(\"Tokyo\", \"Los Angeles\", \"Barcelona\", \"Atlanta\", \"Beijing\",\n                  \"Rio de Janeiro\") ~ 1.3,\n \n      TRUE ~ 0),\n  hjust_city = case_when(\n     city %in% c(\"Munich\", \"London\") ~ 1.1,\n     city %in% c(\"Rio de Janeiro\", \"Sydney\", \"Moscow\", \"Mexico City\") ~ -0.1,\n     TRUE ~ 0.5)\n  )\n\nggplot(path_df |> filter(season == \"summer\")) +\n  aes(x = revenues, y = costs, color = year) +\n  geom_point() +\n  geom_path(arrow = arrow(\n    angle = 15, type = \"closed\",\n    length = unit(0.1, \"inches\")\n  )) +\n  geom_text(aes(label = city,\n                vjust = vjust_city,\n                hjust = hjust_city),\n    show.legend = FALSE,\n    alpha = 0.8,\n    size = 5,\n    ) +\n  scale_color_viridis_c() +\n  geom_abline(slope = 1, intercept = 0, linetype = \"dashed\", color = \"gray\") +\n  labs(\n    title = \"Economic evolution of the summer Olympic Games\",\n    subtitle = \"Millions of 2018 USD\",\n    x = \"Revenues\",\n    y = \"Costs\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 20, face =\"bold\"),\n    plot.subtitle = element_text(size = 18),\n    legend.position = \"right\",\n    legend.justification = c(0, 1),\n    legend.title = element_text(size = 14),\n    legend.text = element_text(size = 14),\n    axis.text.x = element_text(size = 12),\n    axis.text.y = element_text(size = 12),\n    axis.title.x = element_text(size = 12),\n    axis.title.y = element_text(size = 12))\n\n\n\nThis plot allows us to track the evolution of the relationship between costs and revenues of the summer games. We can observe that both dimensions tend to increase overtime, most notably costs. Furthermore, we can quickly check what editions had a positive or negative balance. I did not manage to place annotations above and below the abline to clarify what data points in each area of the graph represent positive or negative balances.\n\n\n\n",
    "preview": "projects/2024/100536195/100536195_files/figure-html5/winter_logo_print-1.png",
    "last_modified": "2025-01-17T11:48:23+01:00",
    "input_file": {},
    "preview_width": 1380,
    "preview_height": 1728
  },
  {
    "path": "projects/2023/100485846/",
    "title": "Seizures of Ammunition and Arms by Country 2017",
    "description": "A brief report based on UNs 2020 Global Study on Firearms Trafficking.",
    "author": [
      {
        "name": "Mecki Hamed-Guerrero",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nWorking with the data\nLibraries and dataset\nData cleaning process\n\nBuilding the graph\nFirst replica\nEdition and color\nFinal graph\nLimitations\n\nImprovements\nFinal Map\nAnalysis and results\nMeso-America and South-America\nMediterrenean Sea\n\nFurther research\n\nIntroduction\nThe illicit trade of weapons is a pervasive issue with far-reaching\nconsequences, intertwining elements of politics, society, and\ninternational relations. The trafficking of arms fuels conflicts,\nexacerbates human suffering, and poses a significant threat to global\nsecurity.\nArms trafficking knows no borders, infiltrating regions plagued by\npolitical instability and social unrest. The consequences are dire, as\nthese weapons often fall into the hands of non-state actors,\nperpetuating violence and hindering efforts for peace. The intertwined\nnature of this problem reflects the complex web of international\nrelations, where the actions of one nation can have ripple effects\nacross the globe.\nTackling the issue of arms trafficking requires a multi-faceted\napproach, involving collaboration between nations, strong regulations\nand a commitment to addressing the root causes of conflict. It also\nrequires information to enable institutions to fully address the issue.\nThis is where data becomes necessary.\nEstablishing a relationship between the different types of arms\ntrafficking that exist and the conflicts that are currently taking place\ncan be very useful in understanding and addressing this phenomenon.\nCreating a model that can explain the dynamics of arms (and components)\ntrafficking at the regional level would provide researchers and\ndecision-makers with a powerful tool to understand and prevent this\nmenace.\nThat is why the intention of this paper will be to plot the ratio of\nammunition seizures in relation to the number of arms seizures on a\nworld map. The motivation for this work lies in the intention to\nidentify regional trafficking dynamics around existing conflicts.\nThe original graph\nThe original graph can be found on page 29 of the UNODC Global Study on\nFirearms Trafficking 2020.\nThe graph to be replicated is Figure 11.\nThe graph shows the relationship between ammunition seizures and weapons\nseizures per country in 2017. The X-axis represents the countries in\nwhich seizures occurred, and the Y-axis represents the ratio of seized\nrounds of ammunition to seized arms (in a logarithmic scale). The graph\nalso has a line at the value 1 for the Y-axis, which indicates the\nboundary between a positive and a negative ratio. Similarly, the graph\nhas a horizontal line above the median value (23), and a space dedicated\nto the common range.\nCountries above the ratio = 1 are those where ammunition trafficking is\nhigher than arms trafficking. This could indicate the presence of arms\nfrom previous conflicts and belonging to already armed groups, which\nrequire more ammunition than arms.\nConversely, where the ratio is < 1, a process of internal rearmament\nmay be taking place. This is probably due to the involvement of third\nstates in the financing of paramilitary or terrorist groups.\nOriginal Source: UNODC Global Study on Firearms Trafficking 2020.Working with the data\nThe database to be used comes from the UNODC (United Nations Office on\nDrugs and Crime) and can be found on the following link: UNODC Firearms\nTrafficking Dataset\nThe dataset contains Categories relating to the ‘Region’, ‘Subregion’\nand ‘Country’. Similarly, the dataset contains information relating to\nthe ‘Source’ that made the seizure and the year in which the seizure was\nmade (2010 to 2020). Also, the dataset contains a specific category,\n‘Indicator’, which gives information about the type of seizure\n(ammunition or arms). Finally, the dataset contains two more important\ncollumns: ‘Dimension’, which explains the reason of the seizured; and\n’Category, which indicates the illegal use of the equipment seized.\nHowever, the dataset lacks the data that the UNODC appears to use to\ndraft the aforementioned Global Study on Firearms Trafficking 2020. For\nthis reason, the scope of the work will be reduced to the information\navailable.\nLibraries and dataset\nThe following libraries will be utilized throughout the entire project,\nencompassing both the replica and subsequent enhancements:\n\n\nlibrary(datapasta)\nlibrary(tibble)\nlibrary(tidyr)\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(rnaturalearth)\nlibrary(rnaturalearthdata)\nlibrary(sf)\nlibrary(RColorBrewer)\n\n\nDue to the fact that the first two columns of the chosen dataset\nprovides no information at all, we will load the .xlsx without them.\n\n\ndata <- read_excel(\"data_iafq_firearms_trafficking.xlsx\", skip=2)\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… other   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… unknown \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Altered…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n6 AGO       Angola  Africa Sub-Saharan A… Individu… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nData cleaning process\nFirst of all:\nThe column “Year” represents the year of the record in the database.\nSince our chart to be replicated relies on data for the year 2017, we\nwill select only records produced in that year.\n\n\ndata <- data[data$Year == 2017, ]\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Ammuniti… Total     Total   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Total   \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… Total   \n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… unknown…\n6 AGO       Angola  Africa Sub-Saharan A… Arms sei… by condi… Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nSecondly:\nThe column “Indicator” indicates whether the data belongs to “Arms\nseized” or “Parts and components seized”. So we must filter the dataset\nso that it contains only these two values:\n\n\ndata <- data |>\n  filter(Indicator %in% c(\"Arms seized\", \"Ammunition seized\"))\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Ammuniti… Total     Total   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Total   \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… Total   \n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… unknown…\n6 AGO       Angola  Africa Sub-Saharan A… Arms sei… by condi… Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nThirdly:\nSince the columns “Dimension” and “Category” segment the total seizures\ninto different subdivisions, we are interested in showing only the sum\ntotal of each of the columns. i.e. those values recorded as ‘Total’, in\nboth columns:\n\n\ndata <- data |>\n  filter(Dimension == \"Total\" & Category == \"Total\")\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country      Region Subregion Indicator Dimension Category\n  <chr>     <chr>        <chr>  <chr>     <chr>     <chr>     <chr>   \n1 AGO       Angola       Africa Sub-Saha… Ammuniti… Total     Total   \n2 AGO       Angola       Africa Sub-Saha… Arms sei… Total     Total   \n3 ALB       Albania      Europe Southern… Arms sei… Total     Total   \n4 ARG       Argentina    Ameri… Latin Am… Ammuniti… Total     Total   \n5 ARG       Argentina    Ameri… Latin Am… Arms sei… Total     Total   \n6 ATG       Antigua and… Ameri… Latin Am… Arms sei… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nFourth:\nWe convert the information in the “VALUE” column (total number of\nseizures) to a numerical value:\n\n\ndata$VALUE <- as.numeric(data$VALUE)\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country      Region Subregion Indicator Dimension Category\n  <chr>     <chr>        <chr>  <chr>     <chr>     <chr>     <chr>   \n1 AGO       Angola       Africa Sub-Saha… Ammuniti… Total     Total   \n2 AGO       Angola       Africa Sub-Saha… Arms sei… Total     Total   \n3 ALB       Albania      Europe Southern… Arms sei… Total     Total   \n4 ARG       Argentina    Ameri… Latin Am… Ammuniti… Total     Total   \n5 ARG       Argentina    Ameri… Latin Am… Arms sei… Total     Total   \n6 ATG       Antigua and… Ameri… Latin Am… Arms sei… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nFifthly:\nWe proceed to calculate the ratio of “Ammunition seized” to “Arms\nseized”, under the previously established conditions.\n\n\nratiocalc <- data |>\n  group_by(data$Country) |>\n  reframe(\n    ratio = VALUE[Indicator == \"Ammunition seized\"] / VALUE[Indicator == \"Arms seized\"])\nhead(ratiocalc)\n\n# A tibble: 6 × 2\n  `data$Country`    ratio\n  <chr>             <dbl>\n1 Algeria        189.    \n2 Angola           6.48  \n3 Argentina        0.0310\n4 Australia      187.    \n5 Azerbaijan      20.7   \n6 Brazil          76.6   \n\nBuilding the graph\nFirst replica\nWe proceed to create a first plot with the most basic information.\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\"\n  ) \n\n\n\nWe then proceed to add both the value relative to the median and a\nhorizontal line at the value 1 for the Y-axis, which will allow us to\nbetter differentiate countries above and below the ratio = 1.\nSimilarly, we can calculate the ‘common range’ and plot it on the graph.\n\n\nmediana <- median(ratiocalc$ratio)\n\ncuartil_ratio <- quantile(ratiocalc$ratio, c(0.25, 0.75))\n\nrango_intercuartil_ratio <- cuartil_ratio[2] - cuartil_ratio[1]\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\"\n  ) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\")  +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) \n\n\n\nFrom here we proceed to modify the aesthetic section of the graphic:\nEdition and color\nThe first modification consists of applying ‘theme_minimal()’ to the\ngraph. We will also add a title to it.\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) \n\n\n\nNext we will change the format of the text displayed on the X and Y\naxes. Similarly, we rotate the names on the X-axis by 90º, in order to\nmake our graphics clearer.\n\n\n  ggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n    geom_col() +\n    scale_y_continuous(labels = function(x) 10^x/100) +\n    labs(x = ' ',\n         y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n    ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n    theme_minimal() +\n    scale_fill_manual(values = c(\"blue\")) +\n    theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n    theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n    geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n    geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\") +\n    annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003)  +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))\n\n\n\nNow, we can proceed to the introduction of aesthetic elements related to\ncolour.\nIn this section we are interested in modifying: The background colour,\nthe colour of the bars and the colour of the line relative to the ratio\n= 1.\nIn the same way, we will proceed in framing the graph:\n\n\n  ggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col(width = 0.5, fill = \"#D2691E\", position = \"identity\") +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"blue\")) +\n  theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n  theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"solid\", size = 1, color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"solid\", size = 1, color = \"black\") +\n  annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003)  +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  theme(panel.background = element_rect(fill = \"lightgrey\"),\n        plot.background = element_rect(fill = \"white\"))\n\n\n\nNext, we remove the grid from the bottom of the graph, leaving us with\nour final replica.\nFinal graph\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col(width = 0.5, fill = \"#D2691E\", position = \"identity\") +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"blue\")) +\n  theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n  theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"solid\", size = 1, color = \"red\") +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) +\n  annotate(\"segment\", x = -0.1, y = log10(100), xend = -0.1, yend = log10(1000), linetype = \"solid\") +\n  geom_hline(yintercept = log10(100), linetype = \"solid\", size = 1, color = \"black\") +\n  annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  theme(panel.background = element_rect(fill = \"#EEE9E9\"),\n        plot.background = element_rect(fill = \"white\")) +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())\n\n\n\nLimitations\nWhile this graph represents an extremely clear identification of those\ncountries that are on either side of the ratio = 1, this information is\nalmost useless for gaining a regional (or global) understanding of the\nrelationships between countries where arms trafficking occurs, their\nneighbours, and the regional circumstances that may cause this (regional\nconflicts, paramilitary groups, etc.).\nIt is for this reason that I consider that the best possible improvement\nto be made to this graph would be to transfer its data to a world map.\nImprovements\nTo convert the information of our dataset we must use the functions\nrelated to the ‘rnaturalearth’ library, creating variables that\nrepresent in R our world map.\nSubsequently, we will establish relationships between the variables\n‘Country’ and the variable ‘Ratio’, since they are the ones we want to\nrepresent.\n\n\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\n\nnames(ratiocalc) <- c(\"Country\", \"ratio\")\n\nmerged_data <- merge(world, ratiocalc, by.x = \"name\", by.y = \"Country\", all.x = TRUE)\n\n\nFinal Map\nFinally, we run the plot that will allow us to visualise our map:\n\n\nggplot(merged_data, aes(fill = log10(ratio*1000))) +\n  geom_sf() +\n  scale_fill_distiller(palette = \"RdYlBu\", direction = 1) +  # Cambia el esquema de colores según tus preferencias\n  labs(fill = \"Ratio\",\n       title = \"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal()\n\n\n\nAnalysis and results\nAlthough it is true that the database lacks the necessary information to\nestablish a global mapping, the extrapolation of the data present in our\ndataset does allow us to visualise more clearly the disposition of\ncertain regional focal points.\nMeso-America and South-America\nIn the Mesoamerica and South America region we have data for: Guatemala,\nEcuador, Peru, Guyana, Brazil and Argentina.\nHere Argentina has the lowest ratio in the region by far. The\ninterpretation of the data leads us to think that, at the regional\nlevel, Argentina has the highest levels with respect to the number of\narms seized per quantity of ammunition seized. In this context, we could\nsituate the dynamics of illegal arms trafficking in Brazil as the most\ndiametrically opposed to those of Argentina. This would indicate that\nmore ammunition has been seized in Brazil than in Argentina. The rest of\nthe region is increasingly closer to a higher level of arms trafficking\nas we move northwards (Peru, Ecuador, Guyana and Guatemala).\nIn the absence of data that could provide information on the behaviour\nof the region as a whole, the overall reading is trivial, although it\nmay be far from reality.\nThe fact that Argentina is the country in the region most specialised in\narms trafficking could be due to its regional status. In this regard,\nArgentina does not have any internal conflicts, so it is to be expected\nthat illegal arms trafficking is aimed at marketing arms to third\ncountries.\nThe violence in the Southern Macrozone in Chile or the narco-terrorist\ninsurgencies in Peru, Paraguay, Colombia and Ecuador can more than\njustify the need to acquire military materiel. Similarly, the fact that\nthe data is so disproportionately in favour of Argentina would support\nthe idea of the latter as a ‘proxy state’ on which a regional network of\nillegal arms trafficking could be built.\nMediterrenean Sea\nRegarding the Mediterranean, we have data from the following countries:\nMorocco, Algeria, Tunisia, Libya and Spain.\nThe data with respect to Spain, which indicates more arms trafficking\nthan ammunition trafficking, could be explained by its geographical\nposition as the ‘gateway to the Mediterranean’ and a maritime exit to\nthe North Atlantic. Further research with data from continental Europe\ncould shed more light on this.\nOn the other side of the Strait of Gibraltar, Libya is the only country\nthat shows similar figures to Spain. The Second Libyan Civil War (2014 -\n) left the country fractured into different centres of power with access\nto different natural resources of vital importance for the functioning\nof the country as a whole. In a state where power is shared between\nlocal militias, terrorist groups, internationally mandated governments\nand unrecognised institutions, armed conflict is already an entrenched\nproblem.\nThis would explain why illegal arms trafficking in Libya has a greater\ntendency towards arms, but maintains a certain level of presence in\nammunition.\nAs for Algeria, the large quantity of seized ammunition could be due to\nthe surplus of military materiel from the colonial era. While Morocco\nunderwent a similar colonial process, the extent to which France armed\nits former colony is greater than that which occurred on Moroccan\nterritory. The high levels of corruption in Morocco could explain a weak\nmilitary chain of command, which sought to take advantage of the\nsurplus. In a context of direct rivalry with Morocco (and with third\nstates involved), it is not at all inconceivable that Algeria would\nconsider selling military surplus to third countries as a means of\nfinancing.\nWith respect to the rest of the regions, the dataset provides\ninsufficient information to make any kind of reading in this regard.\nFurther research\nThe motivation for this work arose from the intention to identify\nregional trafficking dynamics around existing conflicts. The next step\n(once identified) would be to give them a reason.\nI believe that the best way to address the issue of illegal arms\ntrafficking is to situate national contexts in the regional setting.\nThese data (and their visualisation) gave us the opportunity to see\n(through their visualisation) different dynamics taking place in\ndifferent regional settings.\nI believe that this work, accompanied by historical, political and\neconomic contextualisation, would reveal in depth the regional trends of\nillegal arms trafficking and their relationship to the geopolitical\ncontext in which it takes place.\nFrom the numerical and historical analysis of regional trends in illicit\narms trafficking we can expect a clear motivation behind any illegal\ntransaction. The same motivation can give rise to a certain modus\noperandi, refined over time. Identifying such patterns and associating\nthem with patterns would help to map (at a higher level) all the\nelements and actors involved in illegal arms trafficking. This would\nhelp to prevent and eradicate it.\n\n\n\n",
    "preview": "projects/2023/100485846/100485846_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508856/",
    "title": "The Evolution of Working Hours in the World",
    "description": "This project consists in the replicaion and alternative representation of\ngraphs from Our World in Data called \"Working Hours\".",
    "author": [
      {
        "name": "Miao Liao",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nGraph to replicate\n\nFirst two graphs\nMaps\nEvolution path\n\nAlternative representations\nConclusion\n\nIntroduction\nThe graph for this project was inspired by a Working Hours article in Our World in Data, which is about a comparative analysis of average annual hours worked by countries between 1950 and 2019. The first part of the article discusses the average annual working hours of citizens in different countries during this period, depicted through line graphs and maps. We can clearly observe the trends in average annual working hours for each country, identifying which countries have the longest and shortest average annual working hours. Additionally, the variation in colors on the map represents changes in annual working hours. The second part utilizes data on the annual holidays in different countries during this period to depict trends in annual holidays. The third part includes data on population numbers and GDP of various countries, creating different charts to observe the relationships between population numbers, national GDP, and annual working hours in different countries. You can find the full article here.\nGraph to replicate\nThe images I intend to replicate combine line graphs, maps, and bubble charts, each representing different data characteristics. The line graph is used to show the trend of annual working hours over the past 60 years. The maps provide a more macroscopic view of the changes in global working hours. The bubble chart, incorporating population and national GDP, adds complexity to the data and allows for the observation of more information. Finally, an evolutionary path is drawn based on annual working hours and GDP data. The original image depicted the evolutionary paths of all countries over time, dynamically represented across different regional segments. Here is a link to the original graph:\nTime series, 1870-2017Map, 2005First two graphs\nThe first step was to load the libraries, in this case I used these: dplyr, ggplots, ggrepel, tidyr, ggokabeito, tmap and paletteer. The second step was to read the database which was on a csv file.\nThe first image I replicated is a line graph(Figure 1), in which I selected the average annual working hours of over 60 different countries globally from 1950 to 2017. The original was a dynamic trend graph that changed with the slide of time, and I created the final overall line trend graph. However, due to the excessive number of countries, it appeared quite cluttered at first glance. Therefore, in the second image(Figure 2), I chose a few representative countries to make the chart clearer, whereas the original graph was actually an overlay of different countries’ and regions’ trend graphs. Subsequently, there are four map images(Figure 3-6). Each map depicts the state of annual working hours in different regions globally during various years of this period, using shades of color to represent the length of working hours\nThe code for this visual representation can be divided into four parts:\nModify column names after reading the corresponding data table\nSet the X-axis as the year, the Y-axis as the working time, and the colors are differentiated by region\nModify the title to “Annual Working Hours per Country from 1950 to 2017”\nModify the x-axis of the plot\n\n\n# Figure 1\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggrepel)\nlibrary(tidyr)\nlibrary(ggokabeito) # remotes::install_github(\"malcolmbarrett/ggokabeito\")\nlibrary(paletteer)\nworking_hours<-read.csv(file = \"./data/annual-working-hours-per-worker.csv\")\ncolnames(working_hours)<-c(\"Region\",\"Code\",\"Year\",\"working_hours\")\np=ggplot(working_hours, aes(x = Year, y = working_hours, group = Region, color = Region)) +\n   geom_line() +\n    theme_minimal() +\n   labs(title = \"Annual Working Hours per Country from 1950 to 2017\",\n                  x = \"Year\",\n                  y = \"working Hours\",\n                  color = \"Region\") +\n     scale_x_continuous(breaks = seq(1950, 2017, by = 10)) \n \np\n\n\n\n\n\n#Figure 2\n\ndata <- read.csv(file = \"./data/annual-working-hours-per-worker.csv\")\ncolnames(data)[4] <- \"time\"\ndata1 <- dplyr::filter(data, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\np<-ggplot(data1,aes(Year,time,group=Entity,color=Entity))+\n  geom_line(position = position_dodge(0.1),cex=1)+\n  scale_x_continuous(breaks = seq(1870, 2020, 30))+\n  theme_bw()+\n  labs(x=\"Year\",\n       y=\"Hours\",\n       color=\"Country/Region\")+\n  scale_color_manual(values=paletteer_d(\"ggthemes::Classic_20\", n=9))+\n  theme(panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        panel.grid.major.y = element_line(linetype=2),\n        panel.grid.minor.y = element_blank(),\n        axis.text=element_text(size = 13), \n        axis.title =element_text(size = 15),\n        plot.margin=unit(c(3,0,3,0),'cm'),\n        panel.border = element_blank(),\n        axis.line.x= element_line(colour = \"black\"))\np\n\n\n\nMaps\nSelect the data for the corresponding year and select the required column name (entity and time).\nChange the column name and merge data\nModify the Settings of the map: set the title, control the title text size, scale size, map proportion, text color, etc\n\n\n#Figure 3 maps\n\nlibrary(tmap)\ndata(\"World\")\n\n## The map in 1900\n\n## Using ggplot2\n\nlibrary(ggplot2)\nlibrary(sf)\ndata_1900 <- data[data$Year==1900,]  |>  select(\"Entity\",\"time\")\ncolnames(data_1900) <- c(\"sovereignt\",\"Hours\")\nworld_1900 <- left_join(World,data_1900,by=\"sovereignt\")\nggplot(data = world_1900) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1900\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n##Figure 4 \n\n## The map in 1950\n\n## Using ggplot2\ndata_1950 <- data[data$Year==1950,]  |>  select(\"Entity\",\"time\")\ncolnames(data_1950) <- c(\"sovereignt\",\"Hours\")\nworld_1950 <- left_join(World,data_1950,by=\"sovereignt\")\nggplot(data = world_1950) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1950\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n#Figure 5\n## The map in 1997\n\ndata_97 <- data[data$Year==1997,]  |>  select(\"Entity\",\"time\")\ncolnames(data_97) <- c(\"sovereignt\",\"Hours\")\nworld_1997 <- left_join(World,data_97,by=\"sovereignt\")\n\nggplot(data = world_1997) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1997\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n#Figure 6\n\n## The map in 2017\n\ndata_17 <- data[data$Year==2017,]  |>  select(\"Entity\",\"time\")\ncolnames(data_17) <- c(\"sovereignt\",\"Hours\")\nworld_17 <- left_join(World,data_17,by=\"sovereignt\")\nggplot(data = world_17) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 2017\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\nEvolution path\nThe original graph is the evolutionary path of the data of different countries superimposed, and then dynamic simulation is carried out. In this part, I select several regions to draw one of them. Here is a link to the original graph\n\n\ndata <- read.csv(file = \"./data/annual-working-hours-vs-gdp-per-capita-pwt.csv\")\n\ncolnames(data)[c(4,5)] <- c(\"work_time\",\"GDP\")\ndata1 <- data[-which(is.na(data$GDP)),]\ndata2 <- data1[-which(is.na(data1$work_time)),]\ndata3 <- dplyr::filter(data2, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\nggplot(data3,aes(GDP,work_time,color=Entity))+\n  geom_point(alpha=0.5)+\n  geom_line(alpha=0.5) +\n  scale_color_okabe_ito(name = \"Country/Region\")+\n  \n  labs(x = 'GDP per capita', y = 'Annual working hours per worker',color=\"Country/Region\") +\n  scale_x_continuous(breaks = c(0,10000,20000,30000,40000,50000,60000,70000))+\n  theme_bw()+\n  theme(axis.text=element_text(size = 7),\n        axis.title.x =element_text(size = 10),\n        axis.title.y =element_text(size = 12))\n\n\n\nAlternative representations\nIn this section, new data has been added, specifically the GDP and population numbers of different countries. Consequently, the next image I replicated is a bubble chart(Figure 7), used to compare the relationship between the average annual working hours, the population size, and the GDP of various countries. Due to the large number of countries, this chart primarily displays a selection of countries and regions, represented in different colors.\nRead file data\nExtract and modify column names\nClean data: Remove blank data\nExtract the country I want to draw\nUse the log10 function to draw the bubble, and use the ggplot2 function to set the x axis, y axis, color, title\n\n\ncolnames(data)[c(4,5)] <- c(\"work_time\",\"GDP\")\ndata1 <- data[-which(is.na(data$GDP)),]\ndata2 <- data1[-which(is.na(data1$work_time)),]\ndata3 <- dplyr::filter(data2, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\ndata3_1 <- data3[data3$Year==2019,]\ndata3_1$Population..historical.estimates. <- log10(data3_1$Population..historical.estimates.)\nrownames(data3_1) <- data3_1$Entity\np<-ggplot(data = data3_1, aes(x = GDP, y = work_time)) +\n  geom_point(aes(size = Population..historical.estimates., fill = Entity), shape = 21, color = 'black', stroke = 1,alpha=0.5) +\n  geom_text(\n    label=rownames(data3_1), \n    nudge_x = 0.25, nudge_y = -10, \n    check_overlap = T\n  )+\n  xlim(0,80000)+\n  labs(x = 'GDP per capita', y = 'Annual working hours per worker') +\n  theme_bw()+\n  labs(fill = \"Country/Region\",\n       size = \"log10(Circles sized by Population)\")+\n  theme(legend.key.size=unit(0.5,\"cm\"))\np\n\n\n\nConclusion\nIn the process of replicating these charts, I encountered two main problems. The first was the excessive number of countries; I attempted to draw them according to different continental plates, but this was unsuccessful. Therefore, I ultimately focused on depicting a selection of typical countries and regions. The second issue was that the original charts dynamically displayed the data from earlier to more recent years, a feature I couldn’t replicate successfully. Thus, I produced a static version of the evolutionary path chart. In further elaboration, I added population data, enriching the information in the charts and allowing for potentially useful conclusions to be drawn through observation of the charts.\n\n\n\n",
    "preview": "projects/2023/100508856/100508856_files/figure-html5/unnamed-chunk-7-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508949/",
    "title": "Water Sanitation Visualization",
    "description": "Graph on the use of water and water sanitisation tools among the various\nregions of the world.",
    "author": [
      {
        "name": "Nadia Napolano",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\nEnhancement\n\nIntroduction\nThe graph was found at Visual Capitalist, it consists of two semicircles facing each other. The data are in percentage form I was able to transcribe them by hand and insert them into the dataset.\nOriginal graph.Replication\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(gridExtra)\n\n\n\n\n\nThe first step in the creation of this graph is the collection of data for the first semicircle: numerical values and information on world regions and water quality values are entered.\nThe second step is to ensure that the values are structured as a percentage, and that their sum is equal to 1.\n\n\ngraph <- ggplot(dati_grafico1_long, aes(x = Region, y = Percentage, fill = Category)) +\n  geom_bar(stat = \"identity\", position = \"stack\", color = \"white\", size = 0.1) +\n  ylim(c(0, 2)) +\n  scale_x_discrete(limits = c(letters[1:9], dati_grafico1$Region)) +\n  coord_polar(theta = \"y\", start = 0, direction = 1) +\n  theme_void() +\n  theme(\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(0, 200, 0, 0),\n    legend.key.size = unit(0.5, \"cm\"),\n    legend.key.width = unit(0.5, \"cm\")\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Safely_Managed\" = \"#7E8EF3\", \"Basic\" = \"#7DCA96\",\n      \"Limited\" = \"#CCC0F1\", \"surface_water\" = \"black\",\n      \"Unimproved\" = \"#CBF8C8\"\n    )\n  ) +\n  annotate(\n    \"segment\",\n    x = 9,\n    xend = 20,\n    y = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    yend = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    colour = \"white\",\n    size = 0.2\n  ) +\n  annotate(\"point\", x = 9, y = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0, yend = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2) +\n  annotate(\"point\", x = 9, y = c(0.8, 0.9, 1), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0.7, yend = c(0.8, 0.9, 1), color = \"black\", size = 0.2) +\n  annotate(\n    \"text\", x = 9, y = 0.65,\n    label = \"Safe\",\n    angle = 70,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +  \n  annotate(\n    \"text\", x = 8.5, y = 0.52,\n    label = \"drinking\",\n    angle = 90,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  )+ \n  annotate(\n    \"text\", x = 8.5, y = 0.37,\n    label = \"water\",\n    angle = 106,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +\n  annotate(\"text\", x = 20, y = 0, label = \"0%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.1, label = \"10%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.2, label = \"20%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.3, label = \"30%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.4, label = \"40%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.5, label = \"50%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.6, label = \"60%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.7, label = \"70%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.8, label = \"80%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.9, label = \"90%\", size = 3) +\n  annotate(\"text\", x = 20, y = 1, label = \"100%\", size = 3) +\n  guides(\n    fill = guide_legend(\n      title = \"         Percentage of\\n      Population Accessing\\n         the Following\",\n      ncol = 3, colour = guide_legend(override.aes = list(shape = 17))\n    )\n  )\n\nprint(graph)\n\n\ntheme_legend_title <- theme(\n  legend.title = element_text(size = 8, face = \"bold\", family = \"Arial Black\")\n)\n\ntheme_legend_text <- theme(\n  legend.text = element_text(size = 5, family = \"Arial\")\n)\ntheme2<- theme( legend.key.size = unit(0.3, \"cm\")\n)\ncombined_graph <- graph + theme_legend_title + theme_legend_text + theme2\nlegend <- get_legend(combined_graph)\ngraph<- graph+ theme(legend.position=\"none\")\nprint(graph)\n\n\n\nThe code opens with the creation of the graph itself using ggplot. The ‘Region’, ‘Percentage’, and ‘Category’ columns play a key role in defining the axes and bars of the graph.\nThe use of geom_bar allows bars representing the different categories to be added to the graph, with the possibility of stacking them for clear representation. Customisation continues with scale_x_discrete, limiting the x-axes to specific categories, and coord_polar, which sets the polar coordinate system for a more dynamic display.\nTo make the graph even more appealing, various style changes were made, such as the use of custom colours with scale_fill_manual and the addition of segments, points and annotated text to highlight particular areas of the graph.\nIn the continuation of the code, we refine the aesthetics of the graph. we create an object called combined_graph, to which we add the title and customise the size of the legend text to make it appropriate for the project. Finally, the original legend is hidden and a new customised legend is inserted that reflects all the changes made, bringing the graph closer to the original image.\n\n\ntheme_legend_title <- theme(\n  legend.title = element_text(size = 8, face = \"bold\", family = \"Arial Black\")\n)\n\ntheme_legend_text <- theme(\n  legend.text = element_text(size = 5, family = \"Arial\")\n)\ntheme2<- theme( legend.key.size = unit(0.3, \"cm\")\n)\ncombined_graph <- graph + theme_legend_title + theme_legend_text + theme2\nlegend <- get_legend(combined_graph)\n\n\ngraph<- graph+ theme(legend.position=\"none\")\nprint(graph)\n\n\n\nIn the code provided, the legend of a polar bar graph is being customised in R. A style was defined for the title of the legend, specifying the text size, bold and font. Next, the text of the legend was customised by setting the desired size and font type. The size of the legend keys was also adjusted.\nAfter combining these customisations with the original graph, a new graph called combined_graph was obtained. Next, the customised legend was extracted using the get_legend method.\nFinally, the original legend was hidden in the original graph and the final result was printed, incorporating the customised legend.\n\n\ndati_graficoper <- data.frame(\n  Region = c(\"South Asia\", \"East Asia and Pacific\", \"West and Central Africa\",\n             \"Eastern and Southern Africa\", \"Latin America and Caribbean\",\n             \"Middle East and North Africa\", \"Eastern Europe and central asia\",\n             \"Western Europe\", \"North America\"),\n  Safely_Managed = c(0, 0.55, 0, 0, 0.22, 0.32, 0.33, 0.87, 0.80),\n  Basic = c(0.46, 0.22, 0.27, 0.30, 0.64, 0.56, 0.60, 0.13, 0.20),\n  Limited = c(0.13, 0.6, 0.23, 0.13, 0.05, 0.07, 0.01, 0, 0),\n  Unimproved = c(0.9, 0.14, 0.25, 0.36, 0.06, 0.03, 0.06, 0, 0),\n  surface_water = c(0.32, 0.03, 0.25, 0.21, 0.03, 0.02, 0, 0 , 0)\n)\n\n\n\n\n\ndati_graficoper_long <- dati_graficoper |> \n  tidyr::pivot_longer(cols = -Region, names_to = \"Category\", values_to = \"Percentage\") |> \n  dplyr::group_by(Region) |> \n  dplyr::mutate(Percentage = Percentage / sum(Percentage))\ngraphper <- ggplot(dati_graficoper_long, aes(x = Region, y = Percentage, fill = Category)) +\n  geom_bar(stat = \"identity\", position = \"stack\",color = \"white\", size = 0.1) +\n  ylim(c(0, 2)) +\n  scale_x_discrete(limits = c(letters[1:9], dati_grafico1$Region)) +\n  coord_polar(theta = \"y\", start = 0, direction = -1) +\n  theme_void() +\n  theme(\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(0, 0, 0, 200)\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Basic\" = \"#7DCA96\",\n      \"Safely_Managed\" = \"#7E8EF3\",\n      \"Limited\" = \"#CCC0F1\",\n      \"Unimproved\" = \"#CBF8C8\",\n      \"surface_water\" = \"black\"\n    )\n  ) +\n  annotate(\n    \"segment\",\n    x = 9,\n    xend = 20,\n    y = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    yend = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    colour = \"white\",\n    size = 0.2\n  ) +\n  annotate(\"point\", x = 9, y = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0, yend = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2) +\n  annotate(\"point\", x = 9, y = c(0.8, 0.9, 1), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0.7, yend = c(0.8, 0.9, 1), color = \"black\", size = 0.2) +\n  annotate(\n    \"text\", x = 8.7, y = 0.60,\n    label = \"Managed\",\n    angle = 105,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +  \n  annotate(\n    \"text\", x = 8.7, y = 0.40,\n    label = \"sanitation\",\n    angle = 75,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  )+\n  annotate(\"text\", x = 20, y = 0, label = \"0%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.1, label = \"10%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.2, label = \"20%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.3, label = \"30%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.4, label = \"40%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.5, label = \"50%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.6, label = \"60%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.7, label = \"70%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.8, label = \"80%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.9, label = \"90%\", size = 3) +\n  annotate(\"text\", x = 20, y = 1, label = \"100%\", size = 3) +\n  theme(legend.position = \"none\")\n\n\nIn this case we carry out exactly the same procedures for the second data set of information, obtaining a similar result.\n\n\ndoppiografico <- grid.arrange(graphper,legend, graph,  ncol = 3, widths = c(30, 0.01, 30)) \n\n\ndoppiografico2 <- cowplot::ggdraw(doppiografico) + \n  theme(plot.background = element_rect(fill=\"#A6A6E2\"))\nprint(doppiografico2)\n\n\n\nIn this step, three graphic elements are combined using the grid.arrange function of gridExtra: graphper, legend, and graph. The layout is organised in three columns, with specific widths for each element. Next, an additional style is applied to the combined layout using cowplot::ggdraw, setting a plot background with a specific colour (#A6A6E2). Finally, the final result is printed.\nEnhancement\n\n\ndati_grafico1 <- data.frame(\n  Region = c(\"South Asia\", \"East Asia and Pacific\", \"West and Central Africa\",\n             \"Eastern and Southern Africa\", \"Latin America and Caribbean\",\n             \"Middle East and North Africa\", \"Eastern Europe and central asia\",\n             \"Western Europe\", \"North America\"),\n  Safely_Managed = c(0, 0, 0.23, 0.26, 0.65, 0.77, 0.84, 0.96, 0.99),\n  Basic = c(0.88, 0.94, 0.40, 0.28, 0.31, 0.16, 0.11, 0.3, 0),\n  Limited = c(0.4, 0.1, 0.10, 0.18, 0.1, 0.4, 0.2, 0, 0),\n  Unimproved = c(0.7, 0.4, 0.2, 0.16, 0.2, 0.2, 0.2, 0.1, 0.1),\n  surface_water = c(0.1, 0.1, 0.7, 0.12, 0.1, 0.1, 0.1, 0, 0)\n)\n\ndati_grafico1_long <- dati_grafico1 |> \n  tidyr::pivot_longer(cols = -Region, names_to = \"Category\", values_to = \"Percentage\") |> \n  dplyr::group_by(Region) |> \n  dplyr::mutate(Percentage = Percentage / sum(Percentage))\n\ngrafico1_best <- ggplot(dati_grafico1_long, aes(x = Percentage, y = Category, fill = Region)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  xlab(\"Percentage\") +\n  ylab(\"Water Category\") +\n  ggtitle(\"Water Sanitation in Different Regions\") +\n  theme(axis.text.y = element_text(angle = 0, hjust = 0)) +\n  scale_fill_manual(values = c(\n    \"South Asia\" = \"#98F5FF\",\n    \"East Asia and Pacific\" = \"#FFF68F\",\n    \"West and Central Africa\" = \"#FFA07A\",\n    \"Eastern and Southern Africa\" = \"red\",\n    \"Latin America and Caribbean\" = \"black\",\n    \"Middle East and North Africa\" = \"blue\",\n    \"Eastern Europe and central asia\" = \"green\",\n    \"Western Europe\" = \"purple\",\n    \"North America\" = \"orange\"\n  )) +\n  guides(fill = guide_legend(title = \"Region\"))  # Change legend title\n\nprint(grafico1_best)\n\n\n\nI decided to improve this graph by simplifying, a simple bar plot makes the information clearer and less confusing. It conveys all the information without making it difficult for the reader to understand.\nInitially, the dataset data_graph1 is transformed from wide to long format using the function tidyr::pivot_longer. Next, the percentages are normalised for each region, ensuring that the total sum of each region is equal to 1.\nNext, using the ggplot2 library, a bar graph called graph1_best is created, which visually represents the distribution of the water supply categories in the different regions. The categories are positioned on the y-axis, while the percentages are represented on the x-axis. The bars are coloured according to the specific regions.\nThe graph has been customised with titles for the axes and the main title, and the angle of the text on the y-axis has been changed for better readability. The colours of the bars were manually selected to distinctively represent each region. The legend was adapted to include the title ‘Region’.\n\n\ngraficomigliore_per <- ggplot(dati_graficoper_long, aes(x = Percentage, y = Category, fill = Region)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  xlab(\"Percentage\") +\n  ylab(\"Sanitation Category\") +\n  ggtitle(\"Managed Sanitation in Different Regions\") +\n  theme(axis.text.y = element_text(angle = 0, hjust = 0)) +\n  scale_fill_manual(values = c(\n    \"South Asia\" = \"#98F5FF\",\n    \"East Asia and Pacific\" = \"#FFF68F\",\n    \"West and Central Africa\" = \"#FFA07A\",\n    \"Eastern and Southern Africa\" = \"red\",\n    \"Latin America and Caribbean\" = \"black\",\n    \"Middle East and North Africa\" = \"blue\",\n    \"Eastern Europe and central asia\" = \"green\",\n    \"Western Europe\" = \"purple\",\n    \"North America\" = \"orange\"\n  )) +\n  guides(fill = guide_legend(title = \"Region\"))  # Change legend title\n\nprint(graficomigliore_per)\n\n\n\nThe same enhancement have been done for the second data set.\n\n\n\n",
    "preview": "projects/2023/100508949/100508949_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100517341/",
    "title": "Is the World Moving Enough?",
    "description": "A look at the mortality due to low physical activity worldwide.",
    "author": [
      {
        "name": "Mathieu Bietrix",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nOriginal graph\nThe data\nDeaths due to low physical activity\nWorld’s population data\nWorld data\nFinal dataset\n\nMain chart\nCreating the world map\nAdding the text elements\nTheme\nAdding the data\nAdjustments\nInteractive version of the plot\n\nThe line graph\nCoordinate and axes\nTheme and labs\nAdding the data\nAnnotations\n{ggiraph} version of the line plot\nAdjustments\n\nAlternative graphs\nThe data\nAlternative map\nAlternative line graph\n\nProject takeaways and what I learned\n\nOriginal graph\nThe original graph can be found following this link.\nOriginal graphThe data\nDeaths due to low physical activity\n\n\n# Libraries used\n\nlibrary(tidyverse)\nlibrary(arules)\nlibrary(sf) \nlibrary(rnaturalearth)  \nlibrary(ggtext)  \nlibrary(ggiraph)\nlibrary(ggrepel)\nlibrary(kableExtra) \nlibrary(gt)\nlibrary(gtExtras)\nlibrary(ggpp)\n\n\nFortunately, the data used to create this graph was already available on Our Word In Data and can be downloaded in a CSV format. This dataset was originally published by the Institute of Health Metrics and Evaluation, an American research institute in the area of global health statistics. It consists of the number of deaths attributed to low physical activity per country per year. As the data is already available, I will not make use of the {owidR} package that enable to load OWID data in R. Let’s import the dataset.\n\n\ndata <- read_csv(file = \"Final_Project_Dataset.csv\")  \n\n\nThe dataset is already tidy data, and is ready to be used.\nWorld’s population data\nIn order to facilitate the modifications that we would like to do to the original graph later, we need to add a new column to the dataset with the population of the countries. To do so, we need a dataset of the total population of these countries from 1990 to 2019. One can be found one via another chart created by Our World In Data.\nWe need to filter the data to only keep the data from 1990 to 2019. Also, the population dataset contains the total population per continent. These rows are easy to spot, they have missing values as country codes.\n\n\npopulation <- read_csv(file = \"Population_per_country_per_year.csv\")\n\npopulation <- population |>\n    filter(Year >= 1990 & Year <= 2019) |>\n    drop_na(Code)\n\n\nNow that we have the population dataset containing the total population of countries between 1990 and 2019, we can create a new dataset that joins the data tibble and the population tibble and that contains a column with the total population of each country for each year.\n\n\ndata <- \n  inner_join(data, population, \n             by = c('Code'='Code', 'Year'='Year', 'Entity'='Entity')) |>\n# Let's rename the columns for better readability\n  rename(c(\n    Deaths = `Deaths that are from all causes attributed to low physical activity, in both sexes aged all ages`,\n    Population = `Population (historical estimates)`\n           )\n         )\n\n\nWe are almost done. As we can see on the original Our World in Data graph, the color attributed to each country is assigned on the basis of the range of number of deaths due to low activity in the country for a given year. Therefore, we need to discretize this variable in 9 different ranges, as the color scale used by OWID contains 9 ranges. After searching on the Web, I found that such an operation could be performed thanks to the {arules} package, using the discretize() function.\n\n\nlibrary(arules)  \n\n# We define a vector that contains the values of the edges of each range used in the color scale of the original graph.\n\nbreaks_map <- c(0, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000)\ndata <-   \n  data |> \n  mutate(Deaths_disc = discretize(Deaths, method = 'fixed', breaks = breaks_map),\n         .after = Deaths) \n\n\nWorld data\nTo plot a map of the deaths due to low physical activity, we obviously need a map. To build this map, we need data as longitudes and latitudes of the countries worldwide. We will use the {sf} package to represent visally the geographic data (which are polygons) and the {rnaturalearth} to obtain this data.\nFirst, we use the ne_countries() function from the rnaturalearth package. This function contains predownloaded vector maps for the world’s countries. We also want to make our world data a sf object, so that we can use the sf package in the future. The latter can be done by providing the argument returnclass = 'sf' (the default).\n\n\nlibrary(sf) \nlibrary(rnaturalearth)  \n\nworld <- ne_countries()\n\n\nFinal dataset\nWe know need to join the world dataset and the data dataset to create the dataset that will be used to project the world map in ggplot2 and display the number of deaths due to low physical activity at the same time.\n\n\ndata <-\n  world |>\n  left_join(data, by = c('adm0_a3' = 'Code'))\n\n\nFinally, let’s clean up our data dataset a bit so that R may have less difficulty to run the code that we will write to create the graph. Indeed, there are a vast majority of columns that we are not going to be using to display the data of interest with ggplot. The only columns that we need are :\ngeometry, which is used by geom_sf() to plot the shapes of the countries.\nEntity: the name of the country\ncontinent\nsubregion\nYear\nDeaths\nDeaths_disc\nPopulation\n\n\ndata <-\n  data |>\n  select(Entity,\n         continent,         \n         subregion,          \n         Year,          \n         Deaths,          \n         Deaths_disc,          \n         Population,          \n         geometry)  \n\n\nOn a visual standpoint, the OWID graph doesn’t show Antartica, so we can remove the data linked to it in our dataset. Lastly, there are many islands that might pop on our graph. The simplest solution is to clear our data dataset from some of these islands, which seem to be Polynesia.\n\n\ndata <-   \n  data |>   \n  filter(continent != 'Antarctica') |>    \n  filter(subregion != 'Polynesia')\n\n\nMain chart\nCreating the world map\nThe first thing we need to do is to create a projection of the world. As mentioned earlier, we will use the {sf} package, particularly the geom_sf() geom that enables to easily visualize sf objects. One of the advantage of this geom is that it is smart enough to understand the geometry type to draw according to the dataset we provide it.\n\n\np <-    \n  data |>    \n  ggplot() +   \n  geom_sf()  \n\np\n\n\n\nAt this point, we have generated an empty map of the world. One thing we can notice is that the projection (meaning the way a 3D object, the world, is represented in 2D) used by default by geom_sf() is not exactly the same as the one used by Our World In Data. It seems that the latter is a “Robinson” projection. We can use the coord_sf() function to change our projection to a Robinson one.\n\n\np <-    \n  p +   \n  coord_sf(crs = \"+proj=robin\")  \n\np\n\n\n\nAdding the text elements\nLet’s add:\nThe title: “Deaths due to low physical activity, 2019”,\nThe subtitle: “Estimated annual number of deaths attributed to low physical activity”,\nAnd the caption “Data source: IHME, Global Burden of Disease (2019) – Learn more about this data\nOurWorldInData.org/causes-of-death | CC BY”\nAfter going further, it appeared that the caption was more easily handled if we divided it in two parts: a caption and a tag. Note that for the moment, the tag position is clearly not good, as well as the size of its text, which will both be addressed when setting the theme. For convenience until then, let’s comment the tag.\n\n\nplot_title <- \"Deaths due to low physical activity, 2019\" \nplot_subtitle <- \"Estimated annual number of deaths attributed to low physical activity.\"\nplot_caption <- \"Data source: IHME, Global Burden of Disease (2019) - Learn more about this data\" \nplot_tag <- \"OurWorldInData.org/causes-of-death | CC BY\"  \n\n\n\n\np <-   \n  p +  \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption        \n       #tag = plot_tag        \n       )  \n\np\n\n\n\nTheme\nOne thing that we notice is that the OWID graph has a clean white background, without any displayed meridian. As the meridians are already colored in white, adding a theme_classic() should give us the look we are looking for. But we also want to get rid of the longitude axis. Then, the most appropriate theme to use is the theme_void().\n\n\np <- \n  p +\n  theme_void()\n\n\nAlso the caption of the OWID plot has to be moved on the left, the size of the font has to be modified so that the subtitle and caption are smaller, and the title bigger. Finally, the font of the title can be switched to something approximating the Times New Roman font. Unfortunately, we were unable to use the latter font (which remains the biggest mystery of my year 2023 as it’s the most basic font ever), so we needed to get an equivalent from the Google Font, the Merriweather font.\nWe can also de-comment the tag, and set its size and position in the theme(). After unsuccessfully trying several positions for the tag, such as ‘bottom’, and ‘bottomleft’, it appeared that the easiest solution was to manually set its position using plot.tag.position = 'bottom' (which gets the tag under the caption but in the center of the plot), and the margin argument of plot.tag = element_text().\n\n\nsysfonts::font_add_google('Merriweather', family = 'merriweather') \nshowtext::showtext_auto()\n\n\n\n\np <-   \n  data |>   \n  ggplot() +   \n  geom_sf() +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) + # adding the tag   \n  theme_void() +   \n  theme(plot.title = element_text(family = 'merriweather', size = 15),         \n        plot.caption = element_text(hjust = 0),         \n        plot.tag.position = 'bottom',         \n        plot.tag = element_text(size = 10, # customizing tag's size and position\n                                margin = margin(l = -340)))  \n\np\n\n\n\nAdding the data\nSo far, we have a chart that has some common appearance traits shared with the Our World in Data graph. We can now add the information we want to display, focusing on a single year: 2019.\nThe first step is to filter the data to obtain only the data from 2019. Then, we can add an aesthetic to the geom_sf() geom to display the number of Deaths from low physical activity around the world. Since we want to color the map according to this variable, we will use the fill aesthetic.\n\n\np <-    \n  data |>\n  filter(Year == 2019) |> # filtering by year   \n  ggplot() +   \n  geom_sf(aes(fill = Deaths_disc)) +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) +   \n  theme_void() +   \n  theme(plot.title = element_text(family = 'merriweather', size = 15),   \n        plot.caption = element_text(hjust = 0),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(size = 10,    \n                                margin = margin(l = -340)))\n\np\n\n\n\nAdjustments\nOne striking difference with the original plot is the legend. We need to move the legend to the bottom of the chart and change the color palette. We need to change the legend key into a color bar. This can be done by using a “Discretized colourbar guide”: the guide_colorsteps() guide. Within this guide, the “YlorRd” palette seems exactly the one that was used by Our Word In Data for their map.\n\n\np <-    \n  data |>   \n  filter(Year == 2019) |>   \n  ggplot() +   \n  geom_sf(aes(fill = Deaths_disc)) +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = 'merriweather',\n      size = 15),\n    plot.caption = element_text(\n      hjust = 0),\n    plot.tag.position = 'bottom',         \n    plot.tag = element_text(\n      size = 10,                                  \n      margin = margin(l = -340)),\n    legend.position = 'bottom', # moving the legend around           \n    legend.title = element_blank()) +   \n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps( # Modifying the default legend guide\n                      ticks = TRUE,  \n                      barwidth = 25,  \n                      barheight = 0.5, \n                      frame.colour = 'black',  \n                      frame.linewidth = 0.01,      \n                      ticks.colour = 'black',   \n                      ticks.linewidth = 0.01) \n                    )   \n\np\n\n\n\nOur plot starts looking a bit similar to the OWID one. Let’s move the legend’s labels on top of the legend, and display the limits of the legend. I thought that the first operation could be done by modifying the legend.text in the theme() function, but it seems not possible. Therefore, we can play on the margin argument of the element_text() function in the theme() to move the legend’s label around.\nThe limits are ruled by an argument of the previously used guide_colorsteps(): show.limits.\n\n\np <-    \n  data |>   \n  filter(Year == 2019) |>    \n  ggplot() +  \n  geom_sf(\n    aes(fill = Deaths_disc)) +\n  coord_sf(crs = '+proj=robin') +\n  labs(title = plot_title,\n       subtitle = plot_subtitle,\n       caption = plot_caption,\n       tag = plot_tag) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = 'merriweather',\n      size = 15),\n    plot.caption = element_text(\n      hjust = 0),\n    plot.tag.position = 'bottom',         \n    plot.tag = element_text(\n      size = 10,\n      margin = margin(l = -340)),\n    legend.position = 'bottom',\n    legend.title = element_blank(),\n    legend.text = element_text(           \n      margin = margin(t = -22) # adjusting the position of legend's labels\n      )\n    ) +   \n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps(  \n                      show.limits = TRUE, # adding the scale limits to the legend\n                      ticks = TRUE,      \n                      barwidth = 25,                       \n                      barheight = 0.5,                       \n                      frame.colour = 'black',\n                      frame.linewidth = 0.01,                       \n                      ticks.colour = 'black',\n                      ticks.linewidth = 0.01)\n                    )   \n\np\n\n\n\nNow the caption is slightly overriding the legend. We couldn’t fix it in the theme() by specifying a vjust argument to plot.caption, so rather decided to add a \\n at the beginning of the caption to create an empty line.\n\n\n# We added a newline character at the beginning of the string to create space over the caption\nplot_caption <- \"\\nData source: IHME, Global Burden of Disease (2019) - Learn more about this data\" \n\n\n\n\np \n\n\n\nSome adjustments also need to be done:\nThe borders of the polygons projected by geom_sf() seem to be a bit thicker than on our original OWID graph.\nMany islands remain on the graph, giving it a messier look than the original one.\nThe title, subtitle, caption and tag need to be spaced a bit from the border of the graph.\nFor the first two issues, it seems that the solution could lie in the fact that the resolution/definition of the geometry variable used to project polygons on the graph and thus create a world map, is too high. I tried to use the st_simplify() function from the sf package but wasn’t able to then map my data. However, a much simpler way to do so worked well, by just lowering the scale of the ne_countries() function. This results in less details in the geometry variable, and thus, a less messy visual appearance. Of course, this option is not the optimal one in terms of precision, but it seems that Our World In Data opted for displaying the data for not all countries and island worldwide.\nThe 3rd issue can easily be solved with some little modifications of the theme() by passing a hjust argument to plot.title = element_text() and so on for the subtitle and caption.\nThe look is a lot cleaner, with softer edges. Let’s then try to :\nSpace the title, subtitle, caption, and tag a bit from the left of the plot. This can be achieved by playing on the hjust (margin for the tag) argument of each of these element_text() in the theme().\nGet the title bold, the caption at the same size as the subtitle, the size of the tag a bit lower than the caption. To do so, we will add face and size arguments to element_text() in the theme().\nGet the “Data source” string in the caption bold. For this, we will modify the plot_caption variable, load the {ggtext} library, and set plot.caption to ggtext::element_markdown.\nFinally, the color of the text is not black in the original plot, but this color: #5b5b5b.\n\n\n# Recap of the data processing with the modification on the ne_countries() function\n\ndata <- read_csv(file = \"Final_Project_Dataset.csv\")  \n\npopulation <- read_csv(file = \"Population_per_country_per_year.csv\")  \n\npopulation <- \n  population |>\n  filter(Year >= 1990 & Year <= 2019) |>\n  drop_na(Code)  \n\ndata <-\n  inner_join(\n    data, \n    population, \n    by=c('Code'='Code', 'Year'='Year', 'Entity'='Entity')) |>\n  rename(c(Deaths = `Deaths that are from all causes attributed to low physical activity, in both sexes aged all ages`,\n           Population = `Population (historical estimates)`))\n\nbreaks_map <- c(0, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000)  \n\ndata <-\n  data |> \n  mutate(Deaths_disc = discretize(\n      Deaths, \n      method = 'fixed', \n      breaks = breaks_map),          \n    .after = Deaths)  \n\nworld <- \n  ne_countries(   \n    scale = 'small', # setting the value of the scale from \"large\" to \"small\"   \n    returnclass = 'sf'\n    )  \n\ndata <-\n  world |>    \n  left_join(data, \n            by = c('adm0_a3' = 'Code'))   \n\ndata <-  \n  data |>\n  select(Entity,          \n         continent,          \n         subregion,          \n         Year,          \n         Deaths,          \n         Deaths_disc,          \n         Population,          \n         geometry)  \n\ndata <-\n  data |>\n  filter(continent != 'Antarctica') |>    \n  filter(subregion != 'Polynesia')\n\n\n\n\n# The plot, with these changes\n\nlibrary(ggtext)  \n\nplot_caption <- \"\\n**Data source**: IHME, Global Burden of Disease (2019) - Learn more about this data\"  \n\np <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf(\n    aes(fill = Deaths_disc)\n    ) +   \n  coord_sf(crs = '+proj=robin') +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    \n    # We add more space to the title, subtitle, caption and tag, using hjust, vjust, and margin. \n    # We also play on the size of these text elements.\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b', # We add the grey color for text elements (modif 1)\n      face = 'bold',\n      size = 23,                                   \n      hjust = 0.08,\n      margin = margin(t = -10)\n      ),\n    \n    plot.subtitle = element_text(\n      color = '#5b5b5b', # grey color added\n      hjust = 0.1,                                     \n      size = 18),\n    \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b', # grey color added\n      hjust = 0.1,\n      size = 18,\n      margin = margin(t = 20)\n      ),       \n    \n    plot.tag.position = 'bottom',     \n    \n    plot.tag = element_text(\n      color = '#5b5b5b', # grey color added\n      size = 16,                                  \n      vjust = -1,\n      margin = margin(l = -280)\n      ),          \n    legend.position = 'bottom',\n    legend.title = element_blank(),         \n    legend.text = element_text(\n      size = 20,         \n      margin = margin(t = -22)\n      )\n    ) +   \n  \n  # No change in the scale\n  scale_fill_brewer(\n    palette = 'YlOrRd',\n    guide = guide_coloursteps(                        \n      show.limits = TRUE,\n      ticks = TRUE,            \n      barwidth = 25,           \n      barheight = 0.5,        \n      frame.colour = 'black', \n      frame.linewidth = 0.01,    \n      ticks.colour = 'black', \n      ticks.linewidth = 0.01)\n    ) \n\np \n\n\n\nInteractive version of the plot\nExactly as in the gapminder project, one of the point of the graph is to get it display an evolution over time. So far, we’ve been plotting the data only for year 2019, but it would be nice to create a more interactive plot, just as the original Our World In Data graph, that enables the user to filter the data by year and continent. Unfortunately for me, the integration of geom_sf() into the plotly library is not optimal, rendering a plot that is dynamic, but looks awful, with quite all of the modifications to the theme() not taken into account.\nA solution that I found was to use the {ggiraph} package to make the plot interactive. The filtering function seems requiring some features to create interfaces that ggplot cannot provide, such as integrating the plot in a Shiny application. Therefore, we will give up this last feature.\nThe ggiraph package is very easy to use and works the following way :\nWe make the geoms interactive by appending the “_interactive” to them.\nWe provide two aesthetics: tooltip, and data_id.tooltip enables to specify which variable needs to be displayed in the tooltip generated by the package.\nOn the other hand, data_id enables to indicate the variables that will be linked to visual effects, that we can define with CSS code paired with the argument options of the girafe() function.\nWe create a new and interactive graph by passing our plot to the girafe() function.\n{ggiraph} version of the map plot\n\n\nlibrary(ggiraph)  \n\np_girafe <-    \n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive( # Switching geom_sf to its ggiraph version       \n    aes(\n      fill = Deaths_disc,        \n      tooltip = sprintf(\"%s: %.3f\", Entity, Deaths)  # Enables to get a tooltip when hovering over the countries with name and percentage of death       \n      )\n    ) +   \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",                                    \n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 15,                                  \n      hjust = 0.1,                                   \n      margin = margin(t = -10)\n      ),\n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.11,                                      \n      size = 11\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.11,\n      size = 11,                                                 \n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 10,                                  \n      vjust = -1,                                 \n      margin = margin(l = -301)\n      ),\n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(           \n      margin = margin(t = -22)          \n      )\n    ) +\n  scale_fill_brewer(\n    palette = \"YlOrRd\",\n    guide = guide_coloursteps(                        \n      show.limits = TRUE,                        \n      ticks = TRUE,                       \n      barwidth = 25,                       \n      barheight = 0.5,                       \n      frame.colour = \"black\",\n      frame.linewidth = 0.01,                       \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.01\n      )\n    )  \n\ngirafe(ggobj = p_girafe)\n\n\nYay it works ! A few things need to be modifed. “A few”.\nAdjustments\nFirst, the position of the plot in the panel is not good. After a few iterations, I noticed that this was just a matter of playing on the margins already existing in our ggplot. Similarly, other theme() elements need to be adjusted.\nHowever, one drawback of the {ggiraph} package is that, without really knowing why:\nIt sizes the theme elements in a differently than the original plot, which requires a lot of micro-adjustment.\nIt seems that its integration to the different types of rendering such as Quarto Presentations or html also requires a lot of these micro-adjustments.\n\n\n# Micro adjustments of size, margin arguments, nothing mindblowing here\np_girafe <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive(\n    aes(        \n      fill = Deaths_disc,        \n      tooltip = sprintf(\"%s: %.0f\", Entity, round(Deaths)) # btw, this was copied from the ggiraph documentation       \n      )\n    ) +    \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,\n    tag = plot_tag\n    ) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",                                   \n      size = 12,                                   \n      hjust = 0.1,                                   \n      ),          \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                      \n      size = 8),\n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.11,                                                 \n      size = 8,\n      margin = margin(t = 20)\n      ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",                                 \n      size = 7,\n      vjust = -1,\n      margin = margin(l = -261)\n      ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(           \n      hjust = 0.8,           \n      size = 8,           \n      margin = margin(t = -22)         \n      )\n    ) +   \n  scale_fill_brewer(\n    palette = \"YlOrRd\",\n    guide = guide_coloursteps_interactive(\n      show.limits = TRUE,                        \n      ticks = TRUE,                       \n      barwidth = 25,            \n      barheight = 0.5,          \n      frame.colour = \"black\",    \n      frame.linewidth = 0.1,      \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.1)\n    )  \n\ngirafe(ggobj = p_girafe)\n\n\nHere are some improvements that we can still do:\nGive the tooltip a better appearance and make them display the absolute number of deaths due to low physical activity.\nThis interactivity with the plot will be created by adding an options in the girafe() function.\nThis require to create a CSS declarations for the style we want for the elements that are hovered, and pass these declarations to the css argument of the hover_opt() functions and functions related. These functions enable us to tailor the effects of hovering parts of the graph with our mouse. For sake of efficiency and because of my lack of knowledge in CSS, the declarations are generated by AI and adjusted if needed.\nNote: After knitting, I end up with a location of the graph in the panel that is really not good. The aspect of the plot in R Studio is not how it will be rendered. I think I may have used an argument in a way that it is not purposed to, but I couldn’t figure it out.\n\n\n# A \" ' \" symbol for the country \"Cote d'Ivoire\" was producing errors in ggiraph (God Bless French subtleties)  \n\ndata <-\n  data |>\n  mutate(Entity = if_else(Entity == \"Cote d'Ivoire\", \"Cote d Ivoire\", Entity))\n\n# Defining the style of the tooltip  \ntooltip_css <- \"background-color: rgba(245, 245, 245, 1); \n                color: #000000; \n                font-family: 'Arial', sans-serif;\n                font-size: 11px; \n                border-radius: 4px;\n                border: 1px solid #d9d9d9; \n                padding: 8px;\"  \n\np_map_girafe <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive(\n    aes(        \n      fill = Deaths_disc,        \n      tooltip = paste0(\"<b>\", Entity,\"<\/b>\", \"\\nNumber of Deaths: \", round(Deaths)),\n      data_id = Entity)\n    ) +   \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,       \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 12,                                   \n      hjust = 0.1,  \n      ), \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                      \n      size = 8\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                                 \n      size = 8,                                                 \n      margin = margin(t = 20)\n      ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 7,\n      vjust = -1,\n      margin = margin(l = -292)\n      ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(         \n      size = 8,\n      margin = margin(t = -22)          \n      )\n    ) +   \n  scale_fill_brewer(     \n    palette = \"YlOrRd\",     \n    guide = guide_coloursteps(       \n      show.limits = TRUE,        \n      ticks = TRUE,       \n      barwidth = 25,\n      barheight = 0.4,       \n      frame.colour = \"black\",\n      frame.linewidth = 0.1,       \n      ticks.colour = \"black\",    \n      ticks.linewidth = 0.1)\n    )  \n\n# * Lowering the opacity of all the non-hovered elements \n## * Defining borders around the hovered elements\n\ngirafe(ggobj = p_map_girafe,        \n       options = list(          \n         opts_hover_inv(css = \"opacity:0.7;\"), # *          \n         opts_hover(css = \"stroke-width:1.2;stroke:black;\"), # **          \n         opts_tooltip(css = tooltip_css)\n         )\n       )  \n\n\nAt this stage, I think my map is complete.\nThe line graph\nA second graph is joined to the map, in a new tab, that contributes to make this Our World In Data plot so complete. It shows the evolution of the number of deaths due to low physical activity year after year between 1990 and 2019. Since we already have the dataset, we can create a line plot. It has to be noted we are not plotting the entire dataset, as you could access it on the original graph.\nIf fact, one of the cool features that it has is that it provides a filter that enables you to select which countries you want to see on the graph. This greatly facilitates the comparison of evolutions between countries. However, I couldn’t find ways to provide this feature other than placing the graph into a Shiny Application. Since I really don’t know anything about Shiny, I’ll focus on a graph of the 10 countries with most Deaths by year.\nCoordinate and axes\nUnlike the map, this type of graph has axis. These axes have:\nNo label\nIncrementation of 5 years (for x axis) and 5000 deaths (for y axis)\nStarting points at the origin of the coordinate system\nThe plot also has horizontal lines for each 5000 deaths. We had to add also a geom_vline() because without it, the x-axis was disappearing.\n\n\np_line <-    \n  data |>    \n  ggplot(aes\n         (x = Year, \n           y = Deaths)\n         ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),              \n    linetype = 'dashed', \n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019), \n    ylim = c(0, 140000)\n    ) +\n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019), \n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    )  \n\np_line\n\n\n\nTheme and labs\nLet’s now add some elements of theme to the plot, according to the original graph:\nThe y axis is removed, as well as the ticks,\nWe have no titles for both x and y axes,\nThe values displayed along the axes are colored in the same grey as the title, subtitle, caption, and tag of the map,\nThe background is removed, which can be easily done with a theme_classic()\n\n\np_line <-\n  data |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +    \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 20000, to = 140000, by = 20000),        \n             linetype = 'dashed',\n             color = '#dddddd'\n             ) +    \n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"         \n      )\n    )  \n\np_line\n\n\n\nNow, we can add the labs, which are almost the same as on our map.\n\n\np_line <-\n  data |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),              \n    linetype = 'dashed',\n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +\n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  scale_y_continuous(breaks = seq(from = 0, to = 140000, by = 20000),\n                     expand = expansion(mult = c(0, 0.1))\n                     ) +\n  # Copy and paste the labs from our map   \n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"),\n    # Copy paste the theme elements associated to the labs from the map\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b',\n      face = 'bold',\n      size = 15,                                   \n      hjust = -0.18, # Adjusted                                 \n      margin = margin(t = 10) # Adjusted\n      ),         \n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = -0.205, # Adjusted                                       \n      size = 11,\n      margin = margin(t = 5) # Added\n      ), \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = -0.280, # Adjusted\n      size = 11,\n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 10,\n      vjust = -1,                                 \n      margin = margin(b = 10, # Added\n                      l = -320) # Adjusted\n      )          \n    )   \n\np_line\n\n\n\nAdding the data\nThe aesthetic we want to get is color, with each color representing a country, so we map Entity to color. However, since there are more than 150 countries in our data dataset, the best option that we have for the moment is to filter our data with certain countries. For instance, we can get the 10 countries with most deaths in 2019.\nAlso, the original plot has a second geom, that is geom_point() so let’s add it.\n\n\n# Defining a vector of the 10 countries with most Deaths in 2019\ntop10_countries_2019 <-\n  data |> \n  filter(Year == 2019) |> \n  slice_max(order_by = Deaths, n = 10) |> \n  select(Entity) |> \n  st_drop_geometry() |> \n  as_vector()\n\np_line <-\n  data |>  \n  filter(Entity %in% top10_countries_2019) |> # Now, our data is filtered\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +  \n  # Adding the points layer to the plot\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE,\n    size = 0.7\n    ) +   \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dashed',    \n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),         \n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"\n      ),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 25,\n      hjust = 0,                                    \n      margin = margin(t = 10)\n      ),          \n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 16,\n      margin = margin(t = 5)\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 16,                                                 \n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 15,                                  \n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -270)\n      )\n    )   \n\np_line\n\n\n\nAnnotations\nWe can add the annotations thanks to the {ggrepel} package. To be honest, I had a lot of struggle to find the good balance between the size of the annotation, the segments and the alignment of the annotations. At this stage, it was mostly a matter of iterations playing on the arguments of the geom_text_repel() function.\n\n\nlibrary(ggrepel) \n\np_line <-   \n  data |>  \n  filter(Entity %in% top10_countries_2019) |> \n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE,\n    size = 0.7\n    ) +   \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +   \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 20000, to = 140000, by = 20000),  \n             linetype = 'dashed',\n             color = '#dddddd'\n             ) +    \n  coord_cartesian(\n    xlim = c(1990, 2019), \n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.2))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),               \n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"\n      ),\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b',\n      face = 'bold',\n      size = 25,                                   \n      hjust = 0,                                    \n      margin = margin(t = 10)\n      ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 16,\n      margin = margin(t = 5)\n      ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 16,                                                 \n      margin = margin(t = 20)\n      ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 15,                                  \n      vjust = -1,                                 \n      margin = margin(b = 10,\n                      l = -255))\n    ) +\n  \n  # Adding the different annotations       \n  geom_text_repel(aes(\n    label = Entity,                           \n    color = Entity,                           \n    segment.shape = 0\n    ),\n    show.legend = FALSE,\n    data = data |>\n      filter(Year == 2019 & Entity %in% top10_countries_2019),\n    size = 4,                           \n    force = 0.5,                           \n    position = position_nudge_to(x = 2021),\n    direction = \"y\",\n    hjust = 0,\n    segment.curvature = -0.0000001,\n    segment.linetype = 'dotted'\n    )   \n\np_line\n\n\n\nThis is my final line graph.\nNow, let’s try to apply what we learned about {ggiraph} here.\n{ggiraph} version of the line plot\nThe {ggiraph} version follows the same logic as the map we previously created. We’re therefore appending “_interactive” to the geom_line() and to the geom_point() geoms.\n\n\np_line_girafe <-\n  data |>  \n  filter(Entity %in% top10_countries_2019) |>   \n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +   \n  # Making the line interactive   \n  geom_point_interactive(\n    aes(\n      color = Entity,     \n      tooltip = paste0(Year, \" \", Deaths),     \n      data_id = Year\n      ),\n    show.legend = FALSE,     \n    size = 0.7\n    ) +    \n  # Making the points interactive   \n  geom_line_interactive(\n    aes(   \n      color = Entity,     \n      tooltip = Deaths,     \n      data_id = Year\n      ),\n    show.legend = FALSE) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dashed',\n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.2))\n    ) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,\n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_classic() +\n  theme(axis.line.y = element_blank(),         \n        axis.ticks.y = element_blank(),\n        axis.title = element_blank(),         \n        axis.text = element_text(           \n          size = 13,   \n          color = \"#5b5b5b\"\n          ),         \n        plot.title = element_text(\n          family = 'merriweather',                                    \n          color = '#5b5b5b',\n          face = 'bold',\n          size = 15,                                   \n          hjust = -0.18,                                    \n          margin = margin(t = 10)\n          ),          \n        plot.subtitle = element_text(\n          color = '#5b5b5b',\n          hjust = -0.205,                                       \n          size = 11,\n          margin = margin(t = 5)\n          ),\n        plot.caption = ggtext::element_markdown(\n          color = '#5b5b5b',\n          hjust = -0.280,                                                  \n          size = 11,\n          margin = margin(t = 20)\n          ),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(\n          color = '#5b5b5b',\n          size = 10,\n          vjust = -1,\n          margin = margin(b = 10,                                           \n                          l = -320))\n        ) +\n  geom_text_repel(\n    aes(\n      label = Entity,\n      color = Entity,                           \n      segment.shape   = 0\n      ),\n    show.legend = FALSE,                       \n    data = data |>                          \n      filter(Year == 2019 & Entity %in% top10_countries_2019),\n    size = 3,\n    force = 0.5, \n    position = position_nudge_to(x = 2021),\n    direction = \"y\",\n    hjust = 0,                          \n    segment.curvature = -0.0000001\n    )   \n\ngirafe(ggobj = p_line_girafe)\n\n\nAdjustments\nWe can notice that the lines are displaying the number of deaths due to low physical activity for year 1990 (which is not what we want), and that even if the points display the year and number of deaths, they are super hard to hover over with the mouse. A cool feature that has been included on the OWID graph is that when you hover your mouse over the graph, a table is displayed with the following information :\nThe year that corresponds to the position of your mouse on the graph,\nThe unit of what is measured (deaths),\nThe legend followed by the number of deaths of each country for this specific year.\nI actually don’t know if I can include the legend, but it seems to me that I read something in the {ggiraph} documentation about possibilty to make tables pop on your graph interactively, so let’s give it a try.\nEdit: I actually found a great tutorial to do so: https://uncharteddata.netlify.app/posts/2022-09-30-interactive-tooltip-tables/\nCreate the table for the tooltip\nWe first need to create a summary table of the pieces of information we want to display in our tooltip. We can do so by extracting the following columns from our data dataset: Entity, Year, Deaths. It is advised to use the {kableExtra} package to do so.\n\n\nlibrary(kableExtra) \n\n# This code chunk is not run, it shows the process followed to build the function\n# that creates these tables for all rows of the dataset.\n\ntooltip_table <-    \n  data |>  \n  filter(Entity %in% top10_countries_2019) |>    \n  select(Entity, Year, Deaths) |> \n  st_drop_geometry() |> \n  kbl(row.names = FALSE)\n\n\nCreating a table for each observation\nIf we pass the newly created table to our tooltip aesthetic in the line graph, each tooltip will show the whole table. To only show the table part that correspond to the Year we are hovering with the mouse, the author of the tutorial suggests to create a new column in data that will contain a sub-table for each Year. To do so, he creates a function that loops trough each row and create the corresponding table.\nNote: I find it genius, especially because I would have never thought about crafting a function to assign a table to each row. Well, I didn’t even know it was possible, but I still wouldn’t have thought about it.\n\n\n#Not run, process\n\nmake_table <- \n  function(year){\n    data |>\n      filter(Entity %in% top10_countries_2019) |>   \n      filter(Year == year) |>    \n      select(Entity, Year, Deaths) |>    \n      st_drop_geometry() |>  # Only way I found to remove the geometry column\n      kbl(row.names = FALSE)  \n  }\n\n\nThis function is intended to create a table from the data dataset according to the specified year parameter. However, expecting that my computer is going to go crazy if we do so with the more than 5000 rows of the dataset, we can apply it to only the top 10 countries used until now in our line graph. To apply this function to each row, we can use the map() function from the {purrr} library. I purposefully don’t run these code chunk because creating a table for every single line in very heavy on my computer and takes forever. I will therefore only run the final function and “tooltip_table” variable.\n\n\ntooltip_table <-    \n  data |>\n  filter(Entity %in% top10_countries_2019) |>\n  mutate(tooltip_table = purrr::map(Year, make_table)) |>\n  select(Entity, Year, Deaths, tooltip_table)\n\n\nCustomizing the table shown by the tooltip\nTo do so, the author advises to modify the style of the table directly in the function that created them, the make_table() function. Also, it seems that a good appearance can be achieved by using the {gt} and {gtExtras} packages. We will start from the styling of the author and try to customize it.\n\n\nmake_table <- \n  function(year){\n    data |>\n      filter(Entity %in% top10_countries_2019) |>\n      filter(Year == year) |>    \n      select(Entity, Deaths) |>    \n      sf::st_drop_geometry() |>\n      gt() |>\n      gt::fmt_number(columns = Deaths, decimals = 0) |>\n      # adjust column widths   \n      gt::cols_width(everything() ~ px(120)) |>\n      # apply the nytimes theme from {gtExtras}   \n      gtExtras::gt_theme_nytimes() |>\n      # add a title and subtitle to the table   \n      # in the original graph, the title is the Year we are hovering with the mouse   \n      gt::tab_header(title = year, subtitle = \"in deaths\") |>\n      # get HTML content of table   \n      gt::as_raw_html() \n  }\n\n\nIT WORKS. Let’s add some new adjustments:\nWe want to make the tables a little smaller, which can be modified in the function make_table() that create the tables.\nLet’s also reproduce the kind of animation that makes the user see the tables that corresponds to the year her mouse is hovering over. I couldn’t find how to reproduce it exactly, so let’s opt for creating vertical reference lines with geom_vline_interactive(), and make them transparent thanks to the alpha argument. We will make these lines sufficiently wide to reproduce the effect of the OWID graph, which is that whenever the user hovers the graph, a table appears.\nAdd an effect that does the following: when hovering over the name of a country, the lines of the other countries get lower opacity, as on the original OWID graph. This can be done by providing a data_id aesthetic to geom_point_interactive, geom_line_interactive and geom_text_repel_interactive, and adding a first a opt_hover() and opts_hover_inv() similar to the one on the map we previously created.\nTweaking the style of our tooltip tables a bit.\n\n\nlibrary(gt)\nlibrary(gtExtras)\n\nmake_table <- function(year){     \n    data |>     \n    slice_max(n = 10, order_by = Deaths, by = Year) |>     \n    filter(Year == year) |>\n    select(Entity, Deaths) |>\n    sf::st_drop_geometry() |>     \n    drop_na() |>\n    gt() |>\n    gt::fmt_number(columns = Deaths, decimals = 0) |>\n    # Adding the Arial font     \n    opt_table_font(font = \"Arial\") |>\n    # making the Deaths column bold     \n    tab_style(       \n      style =  cell_text(weight = \"bold\"),\n      locations = cells_body(columns = Deaths)\n    ) |>\n    # lowering column widths and row height\n    gt::tab_options(data_row.padding = px(4)) |>\n    gt::cols_width(everything() ~ px(100)) |>\n    # Modifying the font size     \n    gt::tab_options(\n      table.font.size = 11,\n      heading.background.color = \"lightgrey\"\n    ) |>\n    gt::tab_header(title = year,                    \n                   subtitle = \"in deaths\"\n    ) |>\n    gt::as_raw_html()   \n}\n\n\n\n\ntooltip_table <-    \n  data |>\n  slice_max(n = 10, order_by = Deaths, by = Year) |>   \n  mutate(table = purrr::map(Year, make_table)) |>\n  select(Entity, Year, Deaths, table)  \n\np_line_girafe <-\n  tooltip_table |>  \n  drop_na() |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +    \n  geom_point_interactive(aes(      \n    color = Entity,     \n    data_id = Entity),\n    show.legend = FALSE, \n    size = 0.45\n  ) +\n  geom_line_interactive(aes(     \n    color = Entity,     \n    data_id = Entity),\n    show.legend = FALSE,\n    size = 0.3) +   \n  # Adding the vertical reference lines that, when hovered will display the tables with data for the corresponding year.   \n  geom_vline_interactive(aes(\n    xintercept = Year,\n    tooltip = table),\n    alpha = 0,                          \n    size = 4.75) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dotted',\n    color = '#dddddd'\n  ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000),\n    clip = 'off'\n  ) +\n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019)) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),                      \n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +\n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 9.5,\n      color = \"#5b5b5b\"\n    ),\n    axis.line = element_line(linewidth = 0.2),\n    plot.margin = \n      margin(r = 60,\n             b = 10\n      ),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 13,                                    \n      hjust = 0,                                    \n      margin = margin(t = 0)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                      \n      size = 9,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 9,                                                  \n      margin = margin(t = 10)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',       \n      size = 8,\n      vjust = -1,\n      margin = margin(l = -173)\n    ) \n  ) +\n  geom_text_repel_interactive(aes(\n      label = Entity,                       \n      color = Entity,                       \n      segment.shape   = 0,\n      data_id = Entity),\n    show.legend = FALSE,\n    data = data |>\n      filter(Year == 2019) |>\n      slice_max(n = 10, order_by = Deaths),\n    size = 2.5,                    \n    force = 0.5,\n    position = position_nudge_to(x = 2022),   \n    direction = \"y\",                  \n    hjust = 0,       \n    segment.curvature = -0.0000001,    \n    segment.size = 0.1,                   \n    xlim = c(NA, Inf)                 \n  )   \n\ngirafe(ggobj = p_line_girafe,        \n       options = list(          \n         opts_hover(css = \"color:;\"),          \n         opts_hover_inv(css = \"opacity:0.15;\")\n       )\n)\n\n\nI know that these elements might not be the core of the Data Viz projects, but I am still super proud of having explored the {ggiraph} package that much, and to have replicated a feature that I thought it would be impossible to make.\nAlternative graphs\nTo be honest, I find that the original Our World In Data graph is very complete, especially because it consists of two graphs that enables us to compare very easily countries between each other thanks to the map, but also take a look at the evolution through the years, and even compare evolutions thanks to the line graph.\nHowever, all the data that is displayed by these graphs are absolute numbers. We now that China is the country with most deaths due to low physical activity in 2019, but China is also the country with the most deaths all causes combined, because China is of course the most populated country in the world. Therefore, it seemed to me that these absolute values failed to convey the information we want to extract from the graphs, which might be something like: “Which country best meet physical activity standards in the world?” for instance.\nTherefore, the alternative graphs proposed are replicates of the original, but showing the data as percentages of the population that died from low physical activity.\nThe data\nThanks to the Population column that we added during the first process of the data to replicate the original graph, we just need to add a Percentage column to the ‘data’ dataset (for sake of clarity, we’ll create a second dataset for the alternative graphs, called data_alt and to discretize the Percentage variable for the alternative map.\nAlso, based on an advice of Iñaki, I chose to multiply by 1000 the percentages since they are very small, to enables a better visualization of the numbers, and to better compare them between each other.\n\n\ndata_alt <-    \n  data |> \n  mutate(\n    Percentage = round((Deaths/Population)*100*1000, digits = 3),\n    .after = Deaths_disc\n    ) |>  # the round() function is used for simpler visualization of the legend later.   \n  mutate(\n    Percentage_disc = discretize(Percentage, method = 'frequency', breaks = 9)\n    )\n\n\nAlternative map\nStatic version\nThe only change is therefore that we are using the data_alt dataset. We also have to modify the subtitle to precise that the numbers are not actual percentages, but thousandths of percentage.\n\n\nplot_subtitle_alt <- \"Estimated annual thousandth of percentage of the populations with deaths attributed to low physical activity.\" \n\n\n\n\np_map_alt <-    \n  # Using data_alt instead of data   \n  data_alt |>   \n  drop_na() |>\n  filter(Year == 2019) |>\n  ggplot() +   \n  # Using the column 'Percentage_disc' instead of 'Deaths\"  \n  geom_sf(aes(fill = Percentage_disc)) +   \n  coord_sf(crs = '+proj=robin') +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_void() +\n  theme(plot.title =\n          element_text(\n            family = 'merriweather',                                    \n            color = '#5b5b5b',\n            face = 'bold',\n            size = 20,\n            hjust = 0.125,                                   \n            margin = margin(t = -10)\n            ),\n        plot.subtitle = \n          element_text(\n            color = '#5b5b5b',\n            hjust = 0.42,\n            size = 16\n            ),         \n        plot.caption = ggtext::element_markdown(\n          color = '#5b5b5b',\n          hjust = 0.2,\n          size = 16,\n          margin = margin(t = 20)\n          ),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(\n          color = '#5b5b5b',\n          size = 15,\n          vjust = -1,\n          margin = margin(l = -248)\n          ),\n        legend.position = 'bottom',\n        legend.title = element_blank(),\n        legend.text = element_text(           \n          margin = margin(t = -22)\n          )\n        ) +\n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps(                        \n                      show.limits = TRUE,                        \n                      ticks = TRUE,\n                      barwidth = 25,\n                      barheight = 0.5,                       \n                      frame.colour = 'black',\n                      frame.linewidth = 0.01,                       \n                      ticks.colour = 'black',\n                      ticks.linewidth = 0.01)\n                    ) \n\np_map_alt\n\n\nInteractive version\n\n\n# Still a ' symbol for the country \"Cote d'Ivoire\" causing errors in ggiraph \ndata_alt <-\n  data_alt |>\n  mutate(Entity = if_else(Entity == \"Cote d'Ivoire\", \"Cote d Ivoire\", Entity))\n\ntooltip_css <- \"background-color: rgba(245, 245, 245, 1);\n                color: #000000; font-family: 'Arial', sans-serif;\n                font-size: 11px;\n                border-radius: 4px;\n                border: 1px solid #d9d9d9;\n                padding: 8px;\"\n\np_map_alt_girafe <-   \n  data_alt |>\n  filter(Year == 2019) |>\n  ggplot() +   \n  geom_sf_interactive(aes(        \n    fill = Percentage_disc,        \n    tooltip = \n      paste0(sprintf(\"<b>%s<\/b>: %.2f\", Entity, Percentage), \"\\nNumber of Deaths: \", round(Deaths)),\n    data_id = Entity\n  )) +\n  coord_sf(crs = \"+proj=robin\") +\n  labs(title = plot_title,        \n       subtitle = plot_subtitle_alt,        \n       caption = plot_caption,        \n       tag = plot_tag\n  ) +\n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 12,    \n      hjust = 0.12                                   \n    ),\n    #margin modified         \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.32,                                      \n      size = 8\n      ),\n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.14,                                                 \n      size = 8,                                                 \n      margin = margin(t = 20)\n    ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 7,  \n      vjust = -1,\n      margin = margin(l = -278)\n    ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),\n    legend.text = element_text(           \n      size = 8,\n      margin = margin(t = -22)\n    )\n  ) +\n  scale_fill_brewer_interactive(\n    palette = \"YlOrRd\",\n    # making the legend interactive\n    guide = guide_coloursteps_interactive(                        \n      show.limits = TRUE,                       \n      ticks = TRUE,\n      barwidth = 25,\n      barheight = 0.4,\n      frame.colour = \"black\",                       \n      frame.linewidth = 0.1,                       \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.1)   \n  ) \n\ngirafe(ggobj = p_map_alt_girafe,        \n       options = list(          \n         opts_hover_inv(css = \"opacity:0.7;\"),          \n         opts_hover(css = \"stroke-width:1.2;stroke:black;\"),          \n         opts_tooltip(css = tooltip_css        \n         )\n       )\n)\n\n\nAlternative line graph\nStatic version\nIn order to stay consistent with the first graph, I decided to plot the same countries as on the first replicate to have a comparison between the absolute numbers and percentage trends.\n\n\n# Countries that have the highest percentage of Deaths in 2019  \n\ncountries_top10 <-\n  data_alt |>\n  filter(Year == 2019) |>    \n  slice_max(n = 10, with_ties = FALSE, order_by = Deaths) |>\n  select(Entity) |>\n  sf::st_drop_geometry() |>\n  as_vector()  \n\np_line_alt <-    \n  # We use the same filtering process to get the same data as on the first line graph  \n  data_alt |>\n  filter(Entity %in% countries_top10) |>  \n  # Switching from the \"Deaths\" column to the \"Percentage\" one\n  ggplot(aes(\n    x = Year,\n    y = Percentage)\n  ) +\n  geom_point(aes(\n    color = Entity),\n    show.legend = FALSE,     \n    size = 0.7\n  ) +\n  geom_line(\n    aes(color = Entity),      \n    show.legend = FALSE\n  ) +   \n  geom_vline(xintercept = 0) +\n    # The reference lines will not be the same. As the max percentages between the countries plotted are around 4 units, let's set a horizontal reference line each 1   \n  geom_hline(\n    yintercept = seq(from = 0, to = 40, by = 10),\n    linetype = 'dashed',            \n    color = '#dddddd'\n  ) +\n  # The ylim will also not be the same   \n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 40),\n    clip = 'off'\n  ) +   \n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019)) + # expand removed\n  scale_y_continuous(breaks = seq(from = 0, to = 40, by = 10), # Also Adjusted\n                     expand = expansion(mult = c(0, 0.1)\n                     )\n  ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,           \n      color = \"#5b5b5b\"\n    ),\n    plot.margin = margin(r = 60), # Added\n    plot.title = element_text(family = 'merriweather',\n                              color = '#5b5b5b',                                   \n                              face = 'bold',\n                              size = 15,\n                              hjust = 0,                                    \n                              margin = margin(t = 10)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 11,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 11,\n      margin = margin(t = 20)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',                                \n      size = 10,\n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -320)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = Entity,                       \n      color = Entity,                       \n      segment.shape   = 0\n    ),\n    show.legend = FALSE,                       \n    data = data_alt |>\n      filter(Year == 2019 & Entity %in% countries_top10),\n    #slice_max(n = 10, order_by = Deaths),\n    size = 2.5, # Adjusted\n    force = 0.5,                       \n    position = position_nudge_to(x = 2022),\n    direction = \"y\",\n    hjust = 0,\n    segment.curvature = -0.0000001,                       \n    segment.size = 0.1, # Making segments thiner\n    xlim = c(NA, Inf) # Added to enable labels to past the boundaries of the plot\n  )\n\np_line_alt\n\n\n\nThe line graph is now a bit messier since the values for mortality due to low physical activity are actually quite close between countries. It seems to me that putting all these lines into a Slope chart might be clearer.\nSlope charts\nI still had the problem of having to choose which countries to plot. As I can’t replicate the filter function of the OWID graph, I made compromises. To me, the evolution is what we seek and the reason why we have the data available from 1990. Therefore, I chose to answer both following questions:\nWhat is the evolution of the countries that had the highest deaths-due-to-low-physical-activity rate in the past ?\nOn the other hand, what evolution led the countries that have the highest rates today, to this situation ?\nAnswering this means plotting on the one hand the 10 countries that had the highest percentages in 1990 and on the other hand, those who had the highest rates in 2019.\n\n\ncountries_top_percentage_2019 <-\n  data_alt |>\n  filter(Year == 2019) |>\n  slice_max(n = 10, with_ties = FALSE, order_by = Percentage) |>    \n  select(Entity) |>    \n  sf::st_drop_geometry() |>\n  as_vector()  \n\ncountries_top_percentage_1990 <-\n  data_alt |>\n  filter(Year == 1990) |>    \n  slice_max(n = 10, with_ties = FALSE, order_by = Percentage) |>  \n  select(Entity) |>    \n  sf::st_drop_geometry() |>\n  as_vector()\n\n# Slope graph of the countries which had the highest death rates in 1990.\np_slope_1990 <-    \n  data_alt |>\n  filter(Entity %in% countries_top_percentage_1990, Year == 1990 | Year == 2019) |>\n  ggplot(\n    aes(\n      x = Year, \n      y = Percentage)\n  ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE) +\n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE) +\n  coord_cartesian(\n    xlim = c(1975, 2034),\n    ylim = c(10, 60),\n    clip = 'off'\n  ) +     \n  scale_x_continuous(breaks = c(1990, 2019)) +     \n  scale_y_continuous(\n    breaks = seq(from = 10, to = 60, by = 10),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = \"The 10 countries with most deaths from low physical activity in 1990\",\n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),\n    axis.line.x = element_line(\n      linetype = 'dashed',\n      color = '#dddddd'\n    ),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(\n      size = 15,\n      color = \"#5b5b5b\"\n    ),         \n    plot.margin = margin(r = 50,\n                         l = 50),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 18,\n      hjust = 0,                                    \n      margin = margin(t = 20)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',  \n      hjust = 0,\n      size = 14,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 14,                                                 \n      margin = margin(t = 10)\n    ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 13,\n      vjust = -1,\n      margin = margin(b = 10,                                             \n                      l = -215)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(round(Percentage,1), \" \",Entity),                       \n      color = Entity),\n    data = data_alt |>\n      filter(Year == 2019) |>                        \n      filter(Entity %in% countries_top_percentage_1990),                       \n    show.legend = FALSE,\n    direction = 'y',\n    nudge_x = 5.5,                       \n    size = 5,\n    hjust = 0,\n    segment.alpha = 1,                      \n    segment.linetype = 'dotted'                      \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(Entity, \" \", round(Percentage,1)),\n      color = Entity),\n    data = data_alt |>\n      filter(Year == 1990) |>\n      filter(Entity %in% countries_top_percentage_1990),\n    show.legend = FALSE,                      \n    direction = 'y',\n    nudge_x = -5.5,                       \n    size = 5,\n    hjust = 1,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                     \n  ) +     \n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 10, to = 60, by = 10),\n    linetype = 'dashed',\n    color = '#dddddd'\n  )\n\n# Slope graph of the countries which had the highest death rates in 2019.\np_slope_2019 <-    \n  data_alt |>      \n  filter(Entity %in% countries_top_percentage_2019, Year == 1990 | Year == 2019) |>  \n  ggplot(aes(\n    x = Year, \n    y = Percentage)\n  ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +  \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n  ) +\n  coord_cartesian(\n    xlim = c(1975, 2034),\n    ylim = c(10, 60),\n    clip = 'off'\n  ) +\n  scale_x_continuous(breaks = c(1990, 2019)) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 60, by = 10),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = \"The 10 countries with most deaths from low physical activity in 2019\",        \n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +\n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),         \n    axis.line.x = element_line(\n      linetype = 'dashed',\n      color = '#dddddd'\n    ),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),         \n    axis.text = element_text(           \n      size = 15,\n      color = \"#5b5b5b\"\n    ),\n    plot.margin = margin(r = 50,                              \n                         l = 50), # Adjusted for making the slope plot thinner\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 18,\n      hjust = 0,                                    \n      margin = margin(t = 20)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',                                      \n      hjust = 0,                                       \n      size = 14,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 14,                                                 \n      margin = margin(t = 10)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 13,\n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -215)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(round(Percentage,1), \" \",Entity),\n      color = Entity),\n    data = data_alt |>  \n      filter(Year == 2019) |>\n      filter(Entity %in% countries_top_percentage_2019),                       \n    show.legend = FALSE,                       \n    direction = 'y',\n    nudge_x = 5.5,                       \n    size = 5,\n    hjust = 0,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                      \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(Entity, \" \", round(Percentage,1)),\n      color = Entity),\n    data = data_alt |>\n      filter(Year == 1990) |>\n      filter(Entity %in% countries_top_percentage_2019),                       \n    show.legend = FALSE,                      \n    direction = 'y',\n    nudge_x = -5.5,                       \n    size = 5,\n    hjust = 1,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                     \n  ) +     \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 10, to = 60, by = 10),\n             linetype = 'dashed',\n             color = '#dddddd'\n  )   \n\n\nI think this slope chart conveys the evolution of the mortality due to low physical activity a bit better than the line graph. To make it even clearer, I’d like to make the countries which have a downward slope blue and the ones which have an upward slope red. To do this, I’ll define a vector that will contain the color palette and manually add the assign each color to the countries.\nIn the beginning, I wanted to use pivot_wider() to create a column 1990 and a column 2019 that contained the Percentages of each country for these years, then use mutate() to create a new column equals to 2019 - 1990, and then pivot_longer() on both 1990 and 2019 columns to get back tidy data. However, when using the pivot_wider() function on thedata_alt data set, I repetedly got the error message “Object Year can’t be found” and couldn’t get the solution to this issue.\nTherefore, I manually pointed the upward slopes and the downward ones, and crafted the vector in a specific order to align the blue colors with downward slopes and the red ones to the upward ones.\nAn improvement that I could still do: tailor the shade of the color to the slope of the line.\n\n\ncolor_palette_1990 <- \n  c(   \n    '#FF0000',   \n    '#001EE0',\n    '#FF3C00',\n    '#0021F5',\n    '#0A2BFF',   \n    '#1F3DFF',\n    '#334EFF',  \n    '#FF531F',\n    '#4760FF',\n    '#FF6333' \n  )  \n\ncolor_palette_2019 <- \n  c(   \n    '#FF0000',\n    '#FF2800',\n    '#FF3C00',\n    '#FF4F00',\n    '#FF5900',\n    '#FF6300',\n    '#FF7600',\n    '#FF8300',\n    '#FF9000',\n    '#FF9D00' \n  )\n\np_slope_1990 <-   \n  p_slope_1990 +\n  scale_color_manual(\n    breaks = countries_top_percentage_1990,                      \n    values = color_palette_1990,                      \n    labels = countries_top_percentage_1990\n  )  \n\np_slope_2019 <-\n  p_slope_2019 +\n  scale_color_manual(\n    breaks = countries_top_percentage_2019,                      \n    values = color_palette_2019,\n    labels = countries_top_percentage_2019\n  )  \n\np_slope_1990 \n\n\np_slope_2019  \n\n\n\nProject takeaways and what I learned\nThis project was the best of the semester to be honest. It was the best because of how far it required us to push our newly acquired skills in {ggplot}. Actually, I really did not expect it to be that exciting. This excitment of exploring and failing then testing and finally succeeding can be seen with capital “IT WORKS” that I could have included a loooot more often in this article.\nMore seriously, at the end of the day, it might be one of the learning project that I found the most meaningful. Shoutout to Iñaki for enabling us to end the semester with much higher skills in Data.\nMy advices (For what they’re worth)\nDig deep in documentations, everyone say it, teachers say it. Okay now I understand.\nI’m currently learning Python, and having discovered the importance of understanding what’s in a library and how it works it so powerful.\nStart veeeeery soon. Unlike other projects, this one is given on the very first day of class, and that’s a huge chance to take the time to do a cool project that is interesting and valuable in my opinion Word of a dude who started in end of November and made the pull request 30 minutes before the deadline.\nMargins are a nightmare to render. A nightmare. They never end up where I expect them to be. I guess I’m just using them poorly lol\nInclude a pie chart in your project. Be braver than us ahahaha\n\n\n\n",
    "preview": "projects/2023/100517341/100517341_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100430897/",
    "title": "Public Trust in Government",
    "description": "Visual representation of the evolution of public trust in the United States\ngovernment by race and ethnicity from 1958 to 2023, as documented in the\nPew Research Paper.",
    "author": [
      {
        "name": "Carlos San-Juan-Baeza",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\nBackground\n\nWorking with the data\nPackgages\nCleaning and getting the data\n\nBuilding the graph\nFirst steps…\nMore aesthetic\nTheme\nOther details and replica\nLimitations\n\nImprovements\nAdd a new variable\nSolving problems\nNew axes\nFinal details\nFinal graph\n\nAnalysis and results\nConclusions and explanations\nPossible future implications\n\n\nIntroduction\nIn recent decades, perceptions of U.S. presidents have experienced a significant change, reaching historically low levels in recent years, which has led to numerous debates and articles discussing this phenomenon. In this paper, however, we will not only analyse the overall trust in presidential leadership, but we will disaggregate this trust by ethnic and racial categories within American society. Our goal is to understand the distinctive variations that emerge in this context and to examine closely how different communities evaluate the effectiveness and integrity of presidents. At the same time, we will be able to explore the impact that different leaders and historical events have had on society’s trust in government.\nIn order to carry out this research, we will rely on the newspaper article provided by Pew Researhc Paper, which analyses this social phenomenon in detail.\nThe original graph\nThe original graph that we are going to take into account for this article can be found on the same page mentioned in the previous section. This graph, as you can see below, presents information on the confidence of United States citizens in the different governments from 1958 to 2023. More specifically, the graph shows information on the most numerous races and ethnicities in the United States, which are Hispanic, Black, White and Asian. In addition, it allows us to see in which periods of time and under which US president there has been a growth or decline in trust, which could be interesting for numerous studies and to understand how social and political evolution has changed.\nOriginal Source: Pew Research Paper.Background\nThe history of ethnic and racial differences in the United States has been a difficult one, marked by diverse experiences and problems over time. From the earliest days of colonization, the presence of different ethnic groups, such as Native Americans, enslaved Africans, Europeans and later immigrants from various regions of the world, has shaped the cultural diversity of the nation. However, they have also faced significant challenges, such as slavery and racial discrimination, showing social inequalities. These experiences have consequently left their mark on society, generating distrust of government, especially when presidents have failed to adequately address these problems.\nHowever, while challenges persist, history also shows progress toward equality, and the relationship between ethnic identity and perceptions of the presidency remains an important theme in U.S. history.\nWorking with the data\nThe data we are going to use throughout the work are collected from numerous sources, such as Pew Research Center, National Election Studies, Gallup, ABC/Washington Post, CBS/New York Times, and CNN Polls. Moreover, the database for race and ethnicity analysis was obtained from searches of the iPOLL Databank provided by the Roper Center for Public Opinion Research. This database was obtained through telephone surveys of random individuals in the United States. More information on the questions that were used can be found here. Although the data is obtained from different sources, the complete database can be downloaded at Pew Researhc Paper\nPackgages\nThe libraries that we are going to use in all the work, both in the replica and in the subsequent improvements, are the following:\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(readr)\n\n\nCleaning and getting the data\nThe database provides information on the trust of citizens of different ethnicities and races on specific dates in the history of the United States. The trust of citizens is represented as a number between 0 and 100, with 0 being no trust and 100 being total trust. First, we have had to transform the “Date” column, which provides the different dates, into a specific format, which will facilitate the handling and analysis of temporal data.\n\n\ndata <- read_csv(\"database.csv\")\ndata.df <- data.frame(data[1:150,1:6])\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\n\nThe second step we have done in order to be able to treat the data correctly and to be able to analyse it, is to convert the data with tidyverse, in order to be able to clean it from NA. The reason for choosing Tidyverse is that it allows us to omit missing values without losing valuable information.\n\n\ndata.df <- data.df |>\n  tidyr::pivot_longer(c(Hispanic, White, Asian, Black)) |> \n  na.omit()\ndata.df\n\n# A tibble: 283 × 4\n   Date       .     name     value\n   <date>     <chr> <chr>    <dbl>\n 1 2023-06-11 PEW   Hispanic    23\n 2 2023-06-11 PEW   White       13\n 3 2023-06-11 PEW   Asian       23\n 4 2023-06-11 PEW   Black       21\n 5 2022-05-01 PEW   Hispanic    29\n 6 2022-05-01 PEW   White       16\n 7 2022-05-01 PEW   Asian       37\n 8 2022-05-01 PEW   Black       24\n 9 2021-04-11 PEW   Hispanic    36\n10 2021-04-11 PEW   White       18\n# ℹ 273 more rows\n\nFinally, before starting to replicate the graph, we have created a series of vectors which will be necessary later on in the elaboration of the graph. Such as the case of “years_to_highlight” which indicates the dates in which the mandate of the different presidents of the U.S. history from Eisenhower to Biden begins. The U.S. presidents we are going to take into account are the following:\nDwight D. Eisenhower (1953-1961) - Republican Party\nJohn F. Kennedy (1961-1963) - Democratic Party\nLyndon B. Johnson (1963-1969) - Democratic Party\nRichard Nixon (1969-1974) - Republican Party\nGerald Ford (1974-1977) - Republican Party\nJimmy Carter (1977-1981) - Democratic Party\nRonald Reagan (1981-1989) - Republican Party\nGeorge H.W. Bush (1989-1993) - Republican Party\nBill Clinton (1993-2001) - Democratic Party\nGeorge W. Bush (2001-2009) - Republican Party\nBarack Obama (2009-2017) - Democratic Party\nDonald Trump (2017-2021) - Republican Party\nJoe Biden (2021-present) - Democratic Party\nIt should be noted that we will only use data from 1958 onwards, i.e. we will not consider Eisenhower’s entire term of office.\n\n\nyears_to_highlight <- c(\n  \"1958-12-01\",  # Dwight D. Eisenhower\n  \"1961-01-20\",  # John F. Kennedy\n  \"1963-11-22\",  # Murder de John F. Kennedy\n  \"1963-11-22\",  # Lyndon B. Johnson assumes the presidency\n  \"1969-01-20\",  # Richard Nixon\n  \"1974-08-09\",  # Resignation of Richard Nixon\n  \"1974-08-09\",  # Gerald Ford takes office\n  \"1977-01-20\",  # Jimmy Carter\n  \"1981-01-20\",  # Ronald Reagan\n  \"1989-01-20\",  # George H.W. Bush\n  \"1993-01-20\",  # Bill Clinton\n  \"2001-01-20\",  # George W. Bush\n  \"2009-01-20\",  # Barack Obama\n  \"2017-01-20\",  # Donald Trump\n  \"2021-01-20\"   # Joe Biden\n)\n\n\nOn the other hand, we also convert into a vector the dates that will later be represented on the x-axis, which is 10 years difference.\n\n\ndesired_dates <- as.Date(c(\n  \"1960-01-01\", \"1970-01-01\", \"1980-01-01\", \"1990-01-01\",\n  \"2000-01-01\", \"2010-01-01\", \"2020-01-01\"\n))\n\n\nFinally we are going to add a function, which will be used to modify the background of the chart. The purpose of this function is to differentiate the background by sections of two different colours, White and “Beige” (being more specific #F0F0E6), which are interspersed. This difference is used to clarify the periods in which different presidents ruled.\nTo do this, we will create a series of vectors, “rect_dates”, which indicates the dates on which the background colours will change, “rec_alpha”, which is used to indicate the transparency of each rectangle that we will use to modify the background and “rect_colors” which indicates the different colours.\nIn short, the fucnion uses “lapply” to generate a list of rectangular layers, each representing a time interval defined by the dates in “rect_dates”. Each rectangle has a specific colour and transparency according to the “rect_colors” and “rect_alpha” vectors. These rectangles can then be added to a chart to highlight and visualize specific time segments. The function is called “rect_layers”.\n\n\nrect_dates <- c(\n  \"1958-12-01\", \"1961-01-20\", \"1963-11-22\", \"1969-01-20\", \"1974-08-09\", \"1977-01-20\",\n  \"1981-01-20\", \"1989-01-20\", \"1993-01-20\", \"2001-01-20\", \"2009-01-20\",\n  \"2017-01-20\", \"2021-01-20\", \"2023-10-12\"\n)\n\n\nrect_colors <- c(\"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\",\n                 \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\" , \"white\")\n\n\nrect_alpha <- c(0.2,0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2)\n\n\nrect_layers <- lapply(1:(length(rect_dates) - 1), function(i) {\n  geom_rect(\n    aes(xmin = as.Date(rect_dates[i]), xmax = as.Date(rect_dates[i + 1])),\n    ymin = -Inf, ymax = Inf,\n    fill = rect_colors[i], alpha = rect_alpha[i],\n    inherit.aes = FALSE\n  )\n})\n\n\nBuilding the graph\nFirst steps…\nIn order to analyse the data correctly, we will replicate the original graph developed by Pew Research Paper, which we mentioned earlier. Consequently, the first step to follow is to construct the axis on which our line chart will be developed.\nTo do so, we will use the time variable on the x-axis, which shows the different dates on which respondents were called to obtain the results. While on the y-axis, we have represented “Value” which shows the value of trust that voters placed in the presidents over time.\n\n\nj <- ggplot(data.df)+\n  aes(Date, value, color=name)\nj\n\n\n\nOnce the axis is established, the next step is to modify the background, as we have briefly mentioned before, in which we will use the function called “rect_layers” which we have already explained in previous sections. Its use will allow us to divide the background into two colours, forming different rectangles.\n\n\nj <- j + rect_layers\nj\n\n\n\nOnce the background of the graph has been divided according to the duration of government of the respective presidents, we introduce the data for the respective ethnicities. The different lines show how the trust of the different races and ethnicities has evolved over time in the United States. We have also added the legend in order to distinguish the different lines and know who they correspond to.\n\n\nj <- j + geom_line(linetype=\"solid\", size=1.75, alpha = 1, lineend= \"round\") +\n  scale_color_manual(\n    values = c( \"Asian\" = \"#DE996A\",\"White\" = \"#F2DBCD\",\"Black\" = \"#E7BA9A\",\"Hispanic\" = \"#A55A26\"),\n    name = \"\"\n  )\nj\n\n\n\nOnce the initial phase of the project has been completed, the next step will be to perfect it. So the next step will be to focus on the aesthetic aspect, seeking to enhance and expand its visual qualities, with the aim of making it look as similar as possible to the original graphic.\nMore aesthetic\nIn this part of the code I have focused on improving the title of the graphic, the subtitle, and the caption. At the same time we have added the X and Y axes, adding the corresponding scales to improve the compression of the line chart.\nIn the previous graph, the x-axis was segmented into 20-year sections, and at the same time, it is observed that the x-axis goes beyond the limits of the data, generating empty spaces at the extremes. In other words, the graph starts before the first data, collected in 1958, and ends after the last data in 2023, which can lead to confusion. On the other hand, the y-axis is less well represented, as it only shows information up to 80% confidence. To improve visualization, the x-axis could be adjusted to cover only the range of years available, providing a more accurate representation. Similarly, extending the y-axis to 100% would allow more subtle variations in confidence to be captured, providing a more complete representation of the data.\nConsequently, the function “scale_x_date” has been used in order to define the desired intervals and eliminate the gaps on the x-axis, using the vector previously named “desired_dates”, which organises the dates by decades. By using the format “%Y”, we achieve that only the years on the x-axis are displayed. Simultaneously, we have used the “expand” function to adjust the spacing between the ends of the graph and the y-axis, indicating that we want to remove any unnecessary space, which helps to eliminate gaps without data.\nFor the y-axis, we have applied similar strategies. We used the “breaks” and “limits” functions to set the limits and frequency of occurrence of numbers on the y-axis, extending the limits up to 100%.\n\n\nj <- j +\n  labs(\n    x = NULL,\n    y =NULL,\n    title = expression(paste(bold(\"Trust in government by race and ethnicity\"))),\n    subtitle = \"% who say they trust the government to do what is right just about always/most of time\",\n    color = \"Ethnicity:\",\n    caption = \"Source: PEW RESEARCH CENTER\")  +\n  scale_x_date(\n    breaks = desired_dates,\n    labels = format(desired_dates, \"%Y\"),\n    expand = c(0.00, 0.00) \n  ) +\n  scale_y_continuous(\n    limits = c(0, 100),\n    breaks = seq(0, 100, by = 20),\n    expand = c(0, 0)  \n  ) \n\n\nTheme\nIn this section of the code, we focus on refining the details of the graphic with the goal of making it as close as possible to the original design. To achieve this, we are using the “theme” function, which gives us the ability to adjust a variety of visual and stylistic elements of the graphic.\nSome of the most important adjustments made focus on refining the aesthetics and presentation of the graphic. This process involved customizing several key elements, addressing specific details to achieve a visually coherent and highly readable design. Among the highlights are modifying the size and style of the subtitle to highlight relevant information, specifically selecting the position and appearance of the legend to improve the visual layout, as well as adapting the format and position of the axes for a more accurate and easy-to-understand representation. In addition, the background of the chart is taken care of and margins are added to provide a more polished and professional overall appearance.\n\n\nj <- j + \n  theme_minimal() +\n  theme(\n    plot.subtitle = element_text(size = 10, color = \"grey\", face = \"italic\"),\n    plot.caption = element_text(hjust = -0.1, vjust = -10.0, color = \"black\", size = 10),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\"),\n    legend.text = element_text(size = 10),\n    legend.margin = margin(t = 0, b = -0.2, unit = \"cm\"),  \n    axis.line = element_line(size = 0.5, color = \"black\"),\n    axis.text = element_text(size = 10, color = \"black\"),\n    axis.title = element_text(size = 12, color = \"black\", face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    axis.ticks.x = element_line(size = 0.5),\n    axis.text.x = element_text(angle = 0, hjust = 0.5),  \n    axis.ticks.y = element_line(size = 0.5),\n    axis.text.y = element_text(angle = 0, hjust = 0.5),\n    plot.background = element_rect(fill = \"white\"),\n    plot.margin = margin(1, 1, 1, 1, \"cm\"), \n    legend.key.width = unit(1, \"cm\"),  \n    legend.key.height = unit(1, \"cm\"),  \n    legend.spacing = unit(0.5, \"cm\"),  \n    legend.box.margin = margin(0, 0, 0, 0, \"cm\")  \n  )\nj\n\n\n\nOther details and replica\nIn this final phase of the work, we focused on making the last improvements to obtain the final replica of the chart. We started by using the “guides” function, which plays a crucial role in improving the appearance and clarity of the legend. Through this function, we adjust specific aspects of the legend’s presentation, such as its position, title, and text formatting.\n\n\nj <- j + guides(\n    color = guide_legend(\n      keywidth = 1, keyheight = 0.5,  \n      label.position = \"right\", \n      ncol = 4  \n    )\n  )\n\n\nIn the final phase of replicating the original graph, the names of the presidents have been added above each rectangle to clearly identify the periods of their administrations. In addition, a colour code has been introduced, using red for Republican presidents and blue for Democratic presidents, to indicate the political party they represented in each case. On the other hand, we have marked it as a vector to be used later in a simpler way.\n\n\npresident <- c(\n  geom_text(aes(x = as.Date(\"1958-12-01\"), y = 90), label = \"Eisenhower\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1961-01-20\"), y = 90), label = \"Kennedy\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1963-11-22\"), y = 90), label = \"Johnson\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1969-01-20\"), y = 90), label = \"Nixon\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1974-08-09\"), y = 90), label = \"Ford\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1977-01-20\"), y = 90),\n            label = \"Carter\", vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1981-01-20\"), y = 90), \n            label = \"Reagan\", vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1989-01-20\"), y = 90), label = \"H.W. Bush\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1993-01-20\"), y = 90), label = \"Clinton\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"2001-01-20\"), y = 90), label = \"W. Bush\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"2009-01-20\"), y = 90), label = \"Obama\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"2017-01-20\"), y = 90), label = \"Trump\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"2021-01-20\"), y = 90), label = \"Biden\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\")\n)\n\n\nj <- j + president\nj\n\n\n\nLimitations\nBefore moving on to the analysis of the graph and exploring the possible impacts that this study could generate, it is necessary to address a number of limitations that affect its clarity and comprehensibility. First of all, there are obvious areas for improvement, for example, the excessive accumulation of lines in the central section, which makes the graph difficult to interpret. Furthermore, the similarity of colours used adds to the difficulty of the aforementioned visual problem. Additionally, when examining the lines corresponding to the Hispanic and Asian ethnic groups, there is a later beginning, especially noticeable in the case of Asia, where they are difficult to see due to the accumulation of lines. Nevertheless, I believe that this graph has a lot of potential for improvement to show the data with more detail and accuracy, as I consider this to be the main problem with the graph.\nFor this reason, before we go into explaining the bugs, we are going to make a number of improvements that could greatly benefit the compression of the line chart.\nImprovements\nAt this stage of the work, we will focus on improving the graph in order to make the analysis more effective and the visualization more understandable.\nAdd a new variable\nOne potential problem that we may encounter in further analysis is the absence of a reference point to assess with greater precision and accuracy the impact on the US presidency. Because of this, we have decided to add a new variable, “Trust.Average”. This variable allows us to measure the average trust of US citizens, which becomes an essential factor in measuring when the trust of different ethnicities is below or above the average trust.\nIt also gives us the ability to examine in more detail the specific times when changes in trust occur. This allows us to identify when the trust of different ethnicities shifts from above to below average, better understanding how different presidents and what time periods have impacted this process of variation in trust.\nTo add this variable, we have used another database provided by Pew Research Paper, which has the same format as our original database, so it is quite easy to add the confidence mean to our database.\n\n\ndata <- read_csv(\"database.csv\")\ndata.df <- data.frame(data[1:150,1:6])\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\ntrust <- read_csv(\"chart-export-cda90f7d-1ac9-45fd-99e1-ec61f808868b.csv\")\ntrust.df <- data.frame(trust[1:150,1:4])\n\ndata.df$Trust.Average <-trust.df$Trust.average\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\n\nOnce the variable has been added, we clean the NA data again with tidyverse. In addition, we have also named a new vector, which collects the names of the ethnicities, which we will use and explain later.\n\n\ndata.df <- data.df |>\n  tidyr::pivot_longer(c(Hispanic, White, Asian, Black)) |> \n  na.omit()\ndata.df\n\n# A tibble: 283 × 5\n   Date       .     Trust.Average name     value\n   <date>     <chr>         <dbl> <chr>    <dbl>\n 1 2023-06-11 PEW              16 Hispanic    23\n 2 2023-06-11 PEW              16 White       13\n 3 2023-06-11 PEW              16 Asian       23\n 4 2023-06-11 PEW              16 Black       21\n 5 2022-05-01 PEW              20 Hispanic    29\n 6 2022-05-01 PEW              20 White       16\n 7 2022-05-01 PEW              20 Asian       37\n 8 2022-05-01 PEW              20 Black       24\n 9 2021-04-11 PEW              21 Hispanic    36\n10 2021-04-11 PEW              21 White       18\n# ℹ 273 more rows\n\ndata.df$name <- factor(data.df$name, levels = c(\"White\", \"Black\", \"Hispanic\", \"Asian\"))\n\n\nSolving problems\nFirst of all, we are going to solve one of the main problems with the graph and that was the similarity of colours, which made it difficult to recognize and distinguish the different lines.\n\n\nj <- ggplot(data.df)+\n  aes(Date, value, color=name)+\n  rect_layers+\n  geom_line(linetype=\"solid\", size=1.75, alpha = 1) +\n  scale_color_manual(\n    values = c(\"Asian\" = \"#cdb4db\",  \"White\" = \"#bde0fe\", \"Black\" = \"#ffafcc\", \"Hispanic\" = \"#a7c957\"),\n    name = \"Ethnicity and race: \"\n  )\n\n\nIn the following code we are going to implement the new variable “Trust.Average”, which we have added as “dashed” so that there is no confusion with the colours, being easily visible and comparable with the rest of the variables.\n\n\nj <- j+\n  geom_line(aes(x = Date, y = Trust.Average, linetype = \"Trust.Average\"), color = \"black\") +\n  scale_linetype_manual(name = \"Trust.Average\", values = \"dashed\") \nj\n\n\n\nWe re-create the title and add the same details again.\n\n\nj <- j + \n  labs(\n    x = NULL,\n    y =NULL,\n    title = expression(paste(bold(\"Trust in government by race and ethnicity\"))),\n    subtitle = \"% who say they trust the government to do what is right just about always/most of time\",\n    color = \"Ethnicity:\",\n    caption = \"Source: PEW RESEARCH CENTER\")\n\n\nNew axes\nAnother important improvement we have developed is in the x-axis line, where we have added many more important dates that mark crucial events in US history, with significant impacts on public confidence and perceptions of the government. Here is a brief explanation of each of them:\nMLK. Jr Murdered. - 1968: The assassination of Martin Luther King Jr. was a critical moment in the struggle for civil rights, affecting confidence in equality and social justice.\nEnd of the Vietnam War - 1975: The conclusion of the Vietnam War in 1975 was a historic milestone in ending direct U.S. military involvement, generating profound reflections on foreign policy, social resistance and the reconceptualization of the U.S. role in international conflicts.\nIrangate - 1986: The Irangate scandal revealed the Reagan administration’s secret sale of arms to Iran, with funds destined for Nicaraguan rebels. This generated controversy over government transparency and ethics, impacting on trust in government integrity.\nOklahoma City Bombing - 1995: The terrorist attack in Oklahoma City, which resulted in the deaths of 168 people, left a deep imprint on the national conscience and led to an increase in homeland security.\n9/11 - 2001: The terrorist attacks of September 11 caused the deaths of thousands of people, leading the United States to declare the “War on Terror”. This transformative event altered global politics, national security and the perception of risk in American society.\nFinancial Crisis of 2008: The Financial Crisis, triggered by the collapse of large financial institutions and the housing bubble, resulted in a global recession. The consequences included massive job losses, government intervention in the financial sector and significant economic reforms to prevent future crises.\nSnowden Revelations - 2013: Edward Snowden, a National Security Agency (NSA) contractor, leaked classified documents that revealed massive U.S. government surveillance programs. These revelations generated intense debate about privacy, national security and the ethics of spying, impacting intelligence policies and public perception.\nCOVID-19 - 2020: The COVID-19 pandemic, which began in 2019, had a devastating impact on public health globally, triggering economic crises and undermining confidence in governmental responsiveness\nThis incorporation is essential to our analysis, as it gives us the opportunity to examine in greater detail and precision how each of these historical events impacted on the trust of different ethnicities. This comparison allows us to identify whether these events affected the average trust of individuals, as well as whether any of these events significantly affected one ethnicity or race more than another.\n\n\nj <-  j+ scale_x_date(\n    breaks = c(desired_dates, as.Date(\"2001-09-11\"), as.Date (\"2021-12-20\"), \n               as.Date(\"2008-01-01\"), as.Date(\"2013-02-02\"), as.Date(\"1995-01-01\"), \n               as.Date(\"1975-04-30\"), as.Date(\"1967-04-20\"), as.Date(\"1985-08-20\")),\n    labels = c(format(desired_dates, \"%Y\"), \"9/11\", \"COVID-19\", \"2008 Crisis\",\n               \"Snowden revelations\", \"Oklahoma City Bombing\", \"End of Vietnam War\", \n               \"MLK.Jr Murdered\", \"Irangate\"),\n    expand = c(0.00, 0.00), \n  )+ \n  scale_y_continuous(\n    limits = c(0, 100),\n    breaks = seq(0, 100, by = 20),\n    expand = c(0, 0) \n  )\n\n\nFinal details\nAgain, we reuse the “theme” function in which we have introduced slight improvements to show a neater and more detailed graphic and we add the “president” vector we created earlier, which we have not modified from the original graphic.\n\n\nj <- j + theme_minimal() +\n  theme(\n    plot.subtitle = element_text(size = 10, color = \"grey\", face = \"italic\"),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\", size=10),\n    legend.text = element_text(size = 10),\n    legend.margin = margin(t = 0, b = -0.2, unit = \"cm\"),  \n    axis.line = element_line(size = 0.5, color = \"black\"),\n    axis.text = element_text(size = 10, color = \"black\"),\n    axis.title = element_text(size = 12, color = \"black\", face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    axis.ticks.x = element_line(size = 0.5),\n    axis.ticks.y = element_line(size = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.text.y = element_text(angle = 0, hjust = 0.5),\n    plot.background = element_rect(fill = \"white\"),\n    plot.margin = margin(t=0.45, r= 0.5, b=0, l= 0.5, \"cm\"),\n    legend.key.width = unit(1, \"cm\"), \n    legend.key.height = unit(1, \"cm\"),  \n    legend.spacing = unit(0.5, \"cm\"),  \n    legend.box.margin = margin(0, 0, 1, 0, \"cm\"),\n    plot.caption = element_text(hjust = 0, vjust = 0, color = \"black\", size = 10, \n                                margin = margin(t = 0, b = 0.5, l = 0, r = 0, \"cm\"))\n  ) + president\n\n\nWe add a modification to the legends\n\n\nj <-  j + \n  guides(\n    color = guide_legend(\n      keywidth = 2, keyheight = 0.2,  \n      title.position = \"top\",  \n      label.position = \"bottom\",  \n      ncol = 4  \n    )) + guides(linetype = guide_legend(title = NULL,\n                                 label.position = \"bottom\",  keywidth = 0.2))\n\n\nFinal graph\nDespite improvements, the graph is still quite confusing, as there are many lines that are concentrated at similar points. This accumulation of lines can be confusing, making the interpretation of the graph more complicated. It is therefore necessary to treat data visualisation even more effectively to achieve a clearer and more accessible representation, ensuring that the information is easily assimilated by those viewing the graph.\nConsequently, we have used the function “facet_wrap” to divide the graph by ethnicity, leaving the variable “Trust.Average” as a constant. In this way, the graph is much more understandable, allowing us to take the average as a reference and make comparisons between graphs with greater precision. In addition, we have used the vector “names” mentioned above to display the graphs in the following order:\n\n\nj <- j+\n  facet_wrap(~name, scales = \"free\",nrow=2, ncol=2) \nj\n\n\n\nAnalysis and results\nOnce the improvement has been made, we can see that the graph is much clearer, which will allow us to analyse more precisely how US citizen confidence in the presidency has evolved and what historical factors may have affected these developments.\nFirst of all, it should be mentioned that these facts do not link direct causality, but provide a clearer visual representation of the underlying data. That is, the improved visualisation of the chart focuses on variations and trends, allowing us to identify patterns that might have previously gone unnoticed. However, at no point can we claim that these variations in confidence are due to the facts we mentioned, as well as to the president in question. This is because a large number of factors would have to be taken into account that cannot be predicted, at least not with our data. Therefore, our analysis will be based on observing how the different populations reacted to the different periods and analysing the key moments that have influenced citizens’ perceptions of the presidency.\nConclusions and explanations\nFirst of all, we are going to focus on explaining the 2 main graphs, which are those corresponding to the “White” and “Black” breeds. These are considered the main ones because they provide more data, since they start in 1958, therefore, we can make a more precise study and allow us to analyse a greater number of details.\nIn the graph that represents white people, the first thing that strikes us is the large decrease in trust over the years, as in 1958 trust was around 80% and in 2023 it dropped to just 20%. This shows that regardless of the type of government, the trust of white people has declined enormously. On the other hand, since Johnson’s presidency, the trust of this race plummeted and broke through the median barrier at the end of the Vietnam War along with the beginning of Carter’s presidency. This means that this date seems to be the exact point at which white confidence was below average for the first time in history, declining throughout that president’s term until the arrival of Nixon, where he regained confidence and again surpassed the average.\nHowever, one fact that is quite remarkable about this mandate is the lack of importance or repercussions that Irangate had, because although the average level of trust decreased from that date onwards, the trust of white people remained fairly constant. Subsequently, with the Bush administration, trust was also above average until the arrival of Clinton, when trust was again below average. However, during the eight years of Democratic rule, average trust increased by almost 40% during this period. Moreover, the beginning of this period of trust growth seems to coincide with the Oklahoma bombing. In 2001 there was a change of government from Democrat to Republican, with Bush again as President. However, this year was marked by the attack on the Twin Towers on 11 September 2001 (known as 9/11 or 11S ), which triggered the beginning of a loss of confidence in the government that continues to this day, both on average and in the specific case of white people. Since then, the only time that white people’s trust has been above average was with Trump. In general, we can observe that the trust of white people tends to be above average when political representatives belong to the Republican party. However, the overall average tends to decrease when these candidates are not in government.\nOn the other hand, in the case of Black individuals, we can see how their confidence in the government has also decreased over time, consistently remaining below the average. The trust of Black people in the government has remained relatively constant over time, ranging between 20% and 40%, except during two key events. The first and most notable change occurred with the assassination of Martin Luther King Jr. Following those dates, there was a marked decline in trust, which is understandable considering the impact of this historical event. Martin Luther King was one of the early and prominent advocates for racial equality in the United States. His assassination in 1968 not only represented the tragic loss of an influential leader but also symbolized a significant setback for the civil rights movement and equality. From that moment until the Clinton administration, trust remained below average, but this only lasted for a couple of years until the Oklahoma bombing.\nThe second event that saw a resurgence in the confidence of Black individuals was during the Obama administration. Upon assuming office in 2009, Obama became the first African-American president of the United States. His tenure marked a historic milestone that not only symbolized progress towards inclusion and diversity in the country’s leadership but also had a significant impact on the perception of the African-American community. The cultural connection and identification with a leader who shared their ethnic heritage contributed to strengthening trust in government institutions. Additionally, the policies and programs implemented during his administration to address specific challenges faced by the Black community reinforced the notion of progress and social justice, thus consolidating a tangible improvement in the confidence of this population during that period.\nRegarding the Hispanic ethnicity, for which we only have information from 1990, their confidence also shows a negative trend, although much less abrupt than in the previous cases, consistently remaining above the average. The historical event that most affected their confidence was the 9/11 attacks, similar to the majority of citizens in the country. It is also noted that in 2010, during the Obama administration, there were variations in their confidence, possibly influenced by the revelations of Edward Snowden.\nFinally, regarding Asians, we have very little information to effectively assess the provided data. However, starting from the COVID-19 crisis, there is observed a decrease in their confidence in the government, which could make sense considering that they were the target of attacks and discrimination during the pandemic. The Asian community faced stigmatization and prejudice linked to the origin of the virus, which possibly influenced their perception of the government.\nIn summary, we can affirm that the overall trust of American citizens has decreased over the years, affecting all the ethnicities and races we have observed. However, this decline has not affected all Americans equally. The analysis shows that white individuals have consistently shown a significant increase in trust when representatives from the Republican party are in power, a situation not mirrored in the majority of other cases, where trust tends to decline. The same pattern is observed with specific events, such as the assassination of Martin Luther King Jr., which had a more significant impact on the trust of Black individuals, or the COVID-19 pandemic, which affected the trust of Asian individuals.\nPossible future implications\nThis growing crisis in governmental trust could trigger a number of significant consequences on the stability and effectiveness of the political system, as well as result in increased social polarization, loss of legitimacy of governmental institutions and decreased citizen participation in the democratic process. Therefore, it will be essential to carefully analyze the underlying causes of the decline in trust and to implement effective measures to rebuild the connection between government and society.\nThis could have a wide range of political implications in the future, especially with the aim of reducing such politicization and rebuilding trust in the presidency, because if the necessary measures are not taken, it could lead to the outright rejection of political decisions, ending political support and causing the failure of different governments. Therefore, to avoid more unfavorable scenarios, it will be crucial to undertake significant efforts to rebuild trust through transparency, accountability and commitment to the needs and concerns of the population.\nFinally, understanding the reasons that generate this distrust in the presidency could be essential to address the Sustainable Development Goals (SDGs) of the 2030 Agenda. By identifying the causes and consequences of the lack of trust, more effective strategies can be developed to promote citizen participation and collaboration in the implementation of policies aimed at achieving sustainable goals.\n\n\n\n",
    "preview": "projects/2023/100430897/100430897_files/figure-html5/unnamed-chunk-22-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2880,
    "preview_height": 1872
  },
  {
    "path": "projects/2023/100507468/",
    "title": "Causes of Deaths 2019",
    "description": "Treemap that describe the causes of death before covid pandemic.",
    "author": [
      {
        "name": "Alejandro Saavedra-García",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction and libraries\nOriginal Graph\nReplication of the graph\nAnnotate\n\nFinal Replication\nLimitations\n\nEnhancement\n\nIntroduction and libraries\nIn order to make this chart, we need tidyverse to tidy the data, ggplot2\nto make the graph, and treemapify to helps us to improve our treemap.\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(treemapify)\n\n\nOriginal Graph\nWe found out this plot in the section of Terrorism in Our World in Data\nbut Terrorism and War battle deaths were the most insignificant cause of\ndeaths. This graph was published in Our World in data and the author is\nMax Roser.\nThe data was collected by IHME global Burden of Disease and Global\nTerrorism Database. This database contain data about causes of deaths\nfrom 1970 to 2021. Nevertheless, this graph just represents data\ncollected in 2019, which is the previous year before the covid-19\npandemic. 2020 and 2021 are not a significant year if you want to study\nthe evolution of the causes of deaths because they were significantly\naffected by the pandemic.\nOriginal graphReplication of the graph\n\n\nTree_terror <- read.csv(\"pruebacsv.csv\")\n\n\nAfter running the read.cvs, I had to make the tidy data of this\ndatabase.\nAt first, there were more illnesses than needed so I had to aggregate\nthem all in a new columns with their proper names. For this task, I had\nto search and determine the most suitable column for each illness.\n\n\nQ <- Tree_terror |>\n  drop_na() |> \n  mutate(Digestive_diseases = Digestive.diseases + Cirrhosis.and.other.chronic.liver.diseases,\n         Neurological_deseases = Alzheimer.s.disease.and.other.dementias + Parkinson.s.disease,\n         Other_noncommunicable_diseases = Chronic.kidney.disease + Drug.use.disorders + Alcohol.use.disorders, \n         Nutricional_deficiencies = Nutritional.deficiencies + Protein.energy.malnutrition,\n         Other_infectious_diseases = Meningitis + Acute.hepatitis,\n         Other_accidents = Drowning + Fire..heat..and.hot.substances + Exposure.to.forces.of.nature +Environmental.heat.and.cold.exposure,\n         Homicides = Interpersonal.violence + Poisonings)|> \n  filter(Year == 2019, Entity == \"World\") |> \n  select(-Digestive.diseases, \n        -Cirrhosis.and.other.chronic.liver.diseases, \n        -Alzheimer.s.disease.and.other.dementias, \n        -Parkinson.s.disease,\n        -Chronic.kidney.disease,\n        -Drug.use.disorders,\n        -Alcohol.use.disorders,\n        -Nutritional.deficiencies, \n        -Protein.energy.malnutrition,\n        -Meningitis,\n        -Acute.hepatitis,\n        -Drowning,\n        -Fire..heat..and.hot.substances,\n        -Exposure.to.forces.of.nature ,\n        -Environmental.heat.and.cold.exposure,\n        -Interpersonal.violence,\n        -Poisonings,\n        -Code,\n        -Year,\n        -Entity)  |> \n  pivot_longer(cols = \"Malaria\":\"Homicides\", \n               names_to = \"Causes\", \n               values_to = \"Num_of_deaths\")\n\n\nTo make this a treemap, all illnesses must be within a group. To\naggregate them I decided to create a new column(clasificación) and use a\ncase_when when they were classified as Infectious disease, Suicides and\nso on.\nIn this way, you can create groups(type of illness) and subgroups(which\nare the illnesses themselves).\n\n\nQ <-  Q |> \n    mutate(\n    clasificación = case_when(\n      Causes %in% c(\"Cardiovascular.diseases\", \"Neoplasms\", \"Chronic.respiratory.diseases\", \"Digestive_diseases\", \"Neurological_deseases\", \"Diabetes.mellitus\", \"Other_noncommunicable_diseases\") ~ \"Noncommunicable Diseases\",\n      Causes %in% c(\"Lower.respiratory.infections\", \"Diarrheal.diseases\", \"Tuberculosis\", \"HIV.AIDS\", \"Malaria\", \"Other_infectious_diseases\") ~ \"Infectious Diseases\",\n      Causes %in% c(\"Neonatal.disorders\", \"Maternal.disorders\", \"Nutricional_deficiencies\") ~ \"Maternity Deaths\",\n      Causes %in% c(\"Road.injuries\", \"Other_accidents\") ~ \"Transport Accidents\",\n      Causes %in% c(\"Self.harm\") ~ \"Suicides\",\n      Causes %in% c(\"Homicides\", \"Conflict.and.terrorism\") ~ \"Homicides\",\n      TRUE ~ \"Other\"\n    )\n  )\n\n\nWhen you finish with tidy and create groups and subgroups, now it is\ntime for ggplot(geom_treemap).\n\n\nQ <-ggplot(Q, \n            aes(area = Num_of_deaths, fill = clasificación, subgroup = clasificación, label = Causes)) + \n  geom_treemap() +\n  geom_treemap_subgroup_border() +\n  theme(legend.position = \"none\", plot.title = ggtext::element_markdown(),\n        axis.title = element_blank(), \n        axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        axis.line = element_blank()) +\n  labs(title = \"**What do people die from?** Causes of death globally in 2019\",\n       subtitle = \"The size of the entire visualization represents the total number of deaths in 2019: 55 million.\nEach rectangle within it is proportional to the share of deaths due to a particular cause\",\n       caption = \"Data source: IHME Global Burden of Disease and Global Terrorism Database\") +\n  scale_fill_manual(values = c(\"Noncommunicable Diseases\" = \"#084964\", \n                                \"Infectious Diseases\" = \"#a4184d\", \n                                \"Maternity Deaths\" = \"#b73695\", \n                                \"Transport Accidents\" = \"#0f9d76\", \n                                \"Suicides\" = \"#5b8464\", \n                                \"Homicides\" = \"#008e84\"))\nQ\n\n\n\nAnnotate\nI used annotate to write the name of the principle causes of deaths.\nBut, you have to be cautious because when you use annotate you will\nwrite on the chart, and everything you write it can overlap with other\nboxes. Therefore, the box will remain static even though you because\n\n\n#If you do anotate and the name are too long, it will overlap\n\nQ <- Q +\n   annotate(geom = \"text\", x = 0.0, y = 1, colour = \"white\", label = \"Cancer\") +\n   annotate(geom = \"text\", x = 0.1, y = 0.4, colour = \"white\", label = \"Cardiovascular diseases\") +\n   annotate(geom = \"text\", x = 0.42, y = 0.75, colour = \"white\", label = \"Digestive diseases\") +\n   annotate(geom = \"text\", x = 0.39, y = 1, colour = \"white\", label = \"Neurological\")+\n   annotate(geom = \"text\", x = 0.71, y = 1, colour = \"white\", label = \"Diabetes\") +\n   annotate(geom = \"text\", x = 0.85, y = 1, colour = \"white\", label = \"Suicide\") +\n   annotate(geom = \"text\", x = 0.87, y = 0.87, colour = \"white\", label = \"Road Injuries\")+\n   annotate(geom = \"text\", x = 0.90, y = 0.77, colour = \"white\",size = 3.2, label = \"Neonatal disorders\") +\n   annotate(geom = \"text\", x = 0.84, y = 0.60, colour = \"white\", label = \"Malaria\") +\n   annotate(geom = \"text\", x = 0.87, y = 0.5, colour = \"white\", label = \"Tuberculosis\") +\n   annotate(geom = \"text\", x = 0.85, y = 0.35, colour = \"white\", label = \"Diarrheal\")+\n   annotate(geom = \"text\", x = 0.89, y = 0.13, colour = \"white\", label = \"Lower infections\") +\n   annotate(geom = \"text\", x = 0.1, y = 0.4, colour = \"white\", label = \"Cardiovascular diseases\") +\n   annotate(geom = \"text\", x = 1, y = 1, colour = \"white\", size = 3, label = \"Homicides \") \nQ\n\n\n\nFinal Replication\n\n\nQ\n\n\n\nLimitations\nThere are 2 main limitations in this chart.\nFirst, the shape of this graph was made by r and I cannot change it into\nthe shape I want to replicate.\nSecond, because i cannot replicate the shape of the graph, the names and\nexplanations within the box cannot be replicated because of the length\nand annotation properties.\nEnhancement\nFor the improvement, I have created a geom_col to visualize all deaths\ncauses by violence. This is a better plot to study terrorism and its\nimpact to the total deaths.\nInfections, non-communicable disease, fire and so on, on the whole are\nunintentional causes. But suicide, terrorism and homicide are\nintentional so they have different variables to take into account and\nshould be studied apart from the rest.\nWe can see African, European, Americas, South-east Asia, and western\nPacific region to compare the three different violent causes per capita.\nThus, we can compare per capita the proportion of each cause by their\npopulation.\nTo create this chart, I have just saved the data(regions,number of\npeople that were affected and the population of those regions). Then, we\nhad to adjust the name of the column after the gather function. If we do\nnot do it, we will see in the legend Conflict.and.terrorism instead of\nConflict and terrorism. Finally, we use ggplot for the violent cause per\ncapita.\n\n\ndata <- data.frame(\nRegion = c(\"African Region (WHO)\", \"European Region (WHO)\", \"Region of\nthe Americas (WHO)\", \"South-East Asia Region (WHO)\", \"Western Pacific\nRegion (WHO)\"),\nHomicides = c(98527, 51451, 177179, 61714, 63379),\nConflict.and.terrorism = c(9519, 565, 32, 1880, 421),\nSuicide = c(69367, 137266, 94784, 230453, 184918),\nPopulation = c(1292124691, 342597698, 585172586, 655000000, 1900000000)\n)\n\n\n\ndatos_long <- gather(data, key = \"Causes\", value = \"Cantidad\", -Region,\n-Population)\n\n#We have to adjust the name of the column after the gather function\ndatos_long$Causes <- ifelse(datos_long$Causes == \n                            \"Conflict.and.terrorism\", \"Conflict and terrorism\",    datos_long$Causes)\n\n\nggplot(datos_long, \n       aes(x = Cantidad / Population * 100, y = Region, fill = Causes)) +\n       geom_col(position = \"dodge\") +\n       labs(title = \"Causes of violent death per capita\",\n       x = \"Violent deaths per capita\") +\n       theme_bw() +\n       theme(panel.background = element_rect(fill = \"white\"),\n             axis.text.y = element_text(angle = 0, hjust = 1),\n             axis.title.y = element_blank()) + \n       scale_fill_manual(values = \n                           c(\"Homicides\" = \"green\", \n                             \"Conflict and terrorism\" = \"yellow\", \n                             \"Suicide\" = \"brown\"))\n\n\n\nThe main finding of this plot is that, even thought you just compare\nviolent causes, terrorism is not as important as we might have thought.\nI do not want to undermine the position of the victims that terrorism\nhas caused. I just point out that following this plot, yourself and your\nneighborgs are more dangerous than a terrorist even though terrorism has\na critical impact on social media.\nTo sum up, public policies should take more into account preventing\nsuicide and homicides, at least, as much as they do with terrorism.\n\n\n\n",
    "preview": "projects/2023/100507468/100507468_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100509696/",
    "title": "Changing Sources of Electricity Generation in the United States",
    "description": "This graph describes how the sources of electricity generation in the United\nStates have changed from 2001 to 2017.",
    "author": [
      {
        "name": "Jieun Park",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nPackages and libraries\nOriginal graph\nData Processing\nReplication\nEnhancement\n\nPackages and libraries\n\n\nlibrary(readxl)\nlibrary(tidyverse)\n# remotes::install_github(\"davidsjoberg/ggsankey\")\nlibrary(ggsankey)\n\n\nOriginal graph\n\n\n\nFigure 1: Original graph\n\n\n\nThe presented graphical representation delineates the evolution of electricity generation sources in the United States across the span of 16 years, from 2001 to 2017, encompassing data from all 50 states. You can find the data from this link: https://www.eia.gov/totalenergy/\nTraditionally, over the 16-year period under scrutiny, coal, nuclear, and natural gas have consistently constituted the primary resources for electricity generation in the U.S. A comprehensive analysis, as outlined in the accompanying article, suggests that the relative rankings of these sources have undergone minimal alteration over 17 years for 13 states. Contrarily, in the remaining 37 states, both the proportions of electricity generated and the hierarchical ordering of different sources exhibit discernible changes. Consequently, the points of intersection or crossovers in the graph predominantly stem from the dynamic shifts observed in these 37 states.\nData Processing\n\n\ndata <- read_excel(\"Net_generation_United_States_all_sectors_annual.xls\")\n\n\ndata <- data |> separate(\"Year,petroleum liquids thousand megawatthours,coal thousand megawatthours,natural gas thousand megawatthours,nuclear thousand megawatthours,conventional hydroelectric thousand megawatthours,wind thousand megawatthours,all solar thousand megawatthours,geothermal thousand megawatthours\",\n                         into=c(\"year\", \"Petroleum\", \"Coal\", \"Natural Gas\", \"Nuclear\", \"Hydroelectric\", \"Wind\", \"Solar\", \"Geothermal\"), sep=\",\")\n\ndata <- data[-c(22),]\ndata <- data[-c(1,2,3,4),]\n\ndata$Petroleum <- as.numeric(data$Petroleum)\ndata$Coal <- as.numeric(data$Coal)\ndata$\"Natural Gas\" <- as.numeric(data$\"Natural Gas\")\ndata$Nuclear <- as.numeric(data$Nuclear)\ndata$Hydroelectric <- as.numeric(data$Hydroelectric)\ndata$Wind <- as.numeric(data$Wind)\ndata$Solar <- as.numeric(data$Solar)\ndata$Geothermal <- as.numeric(data$Geothermal)\n\ndata[is.na(data)] <- 0 #to calculate the proportion, NA should be replaced by 0\n\nyear <- rep(2001:2017, by = 1) #creating year variable\nyear <- as.matrix(year)\n\nx <- data |> select(-year)\nx <- as.matrix(x)\nx =  prop.table(x, margin = 1)\nx <- cbind(x, year)\n\nx <- as.data.frame(x) #change the matix to data.frame \nx <- relocate(x, \"V9\", .before = \"Petroleum\")\nx <- x |>  rename(c(year = V9))\nx$year <- sort(x$year, decreasing = TRUE)\n\nk <- pivot_longer(x, !year, names_to = \"energy\", values_to = \"percent\")\nk <- k |> mutate(percentage = percent * 100)\n\n\nThis is the code that I used for the replication of the original graph.\nI’ll explain some challenges that I have been faced using some codes below.\nReplication\n\n\ncolor <- c(\"Coal\" = \"#67614c\", \"Geothermal\" = \"#e2e2e2\", \"Hydroelectric\" = \"#81e3e9\",\n           \"Natural Gas\" = \"#e39424\", \"Nuclear\" = \"#9e71c2\", \"Petroleum\" = \"#d366a8\",\n           \"Solar\" = \"#f7d930\", \"Wind\" = \"#719bc2\")\n\nggplot(k, aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  theme_sankey_bump(base_size = 7)  +\n  labs(x = NULL, y = NULL,\n       title = \"Change of electricity generation sources in the United States\") +\n  scale_x_continuous(breaks = c(2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n                                2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017),\n                     labels = c(\"2001\", \"'02\", \"'03\", \"'04\", \"'05\", \"'06\", \"'07\", \"'08\", \"'09\",\n                                \"'10\", \"'11\", \"'12\", \"'13\", \"'14\", \"'15\", \"'16\", \"2017\")) +\n  scale_y_continuous(labels = NULL) +\n  theme_bw() + coord_cartesian(expand = FALSE) +\n  theme(legend.position = c(0.8,-0.4), legend.title = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.key.size = unit(c(0.35,0.35), \"cm\"),\n        plot.title = element_text(size = 9, face = \"bold\"),\n        legend.background = element_rect(color = \"black\"),\n        legend.text = element_text(face = \"bold\", family = \"Noto Sans KR\", size = 7),\n        plot.margin = unit(c(1,1,4,1), \"cm\"),\n        legend.spacing.x = unit(0.2, 'cm')) +\n  scale_fill_manual(values = color) +\n  guides(fill = guide_legend(nrow = 4)) +\n  annotate(\"text\", x = 2003, y = 75, label = \"Coal\", size = 5, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2006.5, y = 40, label = \"Natural gas\", size = 4, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2007.5, y = 20, label = \"Nuclear\", size = 4, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2003, y = 7, label = \"Hydroelectric\", size = 3, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2015.3, y = 5.3, label = \"WIND\", size = 1.9, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 70, label = \"51%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 40, label = \"21%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 19, label = \"17%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 6, label = \"6%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 85, label = \"32%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 52, label = \"30%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 28, label = \"20%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 13, label = \"7%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 6, label = \"6%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\")\n\n\n\nCode below is a fundamental structure of my graph replication.\nI put node, fill, and value to ggplot function and it constructs nodes for different sources of electricity generation and fills it by each color of sources. Moreover, as I put the percentage into the value, the magnitude of node is specified.\nThen, geom_sankey_bump() is used to execute the basic ggplot code into geom_sankey graph format. With this function, I was able to smooth the graph and the type is specified as alluvial.\n\n\nk |> ggplot(aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  scale_fill_manual(values = color)\n\n\n\nBecause in the original graph, there is no background space except for the generated graph, I used theme_sankey_bump() function to adjust the base size of the graph.\n\n\nk |> ggplot(aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  theme_sankey_bump(base_size = 7) +\n  scale_fill_manual(values = color)\n\n\n\nEnhancement\n\n\nnew_plot <- k |> \nggplot(aes(x=year, y=energy, fill=percentage)) +\n  geom_tile(col = \"white\") +\n  coord_equal() +\n  scale_fill_gradient(low=\"white\", high=\"blue\") +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 11, face = \"bold\"),\n    legend.title = element_text(size = 11)\n  ) + labs(\n    x = NULL,\n    y = NULL,\n    title = \"Change of electricity generation sources in the United States\",\n    fill = \"Percentage\"\n  ) + coord_cartesian(expand = FALSE) +\n  scale_x_continuous(breaks = c(2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n                                2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017),\n                     labels = c(\"2001\", \"'02\", \"'03\", \"'04\", \"'05\", \"'06\", \"'07\",\n                                \"'08\", \"'09\", \"'10\", \"'11\", \"'12\", \"'13\", \"'14\",\n                                \"'15\", \"'16\", \"2017\")) \n\nplotly::ggplotly(new_plot)\n\n\n\nIn the pursuit of data visualization enhancement, I employed the ggplot2 package in R, leveraging the versatile geom_tile() function. This particular function facilitates the systematic examination of individual observations arranged by rows and tiles, offering an intuitive approach to data analysis. To further refine the visual representation, the coord_equal() function was utilized, contributing to the generation of tiles that appear more as squares than rectangles. This adjustment enhances the overall visual organization of the graph.\nIn the realm of color aesthetics, the scale_fill_gradient() function played a pivotal role in orchestrating a gradient color scheme. By specifying “white” as the lower end and “blue” as the higher end of the gradient, the color spectrum effectively denotes the range of values within the dataset. The strategic arrangement of colors, transitioning from white for the lowest values to blue for the highest values, imparts a visual cue where darker hues correspond to higher values and lighter hues signify lower values. This gradient color mapping enhances the interpretability of the graph, fostering a more intuitive understanding of the underlying data.\nAs a final touch, the ggplotly() function was employed to impart interactivity to the graph. This transformation elevates the visual experience by allowing users to dynamically explore and interact with the plotted data.\n\n\n\n",
    "preview": "projects/2023/100509696/100509696_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100513795/",
    "title": "American's Top Concerns 2022",
    "description": "Most important issues for Americans, April-October 2022: step-by-step\nreplication graph and a possible alternative.",
    "author": [
      {
        "name": "Mireia Hontanares Belda-Cortés",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nOriginal graph\nGraphic replication\nLoad libraries and read the database\nData cleaning and filtering\nCreation of the plot\nAnnotations\n\nGraphic alternative\n\nIntroduction\nAnticipating the 2022 midterm American elections, FiveThirtyEight\nundertook a survey to unveil the primary concerns of Americans and their\npotential influence on voting decisions.\nThe forthcoming graph encapsulates the central issues articulated by\n2,000 surveyed Americans from April to October 2022. It aims to shed\nlight on the central aspects of the investigation into the factors\ninfluencing American decision-making in the crucial weeks before the\nelections.\nThe principal aim of this project is to accurately replicate the\ninitially mentioned graph. Subsequently, upon completion of the\nreplication, the intention is to propose an alternative representation\nfor the same set of data by creating another graph.\nOriginal graph\nAs mentioned earlier, the original graph depicts the evolution in\nAmericans’ perception of key concerns from April to October 2022. To\nillustrate this, an alluvial chart is created by FiveThirtyEight,\nshowcasing the progression of this perception across the 6 waves, with\ninflation emerging as the primary perceived issue in each of them. For\nthis, they rely on the results obtained from the FiveThirtyEight/Ipsos\npoll, specifically addressing question three of the survey. In this\nquestion, a set of categories- represented in the graph- are proposed,\nand respondents were required to choose three as their primary concerns.\nOriginal graphGraphic replication\nLoad libraries and read the database\nThe initial step in replicating the graph is to load the necessary\nlibraries for its creation.\n\n\nlibrary(tidyverse)\nlibrary(ggalluvial)\nlibrary(shadowtext)\n\ndf <- readxl::read_excel(\"potser.xlsx\")\n\n\nData cleaning and filtering\nIn order to closely replicate the original graph, it is necessary to\nconduct filtering and recodification of certain categories and\nelements.\nInitially, we filter out the categories related to “other” and “none\nof these” to ensure they are not represented.\n\n\nfiltered_data <- df %>%\n  filter(Categoría != \"None of these\" & Categoría != \"Other\")\n\n\nOn the other hand, a recoding process is implemented for the original\nnames of the so-called “waves,” signifying different time periods. These\nnames are abbreviated as follows: W1, W2, W3, W4, W5, and W6. The same\nprocedure is applied to rename certain categories to match those in the\noriginal graph.\n\n\n# Waves\n\nfiltered_data$Waves <- recode(filtered_data$Waves,\n                                \"W1\" = \"WAVE 1\",\n                                \"W2\" = \"WAVE 2\",\n                                \"W3\" = \"WAVE 3\",\n                                \"W4\" = \"WAVE 4\",\n                                \"W5\" = \"WAVE 5\",\n                                \"W6\" = \"WAVE 6\")\n\n# Categories \n\nfiltered_data$Categoría <- recode(filtered_data$Categoría,\n  \"Inflation or increasing costs\" = \"Inflation\",\n  \"Political extremism or polarization\"= \"Political extremism\",\n  \"Government budget and debt\" = \"Government budget/debt\",\n  \"Election security or fraud\" = \"Election security\",\n  \"Opioid or drug addiction\" = \"Drug addiction\",\n  \"COVID-19/ coronavirus\" = \"COVID-19\")\n\n\nFinally, the diverse categories were arranged to ensure that when\ncreating the graph, they appear in the same order as in the original.\n\n\ndesired_order <- c (\"Inflation\", \"Political extremism\", \"Crime or gun violence\",\n                    \"Immigration\", \"Climate change\", \"Government budget/debt\",\n                    \"Abortion\", \"Race and racism\", \"Economic inequality\",\n                    \"Foreign conflicts or terrorism\", \"Healthcare\",\n                    \"Election security\", \"Taxes\", \"Education\", \"Drug addiction\",\n                    \"COVID-19\", \"Unemployment\", \"Natural disasters\")\n\nfiltered_data$Categoría <- factor(filtered_data$Categoría, levels = desired_order)\n\n\nCreation of the plot\nFor the creation of the alluvial diagram, the ggplot2 package and\nits various extensions were utilized.\nThe initial step involved configuring the graph with ggplot, specifying\nthe dataset to be used. The aesthetics (aes) of the graph were defined,\nwith the X-axis representing the different “waves,” the Y-axis\nrepresenting the associated values (Valores), and color and alluvium\n(flows in the graph) being determined by the concern category\n(Categoría).\nThe application of geom_alluvium was employed to generate the\nalluvial layers of the graph, with various attributes such as\ntransparency (alpha), color, and line size separating different\ncategories being specified.\nFurthermore, scale_x_discrete was used to configure the X-axis, and\nscale_fill_manual was applied to assign specific colors, derived\nfrom the original graph, to each concern category.\nUltimately, the title and subtitle of the graph were added, accompanied\nby additional adjustments to customize elements such as axis titles,\ntext, margins, and grid lines. The use of coord_cartesian facilitated\nthe adjustment of X-axis limits to ensure proper data visualization.\n\n\nplot <- ggplot(filtered_data) +\n  aes(x = Waves, y = Valores, fill = Categoría, alluvium = Categoría) +\n  geom_alluvium(decreasing = FALSE, show.legend = FALSE, alpha = 0.95, colour = \"white\", size = 1.9) +\n  scale_x_discrete(position = \"top\") +\n  scale_fill_manual(values = c(\"#1a40af\", \"#743f96\", \"#8f4683\", \"#9e5276\",\n                               \"#b16f63\", \"#a9606b\", \"#e7ea98\", \"#b67f5c\",\n                               \"#bdad53\", \"#ba8f57\", \"#bdbd54\", \"#bdcc59\",\n                               \"#ccf483\", \"#b7d051\", \"#c1e86f\", \"#bc9e54\",\n                               \"#f2f3e0\", \"#f2f3e0\")) +\n  labs(\n    title = \"Americans' top concern is still inflation\",\n    subtitle = \"Share of Americans who said each issue was among the most important facing the\\n country in six waves of a FiveThirtyEight/Ipsos survey, April-October 2022\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.title.x.top = element_blank(),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.text.x.top = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 9, family = \"Agency FB\", face= \"bold\"),\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    plot.margin = unit(c(1, 1, 1, 1), \"lines\"),\n    panel.grid.major.x = element_line(color = \"black\", size = 0.07),\n    panel.grid.minor.x = element_line(color = \"black\", size = 0.07),\n    plot.title = element_text(family = \"Hansplatz Grotesk Bold\", size = 13,\n                              face = \"bold\", hjust = 0, margin = margin(b = 10, unit = \"pt\")), \n    plot.subtitle = element_text(family = \"Hansplatz Grotesk Bold\", size = 9,\n                                 face = \"plain\", hjust = 0,\n                                 margin = margin(t = 0, r = 0, b = 20, l = 0, unit = \"pt\"))\n  ) +\n  coord_cartesian(xlim = c(NA, NA), expand = FALSE)\n\nplot\n\n\n\nAnnotations\nFinally, ggannotate was employed for the annotations of each\ncategory in the graph, utilizing “shadowText” for the shading of each\nannotation. Adjustments were made to the font type, size, color, as well\nas inclination.\n\n\n plot <- plot + annotate (\"shadowText\", x= 5.4, y=250, label= paste(\"INFLATION\"),\n                          family= \"Franklin Gothic Medium\", size= 3.5,\n                          color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot + annotate (geom= \"text\", x= 5.8, y= 236,\n                          label = paste (\"65 percent of survey respondents said inflation was\",\n                                         \"one of the most important issues facing the country,\",\n                                         \"the highest of any wave of this survey\", sep = \"\\n\"),\n                          family = \"Franklin Gothic Medium\", size= 2.7,colour= \"white\", hjust=1)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.03547189834111, y= 191.940039688379,\n                         label= paste (\"CRIME OR GUN VIOLENCE\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+annotate ( \"shadowText\", x= 2.7681052384344, y = 159.126290409273,\n                         label =paste (\"POLITICAL EXTREMISM\"), \n                        family= \"Franklin Gothic Medium\", size= 3.5,\n                        color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+annotate ( \"shadowText\", x=4.49832172596228, y = 139.615412459535,\n                         label = paste (\"CLIMATE CHANGE\"),\n                         family= \"Franklin Gothic Medium\", size=  3.5, \n                         color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+ annotate ( \"shadowText\",x = 4.50788283594673, y = 121.878250687045,\n                          label = paste (\"IMMIGRATION\"),\n                          family= \"Franklin Gothic Medium\", size= 3.5,\n                          color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 4.77559391551139, y = 103.02794700318,\n                         label = paste (\"GOVERMENT BUDGET/DEBT\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.03040079654389, y = 130.400910778853,\n                         label = paste(\"ABORTION\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.40547189834111, y = 80.7433528761925,\n                         label= paste(\"RACE AND RACISM\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5, angle=-6L,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.50466965260073, y = 97.2508436873157,\n                         label= paste(\"FOREIGN\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5,angle= -35L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.42134402562677, y = 90.9367782109428,\n                         label = paste (\"CONFLICT OR \"),\n                         family=\"Franklin Gothic Medium\", size= 3.5, angle= -35L,\n                         vjust = 0.25, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.35965944508192, y = 87.1183131338777,\n                         label = paste (\"TERRORISM\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5,angle= -35L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x= 3.97289956683296, y = 40.1741646222174,\n                        label = paste (\"COVID-19\"), family= \"Franklin Gothic Medium\",\n                        size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\",x = 3.9202178680187, y = 52.7033197743356,\n                        label = paste(\"HEALTHCARE\"), family= \"Franklin Gothic Medium\",\n                        size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x=  4.46963839600892, y = 64.1996250727836,\n                        label = paste (\"ECONOMIC INEQUALITY\"),\n                        family= \"Franklin Gothic Medium\", size= 3.5, color= \"black\",\n                        bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x= 1.7800952657120652, y = 27.3196877943721,\n                        label = paste (\"ELECTION SECURITY\"),\n                        family= \"Franklin Gothic Medium\", size= 3.3, angle= -7L,\n                        color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x =5.35770595205863, y = 26.8394405136272,\n                         label = paste (\"DRUG ADDICTION\"),family= \"Franklin Gothic Medium\",\n                         size= 3.5, angle= -5L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 5.10049440802788, y = 21.6345688058513,\n                         label = paste (\"EDUCATION\"),family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 5.75082486420105, y = 12.8789224437039,\n                         label = paste (\"TAXES\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 1.98660111783731, y = 4.08708463768002,\n                         label = paste (\"UNEMPLOYMENT\"),\n                         family = \"Franklin Gothic Medium\", size = 3.3,\n                         color= \"black\",bg.color= \"white\", bg.r= 0.08)\n \n \n plot <- plot+ annotate (\"shadowText\",x= 4.10927846574883, y = 2.98728980567533,\n                         label = paste (\"NATURAL DISASTERS\"),\n                         family= \"Franklin Gothic Medium\", size= 3.3,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n plot\n\n\n\nGraphic alternative\nAs an alternative visualization to maintain the objective of depicting\nthe evolution of Americans’ perceptions regarding their top concerns\nacross the six waves, I find the heatmap to be a highly effective\nchoice. This approach facilitates the observation of trend developments\nand patterns, allowing for comparisons between different categories.\nAdditionally, the representation of values through varied color\ngradients enhances the intuitive depiction of intensity for each\ncategory.\nTo accomplish this, the same pre-cleaned database (filtered_data) used\nin replicating the graph was employed. The only modification made was\nchanging the order of the categories.\n\n\norder_heatmap <- filtered_data |>\n  group_by(Categoría) |>\n  summarise(Tendencia = sum(Valores)) |>\n  arrange(Tendencia) |>\n  pull(Categoría)\n\n\nfiltered_data$Categoría <- factor(filtered_data$Categoría, levels = order_heatmap)\n\n\nIn this manner, the ggplot2 library is employed to create a\nheatmap that visualizes the evolution of Americans’ primary concerns\nover six periods (waves) between April and October 2022.\nThe subsequent step revolves around constructing the graph itself.\nUtilizing ggplot, the heatmap is crafted, where waves are positioned on\nthe X-axis, categories (Categoría) on the Y-axis, and values are\nrepresented through colors. Similarly, the heat.colors palette is\nemployed, featuring 10 distinct shades, aiming to accentuate diverse\nchanges and enhance visual perception. To associate warmer colors with\nhigher values, the “rev” function is used, thereby reversing the\norder. Furthermore, the graph’s title is specified, and theme\nadjustments are applied to enhance readability and overall presentation.\nThis approach delivers a clear and effective visual representation of\nthe evolution of Americans’ top concerns over time.\n\n\nheatmap <-ggplot(filtered_data, aes(x = Waves, y = Categoría, fill = Valores)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradientn(colours = rev(heat.colors(10))) +\n  labs(\n    title = \"Americans' top concern's. April-October 2022\",\n    subtitle = \"Share of Americans most important issues perception in six waves, April-October 2022\", \n    fill = NULL\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, vjust = 0.5),\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    legend.title = element_blank(),\n    plot.title = element_text(family= \"Franklin Gothic Medium\",hjust = 1, size = 15,\n                              margin = margin(b = 5, l = 10, unit = \"pt\")), \n    plot.subtitle = element_text(family = \"Hansplatz Grotesk Bold\", size = 9,\n                                 face = \"plain\", hjust = 0.75,\n                                 margin = margin(t = 0, r = 0, b = 20, l = 10, unit = \"pt\")),\n    plot.margin = margin(t = 10, r = 10, b = 10, l = 10, unit = \"pt\") \n    )\n\n heatmap\n\n\n\n\n\n\n",
    "preview": "projects/2023/100513795/100513795_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100514861/",
    "title": "Gender Pay Gap Graph Replication",
    "description": "Using Eurstat data to reproduce the Gender Pay Gap graph of 2020.",
    "author": [
      {
        "name": "Rianne Nienke Visscher",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGraph replication\nIntroduction\nLibraries\nData cleaning and data transformation\nFonts\nCreating the main plot\nTheme specification\nAnnotations\nGraph text\nExtra panels\nCombining the planes with the main graph\nInserting graphics and final result\n\nGraph improvement\nData cleaning and data transformation\nMap\nFacet plot\nCombining graphs\n\n\nGraph replication\nIntroduction\nThe Gender Pay Gap graph of 2020 as presented below is created by Eurostat which is the European office for statistics by the European Commission. The graph shows a literal gap in the earth with a woman and man standing on top of it. For them, the gap is almost invisible as the smaller gaps are closest to the surface. Eurostat collects data concerning the labour market. The Gender Pay Gap is calculated as “the difference between the average gross hourly earnings of men and women expressed as a percentage of the average gross hourly earnings of men” (Eurostat, 2021), and is used as a proxy for the inequality between men and women.\nOriginal graphLibraries\nThe following libraries are used for the graph replication and the graph improvement\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(ggtext)\nlibrary(cowplot)\n\n\nData cleaning and data transformation\nFirst, the data is cleaned, that is, important NA’s and non-useful variables are deleted and only data for the year 2020 is kept. The variables ‘obs_left ’and ’obs_right’ are created which are needed to later compute the main graph. The variable ‘rank’ is computed to order the countries from the highest to the lowest pat gap.\n\n\ngender_pg <- read_csv(\"gender_pg.csv\")\n  \ndata <- gender_pg |> \n  filter(TIME_PERIOD == 2020) |> \n  filter(!(geo %in% c(\"EA20\", \"EA19\"))) |> \n  drop_na(OBS_VALUE) |> \n  select(-(\"DATAFLOW\":\"nace_r2\")) |> \n  select (-(\"OBS_FLAG\")) |> \n  mutate(obs_left = (OBS_VALUE/2)*-1,\n         obs_right = OBS_VALUE/2) |> \n  arrange(desc(OBS_VALUE)) |> \n  mutate(rank = 1:30) |> \npivot_longer(cols = c(\"obs_left\", \"obs_right\"), \n             names_to = \"left_right\", values_to = \"obs_conv\") |> \n  mutate(obs_left = (OBS_VALUE/2)*-1,\n         obs_right = OBS_VALUE/2) \n\n\nAs the original data only contains the abbreviations of the country names, in this section, a variable with the full country names is added to the data set.\n\n\ndata <- data |> \n  mutate(geo_names = case_when(geo == \"AT\" ~ \"AUSTRIA\",\n                               geo == \"BE\" ~ \"BELGIUM\",\n                               geo == \"BG\" ~ \"BULGARIA\",\n                               geo == \"CH\" ~ \"SWITZERLAND\", \n                               geo == \"CY\" ~ \"CYPRUS\",\n                               geo == \"CZ\" ~ \"CZECHIA\",\n                               geo == \"DE\" ~ \"GERMANY\", \n                               geo == \"DK\" ~ \"DENMARK\",\n                               geo == \"EE\" ~ \"ESTONIA\",\n                               geo == \"ES\" ~ \"SPAIN\",\n                               geo == \"FI\" ~ \"FINLAND\",\n                               geo == \"FR\" ~ \"FRANCE\",\n                               geo == \"HR\" ~ \"CROATIA\",\n                               geo == \"HU\" ~ \"HUNGARY\",\n                               geo == \"IE\" ~ \"IRELAND\",\n                               geo == \"IS\" ~ \"ICELAND\",\n                               geo == \"IT\" ~ \"ITALY\",\n                               geo == \"LT\" ~ \"LITHUANIA\",\n                               geo == \"LU\" ~ \"LUXEMBOURG\",\n                               geo == \"LV\" ~ \"LATVIA\",\n                               geo == \"MT\" ~ \"MALTA\",\n                               geo == \"NL\" ~ \"NETHERLANDS\",\n                               geo == \"NO\" ~ \"NORWAY\",\n                               geo == \"PL\" ~ \"POLAND\",\n                               geo == \"PT\" ~ \"PORTUGAL\",\n                               geo == \"RO\" ~ \"ROMANIA\",\n                               geo == \"SE\" ~ \"SWEDEN\",\n                               geo == \"SI\" ~ \"SLOVENIA\",\n                               geo == \"SK\" ~ \"SlOVAKA\",\n                               geo == \"EU27_2020\" ~ \"EU\")) |> \n  drop_na(geo_names)\n\n\nFonts\nThe fonts used in the original graph were checked using an online font detector. However, the original font was unavailable and ‘Roboto Condensed’ was reported as the most similar free font. The font is found in Google fonts and is uploaded using the ‘sysfonts’ package.\n\n\nsysfonts::font_add_google(\"Roboto Condensed\", family=\"Roboto Condensed\")\n\n\nCreating the main plot\nIn this section the main plot is created. Note that the main plot consist of two different geoms: geom_area with geom_linerange on top. Different rectangular annotations are done to match some of the aesthetics of the original graph. Geom_text is used to annotate the graph with the country names and the values of the gender pay gap per country (obs_value). As in the original graph Iceland, Norway and Switzerland with their corresponding obs_values are coloured grey whereas the rest of the countries and their obs_values is coloured black, these three countries have been excluded form the first geom_text and are later added in another geom_text with the specification of colour set as grey. Also, EU is not included in the first geom_text and is not added in the second geom_text as it asks for a different, more specific annotations and will later be added. The text colours have been generated using an online colour detector. Note that the labels are somewhat different from the original graph. This is due to a mismatch between the obtained data and the original graph. As I am uncertain as to what caused this mismatch, I do not change the data and accept these differences.\n\n\np <- data |>\n  ggplot (aes(x=obs_conv, y=rank))+\n  geom_area(fill = \"#ffeacb\")+  \n  geom_linerange(data = data, aes(y = rank,\n             xmin = obs_left, xmax = obs_right),\n             linewidth =0.3) +\n  annotate(\"rect\", xmin= -11.15, xmax= 11.15,\n           ymin=-3.5, ymax=0, fill = \"#ffeacb\" )+\n  annotate(\"rect\", xmin= -16, xmax= -11.15, \n           ymin=-3.5, ymax=1, fill = \"#f7a600\" )+\n  annotate(\"rect\", xmin= 11.15, xmax= 16, \n           ymin=-3.5, ymax=1, fill = \"#f7a600\" )+\n  annotate(\"rect\", xmin= -0.35, xmax= 0.35, \n           ymin=30.1, ymax= 30.5,fill = \"#ffeacb\" )+\n  geom_text(data=subset(data, OBS_VALUE != 12.9\n                        &OBS_VALUE !=12.2\n                        &OBS_VALUE !=13.4\n                        &OBS_VALUE !=18.4)\n            ,aes(label = OBS_VALUE, \n                 x = obs_right, \n                 family = \"Roboto Condensed\", \n                 fontface = 'bold'),\n                 size = 3.5, \n                 vjust = 0.5, \n                 hjust= -0.5)+\n  geom_text(data=subset(data, geo_names != \"EU\" \n                        & geo_names !=\"ICELAND\" \n                        & geo_names != \"NORWAY\"\n                        & geo_names != \"SWITZERLAND\"),\n            aes(label = geo_names, \n                x = obs_left, \n                family = \"Roboto Condensed\",\n                fontface = 'bold'), \n            size = 3.5, \n            vjust = 0.5,\n            hjust = 1.2)+\n  scale_x_continuous(limits = c(-22,22), expand=expansion(0))+\n   scale_y_continuous(limits = c(-3.5,30.5), expand=expansion(0))\n  \n  data_l<-data |> \n   filter(geo_names ==\"ICELAND\"|\n          geo_names == \"NORWAY\"|\n          geo_names == \"SWITZERLAND\")\n  \n p<-p+ \n   geom_text (data=data_l,aes(label = OBS_VALUE, \n                 x = obs_right, \n                 family = \"Roboto Condensed\", \n                 fontface = 'bold'),\n                 colour = \"#8e6001\",\n                 size = 3.5, \n                 vjust = 0.5, \n                 hjust= -0.5)+\n  geom_text(data=data_l,aes(label = geo_names, \n                x = obs_left, \n                family = \"Roboto Condensed\",\n                fontface = 'bold'), \n            colour = \"#8e6001\",\n            size = 3.5, \n            vjust = 0.5,\n            hjust = 1.2)\n p\n\n\n\nTheme specification\nIn this code piece, the panel grid and all themes is relation to the axes are set to element_blank to remove any of these specifications. The colour of the graph is set using the panel.background command.\n\n\np<-p+\n  theme(\n    plot.margin = margin(0,0, 0, 0),\n    panel.background = element_rect(fill = \"#f7a600\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.line = element_blank())\n\np\n\n\n\nAnnotations\nIn order to add the pink labels for EU, two data sets were generated only containing the values needed to plot the labels. Hereafter, geom_label is used to put the labels on top of the plot. The pink bar is computed using the annotate (“rect”) function.\n\n\nlabel_EU <- data |> \n  filter(geo_names ==\"EU\" & left_right== \"obs_left\") \n\nlabel_OBS_VALUE <- data |> \n  filter(left_right== \"obs_right\" & OBS_VALUE == 12.9) \n  \n\nlabel_EU\n\n# A tibble: 1 × 9\n  geo       TIME_PERIOD OBS_VALUE  rank left_right obs_conv obs_left\n  <chr>           <dbl>     <dbl> <int> <chr>         <dbl>    <dbl>\n1 EU27_2020        2020      12.9    15 obs_left      -6.45    -6.45\n# ℹ 2 more variables: obs_right <dbl>, geo_names <chr>\n\np<- p+\n  annotate(\"rect\",ymin=15, ymax= 15, \n           xmin = -6.45, xmax=6.45,\n           fill = NA, color=\"#a71c6d\", linewidth =1)+\n  geom_label(data = label_EU, aes(label = geo_names), \n             family = \"Roboto Condensed\",  fontface = 'bold', size = 3.5, \n             color = \"white\",fill = \"#a71c6d\",\n             label.size = 0, label.r = unit(0, \"lines\"),\n             label.padding = unit(0.05, \"lines\"),\n             vjust = 0.5, hjust = 1.3)+\n  geom_label(data = label_OBS_VALUE, aes(label = OBS_VALUE), \n             family = \"Roboto Condensed\",  fontface = 'bold', size = 3.5,  \n             color = \"white\",fill = \"#a71c6d\", \n             label.size = 0, label.r = unit(0, \"lines\"),\n             label.padding = unit(0.05, \"lines\"),\n             vjust = 0.5, hjust= -0.5)\n  p\n\n\n\nIn this section, the text annotations are computed and are added to the main plot using annotate (‘text’)\n\n\nmiddle_string <- \"For all countries except Czechia and Iceland: data for enterprises \\n employing 10 or more employees. Czechia and Iceland: data \\n for enterprises employing 1 or more employees \"\n\nleft_string <- \"Iceland, Norway, Switzerland: \\n non_EU countries\"\n\nright_string <- \"Ireland, Greece: data not \\n available\"\n\np<-p+ \n  annotate(\"text\", x=0, y=-1, label = middle_string, family = \"Roboto Condensed\", size = 2.5, fontface = 'italic')+\n  annotate(\"text\", x=-12, y=-2, label = left_string, family = \"Roboto Condensed\", size = 2.5,  hjust ='right')+\n  annotate(\"text\", x=12, y=-2, label = left_string, family = \"Roboto Condensed\", size = 2.5, hjust ='left')\n\np\n\n\n\nGraph text\nIn this section the text that annoate the graph is generated for the upper part of the graph. The panels for the upper and lower part of the graph is computed in the next section.\n\n\nsubtitle_string <- \"How much less \\n do women earn \\n than men?\"\n\nsubtitle_string_short <- strwrap(subtitle_string, width = 15)\n\ntag_string <- \"Difference between average gross \\n hourly earnings of male and female \\n employees as % of male gross \\n earnings, 2020\"\n\ntag_string_short <- strwrap(tag_string, width = 35)\n\n\nExtra panels\nIn this section, the extra panels that are at the top and bottom of the graph are computed. The panels contain many different pieces of text. In order to locate them precisely to match the original graph, annotate (‘text’) is used. Later these panels will be added to the main graph using the library ‘patchwork’.\n\n\np1.df<- data_frame(x=c(-20,20), y= c(10,10))\n\np1<- p1.df |> ggplot (aes(x=x, y=y))+\n  geom_area(fill = \"#ffeacb\")\n\np1<-p1+\n  theme(aspect.ratio = 0.4,\n         axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank(),\n         plot.margin = margin (20,0, 0, 0))+\n  scale_x_continuous(expand=expansion(0),limits = c(-20,20)) +\n  scale_y_continuous(expand=expansion(0))+\n  annotate(\"text\", x=0, y=8, label = \"Gender pay gap\",\n           family = \"Roboto Condensed\", size = 12, fontface = 'bold')+\n  annotate(\"text\", x=-7, y=4, label =  paste(subtitle_string_short, collapse = \"\\n\"),\n           family = \"Roboto Condensed\", size = 7.5, fontface = 'bold',\n           lineheight = 0.8, hjust ='right')+\n  annotate(\"text\", x=6, y=4, label =  paste(tag_string_short, collapse = \"\\n\"),\n           family = \"Roboto Condensed\", size = 3.75, fontface = 'italic', \n           hjust = 'left')\n\np1\n\n\np2.df<- data_frame(x=c(-20,20), y= c(10,10))\n\np2<- p2.df |> ggplot (aes(x=x, y=y))+\n  geom_area(fill = \"white\")\n\np2<-p2+\n  theme(aspect.ratio = 0.05,\n         axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank())+\n  scale_x_continuous(limits = c(-20,20), expand=expansion(0)) +\n  scale_y_continuous(expand=expansion(0))+\n  annotate(\"text\", x=-5, y=6, label = \"#InternationalWomensDay\", \n           family = \"Roboto Condensed\", size = 5, fontface = 'bold',\n           color = \"#7a7b7f\", hjust=1)+\n  annotate(\"text\", x=6, y=6, label = \"ec.europa.eu/\", \n           family = \"Roboto Condensed\", size = 5, color = \"#7a7b7f\", hjust=0)+\n  annotate(\"text\", x=12.5, y=6, label = \"eurostat\", \n           family = \"Roboto Condensed\", size = 5, color = \"#7a7b7f\", hjust=0, fontface = 'bold')\n\np2\n\n\n\nCombining the planes with the main graph\nThis section adds to two extra plains to the main graph using the library (‘patchwork’)\n\n\np3<-p1+p+p2+\n  plot_layout(ncol=1)&\n  theme(plot.background = element_rect(fill =\"#ffeacb\"),\n        plot.margin = margin(0,0,0,0))\np3\n\n\n\nInserting graphics and final result\nThis piece of code adds the graphics of the woman and the man in the upper part of the graph as well as the EU sign in the lower part of the graph. The function ggdraw from the ‘cowplot’ package is used to do so.\n\n\np3<-ggdraw(p3) +      \n  draw_image(\"images/female.png\", y = 0.315, x=-0.07, scale = 0.170)\n\np3<-ggdraw(p3)+\n  draw_image(\"images/male.png\", y = 0.315, x=0.06, scale = 0.170)\n\np3<-ggdraw(p3)+\n  draw_image(\"images/eu.png\", y = -0.48, x=0.445, scale = 0.05)\n\np3\n\n\n\nGraph improvement\nIn my opinion, the original graph should not be changed as I think that the graph is clear and concise. It is able to transfer the message that the pay gap exists in all European countries and that the gap is fairly wide in many of them. Moreover, the graph is aesthetically pleasing and easy to interpret. However, a small shortcoming of this graph is that it only shows data for 2020 whereas the evolution of the pay gap over time can show us whether the gap is decreasing or not, that is, whether Europe is heading in the right direction. Therefore, I developed a new graph that is able to express this evolution over time. The graph consists of two sub graphs: a map showing the percentage increase or decrease between 2010 and 2021 and a facet graph showing a line graph of the evolution of the gender pay gap between 2010 and 2021. I have chosen to include the map graph as it is able to summarise the trends shown in the facet graph which are rather hard to compare among themselves due to the large amount of information in the graph.\nData cleaning and data transformation\nThe first step in building both graphs is transforming the data. For both graphs, only data from 2010 onward was selected. For the facet graph, the full country names were computed and a sub data frame only excluding the variable geom_names was created which is needed for specifying part of the graph. For the map graph, two new variables had to be created: the gender pay gap (obs_value) of 2010 (y2010) and the gender pay gap of 2021 (y2021) in order to subtract them from one another and create a variable that expresses the difference between 2010 and 2021. The following was done by making two new data sets with a column just specifying the pay gap in 2010 and 2021 and then merging these new data sets with the main data set. Hereafter, y2010 was subtracted from y2010 and this continuous variable was transformed into a factor variable by classifying the continuous variables into factors of 2 percentage points.\n\n\ngender_pg <- read_csv(\"gender_pg.csv\")\n\n#Data frame used for the facet graph\ndata2<- gender_pg |> \n  filter(TIME_PERIOD > 2009)\n\n#Gnereating the full country names for the facet graph\ndata2 <- data2 |> \n  mutate(geo_names = case_when(geo == \"AT\" ~ \"AUSTRIA\",\n                               geo == \"BE\" ~ \"BELGIUM\",\n                               geo == \"BG\" ~ \"BULGARIA\",\n                               geo == \"CH\" ~ \"SWITZERLAND\", \n                               geo == \"CY\" ~ \"CYPRUS\",\n                               geo == \"CZ\" ~ \"CZECHIA\",\n                               geo == \"DE\" ~ \"GERMANY\", \n                               geo == \"DK\" ~ \"DENMARK\",\n                               geo == \"EE\" ~ \"ESTONIA\",\n                               geo == \"ES\" ~ \"SPAIN\",\n                               geo == \"FI\" ~ \"FINLAND\",\n                               geo == \"FR\" ~ \"FRANCE\",\n                               geo == \"HR\" ~ \"CROATIA\",\n                               geo == \"HU\" ~ \"HUNGARY\",\n                               geo == \"IE\" ~ \"IRELAND\",\n                               geo == \"IS\" ~ \"ICELAND\",\n                               geo == \"IT\" ~ \"ITALY\",\n                               geo == \"LT\" ~ \"LITHUANIA\",\n                               geo == \"LU\" ~ \"LUXEMBOURG\",\n                               geo == \"LV\" ~ \"LATVIA\",\n                               geo == \"MT\" ~ \"MALTA\",\n                               geo == \"NL\" ~ \"NETHERLANDS\",\n                               geo == \"NO\" ~ \"NORWAY\",\n                               geo == \"PL\" ~ \"POLAND\",\n                               geo == \"PT\" ~ \"PORTUGAL\",\n                               geo == \"RO\" ~ \"ROMANIA\",\n                               geo == \"SE\" ~ \"SWEDEN\",\n                               geo == \"SI\" ~ \"SLOVENIA\",\n                               geo == \"SK\" ~ \"SlOVAKA\",\n                               geo == \"EU27_2020\" ~ \"EU\")) |> \n  drop_na(geo_names)\n\n#Deleting the variable geo_names for the facet graph\ndata2a<- dplyr::select(data2, -geo_names)\n\n#Creating data frame for the map graph\n#Creating variable y2021\ndata4<- data2 |> \nfilter(TIME_PERIOD==2021) |>\nmutate(y2021 = OBS_VALUE)\n\n#Creating variable y2010\ndata5<- data2 |> \nfilter(TIME_PERIOD==2010) |>\nmutate(y2010 = OBS_VALUE) \n\n#Merging variable y2021 into the main dataset\ndata3<- data2 |> \n  left_join(data4, by = c(\"geo\" = \"geo\"))\n\n#Merging the variable y2010 into the main data set\ndata3<- data3 |> \n  left_join(data5, by = c(\"geo\" = \"geo\"))\n\n#Selecting only the necessary variables\ndata3<- data3 |> \n  select(geo, TIME_PERIOD, OBS_VALUE, geo_names, y2021, y2010) |> \n  mutate(TIME_PERIOD = as.integer(TIME_PERIOD))\n\n#Creating the continuous variable of the dfference between 2010 and 2021 and transforming this into a categorical varaible\ndata3<- data3 |> \n  mutate(diff_10_21 = y2021-y2010) |>\n  mutate(diff_10_21_fact = ifelse(between(diff_10_21, -8, -6), \"-8 to -6\",\n                           ifelse(between(diff_10_21, -5.99, -4), \"-6 to -4\",\n                           ifelse(between(diff_10_21, -3.99, -2), \"-4 to -2\",\n                           ifelse(between(diff_10_21, -1.99, 0), \"-2 to 0\",\n                           ifelse(between(diff_10_21, 0.01, 2), \"0 to 2\",\n                           ifelse(between(diff_10_21, 2.01, 4), \"2 to 4\",\n                           ifelse(between(diff_10_21, 4.01, 6), \"4 to 6\",\n                           ifelse(between(diff_10_21, 6.01, 8), \"6 to 8\", \"NA\")))))))))\n\n#Uploading the map data from the 'giscoR' package and joing this data with the main dataset\neurope<-giscoR::gisco_get_countries(resolution = \"60\",\n    region=\"Europe\") |> \n  select(CNTR_ID, geometry) |> \n  left_join(data3, by = c(\"CNTR_ID\" = \"geo\"))\n\n\nMap\nThe map is created using geom_sf. Europe is selected by setting the coordinates in the coord_sf command. Also, the title and the legend title are created.\n\n\np1021<- ggplot(europe)+\n  geom_sf(aes(fill = reorder(diff_10_21_fact, diff_10_21)), size = 1)+\n  coord_sf(xlim=c(-20, 50),\n           ylim=c(35, 70))+\n  labs(title = \"Difference in Gender Pay Gap between 2010 and 2021\",\n       fill = \"Percentage change\")\n  \n\np1021\n\n\n\nTheme specification\nIn this section, the aesthetics of the graph are specified. All elements concerning the axis and the panel are set to element_blank to reduce noise in the graph. Also, the colour scale is set manually based on an existing colour palette. The colours are high in contrast to grasp the attention of the viewer and enhances understanding of decreasing or increasing percentages, that is, positive or negative trends. Hjust in the plot title is used to align the title with the scale which will become visible in the final plot.\n\n\np1021<-p1021+\n  theme(axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank(),\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(colour =  \"#33201F\", family = \"Roboto Condensed\", face = \"bold\", hjust = 1),\n    plot.subtitle = element_text(family = \"Roboto Condensed\",colour =  \"#33201F\" ),\n    legend.title = element_text(family = \"Roboto Condensed\",colour =  \"#33201F\" ),\n    legend.position = \"left\",\n    plot.margin = margin(10,10,10,10))+\n  scale_fill_manual(values = c( \"-8 to -6\" = \"#008C89\",\n                                  \"-6 to -4\" = \"#00AD7C\",\n                                  \"-4 to -2\" = \"#72CA5C\",\n                                  \"-2 to 0\" =\"#D2DE32\",\n                                  \"0 to 2\"=\"#E36588\",\n                                  \"2 to 4\"=\"#9D224E\",\n                                  \"4 to 6\"=\"#7B0033\",\n                                  \"6 to 8\"= \"#59001B\"))\n\np1021\n\n\n\nFacet plot\nIn this section the base plot for the facet plot is generated. Each facet shows the line from all countries in the back in light pink. This is to allow the viewer to make comparisons between the trend of a certain country with the rest of the countries.\n\n\nfacet <-ggplot(data2, aes(TIME_PERIOD, OBS_VALUE)) + \n  geom_line(data = data2a, aes(TIME_PERIOD, OBS_VALUE, group= geo), colour =\"#FFD2F2\") +\n  geom_line() + \n  facet_wrap(~geo_names)\n\nfacet\n\n\n\nPlot text\nIn this piece of code the axes labels and the title is added to the graph.\n\n\nfacet<-facet +\n  labs(\n    x = \"Year\",\n    y = \"Gender Pay Gap\",\n    title = \"Evolution of the Gender Pay Gap between 2010 and 2021\"\n  )\n\nfacet\n\n\n\nTheme specification\nIn this section the theme specification is performed for the facet graph. The colours used are taken from the same colour scale used for the map graph to make them aesthetically compatible. The ticks on the x axis have been rotated with an angle of 45 degrees to avoid overlap of the labels.\n\n\nfacet <-facet+\n  theme( panel.background = element_rect(\"#FFFFDD\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title = element_text(family = \"Roboto Condensed\", colour = \"#016A70\"),\n    axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1, margin = margin(10,0,10,0)),\n    title = element_text(family = \"Roboto Condensed\", colour = \"#33201F\",  face = \"bold\", margin = margin(10,0,10,0)),\n    strip.background=element_rect(fill=\"#D2DE32\"),\n    strip.text = element_text(family = \"Roboto Condensed\", colour = \"#33201F\"),\n    plot.margin = margin(10,10,10,10) )\nfacet\n\n\n\nCombining graphs\nIn this section the map graph and the facet graph are combined using the package ‘patchwork’. Also, the widths of the plots are adjusted to give the facet plot more space.\n\n\np4<-p1021+facet\np4<-p4+plot_layout(widths = c(5,7))\n\n\nGraph text\nThis piece of code adds the title, subtitle and caption to the graph. It also includes theme specification of the combined graph. The graph shown below is the final version of the graph improvement.\n\n\np4<-p4+\n  plot_annotation(\n    title= \"The Gender Pay Gap between 2010 and 2021\",\n    subtitle = \"Difference between average gross hourly earnings of male and female employees as % of male gross earnings\",\n    caption = \"Iceland, Norway, Switzerland: non_EU countries and Ireland, Greece: data not available\",\n    theme= theme(plot.title =  element_text(\n      family = \"Roboto Condensed\", colour = \"#016A70\", face = \"bold\", size = 20, hjust = 0.14),\n        plot.title.position = \"plot\",\n        plot.subtitle = element_text(family = \"Roboto Condensed\", colour = \"#33201F\",margin=margin(0,0,30,0), hjust = 0.19),\n        plot.caption =  element_text(family = \"Roboto Condensed\", colour = \"#33201F\"),\n      plot.margin =margin(10,0,10,0)))\n\np4\n\n\n\n\n\n\n",
    "preview": "projects/2023/100514861/100514861_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1872
  },
  {
    "path": "projects/2023/100517886/",
    "title": "The Growth of the Oil Industry",
    "description": "Replication of a graph from El Orden Mundial which aims to represent the\nevolution of oil production since 1910.",
    "author": [
      {
        "name": "Sara Cristina Herranz-Amado",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReflecting on the original visualization\nCleaning the data\nGraph replication\nAddressing some issues\n\n\nAlternative visualizations\n\nIntroduction\nOn September 28, 2023, El Orden Mundial, a digital independent media focused on high-quality and in-depth international analysis, published the article ¿Cerca del peak oil? Así ha crecido la producción de petróleo en el último siglo, which would translate as Approaching Peak Oil? This is how oil production has grown in the last century. The author of the visualization and the article is Álvaro Merino.\nThis report aims to discuss this graphic considering some issues, such as the information it intends to show, the general characteristics and strengths of this type of graphic, the necessary steps to built a replica using R and some points of improvements, proposing a couple of graph alternatives.\nReflecting on the original visualization\nA stream graph is a type of stacked area chart. It represents the evolution of a numeric variable (Y axis) following another numeric value (X axis), for several groups with different colors. Areas are usually displayed around a central axis, and edges are rounded to give a flowing and organic shape. These graphs are good to study the relative proportions of the whole, but they are bad to study the evolution of each individual group.\nFor the current case, and as the title of the visualization suggests, the author was interested in analyzing the overall distribution of the different countries within the whole context of oil producer countries, rather than the detailed changes of each specific country. However, although this can be seen in the original plot below, it becomes way more clear when analyzing the replication process replication. We will delve further into this in the corresponding section.\nFinally, we would like to highlight some positive and negative aspects of the original plot. Regarding the positives, the chosen format is quite striking and appropriate for representing the intended information. The color grouping, not only by country but also changing the shade by region, facilitates the assimilation of the data.\nHowever, concerning the areas for improvement that we took into account when selecting this graph for the final project, we primarily emphasize the amount of text that appeared, as it hindered the readability of the graph. Likewise, the reservoir map was too small and could have appeared as a separate graph to complement it, as it also lacks a country-wise division for easier interpretation. This graph was not included in the replication because we did not have the data for it and we were not able to find it. Finally, the percentages at the end of the represented streams were not very clear regarding what they represented (whether they referred to the total for that year or the overall total).\nOriginal graph\n\n# Loading libraries\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(ggstream)\n\n\nCleaning the data\nThe article collected data from the Statistical Review of World Energy from the Energy Institute. Specifically, the data used for the replication was that published in XSLX panel format in Consolidated Dataset - Panel Format. Therefore, we started by uploading the data base, deleting unnecessary columns and NAs from the main variable (oilprod_kbd):\n\n\ndata <-  read_xlsx(path = \"Panel format.xlsx\", sheet = 1, range = \"A1:M7212\")\n\ndata <- data |>\n  select(-c(OPEC:CIS))\n\npanel <- data |> \n  filter(!is.na(oilprod_kbd)) \n\n\nThen, we organized the countries. First, a vector including the countries that needed to appear explicitly in our graph was created, which was also used to create a new data frame where all these countries appeared. We then filtered the original database to select the undesired countries and aggregated them by region. This approach allowed us to assign the name of the region to the aggregated data. Finally, we merged the two data frames into a new one, panel_c.\n\n\ncountries <- c(\"Australia\", \"China\", \"Indonesia\", \"Norway\", \"Russian Federation\", \n               \"USSR\", \"United Kingdom\", \"Brazil\", \"Venezuela\", \"Mexico\", \n               \"Canada\", \"US\", \"Saudi Arabia\", \"Iran\", \"Kuwait\", \"Iraq\", \"Libya\", \n               \"United Arab Emirates\", \"Nigeria\", \"Other Africa\", \n               \"Other Asia Pacific\", \"Other CIS\", \"Other Caribbean\", \n               \"Other Eastern Africa\", \"Other Europe\", \"Other Middle Africa\", \n               \"Other Middle East\", \"Other Northern Africa\", \n               \"Other S. & Cent. America\", \"Other South America\", \n               \"Other Western Africa\")\n\n# Filtering data by country of interest\npanel_a <-  panel |>\n  group_by(Region, Country) |> \n  filter(Country %in% countries) |> \n  mutate(Region = if_else(Country == \"Australia\", \"Oceania\", Region)) |> \n  select(-c(pop, ISO3166_alpha3, ISO3166_numeric, SubRegion, oilprod_mt)) \n\n  \n# Filtering data by countries that are not of our interest and aggregating them \npanel_b <- panel |> \n  filter(!Country %in% countries) |> \n  group_by(Year, Region) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop') |> \n  mutate(Country = Region) |> \n  select(Country, everything()) |>\n  filter(!is.na(Region)) |> \n  arrange(Country) \n\n# Combining both data frames into a new one\npanel_c <- bind_rows(panel_a, panel_b)\n\n\nOnce panel_c was generated, we moved on to refining the regional variables. To achieve this, we first named six different vectors after the main regions, which included the countries from panel_b (it is worth remembering that these countries were labeled according to the region they belonged to, rather than their individual country names). Next, we created individual data frames for each region. In these, we aggregated the oil production by year, presenting them as “Other -said continent-” in the resulting data frame. Finally, a new data frame, panel_d, was formed by merging all the individual region data frames.\n\n\n# Vectors for main regions\nasia <- c(\"Asia Pacific\", \"Other Asia Pacific\")\nafrica <-  c(\"Africa\", \"Other Africa\", \"Other Eastern Africa\", \"Other Middle Africa\", \n             \"Other Northern Africa\", \"Other Western Africa\")\nmiddle_east <-  c(\"Middle East\", \"Other Middle East\")\neurope <- c(\"Europe\", \"Other Europe\")\namerica <- c(\"Other Caribbean\", \"Other S. & Cent. America\", \"Other South America\", \n             \"S. and Cent. America\")\ncis <- c(\"CIS\", \"Other CIS\")\n\n\n# Data frame for each region\nasia <- panel_c |>\n  filter(Country %in% asia) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% asia, \"Other Asia\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\nafrica <- panel_c |>\n  filter(Country %in% africa) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% africa, \"Other Africa\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\nmiddle_east <- panel_c |>\n  filter(Country %in% middle_east) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% middle_east, \"Other Middle East\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\neurope <- panel_c |>\n  filter(Country %in% europe) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% europe, \"Other Europe\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\namerica <- panel_c |>\n  filter(Country %in% america) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% america, \"Other South America\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\ncis <- panel_c |>\n  filter(Country %in% cis) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% cis, \"Other CIS\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\n# Data frame merging the region ones \npanel_d <-  bind_rows(asia, africa, middle_east, europe, america, cis)\n\npanel_d <- panel_d |> \n  mutate(Region = Country) |> \n  select(Country, Year, Region, everything())\n\n\nThe final data frame was formed by combining panel_d and panel_a. Some name adjustments were implemented to streamline the existing data, and the variables Region and Country were organized in the order observed in the original graph.\n\n\n# Final data frame \npanel_f <- bind_rows(panel_d, panel_a)\n\npanel_f <- panel_f |> \n  filter(!is.na(Region)) |> \n  mutate(Region = if_else(Region == \"Other Europe\", \"Europe\", Region)) |> \n  mutate(Region = if_else(Region == \"Other Asia\", \"Asia\", Region)) |> \n  mutate(Region = if_else(Region == \"Asia Pacific\", \"Asia\", Region)) |> \n  mutate(Region = if_else(Region == \"Other Middle East\", \"Middle East\",\n                          Region)) |> \n  mutate(Region = if_else(Region == \"Other Africa\", \"Africa\", Region)) |> \n  mutate(Region = if_else(Region == \"Other South America\", \"S. & Cent. America\",\n                          Region)) |>   \n  mutate(Region = if_else(Region == \"Other CIS\", \"CIS\", Region)) |> \n  arrange(Region, Country) \n\n# To determine the desired order of appearance for the regions in the graph\npanel_f$Region <- factor(panel_f$Region, levels = c(\"Oceania\", \"Asia\", \"Europe\", \n                                                    \"CIS\", \"S. & Cent. America\",\n                                                    \"North America\", \"Middle East\",\n                                                    \"Africa\"))\n\npanel_f$Country <- factor(panel_f$Country, levels = c(\"Australia\", \"Indonesia\", \n                                                      \"China\", \"Other Asia\", \n                                                      \"United Kingdom\", \"Norway\", \n                                                      \"Other Europe\", \"USSR\", \n                                                      \"Russian Federation\", \n                                                      \"Other CIS\", \"Brazil\", \n                                                      \"Venezuela\",\n                                                      \"Other South America\", \n                                                      \"Mexico\", \"Canada\", \"US\",\n                                                      \"Saudi Arabia\", \"Iran\",\n                                                      \"Kuwait\", \"Iraq\", \n                                                      \"United Arab Emirates\", \n                                                      \"Other Middle East\", \"Libya\", \n                                                      \"Nigeria\", \"Other Africa\"))\n\npanel_f <- \n  panel_f |> \n  arrange(Country, Region)\n\n\nPanel_f was the data frame ultimately used for creating a replica of the graph. However, we encountered certain challenges with the data, such as dealing with missing data from 1900 to 1965 and the distribution peculiarities of Russia, which consisted of two distinct observation groups (USSR and Russian Federation). These impacted the representation of the data. In section “Addressing some issues”, after presenting the definitive graph replication, we discuss the proposed adjustments and the reasons they were ultimately discarded.\nGraph replication\nWe began by defining certain aesthetic aspects and later combined them all using ggplot. First, we proceeded to define those related to colors, scales, axes, background, key and other lines in the graph.\n\n\n# Colors\nmycolors <-  c(\"#08e7a7\",\"#33a4a1\", \"#2bb8b9\", \"#6ad3d0\", \"#d86a6f\", \"#be3e44\", \n               \"#a60400\", \"#e78b71\", \"#ca664a\", \"#b1583f\", \"#e9daa1\", \"#e6cc75\",\n               \"#dab330\", \"#9263e1\", \"#7546be\", \"#4f2991\", \"#e997e8\", \"#e079db\",\n               \"#d168c7\",  \"#c453b0\", \"#ad358d\", \"#9a2366\", \"#89c257\", \"#68a03f\", \n               \"#59882c\") \n\ncolors <- scale_fill_manual(values = mycolors)\n\n# Scales\nscale <- c(scale_x_continuous(name = NULL, limits = c(1961, 2022), \n                              breaks = seq(from = 1970, to = 2020, by = 10), \n                              expand = expansion(0)), \n           scale_y_continuous(name = NULL, labels = NULL, position = \"right\",\n                              expand = expansion(add = c(5000, 5500)))) \n\n# Axes \naxes <- theme(axis.line.y = element_blank(), axis.ticks.y = element_blank()) \n\nticks <- theme(axis.ticks.x = element_line(color = \"gray40\"), \n               axis.ticks.length.x = unit(0.15, \"cm\"))\n\n# Background and key\ntheme <- theme(panel.grid.major = element_blank(), \n               panel.grid.minor = element_blank(),\n               legend.position = \"none\", \n               plot.caption = element_text(hjust = 0, color = \"gray20\"))\n\n# Arrows and lines\narrows <- c(geom_curve(aes(x = 2013, y = 52000, xend = 2019, yend = 52000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 1994, y = 44000, xend = 1997, yend = 38000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2003, y = -48500, xend = 2008, yend = -46000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01), \n            geom_curve(aes(x = 1973, y = -46000, xend = 1977, yend = -43000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_segment(aes(x = 1973, y = 38500, xend = 1973, yend = 36000),\n                         color = \"#08e7a7\", \n                         linewidth = 0.2),\n            geom_segment(aes(x = 1990, y = 19500, xend = 1990, yend = 24200),\n                         color = \"#a60400\", \n                         linewidth = 0.3),\n            geom_segment(aes(x = 1987, y = -28200, xend = 1987, yend = -39700),\n                         color = \"#9a2366\", \n                         linewidth = 0.2),\n            geom_vline(xintercept = c(1979, 2019), \n                      linetype = \"dashed\",\n                      color = \"white\", \n                      linewidth = 0.2))\n\n\nThen, we worked with the aesthetics involving text, such as annotation, labels, titles and subtitles.\n\n\n# Text font\nsysfonts::font_add_google(\"Fira Sans Condensed\")\nsysfonts::font_add_google(\"Fira Sans\")\n\n# Labels\nsubtitle <- expression(paste(bold(\"Producción histórica de petróleo hasta 2022\"), \n                             \" (barriles diarios)\"))\n\nlabels <-  labs(title = \"El crecimiento de la industria petrolera\", \n                subtitle = subtitle,\n                caption = \"\\n \\n Autora: Sara Herranz (2023). Fuente: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme <- theme(plot.title = element_text(family = \"Fira Sans Condensed\", \n                                               size = 14, \n                                               face = \"bold\"),\n                     plot.subtitle = element_text(family = \"Fira Sans Condensed\", \n                                                  size = 9.5, \n                                                  color = \"gray10\", face = \"bold\"), \n                     plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\n# Percentage annotations\n  # First, we compute the percentages\npanel_per <- panel_f |> \n  filter(Year == \"2022\") |> \n  mutate(percent = round((oilprod_kbd/(sum(oilprod_kbd)))*100)) |> \n  filter(percent > 2) |> \n  arrange(Country, Region) \n\n  # Second, we create the annotations\npercent_annotations <- \n  c(annotate(\"text\", x = 2020, y = 46500, size = 3,  label = paste(\"4%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 28000, size = 3,  label = paste(\"12%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 17500, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 14000, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 6000, size = 3,  label = paste(\"6%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -4000, size = 3,  label = paste(\"19%\"), \n             color = \"grey2\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -17500, size = 3,  label = paste(\"13%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -25000, size = 3,  label = paste(\"4%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -28400, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -32000, size = 3,  label = paste(\"5%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -36000, size = 3,  label = paste(\"4%\"), \n             color = \"grey6\",  family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -39500, size = 3,  label = paste(\"3%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -47500, size = 3,  label = paste(\"5%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"))\n\n# Text annotations\ntext_annotations <-  \n  c(annotate(\"text\", x = 2012, y = 51000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"En 2019, justo antes de la pandemia,\\n se alcanzó una producción récord\\n (95 millones)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1993, y = 44000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis financiera\\nasiática de 1997\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1972, y = -45000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis del petróleo\\nde los 70 (guerra de\\nYom Kipur, 1973,\\nRev. iraní, 1979)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1979, y = 45000,  hjust = 0.5, vjust = 0.5, size = 2.5, \n             label = paste(\"1979:\\n 66 millones\"), \n             color = \"grey40\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 2002, y = -48500,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis financiera global de 2008\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1))\n\n# Country labels\ncountry_annotations <- \n  c(annotate(\"text\", x = 1971, y = 40000, size = 3, label = paste(\"Oceanía\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2011, y = 42000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2000, y = 35500, size = 3, label = paste(\"Indonesia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 38000, size = 3, label = paste(\"Resto Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 10, fontface = \"italic\"), \n    annotate(\"text\", x = 1995, y = 27300, size = 3, label = paste(\"R. Unido\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1995, y = 24500, size = 3, label = paste(\"Noruega\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 18000, size = 3, label = paste(\"Resto Europa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1974, y = 17000, size = 3, label = paste(\"URSS\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 23000, size = 3, label = paste(\"Rusia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2008, y = 13000, size = 3, label = paste(\"Resto CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2011, y = 10700, size = 3, label = paste(\"Brasil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\", srt = 15),\n    annotate(\"text\", x = 2005, y = 8100, size = 3, label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 4900, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = 1500, size = 3, label = paste(\"Canadá\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1996, y = -3300, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -13500, size = 3, label = paste(\"Arabia Saudi\"), \n             color = \"#9a2366\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1999, y = -19000, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -25000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", srt = -10, fontface = \"italic\"),\n    annotate(\"text\", x = 1988, y = -24300, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -29300, size = 3, label = paste(\"EAU\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 1990, y = -41000, size = 3, label = paste(\"Resto O. Próximo\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1993, y = -30400, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = -34400, size = 3, label = paste(\"Libia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = -40800, size = 3, label = paste(\"Resto África\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"))\n\n\nThe next version of the plot included these aesthetics. As mentioned earlier, what it represents is how the different proportions of each country relate to each other, rather than examining the specific changes of each group. Thus, the sense of flowing, curvy appearance and smooth transition is evident in this visualization.\nIt is also important to note that some changes were made to the data because we considered them essential. Firstly, ‘Other CIS’ was added to the data, and Libya was repositioned. In the original graph, Libya was included among the countries in the Middle East region, but we deemed it more appropriate to relocate it to Africa, as it is geographically situated there. On the other hand, ‘Other South America’ is not represented, even though it has sufficient data to be included.\n\n\nplot <- ggplot(data = panel_f) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_stream(type = \"mirror\", \n              bw = 0.56, \n              true_range = \"max_x\") + \n  colors + scale + axes + theme_minimal() + ticks +\n  labels + labelstheme + percent_annotations + \n  text_annotations + country_annotations + theme + arrows \n\nplot\n\n\n\nAddressing some issues\nAs seen in the previous graph and mentioned before, we encountered certain challenges with the data, such as handling missing data from 1900 to 1965 and addressing the distribution peculiarities of Russia, which consisted of two distinct observation groups (USSR and Russian Federation).\nDealing with missing data\nRegarding the first issue, Professor Iñaki suggested to include a 0 in the oilprod_kbd variable for the year 1910 in each country However, we managed to define a function that progressively reduced the value of the variable oilprod_kbd from its value in 1965 for each country until 0 in 1910. We opted for 15 instead of 0, as in the original idea, because, in reality, the distribution in the original graph tends toward zero but does not appear to reach that value.\nOn the other hand, after implementing this improvement, we recognized that its main flaw was that the data added to the variable ‘oilprod_kbd’ for each country did not adhere to the same distribution as the available oilprod_kbd data for each country. We attempted to devise a function that considered this existing distribution for each country between the years 1965-2022 (1975-2022 for Norway and 1985-2022 for the USSR and Other CIS) aiming for the newly generated values for the period 1910-1965 to follow the same distribution. Said function worked by applying the ecdf (Empirical Cumulative Distribution Function) to the data distribution. Unfortunately, despite several attempts, we couldn’t make it work. Given that the complexity of the mentioned function surpasses the requirements of this course, we decided to adhere to the solution depicted below, even though it does not entirely align with the original graph.\n\n\n# Adding the necessary rows (from 1910 to 1964)\nrows <- tibble(Country = rep(c(\"Australia\", \"Indonesia\", \"China\", \"Other Asia\", \n                  \"United Kingdom\", \"Norway\", \"Other Europe\", \"USSR\",\n                  \"Russian Federation\", \"Other CIS\",  \"Brazil\", \n                  \"Venezuela\", \"Other South America\", \"Mexico\", \"Canada\", \n                  \"US\", \"Saudi Arabia\", \"Iran\", \"Kuwait\", \"Iraq\", \n                  \"United Arab Emirates\", \"Other Middle East\", \"Libya\", \n                  \"Nigeria\", \"Other Africa\"), each = 55),\n               Year = rep(seq(1910, 1964), length.out = 1375),\n               Region = rep(c(\"Oceania\", \"Asia\", \"Asia\", \"Asia\", \"Europe\", \"Europe\",\n                 \"Europe\", \"CIS\", \"CIS\", \"CIS\", \"S. & Cent. America\", \n                 \"S. & Cent. America\", \"S. & Cent. America\", \n                 \"North America\", \"North America\", \"North America\",\n                 \"Middle East\", \"Middle East\", \"Middle East\",\n                 \"Middle East\", \"Middle East\", \"Middle East\", \"Africa\", \n                 \"Africa\", \"Africa\"), each = 55), \n               oilprod_kbd = 15)\n\nnorway_rows <- tibble(Country = rep(\"Norway\", each = 6),\n                      Year = seq(1965, 1970),\n                      Region = rep(\"Europe\", each = 6),\n                      oilprod_kbd = 15)\n\nrf_rows <- tibble(Country = rep(\"Russian Federation\", each = 20),\n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 15)\n\noc_rows <- tibble(Country = rep(\"Other CIS\", each = 20), \n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 15)\n\n# Merging the new data together and then binding it to the original one\nrows <- bind_rows(rows, norway_rows, rf_rows, oc_rows)\n\npanel_g <- rbind(panel_f, rows) \n\npanel_g <- panel_g |> \n  arrange(Country, Year) |> \n  mutate(Year = as.numeric(Year))\n\n# Function to interpolate oilprod_kbd\ninterp_values <- function(country_df) {\n  approx(\n    x = c(1965, 1910), \n    y = c(country_df$oilprod_kbd[country_df$Year == 1965], 15),\n    xout = country_df$Year\n  )$y\n}\n\n# Applying the function to each country\ndf_interp <- panel_g |> \n  group_by(Country) |> \n  nest() |> \n  mutate(oilprod_kbd_interp = map(data, interp_values)) |> \n  unnest(cols = c(data, oilprod_kbd_interp))\n\n# Merging the interpolated data and the original data \nalternative <- full_join(panel_g, df_interp, by = c(\"Year\", \"Country\"))\n\n# Arranging and filtering the data \nalternative_f <- alternative |> \n  arrange(Country, Year) |> \n  select(-c(oilprod_kbd.x, Region.x)) |> \n  mutate(oilprod_kbd.y = case_when(\n    Country == \"Norway\" & Year > 1975 ~ oilprod_kbd.y,\n    (Country == \"Russian Federation\" | Country == \"CIS\") & Year > 1985 ~ oilprod_kbd.y,\n    Country != \"Norway\" & Country != \"Russian Federation\" \n    & Country != \"CIS\" & Year > 1965 ~ oilprod_kbd.y,\n    TRUE ~ oilprod_kbd_interp))\n\n\nOnce the new data frame was set, we defined some adjustments to fit the new data.\n\n\n# Adjusting the scale to fit the new data\nscale1 <- c(scale_x_continuous(name = NULL, limits = c(1910, 2022), \n                              breaks = seq(from = 1920, to = 2020, by = 10), \n                              expand = expansion(0)),\n            scale_y_continuous(name = NULL, labels = NULL,\n                               expand = expansion(add = c(5000, 5500)))) \n\n# Text annotations\nlabels1 <-  labs(caption = \"\\nAutora: Sara Herranz (2023). Fuente: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme1 <- theme(plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\ntext_annotations1 <- c(\n    annotate(\"text\", x = 1910, y = 51000,  hjust = 0, vjust = 0.5, size = 3.8, \n             label = paste(\"Producción histórica de petróleo hasta 2022\"), \n             color = \"grey20\", family = \"Fira Sans\"), #subtitle\n    annotate(\"text\", x = 1959, y = 51000,  hjust = 0, vjust = 0.5, size = 3.6, \n             label = paste(\" (barriles diarios)\"), \n             color = \"grey30\", family = \"Fira Sans\"), #subtitle\n    annotate(\"text\", x = 1910, y = 55000,  hjust = 0, vjust = 0.5, size = 5, \n             label = paste(\"El crecimiento de la industria petrolera\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"bold\"), #title\n    annotate(\"text\", x = 2011, y = 51000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"En 2019, justo antes de la pandemia,\\n se alcanzó una producción récord\\n (95 millones)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1993, y = 42000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis financiera\\nasiática de 1997\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1967, y = -40000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis del petróleo de los 70\\n (guerra de Yom Kipur, 1973,\\nRev. iraní, 1979)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1950, y = -25000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Irán, Irak, Kuwait, Arabia Saudí y\\nVenezuela fundan la Organización\\nde Países Exportadores de\\nPetróleo (OPEP) en 1960\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1933, y = 19000,  hjust = 0.5, vjust = 0.5, size = 2.8, \n             label = paste(\"El automóvil y la bombilla eléctrica\\nimpulsaron la industria del petróleo a\\nprincipios del siglo XX, hasta\\nentonces limitada al queroseno\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1979, y = -37000,  hjust = 0.5, vjust = 0.5, size = 2.3, \n             label = paste(\"1979:\\n 66 millones\"), \n             color = \"grey40\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 2002, y = -50000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis financiera global de 2008\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1))\n\n# Arrows and lines\narrows1 <- c(geom_curve(aes(x = 1951, y = -23000, xend = 1960, yend = -18000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2012, y = 52000, xend = 2019, yend = 48500), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 1994, y = 42000, xend = 1997, yend = 36500), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2003, y = -50000, xend = 2008, yend = -43000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01), \n            geom_curve(aes(x = 1968, y = -40000, xend = 1973, yend = -31000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_segment(aes(x = 1973, y = 36000, xend = 1973, yend = 29000),\n                         color = \"#08e7a7\", \n                         linewidth = 0.2),\n            geom_segment(aes(x = 1990, y = 21800, xend = 1990, yend = 19300),\n                         color = \"#a60400\", \n                         linewidth = 0.3),\n            #geom_segment(aes(x = 1987, y = -28200, xend = 1987, yend = -39700),\n                         #color = \"#9a2366\", \n                         #linewidth = 0.2),\n            geom_vline(xintercept = c(1979, 2019), \n                      linetype = \"dashed\",\n                      color = \"white\", \n                      linewidth = 0.2))\n\n\n\n\n# Country labels\ncountry_annotations1 <- \n  c(annotate(\"text\", x = 1971, y = 38000, size = 3, label = paste(\"Oceanía\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2009, y = 39000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 1994, y = 32100, size = 3, label = paste(\"Indonesia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 35500, size = 3, label = paste(\"Resto Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 13, fontface = \"italic\"), \n    annotate(\"text\", x = 1995, y = 26400, size = 3, label = paste(\"R. Unido\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1995, y = 23500, size = 3, label = paste(\"Noruega\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 16000, size = 3, label =paste(\"Resto\\nEuropa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1974, y = 17000, size = 3, label = paste(\"URSS\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 23000, size = 3, label = paste(\"Rusia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2010, y = 15370, size = 3, label = paste(\"Resto CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", srt=15),\n    annotate(\"text\", x = 2011, y = 13500, size = 3, label = paste(\"Brasil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface=\"italic\", srt=15),\n    annotate(\"text\", x = 2005, y = 10000, size = 3, label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 7000, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = 3800, size = 3, label = paste(\"Canadá\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1996, y = -3300, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1960, y = -1000, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -12500, size = 3, label = paste(\"Arabia Saudi\"), \n             color = \"#9a2366\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2004, y = -19000, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1975, y = -15800, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -23000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1966, y = -12500, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = -29000, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1976, y = -22700, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2007, y = -27500, size = 3, label = paste(\"EAU\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 2006, y = -29600, size = 3, label=paste(\"Resto O.Próximo\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", srt = -10),\n    annotate(\"text\", x = 1992, y = -27400, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = -34600, size = 3, label = paste(\"Libia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -38800, size = 3, label = paste(\"Resto\\nÁfrica\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", \n             lineheight = 1))\n\n\n\n\nplot2 <- ggplot(data = alternative_f) +\n  aes(x = Year, y = oilprod_kbd.y, fill = Country) +\n  geom_stream(type = \"mirror\", \n              bw = 0.56,\n              true_range = \"max_x\")  +\n  colors + scale1 + axes + theme_minimal() + ticks +\n  labels1 + labelstheme1  + \n  text_annotations1 + country_annotations1 + theme + arrows1 \n\nplot2\n\n\n\nWhile we couldn’t replicate the exact shape and distribution of the missing values from the original plot, we believe this serves as a commendable alternative to our initial visualization attempt. Furthermore, as mentioned earlier, geom_stream is useful for studying the relative proportion of the whole. This is evident in the updated graph, where the representation of the available data appears more accurate compared to the original plot.\nIt also should be noted that certain aesthetic aspects implemented in this replica could not be preserved due to the alteration in the data distribution. This is evident in the percentages at the end; by modifying the joint data distribution, the values of the dependent variable in the last year decrease, leaving little room to include these labels as they appear in the original graph.\nUSSR and Russian Federation\nThe USSR and Russian Federation observations concerned us for two reasons. Firstly, despite having data only until 1984 for the USSR, the characteristics of geom_stream extended the data in the opposite direction to the existing data, distorting the data distribution. On the other hand, we wanted to compare the number of barrels produced (oilprod_kbd) for the US and USSR/Russian Federation in different years, given that in the original graph, the thickness of these streams appeared similar. Upon filtering the data, we were able to verify that the data distributions were similar, despite the graphical representation showing significant differences.\nThus, concerning the data from the USSR and the Russian Federation, we aimed to combine the observations of both countries into a single entity to examine how it influenced the data or whether the distribution resembled that of the original graph. Therefore, we recoded the observations of the USSR so that all of them appeared as the Russian Federation.\n\n\n# Running some tests to compare USSR and US\ntest <- panel_f |> \n  filter(Country == c(\"USSR\", \"US\")) |> \n  group_by(Year) \n\n\n# Merging USSR and Russian Federation into one observation\npanel_h <- \n  panel_f |> \n  arrange(Country, Region) |> \n  mutate(Country = if_else(Country == \"USSR\", \"Russian Federation\", Country))\n\n\nAfter establishing the new data frame, we implemented several adjustments to align with the updated data. Some aesthetics are missing as we solely aimed to observe how the data was distributed. However, as illustrated in the graph below, the distribution of the resulting data deviates from the anticipated outcome. Consequently, we made the decision to discard it.\n\n\nmycolors2 <-  c(\"#08e7a7\",\"#33a4a1\", \"#2bb8b9\", \"#6ad3d0\", \"#d86a6f\", \"#be3e44\", \n                \"#a60400\", \"#e78b71\", \"#b1583f\", \"#e9daa1\", \"#e6cc75\", \"#dab330\",\n                \"#9263e1\", \"#7546be\", \"#4f2991\", \"#e997e8\", \"#e079db\", \"#d168c7\",\n                \"#c453b0\", \"#ad358d\", \"#9a2366\", \"#89c257\", \"#68a03f\", \"#59882c\") \n\ncolors2 <- scale_fill_manual(values = mycolors2)\n\n\nplot3 <- ggplot(data = panel_h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_stream(type = \"mirror\", \n    bw = 0.56, \n    true_range = \"max_x\") + \n  colors2 + labels + scale + axes +\n  theme_minimal() +  theme + labelstheme + ticks \n\nplot3\n\n\n\n\nAlternative visualizations\nTo carry out the proposal for alternative visualizations, we took into consideration the original author’s objective, which was to depict the historical evolution of oil production for the entire oil industry. However, we also aimed to shift the focus to clearly visualize the regional and country-specific contributions. Both aspects were more apparent in the original stream graph. However, they were not as evident in the replication we conducted because the stream graph is useful for gaining a general understanding of the whole structure without getting bogged down by intricate details of each part’s evolution, but not so much for depicting the individual contributions.\nTherefore, in order to keep the intention of the original author, we decided to make an alternative representation using a stacked area chart, and also to combine it with faceting techniques. On one hand, faceting generates small multiples each showing a different subset of the data. It is a powerful tool for exploratory data analysis: one can rapidly compare patterns in different parts of the data and see whether they are the same or different.\nOn the other hand, similarly to the stream graph, a stacked area chart displays the evolution of the value of several groups on the same graphic. The values of each group are displayed on top of each other, allowing to check the evolution of both the total of a numeric variable and the importance of each group. Thus, as it can be seen in the graph below, it is easier to observe variations in the contribution of each category. Additionally, the mentioned appearance resembles better the original graph, although it does not have the mirror aesthetic, since the original visualization not only displays the evolution of all the countries, but also the changes in the individual categories.\nReturning to the features of the faceting employed, we have provided two complementary visualizations alongside the stream graph. The first faceting allows us to observe the contribution of each region to the total barrel production of oil. Additionally, it utilizes the same scale for the dependent variable (oilprod_kbd), enabling visual comparisons between regions. However, in the second faceting, we employ “scales =”free_y”“, which allows for representing different scales for each of the plots, thereby enabling the visualization of the individual evolution of oil production for each region.\nIt was necessary to make some considerations regarding the data used for the following graphs. Firstly, we employed the information available in the original database (after cleaning it to meet our requirements, of course), and we discarded the database that we created afterwards, which included information for oilprod_kbd in the period 1910-1964. The main reason for this decision was our desire to work with accurate and reliable data. Additionally, since the distribution of the new data created by the function we had defined did not align with the distribution of the existing data, it did not seem appropriate to use them for the alternative visualization. Furthermore, given that the data in the original database included separate observations for the USSR and the Russian Federation, we retained the same data frame for this enhancement. Consequently, due to the nature of the graph, which stacks areas on top of the previous ones, there is a gap in the representation of both observations in 1985. In order to adsress this we added 0 to the oilprod_kbd variable for the not available years of USSR and Other CIS (1985-2022) and Russian Federation (1965-1984). This worked perfectly fine. As a side note, we attempted to make the same adjustment in the visualizations that utilized geom_stream. However, due to the characteristics of the streamgraph, the differences were negligible.\nOn the other hand, we also modified some aesthetics, for instance, reducing the amount of text displayed to avoid overloading the graph.\n\n\n# Adding the necessary rows to Russian Federation, Other CIS and USSR\np1 <- tibble(Country = rep(\"Russian Federation\", each = 20),\n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 0)\n\np2 <- tibble(Country = rep(\"Other CIS\", each = 20), \n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 0)\n\np3 <- tibble(Country = rep(\"USSR\", each = 38), \n                  Year = seq(1985, 2022),\n                  Region = rep(\"Other CIS\", each = 38),\n                  oilprod_kbd = 0)\n\n# Merging the new data together and then binding it to the original one\npreb <- bind_rows(p1, p2, p3)\n\nenhan1 <- rbind(panel_f, preb) \n\n\n\n\n# Labels\nsubtitle2 <- expression(paste(bold(\"Historical oil production up to 2022 \"), \n                             \"(barrels per day)\"))\n\nlabels2 <-  labs(title = \"The growth of the oil industry\", subtitle = subtitle2,\n                caption = \"\\n \\n Author: Sara Herranz (2023). Reference: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme2 <- theme(plot.title = element_text(family = \"Fira Sans Condensed\", \n                                               size = 15, \n                                               face = \"bold\"),\n                     plot.subtitle = element_text(family = \"Fira Sans Condensed\", \n                                                  size = 11, \n                                                  color = \"gray10\", face = \"bold\"), \n                     plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\n# Scale\nscale2 <- c(scale_x_continuous(name = NULL, limits = c(1965, 2022), \n                              breaks = seq(from = 1970, to = 2020, by = 10), \n                              expand = expansion(0)), \n           scale_y_continuous(name = NULL, labels = NULL, position = \"right\",\n                              expand = expansion(add = c(5000, 5500)))) \n\n# Text_annotations\ntext_annotations2 <-  \n  c(annotate(\"text\", x = 2018, y = 98300,  hjust = 0.5, vjust = 0.5, size = 3, \n             label = paste(\"2019:\\n record production\\n (95 million)\"), \n             color = \"grey40\", family = \"Fira Sans\"),\n      annotate(\"text\", x = 1979, y = 68200,  hjust = 0.5, vjust = 0.5, size = 3, \n             label = paste(\"1979:\\n 66 millions\"), \n             color = \"grey40\", family = \"Fira Sans\"))\n\n# Country labels\ncountry_annotations2 <- \n  c(annotate(\"text\", x = 1971, y = 60000, size = 3, label = paste(\"Oceania\"), \n             color = \"#08e7a7\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 77000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", srt = 3, fontface = \"italic\"), \n    annotate(\"text\", x = 2006, y = 83000, size = 3, label = paste(\"Indonesia\"), \n             color = \"#33a4a1\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 74000, size = 3, label = paste(\"Other Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 7, fontface = \"italic\"), \n    annotate(\"text\", x = 2001, y = 63300, size = 3, label = paste(\"UK\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2001, y = 60800, size = 3, label = paste(\"Norway\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1999, y = 53000, size = 3, label = paste(\"Other Europe\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1977, y = 48000, size = 3, label = paste(\"USSR\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 46000, size = 3, label = paste(\"Russia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2010, y = 65000, size = 3, label = paste(\"Other CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 54000, size = 3, label = paste(\"Brazil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\", srt = 9),\n    annotate(\"text\", x = 2006, y = 51000, size = 3, srt = 9, \n             label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 30500, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 28000, size = 3, label = paste(\"Canada\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 23000, size = 3, label = paste(\"US\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2015, y = 31000, size = 3, label = paste(\"Saudi Arabia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 24800, size = 3, label = paste(\"Iran\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 21000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", srt = 5, fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 17000, size = 3, label = paste(\"Iraq\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 13000, size = 3, label = paste(\"UAE\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 2016, y = 9800, size = 3, label = paste(\"Other M. East\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 7100, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2001, y = 5500, size = 3, label = paste(\"Lybia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2000, y = 2300, size = 3, label = paste(\"Other Africa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"))\n\narrows2 <- c(geom_curve(aes(x = 1974, y = 55000, xend = 1971, yend = 58000), \n                       colour = \"#08e7a7\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2004, y = 77000, xend = 2004, yend = 81000), \n                       colour = \"#33a4a1\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2002, y = 58700, xend = 2001, yend = 55100), \n                       colour = \"#a60400\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2012, y = 60000, xend = 2010, yend = 63500), \n                       colour = \"#b1583f\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01))\n\n\n\n\n# Geom_area: \nalt_plot <- ggplot(data = enhan1) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area() +\n  geom_vline(xintercept = c(1979, 2019), \n    linetype = \"dashed\", \n    color = \"white\", \n    linewidth = 0.2) + \n  colors + labels2 + scale2 + axes +\n  theme_minimal() +  theme + labelstheme2 + ticks +\n  text_annotations2 + country_annotations2 + arrows2\n\nalt_plot\n\n\n\nFor the faceting, we opted for facet_wrap paired with an area chart, since it is useful when dealing with a single variable having many levels and there is a desire to arrange the plots more efficiently in terms of space. To adjust the data, we computed the total production by region to arrange the facets accordingly. Following that, we made some adjustments to the scales and then proceeded to plot the graphs.\n\n\n# Creating new data frame ordering the data by the total oil production per region, \n  # in an ascending order\nh <- enhan1 |> \n  group_by(Region) |> \n  mutate(toil = sum(oilprod_kbd), \n         Region = case_when(\n           Country %in% c(\"Russian Federation\", \"Other CIS\") & Year < 1985 ~ \"CIS\",\n           Country == \"USSR\" & Year > 1984 ~ \"CIS\",\n           TRUE ~ Region)) |> # dealing with some NAs\n  ungroup() |> \n  arrange(toil)\n\nh$Region <- factor(h$Region, levels = c(\"Oceania\", \"Europe\", \"S. & Cent. America\", \n                                        \"Asia\", \"Africa\", \"CIS\", \"North America\",\n                                        \"Middle East\"))\n\n# Adjusting the scale of the plot\nscale3 <- c(scale_x_continuous(name = NULL, limits = c(1965, 2022), \n                               breaks = seq(from = 1975, to = 2020, by = 15), \n                               expand = expansion(0), position = \"bottom\"),\n            scale_y_continuous(name = NULL, \n                               position = \"left\")) \n\n\n\n\n# Facet 1. Plotting the data\nalt_plot2 <- ggplot(data = h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area(show.legend = FALSE) +\n  facet_wrap(facets = h$Region,\n             nrow = 5,\n             ncol = 2) + \n  colors + scale3 + axes + \n  theme_minimal() + labels2 + labelstheme2 + ticks + theme +\n  theme(panel.spacing.y = unit(2, \"lines\")) \n\nalt_plot2\n\n\n\n\n\n# Facet 2. Plotting the data\nalt_plot3 <- ggplot(data = h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area(show.legend = FALSE) +\n  facet_wrap(facets = h$Region,\n             nrow = 4,\n             ncol = 2,\n             scales = \"free_y\") + \n  colors + scale3 + axes + \n  theme_minimal() + labels2 + labelstheme + ticks + theme +\n  theme(panel.spacing.y = unit(2, \"lines\"))\n\nalt_plot3\n\n\n\n\n\n\n",
    "preview": "projects/2023/100517886/100517886_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1248
  },
  {
    "path": "projects/2023/100061715/",
    "title": "Unveiling Birth Clinical Practice in Spain: Mapping the Cesarian Sections and Birth Dynamics",
    "description": "Exploring the nuances of maternal healthcare in Spain through an augmented map,\nshowcasing original cesarean section rates alongside additional insights such\nas total births per autonomous community and cesarean rates adjusted for the\naverage maternal age.",
    "author": [
      {
        "name": "Celia Muñoz",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nBackground\nFirst steps\nAlternative visualisation\n\nBackground\nOver the past two decades, the global rate of caesarean sections (C-sections) has experienced a notable increase. While C-sections are a life-saving intervention when medically necessary, inappropriate procedures pose potential risks for both mothers and newborns.\nIn Spain, caesarean deliveries rank among the most prevalent surgical procedures, accounting for 22% of all deliveries in 2019. The aggressive nature of caesarean sections becomes particularly concerning when performed without medical justification, as such instances may be regarded as obstetric violence and contribute to gender discrimination.\nThe chart to replicate is found on the Ministry of Health’s website, as part of the indicators from the Minimum Basic Data Set (CMBD). This set comprises a record of all hospital admissions documented over the course of a year (2019 in this case) on a patient-level basis. For each patient, fundamental sociodemographic variables are gathered, and the hospital episode is encoded using international standards for the classification of diseases and procedures.\nC-section rate in Spain (2019), the original graphTo reproduce our graph, the original data on cesarean section rate can be downloaded from the same website. The dataset includes information for all autonomous communities regarding the total number of births in Spain, the age of the mother, the total number of births with a cesarean section, and the average age of mothers who underwent a cesarean section.\nFirst steps\nThe first step is to load the basic libraries and those specific for merging our data, generating maps, etc. Next, we load our original data and perform data cleaning to construct the cesarean section rate variable, which will be essential throughout the development.\n\n\n# Loading packages\nlibrary(tidyverse)\nlibrary(mapSpain)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(stringdist)\nlibrary(fuzzyjoin)\nlibrary(ggtext)\n\n\n\n\n# Adjusting locale settings\nmy_locale <- locale(decimal_mark = \",\", grouping_mark = \".\")\n\n\n# Reading data\nc_section <- read_delim(\"tasa_cesareas.csv\", \n                 skip = 10, \n                 delim = \";\",\n                 col_names = c(\"ccaa\", \"n_births\", \"births_hosp_stay\", \n                               \"birth_age\", \"n_c_section\", \"c_section_age\", \n                               \"c_section_hosp_stay\", \"c_section_rate\"),\n                 locale = my_locale)\n\n# Cleaning data and generating a new cesarea rate\nc_section <- c_section %>% \n  na.omit() %>% \n  filter(ccaa != \"Total Altas\") %>% \n  mutate(c_section_rate = (n_c_section / n_births) * 100)\n\nccaa <- c_section %>% \n  select(ccaa)\n\n\nNow that we have the data loaded and cleaned, we begin constructing our chart. In this case, as it is a map of Spain, we will use the mapSpain library, which allows us to visualize different geographical levels. In this case, we need the data at the level of autonomous communities.\nThere are several libraries for creating map-based graphics; however, most of them place the Canary Islands in their original location. This can be problematic when representing territories that are geographically distant from the general country area. Fortunately, mapSpain comes with the default fictitious location for the Canary Islands, commonly used in such cases.\n\n\n# Loading map data\nspain <- esp_get_ccaa()\n\n# Ploting the basic map\nggplot(spain) +\n  geom_sf()\n\n\n\n\n\n# Verifying that the names of the CCAA match to enhance the join.\nc_section <- c_section %>% \n  stringdist_join(\n    spain,\n    by = c(\"ccaa\" = \"ine.ccaa.name\"),\n    method = \"jaccard\",\n    mode = \"left\",\n    max_dist = 0.3\n  ) %>% \n  mutate(\n    ine.ccaa.name = if_else(ccaa == \"Rioja (La)\", \"Rioja, La\", ine.ccaa.name)) \n\n# Keeping the main variables\nc_section <- c_section %>% \nselect(ccaa, ine.ccaa.name, n_births, birth_age, c_section_rate, c_section_age) \n\n# Joining map data and cesarean data\nc_section <- spain %>% \n  left_join(\n    c_section,\n    by = \"ine.ccaa.name\"\n  )  \n\nstr(c_section)\n\nClasses 'sf' and 'data.frame':  19 obs. of  27 variables:\n $ codauto          : chr  \"01\" \"02\" \"03\" \"04\" ...\n $ iso2.ccaa.code   : chr  \"ES-AN\" \"ES-AR\" \"ES-AS\" \"ES-IB\" ...\n $ nuts1.code       : chr  \"ES6\" \"ES2\" \"ES1\" \"ES5\" ...\n $ nuts2.code       : chr  \"ES61\" \"ES24\" \"ES12\" \"ES53\" ...\n $ ine.ccaa.name    : chr  \"Andalucía\" \"Aragón\" \"Asturias, Principado de\" \"Balears, Illes\" ...\n $ iso2.ccaa.name.es: chr  \"Andalucía\" \"Aragón\" \"Asturias, Principado de\" \"Islas Baleares\" ...\n $ iso2.ccaa.name.ca: chr  NA NA NA \"Illes Balears\" ...\n $ iso2.ccaa.name.gl: chr  NA NA NA NA ...\n $ iso2.ccaa.name.eu: chr  NA NA NA NA ...\n $ nuts2.name       : chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Illes Balears\" ...\n $ cldr.ccaa.name.en: chr  \"Andalusia\" \"Aragon\" \"Asturias\" \"Balearic Islands\" ...\n $ cldr.ccaa.name.es: chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Islas Baleares\" ...\n $ cldr.ccaa.name.ca: chr  \"Andalusia\" \"Aragó\" \"Astúries\" \"Illes Balears\" ...\n $ cldr.ccaa.name.ga: chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Illas Baleares - Illes Balears\" ...\n $ cldr.ccaa.name.eu: chr  \"Andaluzia\" \"Aragoi\" \"Asturiesko Printzerria\" \"Balear Uharteak\" ...\n $ ccaa.shortname.en: chr  \"Andalusia\" \"Aragon\" \"Asturias\" \"Balearic Islands\" ...\n $ ccaa.shortname.es: chr  \"Andalucía\" \"Aragón\" \"Asturias\" \"Baleares\" ...\n $ ccaa.shortname.ca: chr  \"Andalusia\" \"Aragó\" \"Astúries\" \"Illes Balears\" ...\n $ ccaa.shortname.ga: chr  \"Andalucía\" \"Aragón\" \"Asturias\" \"Illas Baleares\" ...\n $ ccaa.shortname.eu: chr  \"Andaluzia\" \"Aragoi\" \"Asturias\" \"Balear Uharteak\" ...\n $ nuts1.name       : chr  \"SUR\" \"NORESTE\" \"NOROESTE\" \"ESTE\" ...\n $ ccaa             : chr  \"Andalucía\" \"Aragón\" \"Asturias (Principado de)\" \"Balears (Illes)\" ...\n $ n_births         : num  54561 7715 3802 6245 11392 ...\n $ birth_age        : num  31.4 32.4 33.1 31.7 31.6 ...\n $ c_section_rate   : num  23.8 18.3 17.4 17.5 17.8 ...\n $ c_section_age    : num  32.5 33.2 34.1 33.4 33.1 ...\n $ geometry         :sfc_GEOMETRY of length 19; first list element: List of 6\n  ..$ :List of 1\n  .. ..$ : num [1:1259, 1:2] -4.27 -4.27 -4.28 -4.28 -4.27 ...\n  ..$ :List of 1\n  .. ..$ : num [1:6, 1:2] -5.61 -5.61 -5.61 -5.61 -5.61 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -3.03 -3.03 -3.04 -3.03 -3.03 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -6.31 -6.32 -6.32 -6.32 -6.31 ...\n  ..$ :List of 1\n  .. ..$ : num [1:6, 1:2] -6.27 -6.27 -6.28 -6.28 -6.27 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -6.47 -6.47 -6.47 -6.47 -6.47 ...\n  ..- attr(*, \"class\")= chr [1:3] \"XY\" \"MULTIPOLYGON\" \"sfg\"\n - attr(*, \"sf_column\")= chr \"geometry\"\n - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ...\n  ..- attr(*, \"names\")= chr [1:26] \"codauto\" \"iso2.ccaa.code\" \"nuts1.code\" \"nuts2.code\" ...\n\nThe next task is to use our cesarean section rate variable to fill the different autonomous communities with varying color intensities according to their values.\n\n\n# Filling the map with cesarean rate data\nc_section_map <- ggplot(c_section) +\n  geom_sf(aes(fill = c_section_rate), color = \"white\", linewidth = 0.2)\n\nc_section_map\n\n\n\nOur original map uses various shades of bluish-green to represent the cesarean section rate. The color darkens with a higher cesarean section rate. These color specifications are determined based on specific values. We use the “colors,” “breaks,” and “limits” adjustments in the scale_fill_stepsn function to indicate these specifications.\n\n\n# Setting the specific colors and breaks\nc_section_map <- c_section_map +\n  scale_fill_stepsn(\n    colors = c(\"#5EAABB\", \"#478B9C\", \"#2f6b7d\", \"#184c5d\", \"#002c3e\"),\n    breaks = c(13.57, 16.83, 20.10, 23.36, 26.63, 29.89),\n    limits = c(13.57, 29.89)) # Setting the limits\n\n\nc_section_map\n\n\n\nOnce we have the colors set for our chart, we slightly adjust the coordinates for a better framing of the graph.\n\n\n# Setting the coordinates so we can have space for the legend\nc_section_map <- c_section_map +\n    coord_sf(xlim=c(-14, 5),\n           ylim=c(34.6, 45.5)) \n\nc_section_map\n\n\n\nOne of the challenges in our chart is the legend. It is placed at the top and in a horizontal position. In addition, the guiding numbers are aligned centrally with the points where the colour changes. This is true for all except the first data point, which is aligned to the left with the beginning of the legend.\n\n\n# Tunning the fonts\nsysfonts::font_add_google(\"Open Sans\", family=\"Open Sans\")\n\n# Tunning the legend\nc_section_map <- c_section_map +\n  theme_void() +\n  theme(\n    legend.position = c(0.2,0.9),\n    legend.direction = \"horizontal\",\n    legend.key.width = unit(12, \"mm\"),\n    legend.key.height = unit(5, \"mm\"),\n    legend.background = element_blank(),\n    legend.title = element_blank())\n\n# Adjusting alignment of the legend\nc_section_map <- c_section_map + \n  theme(text = element_text(size = 10, \n                            color = \"#6d6d6d\",\n                            family=\"Open Sans\"),\n        legend.text.align = c(0, 0.5, 0.5, 0.5, 0.5, 0.5))\n\nc_section_map\n\n\n\nAlternative visualisation\nOne of the factors that may explain for the number of caesarean sections is the age of the pregnant woman.\nThe Ministry of Health website provides information on the average age of women at delivery in each autonomous community, but it is not used in the visualisation.\nInformation on the number of births per autonomous community is also provided.\nIt is necessary to use all the provided information, including the average age of women at delivery and the number of births per autonomous community, to compose a new map depicting the age-adjusted caesarean section rate, while also considering the total number of births. This enhanced visualisation aims to provide insights into the correlation between maternal age and the prevalence of caesarean sections across different autonomous communities.\n\n\n# Enhancement\n# Obtaining the standarised cesarean rate\nmodel <- lm(c_section_rate ~ c_section_age, data = c_section)\ncoefs <- coef(model)\n\nc_section <- c_section %>% \n  mutate(c_section_age = c_section_rate - coefs['c_section_age'] * (c_section_age - mean(c_section_age)))\n\n# Lets take a look at the adjusted cesarean rate\nsummary(c_section$c_section_age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  15.38   18.14   21.95   21.38   23.53   28.93 \n\n\n\nc_section_centroid <- st_centroid(c_section, of_largest_polygon = TRUE)\n\n\nTo show the total number of births in a community we will use bubbles that vary in size according to the number of births. We visualise the age-adjusted caesarean section rate using colour.\n\n\n# Visualising a bubble map\nbubble_map <- ggplot() +\n  geom_sf(data = spain,\n          linewidth = 0.1,\n          alpha = 0.5) +\n  geom_sf(\n    data = c_section_centroid,\n    pch = 21,\n    aes(size = n_births, \n        fill = c_section_age),\n    stroke = 0.1) +\n  coord_sf(xlim=c(-17, 3.5),\n           ylim=c(34, 45))\n  \nbubble_map\n\n\n\nAs this is a continuous variable, instead of using a static colour palette with shades very similar to each other, I will use a colour gradient. We set a gradient where the midpoint of the colour coincides with the average adjusted caesarean section rate.\n\n\n# Adjusting guides\nbubble_map <- bubble_map +\n  scale_fill_gradient2(\n    low = \"#4CAF50\",\n    mid = \"#FFC107\",\n    high = \"#FF5722\",\n    midpoint = mean(c_section$c_section_age),\n    guide = guide_colorbar(\n      title = \"Cesarean section rate (%)\",\n      title.position = \"top\"\n    )) +\n  scale_size(\n    breaks = c(20000, 40000),\n    labels = c(\"20\", \"40\"),\n    range = c(1, 14),\n    guide = guide_legend(title=\"Number of births (K)\", \n                         title.position=\"top\",\n                         order=2)) \n\nbubble_map\n\n\n\nNow we are using two visualisation elements (bubble size and colour), we will have one more legend than in the original chart. We adjust them so that they are placed on the left margin.\n\n\n# A few more tweaks \nbubble_map <- bubble_map + \n  theme_void() +\n  theme(\n    legend.position = c(0.12,0.7),\n    legend.direction = \"horizontal\",\n    legend.key.width = unit(8, \"mm\"),\n    legend.key.height = unit(5, \"mm\"),\n    legend.background = element_blank(),\n    legend.title=element_text(face=\"bold\", size=8),\n    legend.text=element_text(size=6))  \n\nbubble_map\n\n\n\nSince we are visualising an adjusted rate, it is useful to add annotations to improve the understanding of the graph.\n\n\n# Including annotations\nbubble_map <- bubble_map +\n  annotate(\"richtext\", x = -8.5, y = 44.3, \n           label = paste0(\n    \"<span style='color: #e75c93;'>#1 <\/span><b>Galicia<\/b> becomes a higher rate<br>\n    than would be expected:\n    <b>25.05%<\/b><\/span>\"),\n    size = 3,\n    hjust = 0,\n    fill = NA,\n    label.color = NA) +\n  annotate(\"richtext\", x = -7.5, y = 38.5, \n           label = paste0(\n    \"<span style='color: #e75c93;'>#2 <\/span><b>Extremadura<\/b><br>\",\n    \"has around 7K births per year<br>\n    with the highest age-adjusted c-section rate<br>\n    <b>28.93%<\/b><\/span>\"),\n    size = 3,\n    hjust = 1,\n    fill = NA,\n    label.color = NA)\n\nbubble_map\n\n\n\nFinally we add the title and subtitle. Here is the alternative graph showing the number of births in Spain during 2019 and the age-adjusted caesarean section rate, so we can see that the communities in red have high rates and could be having an excess of non-recommendable clinical practices in all cases.\n\n\n# Adding title and subtitle\nbubble_map <- bubble_map + \n  labs(title = \"**Regional disparities in childbirth clinical practice**\",\n       subtitle = \"**Number of births** and _age-adjusted caesarean rates_ across autonomous communities\") +\n  theme(plot.title = element_text(hjust = 0.5,\n                                  size = 14),\n        plot.subtitle = element_text(hjust = 0.5,\n                                     size = 9)) +\n  theme(plot.title = element_markdown(),\n        plot.subtitle = element_markdown())\n\nbubble_map\n\n\n\n\n\n\n",
    "preview": "projects/2023/100061715/100061715_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100407543/",
    "title": "The Demography of the World Population from 1950 to 2100",
    "description": "Visualizing how global demography has changed and what we can expect for the\n21st - century Our World in Data.",
    "author": [
      {
        "name": "Daniel Pérez-Gutiérrez",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nReplication work\nPackages\nGetting the data\nPreparing the data\nBuilding the graph\n\nAlternative graph\nConstructing the new interest variable\nTime series evolution of the difference between the number of men and women\nDoing the graph interactive\n\n\nIntroduction\nIn 1950, the world population was 2.5 billion people. Since then, it has experienced significant growth, currently exceeding 8 billion. According to United Nations projections, the global population is expected to reach approximately 10.4 billion by the end of the century. This visualization of the population pyramid provides a clearer view of how the demographic composition has evolved and will continue to evolve in the coming decades, as it allows us to observe the age and gender distribution, highlighting changes over time.\nThe original graph\n\n\n\nFigure 1: The original graph\n\n\n\nThe selected graph is available in Our World in data. Elements to note about the graph and the composition of the world population are as follows:\nThe width represents the size of the population of a given age; females on the right and males on the left. The bottom layer represents the number of newborns and, above it, are the numbers of the older cohorts.\nIn darker blue, the pyramid representing the structure of the world population in 1950 can be seen. Particularly noteworthy is the increase in the number of births, which widened the base of the pyramid, and the high lifetime risk of death, which is evident because the pyramid narrows toward the top. There were many newborns relative to the number of people at older ages.\nThrough shades of blue and green, the same visualization shows the population structure over the last decades up to 2018. It can be seen that in each subsequent decade, the population pyramid widened, i.e. in each decade the total number of people of all ages increased.\nReplication work\nPackages\n\n\nlibrary(tidyverse)\nlibrary(cowplot)\n\n\nGetting the data\n\n\ndata <- readxl::read_excel(\"data.xlsx\")\n\n\nPreparing the data\nWe are faced with a dataset where information on the ages of individuals is presented in a scattered manner, with each age group located in a separate column. This structure can be challenging for efficient analysis and visualization of the information. To address this situation, the pivot_longer() function of the tidyverse package is used. This operation allows the data to be rearranged so that the ages, originally represented as separate columns, are stacked into a single column called “Age”.\nOnce the data is in the desired format, I make sure that there are no NA\n\n\ndata2 <- data |> \n  pivot_longer(cols = c(2:102),\n               names_to = \"Age\",\n               values_to = \"population\")\n\nif (any(!complete.cases(data2))) {\n  print(\"There are any NA.\")\n} else {\n  print(\"There are not any NA\")\n}\n\n[1] \"There are not any NA\"\n\n\n\n\nSince to replicate the original graph I have to make two separate graphs (one for the male population and one for the female population) I filter the dataframe according to gender, and create a different data set for each gender.\n\n\ndata_male <- data2 |> \n  filter(sex == \"Male\")\n\ndata_female <- data2 |> \n  filter(sex == \"Female\")\n\n\nBuilding the graph\nFirst, I create a vector containing the years that the authors of the original chart highlight with thicker lines and dashed lines.\nSubsequently, this vector will allow me to create 3 layers:\nThe first one for all years from 1950 to 2100.\nThe second for selected years that are actual observations (1950, 1960, 1970, 1980, 1990 and 2018) which have a thicker line.\nThe third one, for the selected years that are projections (2050, 2075 and 2100) with lines of the same thickness as the years of the second layer, but with a dashed line.\nThen, after numerous attempts, the ingenious solution to apply the exact color to the area between the lines delineating the profiles of each year in the population pyramid was to create a vector in which the sequence of each element corresponds directly and precisely to the years (once the color palette was inverted). By establishing a 1:1 correspondence between each color and the area between the lines that draw the profile of each year, I can assign a color to each of the 150 areas to be colored.\n\n\nselected_years <- c(1950, 1960, 1970, 1980, 1990, 2018, 2050, 2075, 2100)\n\ncolor_paleta <- c(\n  \"#3E5189\",                  \n  rep(\"#3371B7\", times = 10),  \n  rep(\"#3B86B7\", times = 10),  \n  rep(\"#48A0AA\", times = 10),  \n  rep(\"#52B6A3\", times = 10),  \n  rep(\"#57C09F\", times = 28),  \n  rep(\"#E6F07C\", times = 32),  \n  rep(\"#E2DB56\", times = 25),  \n  rep(\"#EFDD56\", times = 25)   \n)\ncolor_paleta_invertido <- rev(color_paleta)\n\n\nFemale population\nI use geom_area to display stacked areas representing the distribution of the female population over time. geom_line adds lines with specific settings to highlight selected observations and additional projections. The coord_flip function inverts the x and y axes to enhance the display of the area plot. In addition, geom_text is used to manually add labels and the values of both axes.\n\n\nplot_female <- ggplot(data_female, aes(x = Age, y = population, fill = forcats::fct_rev(Year))) +\n  geom_area(position = \"identity\", alpha = 0.7) +\n  geom_line(aes(color = \"NotSelected\", linetype = \"NotSelected\"),\n            alpha = 0.1, size = 0.1) +\n  geom_line(data = subset(data_female, Year %in% c(1950, 1960, 1970, 1980, 1990, 2018)),\n            aes(color = \"Selected\", linetype = \"Selected\"),\n            alpha = 1, size = 0.3, linetype = \"solid\") +\n  geom_line(data = subset(data_female, Year %in% c(2050, 2075, 2100)),\n            aes(color = \"AdditionalSelected\", linetype = \"AdditionalSelected\"),\n            alpha = 1, size = 0.3, linetype = \"dashed\") +\n  coord_flip() +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5, size = 19, face = \"bold\"),\n        axis.text.y = element_blank(), axis.title.y = element_blank(), axis.text.x = element_blank()) +\n  scale_x_continuous(breaks = seq(0, 100, by = 10), limits = c(-10, 102)) +\n  scale_fill_manual(values = color_paleta_invertido) +\n  scale_color_manual(values = c(\"NotSelected\" = \"#686351\", \"Selected\" = \"#686351\", \"AdditionalSelected\" =\"#686351\")) +\n  scale_linetype_manual(values = c(\"NotSelected\" = \"solid\", \"Selected\" = \"solid\", \"AdditionalSelected\" = \"dashed\")) +\n  geom_text(data = data.frame(x = 9.94307173536714, y = 28511.2785548616, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.3, vjust = 1L,color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 18.0412115460575, y = 26490.5928372464, label = \"1960\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 29.1943328380169, y = 25480.2499784388 , label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.4, vjust = 1L, color = \"#686351\",inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 39.238472992214, y = 25143.4690255029, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label), \n            size = 2, angle = -14L, vjust = 1L,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 49.6413296030791, y = 23571.8245784689, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.35, vjust = 1L, color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 57.6527237837525, y = 40000, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2,angle = -14L, hjust = 1L, vjust = 0.35, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 75.5416978407678, y = 37941.145237066, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -12L, hjust = 0.45, vjust = 0.65, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 82.5215256568887, y = 38165.6658723566, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -13L, hjust = 0.25, vjust = 0.8,color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 87.3963251911341, y = 39400.5293664547, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, vjust = 1L,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 40000, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n             size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3E5189\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y =45500, label = \"1960\"),\n            mapping = aes(x = 0, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3371B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 57567.0830381612, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#48A0AA\",inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0, y = 55560.22486, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3B86B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 65296.5630636051, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#52B6A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 65900.4237224363, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#E6F07C\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 61007, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#E2DB56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 54350.0899600451, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#EFDD56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 66861.9360283455, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#57C09F\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x =0 , y = 29857.4288547544, label = \"Women\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 4, hjust =1L, vjust = 1L, color = \"#4B4B4B\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 25 , y = 65700, label = \"Median Age in 1950:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n geom_text(data = data.frame(x = 23.6 , y = 65700, label = \"23.6 years\"),\n          mapping = aes(x = x, y = y, label = label),\n          size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 31.4  , y = 65700, label = \"Median Age in 2018:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 30 , y = 65700, label = \"30 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 37.5  , y = 65700, label = \"Median Age in 2050:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 36.1 , y = 65700, label = \"36.1 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 40.4  , y = 65700, label = \"Median Age in 2075:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 39 , y = 65700, label = \"39 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 44.4  , y = 65700, label = \"Median Age in 2100:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 43 , y = 65700, label = \"41.6 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 102, y = 10000, label = \"10 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 20000, label = \"20 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 30000, label = \"30 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 40000, label = \"40 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 50000, label = \"50 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 60000, label = \"60 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 70000, label = \"70 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n\n  labs(title = \"\", x = \"\", y = \"\", fill = \"Año\", color = \"Línea destacada\", linetype = \"Discontinuity\")\n\nprint(plot_female)\n\n\n\nMale population\nThe procedure to make this graph is the same as the one used to make the graph with the female data\n\n\nplot_male <- ggplot(data_male, aes(x = Age, y = -population, fill = forcats::fct_rev(Year))) +\n  geom_area(position = \"identity\", alpha = 0.7) +\n  geom_line(aes(color = \"NotSelected\", linetype = \"NotSelected\"),\n            alpha = 0.1, size = 0.1) +\n  geom_line(data = subset(data_male, Year %in% c(1950, 1960, 1970, 1980, 1990, 2018)),\n            aes(color = \"Selected\", linetype = \"Selected\"),\n            alpha = 1, size = 0.3, linetype = \"solid\") +\n  geom_line(data = subset(data_male, Year %in% c(2050, 2075, 2100)),\n            aes(color = \"AdditionalSelected\", linetype = \"AdditionalSelected\"),\n            alpha = 1, size = 0.3, linetype = \"dashed\") +\n  coord_flip() +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5, size = 19, face = \"bold\"),\n        axis.text.y = element_blank(), axis.title.y = element_blank(), axis.text.x = element_blank()) +\n  scale_x_continuous(breaks = seq(0, 100, by = 10), limits = c(-10, 102)) +\n  scale_y_continuous(limits = c(-75000, 0)) +\n  scale_fill_manual(values = color_paleta_invertido) +\n  scale_color_manual(values = c(\"NotSelected\" = \"#686351\", \"Selected\" = \"#686351\", \"AdditionalSelected\" = \"#686351\")) +\n  scale_linetype_manual(values = c(\"NotSelected\" = \"solid\", \"Selected\" = \"solid\", \"AdditionalSelected\" = \"dashed\")) +\n  geom_text(data = data.frame(x = 6.18998544147173, y = -30320.5198591813, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.55, vjust = 0.6, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 14.2745633982306, y = -31880.6425658543, label = \"1960\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.2, vjust = 0.45, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 23.7762261259231, y = -31368.3552619391, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2,angle = 24L, hjust = 0.4,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 33.7651553067948, y = -31496.4270879179, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size =2, angle = 24L, vjust = 0.8,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 41.8050242512531, y = -31624.4989138967, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.40, vjust = 0.35, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 58.8592950465282, y = -35210.5100413027, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size= 2, angle = 27L, hjust = 0.5, vjust = 0.6, color = \"#686351\",inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 72.8681580025912, y = -36107.0128231542, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 25L, hjust = 0.35, vjust = 0.15, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 80.7862113793117, y = -35978.9409971755, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 18L, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 85.6268864011455, y = -36812.4166584925, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 20L, hjust = 0.4, vjust = 0.9, color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0.0540647418287934, y = -41737.516021589, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#3E5189\", inherit.aes = FALSE) +\n\n  geom_text(data = data.frame(x = 0, y =-47403, label = \"1960\"),\n            mapping = aes(x = 0, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#3371B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -60601, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#48A0AA\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0, y = -58589, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#3B86B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -69485, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#52B6A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -68360, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#E6F07C\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -63507, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#E2DB56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -56524, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#EFDD56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -70891, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#57C09F\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x =0 , y = -20000,  label = \"Men\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 4, hjust =1L, vjust = 1L, color = \"#4B4B4B\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 102, y = -10000, label = \"10 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -20000, label = \"20 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -30000, label = \"30 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -40000, label = \"40 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -50000, label = \"50 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -60000, label = \"60 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -70000, label = \"70 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 10, y = -73400, label = \"10 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 20, y = -73400, label = \"20 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 30, y = -73400, label = \"30 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 40, y = -73400, label = \"40 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 50, y = -73400, label = \"50 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 60, y = -73400, label = \"60 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 70, y = -73400, label = \"70 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 80, y = -73400, label = \"80 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 90, y = -73400, label = \"90 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n \n  labs(title = \"\", x = \"\", y = \"\", fill = \"Año\", color = \"Línea destacada\", linetype = \"Discontinuity\")\n\n\n\nprint(plot_male)\n\n\n\nCombined\nOnce both graphs have been made, I proceed to join them. Using the draw_plot and draw_text function of ggdraw I manually adjust the position of each plot and manually include the title, subtitle and the source of the data.\n\n\ncombined_plot <- ggdraw() +\n  draw_plot(\n    plot_male + theme(panel.grid = element_blank()) +\n      geom_hline(yintercept = 0, color = \"black\", size = 0.2, linetype = \"solid\", alpha = 0.2),\n    x = 0.04, y = 0, width = 0.5, height = 1\n  ) +\n  draw_plot(\n    plot_female + theme(axis.text.y = element_blank(), panel.grid = element_blank()) +\n      geom_hline(yintercept = 0, color = \"black\", size = 0.2, linetype = \"solid\", alpha = 0.2),\n    x = 0.46, y = 0, width = 0.5, height = 1\n  ) +\n  draw_text(\n    \"The Demography of the World Population from 1950 to 2100\",\n    x = 0.5, y = 0.96, size = 12, vjust = 0, hjust = 0.5, color = \"#474747\",\n    family = \"Times New Roman\"\n  ) +\n  draw_text(\n    \"Shown is the age distribution of the world population - by sex - from 1950 to 2018 and the UN Population Division's projection until 2100.\",\n    x = 0.5, y = 0.93, size = 5, vjust = 0, hjust = 0.5, color = \"#585858\",\n    fontface = \"italic\"\n  ) +\n  draw_text(\n    \"Data source: United Nations Population, Division - World Population Prospects 2017; Medium Variant.\nThe data visualization is available at OurWorldinData.org. where you find more research on how the world is changing and why.\",\n    x = 0.3, y = 0.02, size = 6, vjust = 0, hjust = 0.5, color = \"#C9C9C9\"\n  )\nprint(combined_plot)\n\n\n\nAlternative graph\nGiven that the original graph is comprehensive and aesthetically appealing, improving both its visual and informational quality proves challenging. Therefore, a viable alternative is to explore the inclusion of an additional graph that provides complementary information on the evolution of the world population.\nIn this way, incorporating the evolution of the population difference between men and women in demographic analysis offers a detailed and specific perspective, enriching the understanding of how the demographic composition has changed over time. This approach allows for the identification of specific patterns in the population difference between genders over the decades, enabling us to observe how demographic dynamics have evolved in relation to gender.\n\n\n\nConstructing the new interest variable\nI calculate for each age group and each year, the difference between the total number of men and women.\nThus, if the difference is positive, the result indicates that the number of males is greater, and if the result is negative, the number of females is greater than the number of males.\n\n\ndf_diff <- data_mejora |> \n    group_by(Year, Age) |> \n    summarise(population_diff = sum(ifelse(sex == \"Male\", population, -population)))\n\n\nTime series evolution of the difference between the number of men and women\n\n\n plot_diff <- ggplot(df_diff, aes(x = Age, y = population_diff, color = as.factor(Year))) +\n    geom_line(size = 0.8) +\n    labs(title = \"Differences between men and women (1950-2100)\",\n         x = \"Age\",\n         y = \"Men population - Women Population\",\n         color = \"Age\") +\n    scale_color_manual(values = c(\"1950\" = \"#3E5189\", \"1980\" = \"#48A0AA\", \n                                  \"2018\" = \"#57C09F\", \"2050\" = \"#E6F07C\",\n                                  \"2075\" = \"#E2DB56\", \"2100\"= \"#EFDD56\" )) +\n    theme_minimal()\n \nplot_diff <- plot_diff + annotate(\"segment\", x = 50, xend = 50, y = 250, yend= 4000)\nplot_diff<- plot_diff + geom_text(data = data.frame(x = 50, y = 4600, label = \"Male population > Female population\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"black\", inherit.aes = FALSE)\n\n\nplot_diff <- plot_diff + annotate(\"segment\", x = 50, xend = 50, y = -250, yend= -4000)\nplot_diff<- plot_diff + geom_text(data = data.frame(x = 50, y = -4600, label = \"Female population > Male population\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"black\", inherit.aes = FALSE)\nprint(plot_diff)\n\n\n\nDoing the graph interactive\nUsing the ggplotly function of the plotly library, we allow the graph to be interactive and give us the exact value of the difference between the number of men and women for a given age if we place the computer cursor over the year in which we are interested.\n\n\nplotly::ggplotly(plot_diff)\n\n\n\n\n\n\n",
    "preview": "projects/2023/100407543/100407543_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100408925/",
    "title": "How Britain Voted in the E.U. Referendum",
    "description": "Britons voted on Thursday to leave the European Union. The Leave side led with\n17.4 million votes, or 52 percent, versus the Remain side’s 16.1 million, or\n48 percent, with a turnout of around 72 percent.",
    "author": [
      {
        "name": "Laura Martinez",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nGetting the data right\nPackages\nLoading and fixing the data\n\nReplication\nCreating two scales\nSetting fonts for the map\nCreating tags for the map\nCreating the base plot (map)\nAdding tags to the map\nLondon close-up\nRemain-Leave bar plot\nLondon zoom-up lines\nPutting everything together\nFinal annotations\nLimitations\n\nIs there an alternative way?\n\nIntroduction\nThe article from The New York Times, published on June 25, 2016, delves into the aftermath of the Brexit referendum, portraying it as a momentous and uncertain chapter in Britain’s storied history. The piece captures the prevailing sentiments of shock and uncertainty following the unexpected decision to leave the European Union, as the country grapples with the potential economic, political, and social consequences.\nIt reflects on the intricate challenges ahead, including the renegotiation of trade agreements, potential shifts in global influence, and the implications for the European Union itself. Through interviews with citizens, politicians, and analysts, the article captures the diverse reactions and apprehensions within the UK and abroad, emphasizing the profound impact of the referendum on the nation’s trajectory and its place in the broader European context.\nLink to article\nThe original graph\nThe original graph can be found on the New York Times graph repository and uses maps and charts to illustrate the voting patterns across various regions, highlighting stark divisions between areas that voted to remain in the European Union and those that opted to leave and providing a detailed breakdown of the results of the Brexit referendum in the United Kingdom.\nOriginal graph, source: NYTGetting the data right\nPackages\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(scales)\nlibrary(sf)\nlibrary(ggforce)\nlibrary(patchwork)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(maps)\nlibrary(ggnewscale)\nlibrary(ggtext)\nlibrary(RColorBrewer)\nlibrary(mapproj)\n\n\nWe should also set here our own working directory\nLoading and fixing the data\nThe data is not precisely easily accessible (or at least not all of it) so I recommend downloading it from Github.\n\n\n# csv data for the UK\nreferendum <- read_csv(\"EU-referendum-result-data.csv\")\n\n# shapefiles\nuk_shp <- read_sf(\"maps/uk_constituencies_2016.shp\")\nireland_shp <- read_sf(\"maps/IRL_adm1.shp\")\n\n# check the geometries to how many divisions they have\nlength(st_geometry(uk_shp))\nlength(st_geometry(ireland_shp))\n\n\nAfter loading the data many variables that were meaningless for creating the graph were eliminated. Once that was done, certain variables were renamed so that the area name and area code were the same in both shapefiles for the UK and Ireland, aligned their coordinate systems so that they matched (at EPSG:4326) and merged the shapefiles altogether and also with the main dataset with all the information.\n\n\n# eliminate meaningless columns of the shp: \nuk_shp$ID <- NULL\nireland_shp$ID_0 <- NULL\nireland_shp$ISO <- NULL\nireland_shp$NAME_0 <- NULL\nireland_shp$TYPE_1 <- NULL\nireland_shp$ENGTYPE_1 <- NULL\nireland_shp$NL_NAME_1 <- NULL\nireland_shp$VARNAME_1 <- NULL\n\n# rename variables\nnames(ireland_shp)[names(ireland_shp) == \"NAME_1\"] <- \"area_name\"\nnames(ireland_shp)[names(ireland_shp) == \"ID_1\"] <- \"area_code\"\n\nreferendum <- referendum |> \n  rename(area_code = Area_Code)\n\n# transform and align the coordinate systems\nuk_shp <- st_transform(uk_shp, crs = st_crs(\"EPSG:4326\"))\nireland_shp <- st_transform(ireland_shp, crs = st_crs(\"EPSG:4326\"))\n\n#check their coordinates systems\nprint(st_crs(uk_shp))\nprint(st_crs(ireland_shp))\n\n#Merge shapefiles\nuk_shp1 <- rbind(uk_shp, ireland_shp)\n\n#Merge with dataset\nbrexit_data <- left_join(uk_shp1, referendum, by = \"area_code\")\n\n\nAlso, I manually filled the referendum data (remain, leave and turnout percentages) for the districts of Northern Ireland with the information made available by the BBC.\n\n\n#West Tyrone\nbrexit_data$Pct_Turnout[18] <- 61.8\nbrexit_data$Remain[18] <- 26765\nbrexit_data$Leave[18] <- 13274\nbrexit_data$Pct_Remain[18] <- 66.8\nbrexit_data$Pct_Leave[18] <- 33.2\n\n#Upper Bann\nbrexit_data$Pct_Turnout[17] <- 63.8\nbrexit_data$Remain[17] <- 24550\nbrexit_data$Leave[17] <- 27262\nbrexit_data$Pct_Remain[17] <- 47.4\nbrexit_data$Pct_Leave[17] <- 52.6\n\n#Strangford\nbrexit_data$Pct_Turnout[16] <- 64.5\nbrexit_data$Remain[16] <- 18727\nbrexit_data$Leave[16] <- 23383\nbrexit_data$Pct_Remain[16] <- 44.5\nbrexit_data$Pct_Leave[16] <- 55.5\n\n#South Down\nbrexit_data$Pct_Turnout[15] <- 62.4\nbrexit_data$Remain[15] <- 32076\nbrexit_data$Leave[15] <- 15625\nbrexit_data$Pct_Remain[15] <- 67.2\nbrexit_data$Pct_Leave[15] <- 32.8\n\n#South Antrim\nbrexit_data$Pct_Turnout[14] <- 63.4\nbrexit_data$Remain[14] <- 21498\nbrexit_data$Leave[14] <- 22055\nbrexit_data$Pct_Remain[14] <- 49.4\nbrexit_data$Pct_Leave[14] <- 50.6\n\n#North Down\nbrexit_data$Pct_Turnout[13] <- 67.7\nbrexit_data$Remain[13] <- 23131\nbrexit_data$Leave[13] <- 21046\nbrexit_data$Pct_Remain[13] <- 52.4\nbrexit_data$Pct_Leave[13] <- 47.6\n\n#North Antrim\nbrexit_data$Pct_Turnout[12] <- 64.9\nbrexit_data$Remain[12] <- 18782\nbrexit_data$Leave[12] <- 30938\nbrexit_data$Pct_Remain[12] <- 37.8\nbrexit_data$Pct_Leave[12] <- 62.2\n\n#Newry and Armagh\nbrexit_data$Pct_Turnout[11] <- 63.7\nbrexit_data$Remain[11] <- 31963\nbrexit_data$Leave[11] <- 18659\nbrexit_data$Pct_Remain[11] <- 62.9\nbrexit_data$Pct_Leave[11] <- 37.1\n\n#Mid Ulster\nbrexit_data$Pct_Turnout[10] <- 61.7\nbrexit_data$Remain[10] <- 25612\nbrexit_data$Leave[10] <- 16799\nbrexit_data$Pct_Remain[10] <- 60.4\nbrexit_data$Pct_Leave[10] <- 39.6\n\n#Lagan Valley\nbrexit_data$Pct_Turnout[9] <- 66.6\nbrexit_data$Remain[9] <- 22710\nbrexit_data$Leave[9] <- 25704\nbrexit_data$Pct_Remain[9] <- 46.9\nbrexit_data$Pct_Leave[9] <- 53.1\n\n#Foyle\nbrexit_data$Pct_Turnout[8] <- 57.4\nbrexit_data$Remain[8] <- 32064\nbrexit_data$Leave[8] <- 8905\nbrexit_data$Pct_Remain[8] <- 78.3\nbrexit_data$Pct_Leave[8] <- 21.7\n\n#Fermanagh and South Tyrone\nbrexit_data$Pct_Turnout[7] <- 67.9\nbrexit_data$Remain[7] <- 28200\nbrexit_data$Leave[7] <- 19958\nbrexit_data$Pct_Remain[7] <- 58.6\nbrexit_data$Pct_Leave[7] <- 41.4\n\n#East Londonderry\nbrexit_data$Pct_Turnout[6] <- 69.9\nbrexit_data$Remain[6] <- 21098\nbrexit_data$Leave[6] <- 19455\nbrexit_data$Pct_Remain[6] <- 52.0\nbrexit_data$Pct_Leave[6] <- 48.0\n\n#East Antrim\nbrexit_data$Pct_Turnout[5] <- 65.2\nbrexit_data$Remain[5] <- 18616\nbrexit_data$Leave[5] <- 22929\nbrexit_data$Pct_Remain[5] <- 44.8\nbrexit_data$Pct_Leave[5] <- 55.2\n\n#Belfast West\nbrexit_data$Pct_Turnout[4] <- 48.9\nbrexit_data$Remain[4] <- 23099\nbrexit_data$Leave[4] <- 8092\nbrexit_data$Pct_Remain[4] <- 74.1\nbrexit_data$Pct_Leave[4] <- 25.9\n\n#Belfast South\nbrexit_data$Pct_Turnout[3] <- 67.6\nbrexit_data$Remain[3] <- 30960\nbrexit_data$Leave[3] <- 13596\nbrexit_data$Pct_Remain[3] <- 69.5\nbrexit_data$Pct_Leave[3] <- 30.5\n\n#Belfast North\nbrexit_data$Pct_Turnout[2] <- 57.5\nbrexit_data$Remain[2] <- 20128\nbrexit_data$Leave[2] <- 19844\nbrexit_data$Pct_Remain[2] <- 50.4\nbrexit_data$Pct_Leave[2] <- 49.6\n\n#Belfast East\nbrexit_data$Pct_Turnout[1] <- 66.5\nbrexit_data$Remain[1] <- 20728\nbrexit_data$Leave[1] <- 21918\nbrexit_data$Pct_Remain[1] <- 48.6\nbrexit_data$Pct_Leave[1] <- 51.4\n\nbrexit_data$Region_Code <- NULL\nbrexit_data$Region <- NULL\nbrexit_data$id <- NULL\nbrexit_data$Area <- NULL\n\n\nReplication\nCreating two scales\nSince our map is based on two scales (Leave and Remain) with their own legends and positive graduated systems (percentage vote ranging from 1 to 100), we need to separate our dataset into two datasets.\nIn order to do so first we have to classify our data according to which option won (got majority) in each district. For that we need to create a column that classifies each observation as “Leave” or “Remain”. Then create the different datasets given the classifier just created.\n\n\n# Making a winner column\nbrexit_data <- mutate(brexit_data, winner = if_else(Pct_Remain > Pct_Leave, \"Remain\", \"Leave\"))\n\n#Add ireland as Pct_leave to plot it gray \nbrexit_data$winner[399:424] <- \"Leave\"\n\n# Creating two different data frames\nleave_df <- brexit_data[brexit_data$winner == \"Leave\",]\nremain_df <- brexit_data[brexit_data$winner == \"Remain\",]\n\n\nOn top of that, in the code all of the observations of Ireland were classified as “Leave”. This is just to later be able to plot Ireland as a gray area so that the whole Island is displayed for geographical reference. As a result this displays the whole island of Ireland, the part corresponding to Northern Ireland with the corresponding colours for Leave and Remain in each district and the rest of the island in gray.\nSetting fonts for the map\nFollowing this, it sets the base graphics parameter par(family = \"Times\") to specify the “Times” font family. The script proceeds to add fonts from Google Fonts using the font_add_google function from both the “Lora” and “DM Serif Display” font families. These are the fonts that will be used in the final map (I decided to choose those fonts instead of the ones in the original map as I liked better these).\nFinally, it activates font rendering with the showtext_auto() function from the “showtext” package, allowing the specified fonts to be used in subsequent graphical output. Overall, these lines of code ensure that the desired fonts are installed, imported, and configured for use in R graphics.\n\n\n#Add fonts\nsysfonts::font_add_google(\"Lora\", family=\"Lora\")\nsysfonts::font_add_google(\"DM Serif Display\", family=\"DM Serif Display\")\nshowtext::showtext_auto()\n\n\nCreating tags for the map\nBefore plotting the map it is also necessary to prepare some of the tags that will be displayed on the map (or at least the ones that are attached geographically to it).\nIn this part of the code, two data frames related to the Brexit referendum leave_df and remain_df are manipulated together with a newly created data frame named country_tag that has the exact coordinates of where each of the tag is to be placed.\nFor both leave_df and remain_df, it is added a new column named country based on a conditional logic using the case_when function. This logic assigns country names (“England,” “Northern Ireland,” “Wales,” or “Scotland”) to each row in the data frames based on the first letter of the area_code column.\nAdditionally, the code reorders the columns to have the newly created country column as the first column. The final section of the code creates a new data frame, country_tag, containing information about the latitude and longitude of specific countries. In simpler terms, this chunk prepares and organizes data by assigning countries to rows based on their area codes and creates a separate data frame with geographical information.\n\n\nleave_df <- leave_df |> \n  mutate(country = case_when(\n    substr(area_code, 1, 1) == \"E\" ~ \"England\",\n    substr(area_code, 1, 1) == \"N\" ~ \"Northern Ireland\",\n    substr(area_code, 1, 1) == \"W\" ~ \"Wales\",\n    substr(area_code, 1, 1) == \"S\" ~ \"Scotland\",\n    TRUE ~ NA_character_\n  )) \nleave_df <- leave_df |> \n  select(country, everything())\n\nremain_df <- remain_df |> \n  mutate(country = case_when(\n    substr(area_code, 1, 1) == \"E\" ~ \"England\",\n    substr(area_code, 1, 1) == \"N\" ~ \"Northern Ireland\",\n    substr(area_code, 1, 1) == \"W\" ~ \"Wales\",\n    substr(area_code, 1, 1) == \"S\" ~ \"Scotland\",\n    TRUE ~ NA_character_\n  )) \nremain_df <- remain_df |> \n  select(country, everything())\n\n#Dataframe of tags (locations on the map)\ncountry_tag <- data.frame(\n  country = c(\"Scotland\", \"England\", \"Wales\", \"Nothern \\nIreland\"),\nlatitude = c(56.999651, 54.383331, 52.000, 55.360043), \nlongitude = c(-4.809075, -1.866667, -4.933, -7.707558)\n)\n\n\nCreating the base plot (map)\nThe following R code constructs a thematic map using the ggplot2 package in R. The map visualizes the results of the E.U. Referendum in Britain, specifically focusing on the percentage of votes for remaining (“Remain”) and leaving (“Leave”) the European Union across different regions. Here’s a detailed breakdown of the code:\nBase Plot Setup: The ggplot() function initializes the plot, and two separate layers are added for the “Remain” and “Leave” data frames using geom_sf. This function is specifically designed for creating visualizations with spatial data, where each observation in the dataset represents a geographic feature such as a point, line, or polygon. The aes argument within it specifies the variables (Pct_Remain or Pct_Leave respectively) to map to the fill color aesthetic. Remain is plotted with a blue scale and Leave with a scale of reds.\nColor Scales: scale_fill_stepsn is used to define color scales for “Remain” and “Leave” percentages. Colors are specified, breaks are set (starting at 50 and ending at 80, which covers the variability of the tunover data), and labels are assigned. The color gradients represent different levels of support, and breaks indicate specific percentage points. Also inside this command the legends are customised for each scale.\nLegend customization: the guide_colorsteps() function is utilized to customize the appearance of the legend associated with data. The configuration ensures even steps in the color scale (uniform distribution of colors across the scale), includes ticks on the legend with specified color and width, orients the legend horizontally, and provides a clear title (“Remain”). Additionally, lines are drawn at the lower and upper limits of the color scale, and the frame of the legend is set to black. The size of text labels within the legend is adjusted to 8 for optimal readability.\nAdding a New Fill Scale: The new_scale_fill() command is introduced to reset the fill scale specifically for the subsequent geom_sf layer that deals with “Leave” data. This is done to separate the color scales for “Remain” and “Leave,” allowing independent customization of color gradients, breaks, labels, and other scale-related properties.\nText Annotations: geom_text is employed to add labels to the map. The country_tag data frame provides coordinates (longitude and latitude) for text placement, and labels are drawn using the specified font (“Lora”). Country names are bold and sized appropriately.\nThemes and Formatting: The appearance of the map is controlled through various theme options. theme_minimal() provides a clean background, and additional adjustments are made for titles, legends, axis labels, grid lines, and font styles. The adjustments include setting the size of the legend title to 9, positioning the plot title to the left with a vertical justification of 0.5, and making the title bold. The legend is positioned at coordinates (0.15, 0.85) within the plot. The text across the plot is set to a specified font family (“DM Serif Display”) and a size of 15. Various elements such as axis text, titles, ticks, and grid lines are removed for a cleaner and more minimalistic design. The legend is oriented horizontally, placed in a vertical box on the right, and justified to the right. The key size of the legend is set to a unit of 0.4 cm, and text within the legend is adjusted to a size of 6. The spacing between legend items along the y-axis is set to zero.\nFinal Plot Object: The final plot object is stored in the variable map.\nThe map effectively visualizes the voting patterns in the E.U. Referendum, distinguishing between regions that voted to remain or leave. The use of color gradients, text annotations, and a clear legend enhances the interpretability of the map.\n\n\nmap <- ggplot() +\n  geom_sf(data = remain_df,\n          aes(fill = Pct_Remain),\n          colour = \"white\",\n          lwd = 0.1) +\n  scale_fill_stepsn(\n    colors = c(\"lightskyblue1\", \"steelblue1\", \"dodgerblue\", \"dodgerblue4\"),\n    breaks = c(50, 60, 70, 80),\n    labels = c(\"\", \"\", \"\", \"\"),\n    limits = c(50, 90),\n    name = \"Remain\", \n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 0.5,\n      direction = \"horizontal\",\n      title = \"Remain\",\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  new_scale_fill() +\n  geom_sf(data = leave_df,\n          aes(fill = Pct_Leave),\n          colour = \"white\",\n          lwd = 0.1) +\n  scale_fill_stepsn(\n    colors = c(\"bisque\", \"lightsalmon\", \"orangered\", \"red3\"),\n    breaks = c(50, 60, 70, 80),\n    labels = c(\"50%\", \"\", \"\", \"80%\"),\n    limits = c(50, 90),\n    name = \"Leave\",\n    na.value = \"gray87\", \n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 0.5,\n      direction = \"horizontal\",\n      title = \"Leave\",\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  geom_text(data = country_tag,\n            aes(x = longitude, y = latitude, label = country),\n            color = \"black\",\n            size = 2.5, fontface = \"bold\",\n            family = \"Lora\") +\n  theme_minimal() +\n  labs(title =                           \"How Britain Voted in the E.U. Referendum\",\n       x = NULL, \n       y = NULL, \n       fill = \"Should Britain remain in the European Union?\") +\n  theme(legend.title = element_text(size = 9),\n        plot.title = element_text(hjust = 0, vjust = 0.5, face = \"bold\"),\n        legend.position = c(0.15, 0.85),\n        text = element_text(family = \"DM Serif Display\",  size = 15),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.box.just = \"right\",\n        legend.key.size = unit(0.4, \"cm\"), \n        legend.text = element_text(size = 6),\n        legend.spacing.y = unit(0, \"cm\"))\nmap\n\n\n\nAs an extra point the coordinates of the map are expanded so that other plots can be added later in the design of the final plot\n\n\n# Expand coordinates of map\n\nexpanded_xmin <- -11.653038\nexpanded_xmax <- 4.382762\nexpanded_ymin <- 49.41625\nexpanded_ymax <- 61.529979\n\n# Modify coord_sf() to include expanded limits\nmap <- map +\n  coord_sf(xlim = c(expanded_xmin, expanded_xmax),\n           ylim = c(expanded_ymin, expanded_ymax))\n\nprint(map)\n\n\n\nAdding tags to the map\nThe code below seeks to generate a map visual using ggplot2, with additional annotations for selected cities. The cities data frame specifies the names, latitudes, and longitudes of several cities in the United Kingdom. Then, the “new” map (updated version of the previous one) is created by adding circles representing cities to the existing map (map). Each circle has a radius of 0.2 units, outlined in gray, and the city names are displayed at specified positions around their respective circles. The geom_text function is used to add city labels, adjusting the vertical and horizontal justification as well as font style and color for each city.\n\n\n#Cities annotations & coordinates\ncities <- data.frame(\n  city = c(\"London\", \"Manchester\", \"Cardiff\", \"Birmingham\", \"Edinburgh\", \"Liverpool\", \"Oxford\", \"Belfast\"),\n  latitude = c(51.509865, 53.4794, 51.4861, 52.479876, 55.9410, 53.3549, 51.750051, 54.5930),\n  longitude = c(-0.118092, -2.2437, -3.1801, -1.9058, -3.29181, -3.0104, -1.25386, -5.9381))\n\n#MAP + tags/circles\nmap1 <- map+\n  geom_circle(data = cities,\n              aes(x0 = longitude, y0 = latitude, r=0.2),  \n              stat= \"circle\",color = \"gray48\" , fill = NA, \n              size = 0.2)+ \n  geom_text(data = cities[c(2, 3, 4, 7), ], aes(x = longitude, y = latitude, label = city),\n            vjust = -2.5, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[c(1, 5), ], aes(x = longitude, y = latitude, label = city),\n            vjust = 3.6 , size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[6,], aes(x = longitude, y = latitude, label = city),\n            hjust = 1.3, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[8,], aes(x = longitude, y = latitude, label = city),\n            hjust = -0.5, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  theme(aspect.ratio = 1.15)\nmap1\n\n\n\nThe resulting map (map1) provides a visual representation of the geographical locations of these cities, enhancing the overall information conveyed by the map. Additionally, the theme function adjusts the aspect ratio of the map for better visual aesthetics.\nLondon close-up\nIn this chunk a zoomed-in version of a map is created using ggplot2. The locations data frame contains geographical coordinates (longitude and latitude) defining bounding boxes for several cities. The location variable specifies the city for which the user wants to generate a zoomed map. In the code, it’s set to “London,” but users can change it to other cities from the list. The code then extracts the longitude and latitude ranges (xlim and ylim) for the specified city from the locations data frame.\n\n\n# Locations dataframe with coordenates \nlocations <- data.frame(\n  rbind(\n    c(\"London\", -0.58913, 0.3520155, 51.2318741, 51.7167602),\n    c(\"Manchester\", -2.4034, -2.0937, 53.3794, 53.5501),\n    c(\"Cardiff\", -3.3124, -3.0971, 51.4461, 51.5521),\n    c(\"Birmingham\", -2.0450, -1.6958, 52.3538, 52.5578),\n    c(\"Edinburgh\", -3.3278, -3.0481, 55.8910, 55.9880),\n    c(\"Liverpool\", -3.0917, -2.8125, 53.3321, 53.4586),\n    c(\"Oxford\", -1.2994, -1.1280, 51.7149, 51.7984),\n    c(\"Belfast\", -5.9959, -5.8481, 54.6430, 51.5400)\n  ),stringsAsFactors = F)\n\nlocation <- \"London\" # Change the location as needed\n\n# Extract xlim and ylim values directly from the locations data frame\nxlim <- as.numeric(locations[locations[, 1] == location, c(2, 3)])\nylim <- as.numeric(locations[locations[, 1] == location, c(4, 5)])\n\n\nWith this now the extraction of the map is plotted and stored:\n\n\nzoomed_map1 <- map +\n  theme(legend.position = \"none\", plot.title = element_blank(),\n        panel.border = element_rect(color = \"black\", fill = NA, size = 1)) +\n  coord_sf(xlim = c(xlim[1], xlim[2]), ylim = c(ylim[1], ylim[2]), crs = 4326) +\n  theme(aspect.ratio = 1)\nzoomed_map1\n\n\n\nThe resulting zoomed_map1 is generated by adjusting the original map (map) with additional themes and coordinates. The adjustments include removing the legend, hiding the plot title, adding a black border to the map, and setting the aspect ratio to maintain the correct proportions. The coord_sf function is used to set the limits for the x and y axes based on the extracted ranges for the chosen city. The resulting map (zoomed_map1) provides a closer look at the specified city by zooming in on its geographical coordinates.\nRemain-Leave bar plot\nAfter having ready the base map we need to start creating the adjacent plots. This code generates a bar plot using ggplot2 in R to visualize the results of the Brexit referendum in different regions of the United Kingdom. The data frame df contains information about the population, “Remain” votes, and “Leave” votes for regions such as Britain, England, London, Scotland, Wales, and Northern Ireland. The factor levels of the “Region” variable are reordered for better visualization.\n\n\n# Create new data frame with the data\ndf <- data.frame(Region = c(\"Britain\", \"England\", \"London\", \"Scotland\", \"Wales\", \"N. Ireland\", \" \"),\n                 Pop_M = c(64.1, 53.0, 8.5, 5.3, 3.0, 1.8, NA),\n                 Remain = c(48, 47, 60, 62, 47, 56, NA),\n                 Leave = c(52, 53, 40, 38, 53, 44, NA))\n\n# Reorder levels of factor\ndf$Region <- factor(df$Region, levels = c(\"London\", \"N. Ireland\", \"Wales\", \"Scotland\", \"England\", \"Britain\", \" \"), ordered = is.ordered(df$Region))\n\n\nAgain, once the data is ready, it just needs to be plotted. The bar_plot is created by reshaping the data using the gather function to represent the “Remain” and “Leave” votes as separate bars for each region. The resulting plot shows a stacked bar chart where each region is divided into “Remain” and “Leave” segments. The code also includes text annotations for specific regions, emphasizing the vote percentages in key areas such as Northern Ireland, Scotland, and London.\nThe plot is then flipped horizontally (coord_flip()) for simulating the one in the reference graph (which is a horizontal plot), and custom themes and color scales are applied to enhance the visual representation. The plot includes two sets of text annotations within the stacked bars, highlighting regions like “N. Ireland,” “Scotland,” and “London” with specific vertical adjustments. Additional annotations label “REMAIN” and “LEAVE,” while the plot is customized with a minimal theme, flipped coordinates, color-filled bars for “Remain” and “Leave,” removal of grid lines, and a dashed horizontal line at 50% for reference, indicating the threshold between “Remain” and “Leave” outcomes.\n\n\n#plot bar plot\nbar_plot <- df |> \n  select(Region, Remain, Leave)  |> \n  tidyr::gather(key, VoteCount, -Region) |> \n  ggplot(aes(x = Region, y = VoteCount, fill = key)) +\n  geom_bar(stat = \"identity\") +\n  geom_text(aes(label = ifelse(Region %in% c(\"N. Ireland\", \"Scotland\", \"London\"), paste0(VoteCount, \"%\"), \"\")),\n            position = position_stack(vjust = c(0.4, 0.47)),\n            color = \"white\", fontface = \"bold\", size = 2) +\n  geom_text(aes(label = ifelse(Region %in% c(\"England\", \"Wales\", \"Britain\"), paste0(VoteCount, \"%\"), \"\")),\n            position = position_stack(vjust = c(0.5, 0.6)),\n            color = \"white\", fontface = \"bold\", size = 2) +\n  annotate(\"text\", x=6.7, y= 12, label = \"REMAIN\",  size = 2)+\n  annotate(\"text\", x=6.7, y= 90, label = \"LEAVE\", size = 2)+\n  labs(title = \"\",\n       x = \"\", y = \"\") +\n  theme_minimal() +\n  coord_flip() +\n  scale_fill_manual(values = c(\"Remain\" = \"dodgerblue4\", \"Leave\" = \"red3\"))+\n  theme(legend.position = \"none\",\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_text(face = \"bold\", color = \"black\", size = 6, hjust = 0, family = \"Lora\"))+\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"white\", size=0.2)\nbar_plot\n\n\n\nLondon zoom-up lines\nTo make this plot closer to the reference plot dashed lines need to be added and connected to the zoomed-up map. he coordinates for the starting and ending points of each line are specified in the origin1, end1, origin2, and end2 vectors. They were manually chosen using a web that displays the coordenates of any point you might choose on a map.\nTwo data frames, line1 and line2, were then created to represent the coordinates of each line. The code builds on an existing map (map1) and uses the geom_segment function to add two dashed line segments to the map. The aesthetics define the starting and ending points of each segment using the x and y coordinates from the respective data frames. The color is set to “grey38,” the linetype to “dashed,” and the size to 0.13, resulting in two visually distinct dashed lines representing the specified segments.\n\n\n#LINE 1\norigin1 <- c(-0.090525, 51.757161)\nend1 <- c(1.904604, 52.578733)\n\n#LINE2\norigin2 <- c(-0.100525, 51.240399)\nend2 <- c(1.904604, 50.999038)\n\nline1 <- data.frame(x = c(origin1[1], end1[1]), y = c(origin1[2], end1[2]))\nline2 <- data.frame(x = c(origin2[1], end2[1]), y = c(origin2[2], end2[2]))\n\nmap2 <- map1 +\n  geom_segment(data = line1,\n               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),\n               color = \"grey38\", linetype = \"dashed\", size = 0.13) +\n  geom_segment(data = line2,\n               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),\n               color = \"grey38\", linetype = \"dashed\", size = 0.13)\nmap2\n\n\n\nThe resulting map, map2, displays the original map with the added line segments.\nPutting everything together\nIn order to put everything together the coordinates (xmin, xmax, ymin, ymax) are specified to determine the placement of the zoomed map within the combined plot, focusing on a specific region. Similarly, coordinates (xmin1, xmax1, ymin1, ymax1) are specified for the placement of the bar plot. The annotation_custom function is then used to add each individual plot as a custom annotation to the main map (map2).\n\n\n# Specify coordinates for the zoomed map\nxmin <- 1.5\nxmax <- 4.5\nymin <- 50.5\nymax <- 53\n\n#specify coordinates for the bar plot\nxmin1 <- -2\nxmax1 <- 5.5\nymin1 <- 55.5\nymax1 <- 60.5\n\n\nThe first annotation_custom call adds the zoomed map (zoomed_map1) to the specified region of the main map (map2). The second annotation_custom call adds the bar plot (bar_plot) to another specified region. The resulting plot, plot_w_addins, displays both the zoomed map and the bar plot in a single composite view. This approach allows for the juxtaposition of different visualizations within the same plot, providing a comprehensive overview of spatial and categorical information.\n\n\n# Combine the maps into one\ncombined_map <- annotation_custom(grob = ggplotGrob(zoomed_map1), \n                                xmin = xmin, xmax = xmax, \n                                ymin = ymin, ymax = ymax)\n\ncombined_bar <- annotation_custom(grob = ggplotGrob(bar_plot), \n                                  xmin = xmin1, xmax = xmax1, \n                                  ymin = ymin1, ymax = ymax1)\n\n\n# Create combination of all plots\nplot_w_addins <- map2 + combined_map + combined_bar\nplot_w_addins\n\n\n\nFinal annotations\nFinally, the big text annotations need to be added on top of everything else.\nFirst, geographical points and annotation texts related to specific regions are defined. Each set of points represents a geographic area (e.g., Scotland, London, Ireland, Wales), and the associated annotation_text provides information or context about that region in relation to the Brexit referendum\n\n\n#Scotland\npoint1 <- c(-0.666206, 55.598766)\npoint2 <- c(-2.456146, 56.080442)\npoint3 <- c(-0.59, 55.152745)\nannotation_text1 <- \"The Scottish first minister has said that a leave\\nvote could trigger a referendum vote in\\nScotland to leave Britain. Scots rejected\\nindependence in a referendum in September\\n2014 by 55 percent to 45 percent.\"\n\n#London\n\npoint4 <- c(1.930838, 53.06749)\nannotation_text2 <- \"London, along with Scotland,\\nled the vote to remain in the\\nEuropean Union, though the\\neast side of the city voted to\\nleave.\"\n\n#Ireland\npoint5 <- c(-7.84579, 55.970628)\npoint6 <- c(-6.506151, 55.300913)\npoint7 <- c(-11.220845, 56.260588)\nannotation_text3 <- \"Northern Ireland shares a\\ncompletely porous border with\\nIreland, which is in the\\nEuropean Union. Trade issues\\ncould arise between the two.\"\n\n#Wales\npoint8 <- c(-5.517893, 50.843996)\npoint9 <- c(-4.524143, 51.599867)\npoint10 <- c(-9.527097, 50.85646)\nannotation_text4 <- \"The majority of Wales voted\\nstrongly to leave, except for the\\nlargest city Cardiff, which voted to\\nremain by 60 percent.\"\n\n\nOverall, this code helps position annotations on a map to provide additional information about key regions and their stances during the Brexit referendum.\nAt last the final plot with the annotations:\nThe code uses geom_curve to draw curved arrows between specific points, creating visual connections on the map. The arrows are labeled with text annotations, conveying additional information about each region’s significance in the context of the Brexit referendum.\nThe annotations are positioned strategically using annotate(\"text\") along with specified coordinates for clarity. Additionally, the overall appearance of the plot is fine-tuned by adjusting the theme to minimize unnecessary elements, such as axis ticks and grid lines, and enhancing the overall aesthetics.\n\n\n#final plot\nplot_w_addins+\n  geom_curve(aes(x = point1[1], y = point1[2], xend = point2[1], yend = point2[2]),\n             curvature = 0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  geom_curve(aes(x = point5[1], y = point5[2], xend = point6[1], yend = point6[2]),\n             curvature = -0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  geom_curve(aes(x = point8[1], y = point8[2], xend = point9[1], yend = point9[2]),\n             curvature = 0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  annotate(\"text\", x = point3[1], y = point3[2],\n           label = annotation_text1, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point4[1], y = point4[2],\n           label = annotation_text2, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point7[1], y = point7[2],\n           label = annotation_text3, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point10[1], y = point10[2],\n           label = annotation_text4, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  theme_minimal()+\n  theme(legend.title = element_text(size = 9),\n        plot.title = element_text(hjust = 0, vjust = 0.5, face = \"bold\"),\n        legend.position = c(0.15, 0.85),\n        text = element_text(family = \"DM Serif Display\",  size = 15),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.box.just = \"right\",\n        legend.key.size = unit(0.4, \"cm\"), \n        legend.text = element_text(size = 6),\n        legend.spacing.y = unit(0, \"cm\"))\n\n\n\nThe legend.position parameter determines the location of the legend, placing it slightly to the right and towards the top of the plot. The text parameter specifies the font family as “DM Serif Display” with a font size of 15, ensuring a consistent and aesthetically pleasing text style throughout the plot. Additionally, various elements such as axis labels, titles, ticks, and grid lines are removed using element_blank(), contributing to a clean and uncluttered layout.\nThe legend is configured to be horizontal (legend.direction), and its box is styled to be vertical with justification to the right (legend.box and legend.box.just). Further customization includes adjusting the size of legend keys (legend.key.size), text size within the legend (legend.text), and eliminating vertical spacing between legend items (legend.spacing.y). Collectively, these theme settings enhance the plot’s readability, maintain a coherent design, and prioritize the display of essential information.\nLimitations\nSome key limitations of this graph are the legend and the zoomed-up map. In the original map the legend was created with another program and with R this is the closest I could manage to get after making a few adjustments. Regarding the zoomed up map I tried different methods like buffer or ggmapinset, but given the structure of my data and layers I was not able to make the zoomed-up map round.\nIs there an alternative way?\nThe remaining library that would be needed:\n\n\nlibrary(htmltools)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(sp)\n\n\nThe data should be loaded again and the data for Northern Ireland should be manually loaded again just like for the previous map:\n\n\n#csv\nreferendum <- read_csv(\"EU-referendum-result-data.csv\")\n#UK shapefile\nuk_shp <- read_sf(\"maps/uk_constituencies_2016.shp\")\n\n#modifications for merging\nreferendum <- referendum |> \n  rename(area_code = Area_Code)\n\n#merge\nbrexit_data <- left_join(uk_shp, referendum, by = \"area_code\")\n\n#West Tyrone ...\n#brexit_data$Pct_Turnout[18] <- 61.8\n#brexit_data$Remain[18] <- 26765\n#...\n\n\nThen the cleaned data should be reprojected into WGS84\n\n\n#Reproject data to WGS84\nbrexit_data <- st_transform(brexit_data, 4326)\n\n\nSubsequently, the brexit_data dataframe is being modified with a new variable called margin. This variable is calculated as the absolute difference between the columns Pct_Remain and Pct_Leave. The mutate function from the dplyr package is used to create this new column.\nThen, the range function is applied to the margin variable within the brexit_data dataframe. The range function returns the minimum and maximum values of a numeric vector. In this context, it calculates the minimum and maximum values of the margin variable. The na.rm = TRUE argument is included to exclude any missing values (NA) when determining the range.\n\n\n#min_max values\nbrexit_data <- mutate(brexit_data, margin = abs(Pct_Remain - Pct_Leave))\nmin_max_values <- range(brexit_data$margin, na.rm = TRUE)\n\n\nAfter that is done a colour palette for the plotted map must be created. This colour palette will take the lightest colour for the smallest number of the margin between votes.\n\n\n#colour palette \n\nleave_palette <- colorNumeric(palette = \"Reds\", domain=c(min_max_values[1], min_max_values[2]))\nremain_palette <- colorNumeric(palette = \"Blues\", \n                               domain=c(min_max_values[1], min_max_values[[2]]))\n\n\nThis code is creating two color palettes, leave_palette and remain_palette, for visualizing the margin between “Pct_Remain” and “Pct_Leave” in a graphical representation. The colorNumeric function is used from the leaflet package, and it allows for the creation of a color palette based on a numeric range.\nThe palette argument specifies the color scheme, with “Reds” for leave_palette and “Blues” for remain_palette. The domain argument sets the range of values for which colors will be assigned. In this case, the range is determined by min_max_values[1] (minimum) and min_max_values[2] (maximum), which were calculated in the previous code block as the minimum and maximum values of the absolute margin between “Pct_Remain” and “Pct_Leave”. The color palettes will be used later for mapping and visualizing the data, with lighter colors representing smaller margins and darker colors representing larger margins.\nFor this visualization, two different dataframes are needed, so they are created in the same way as in the previous plot:\n\n\n# Making a winner column\nbrexit_data <- mutate(brexit_data, winner = if_else(Pct_Remain > Pct_Leave, \"Remain\", \"Leave\"))\n\n#Creating two different data frames\nleave_df <- brexit_data[brexit_data$winner == \"Leave\",]\nremain_df <- brexit_data[brexit_data$winner == \"Remain\",]\n\n\nAlso, in order to have popups for each district to be used in conjunction with the leaflet map, they have to be previously set:\nThis chunk is creating HTML-formatted popups for map markers in a geographic visualization. The popups provide information about the voting results for different areas, particularly focusing on the “Leave” and “Remain” campaigns in the context of the Brexit referendum.\n\n\n#Create a popup\n\nleave_popup <- glue(\"<strong>{leave_df$area_name} AREA<\/strong><br />\n                    <strong>winner: Leave<\/strong><br />\n                    Leave: {scales::comma(leave_df$Pct_Leave, accuracy = 1)}<br />\n                    Remain: {scales::comma(leave_df$Pct_Remain, accuracy = 1)}<br />\n                    Margin: {scales::comma(leave_df$margin, accuracy = 1)}\")  %>%   \n  lapply(htmltools::HTML)\nremain_popup <- glue(\"<strong>{remain_df$area_name} AREA<\/strong><br />\n                      <strong>winner: Remain<\/strong><br />\n                      Remain: {scales::comma(remain_df$Remain, accuracy = 1)}<br />\n                      Leave: {scales::comma(remain_df$Leave, accuracy = 1)}<br />\n                      Margin: {scales::comma(remain_df$margin, accuracy = 1)}\")  %>%   \n  lapply(htmltools::HTML)\n\n\nFor the “leave_popup,” the information includes the area name, the winning campaign (“Leave”), the percentage of votes for “Leave,” the percentage of votes for “Remain,” and the margin between the two. The glue function is used to dynamically insert values from the leave_df dataframe into an HTML template. The lapply function is then applied to convert the resulting string into an HTML object.\nSimilarly, for the “remain_popup,” the information includes the area name, the winning campaign (“Remain”), the percentage of votes for “Remain,” the percentage of votes for “Leave,” and the margin between the two. The glue function is again utilized to create an HTML-formatted string, and lapply converts it into an HTML object.\nLastly, the background for the map is set and the map is plotted:\n\n\n#Set the background of the map\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\")\n\n\n\nThis code above uses the leaflet R package to create an interactive map, and it sets the background map tiles to be provided by CartoDB with a Positron theme. The leaflet() function initializes a new leaflet map, and addProviderTiles(\"CartoDB.Positron\") adds the specified map tiles from CartoDB’s Positron theme as the background to the leaflet map. This provides a clean and visually appealing base map for further layers and data visualization on the leaflet map.\n\n\n#Then we overlay the data\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  addPolygons(\n    data = leave_df,\n    fillColor = ~leave_palette(leave_df$margin),\n    label = leave_popup,\n    stroke = TRUE,\n    smoothFactor = 0.2,\n    fillOpacity = 0.8,\n    color = \"#666\",\n    weight = 1\n  ) %>%\n  addPolygons(\n    data = remain_df,\n    fillColor = ~remain_palette(remain_df$margin),\n    label = remain_popup,\n    stroke = TRUE,\n    smoothFactor = 0.2,\n    fillOpacity = 0.8,\n    color = \"#666\",\n    weight = 1\n  )\n\n\n\nThe previous code just overlays a map on a cartographic base layer using CartoDB’s Positron tiles.\nThe addPolygons function is then used to overlay polygons on the map, representing geographical areas. Two sets of polygons are added to the map, corresponding to the leave_df and remain_df datasets, each with specific styling. The fillColor parameter is set dynamically using color palettes (leave_palette and remain_palette) based on the margin values in each dataset. This creates a choropleth map where different shades of color represent different margins between Leave and Remain votes in each geographic area.\nAdditionally, the label parameter is used to create pop-up labels for each polygon, displaying relevant information such as the area name, the winning side (Leave or Remain), individual vote percentages, and the margin. The map is designed to be interactive, allowing users to explore the data by hovering over each area and viewing the associated information. The stroke, smoothFactor, fillOpacity, color, and weight parameters are set to control the appearance of the polygons, ensuring a visually informative and aesthetically pleasing map.\nAnd with this we have an alternative interactive map to visualize the data!!\n\n\n\n",
    "preview": "projects/2023/100408925/100408925_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1435
  },
  {
    "path": "projects/2023/100481838/",
    "title": "We Feel It Already. How About We Visualize It?",
    "description": "Summer temperatures are getting hotter and this plot does a pretty good job at showing that.",
    "author": [
      {
        "name": "Mikaela DeSmedt",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe plot in question: the story and how it’s told\nVisual encoding\nOther elements\n\nReplication\nOriginal and tidy data\nBase plot\nAnnotations\nBreaking it by periods\nReference area\nAnimation\n\nEnhancement\nEnhancement 1: Ridgelines\nEnhancement 2: Facets\n\n\nIntroduction\nResearchers have found that summer temperatures have shifted drastically since the mid-20th century. An eerie discovery that points to the frightening reality that temperatures in the warmer season of the year are now hot or extremely hot in comparison what they were 40 years ago.\nOriginal chart from NYT websiteThe aim of this tutorial is to analyze the visual encoding and replicate this chart. The final section also proposes additional improvements.\nThe plot in question: the story and how it’s told\nThe following chart uses data from retired NASA climate scientist James Hansen to show how summer temperatures have shifted toward more extreme heat over the past several decades.\nThis representation uses bell curves to compare the distribution in the frequency of occurrence of temperature anomalies (y-axis) divided by local standard deviation for the 1951-1980 period (x-axis) obtained by binning all local results for the indicated region and 11-year period into 0.05 frequency intervals. Additionally, this chart is presented along an animation which shows the transition of all recorded periods.\nIn essence, what this chart aims to communicate is the shift in the distribution of temperatures towards a higher occurrence of hotter temperatures. So, lets take a look at visual encoding it uses to do so…\nREMINDER: Visual encoding is the way in which data items and their attributes are mapped to visual structures such as marks and channels. Taking them From data items (observations, rows) to visual marks and from data attributes (variables, columns) to visual channels\nVisual encoding\nOur raw data consists on rows representing anomalies in recorded temperatures ranging from -6 to +6 in 0.05 intervals. The attributes of these data include the frequency of occurrence of these anomalies and the period in which they were recorded. The visual elements used to map the data are as follow\nVisual mark: area - the shape of the distribution of occurrence in temperature anomalies\nVisual channel (identity): color - determining which anomalies are to be regarded as extremely cold, cold, normal, hot or extremely hot along the X-axis.\nOther elements\nIn order to further the expressive capabilities of these chart, the original authors included further explanatory elements such as tittle and subtitle, text labels and a legend, as well as reference elements such as a reference area that allows comparison with the baseline period and reference lines which emphasize the limits of each temperature group.\nOriginal chart from NYT website marked-up to list additional elements and annotationsReplication\nOriginal and tidy data\nThe authors behind the publication that inspired this chart post data and visualizations of their own in this website http://www.columbia.edu/~mhs119/PerceptionsAndDice/\nFrom here, we download the ‘shifted data’ table named Data: N.H. Land, Jun-Jul-Aug. Which when imported to R is visualized as follows:\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\nccdata<- tibble(read.table(\n  file = \"http://www.columbia.edu/~mhs119/PerceptionsAndDice/NH.JJA.11yrs.txt\", \n  header = TRUE,\n  skip = 1))\n\nwrite.csv(ccdata, \"ccdata.csv\", row.names = FALSE)\n\nhead(ccdata)\n\n# A tibble: 6 × 5\n  anoms.S X1980.1990 X1991.2001 X2002.2012 X2013.2023\n    <dbl>      <dbl>      <dbl>      <dbl>      <dbl>\n1   -6             0          0          0          0\n2   -5.95          0          0          0          0\n3   -5.9           0          0          0          0\n4   -5.85          0          0          0          0\n5   -5.8           0          0          0          0\n6   -5.75          0          0          0          0\n\nIn the author’s website they also make available a visualization of the data which tells the same story as the chart in the NYT post, but dispensing of animation or other aesthetics. This serves us to ‘reverse engineer’ our way into understanding the structure our data must follow for us to be able to replicate it using Ggplot.\nFigures in Warm/Cool Dice Colors [for Northern Hemisphere Land]Note: The data published in the author’s site has been updated since the publication of the NYT article. Hence, the data used to replicate this chart is slightly different to the original.\nFrom looking at the first few rows of ‘ccdata’ we can already tell the first step will be to ‘tidy’ this dataset. The second step then, will be to categorize our anomalies into the four groups seen in the NYT post. Our data has temperature anomalies ranging from -6 to +6. we need to create a categorical variable that labels these anomalies from extremely cold to extremely hot. Following these two steps will yield a ‘tidy’ dataset with all the attributes we need our data to have.\n\n\nccdata <- ccdata |> \n  drop_na(anoms.S)\n\n#tidy up dataset \nlongdata <- ccdata |> \n  pivot_longer(cols = \n                 c(X1980.1990, \n                   X1991.2001, \n                   X2002.2012, \n                   X2013.2023), \n               names_to = \"period\") |> \n  mutate(\"period\" = str_sub(period, 2)) |> \n  \n#create temperature type variable\n  mutate(\"temptype\" = case_when(\n         anoms.S < -3 ~ \"Extremely cold\",\n         anoms.S >= -3 & anoms.S < -0.5 ~ \"Cold\",\n         anoms.S >= -0.5 & anoms.S <= 0.5 ~ \"Normal\",\n         anoms.S > 0.5 & anoms.S <= 3 ~ \"Hot\",\n         anoms.S > 3 ~ \"Extremely hot\"))\n\nhead(longdata)\n\n# A tibble: 6 × 4\n  anoms.S period    value temptype      \n    <dbl> <chr>     <dbl> <chr>         \n1   -6    1980.1990     0 Extremely cold\n2   -6    1991.2001     0 Extremely cold\n3   -6    2002.2012     0 Extremely cold\n4   -6    2013.2023     0 Extremely cold\n5   -5.95 1980.1990     0 Extremely cold\n6   -5.95 1991.2001     0 Extremely cold\n\nNow with the data as we want it, we can head on and start with our graph.\nBase plot\nI have broken down the code of my base plot in four steps\nAs a first step we degine our ggplot() function. This sets up the basic structure of the plot function. It specifies the data (longdata) and aesthetic mappings for the x-axis (anoms.S), y-axis (value), and fill color (temptype). But up to this line, we are left only with an x and a y axis and no markings within it.\nSecondly, we must define our geom, which is this case is geom_area(). This adds an area plot to the ggplot with options specifying that the data is in identity form, the stacking position, the number of bins. Note here that the legend argument has been set to false this is because we wish to add it later on as a separate item.\nThird, we style our plot. using scale_fill_manual() we set the fill colors for different levels of the ‘temptype’ variable using their codes in hexadecimal format.\nIn this step we determine the size of our X-axis using xlim() and we use theme_void() to set the theme of the plot to a blank/void , essentially removing any axes, labels, or background elements.\n\n\nbaseplot<- \n  longdata |> \n  ggplot(aes(x = anoms.S, \n             y = value, \n             fill = temptype)) + \n#2. Adding the geom which will map our data \n  geom_area(stat = \"identity\", \n                 position = \"stack\", \n                 bins = 30,\n                 show.legend = FALSE) \n\n#3. Custom colors\n##saving custom colors to save space later down the road\ncustomcolors <- c(\"Extremely cold\"=\"#085b84\", \n                                 \"Cold\" = \"#54a5ba\",\n                                 \"Normal\" = \"#dfdfdf\", \n                                 \"Hot\" = \"#eb8550\",\n                                 \"Extremely hot\" = \"#cc2821\")\n\nbaseplot<- baseplot +\n  scale_fill_manual(values = customcolors) +\n  \n#4. Axis limits and theme\n  xlim(c(-6, 6))+\n  theme_void()\n\nbaseplot\n\n\n\nAt this point, out plot has the general shape we want it to have. But it still needs additional elements to help us understand what is going on.\nAnnotations\nTo our baseplot we need to add all the explanatory elements such as labels, tittles, legend and others. So lets take a look at the code for that.\nTittle and subtitle\nThis element was added using the labs function which sets these elements for the plot.\n\n\nbaseplot <- \nbaseplot +\n#Tittle and subtittle + the color we want it to have\n  labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\"),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015))\n\n\nLegend and period lable\nWe will add our legend using the annotate function which essentially allows us to add text annotation freely along the plot. For example, consider the line\nannotate(\"text\", x=0, y=-0.04, label= \"Normal\", color = \"#999999\", fontface = 2)\nThis annotates the plot with the text “Normal” at coordinates (0, -0.04) with a gray color and bold fontface. We have done this for all temperature types.\nSimilarly, using this same function, we will add a label for the corresponding period of the plot. As this baseplot is set to consider all our data the period it corresponds to is from 1980 to 2023.\n\n\n#Leged by annotations\n  \nbaseplot +\n  annotate(\"text\", \n           x=0, \n           y=-0.04, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.04, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.04, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.04, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=5, \n           y=-0.04, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2)+\n    annotate(\"text\", \n           x=4, \n           y= 1, \n           label= \"1980-2023\", \n           color = \"black\",\n           size = 10,\n           fontface = 10)\n\n\n\nReference lines\nWe also have reference lines showing the limits of each temp type in the baseline period. We have added these using geom_vline() and setting the places where we want it to intercept the x axis in xintercept, the line type and the color we want it to be.\n\n\nbaseplot<- \n  baseplot +\n  geom_vline(xintercept = c(-3, -0.5, 0.5, 3), \n             linetype = \"dashed\", \n             color = \"gray\")\n\nbaseplot\n\n\n\nNow our chart has almost all the elements it needs. But it still not quite as we want it to be because it doesn’t yet tell the story.\nBreaking it by periods\nOur baseplot is good for showing all the elements that go into the making of our chart. However, we still need this to be made for each of the period we have data for. We can easily do this by filtering our data using the filter function before our ggplot() fucntion as follows\nplot1980.1990<- longdata |> filter(period == \"1980.1990\") |> ggplot(...\nNote: Creating these plots also needs us to adjust the coordinates in the labels. I’m also setting a ylim() argument to make this standard through all plots.\nThe following chunk shows this example for the period of 1980 to 1990.\n\n\nplot1980.1990<-\nlongdata |> \n  filter(period == \"1980.1990\") |> \n  ggplot(aes(x = anoms.S, \n               y = value, \n               fill = temptype)) + \n    geom_area(stat = \"identity\", \n                   position = \"stack\", \n                   bins = 30,\n                   show.legend = FALSE)+\n  scale_fill_manual(values = customcolors)+\n  xlim(c(-6, 6))+    \n    theme_void()+\n  annotate(\"text\", \n           x=3, \n           y= 0.35, \n           label= \"1980-1990\", \n           color = \"black\",\n           size = 10,\n           fontface = 10)\n\n\nOnce that is done, we can add a few more annotations are needed. Namely those that are placed together with an arrow or another visual element. For this we use the function geom_segment and indicate its positioning with x y coordinates as we have done for text annotations.\n\n\n#We save the new lables as a function in order to reuse\nperiod_annotations <- function(plot){\n  plot + \n  #chart aesthetics\n    scale_fill_manual(values = customcolors)+\n    xlim(c(-6, 6))+    \n    theme_void()+\n  #title and subtitle \n    labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n    theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\"),\n          plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015))+\n  #Reference lines\n    geom_vline(xintercept = c(-3, -0.5, 0.5, 3), \n             linetype = \"dashed\", \n             color = \"gray\")+ \n   #Legend\n     annotate(\"text\", \n           x=0, \n           y=-0.02, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.02, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.02, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.02, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=5, \n           y=-0.02, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2)+\n  #Other annotatins\n    geom_segment(\n    x = -4.2, \n    y = 0.05,          \n    xend = -4.2, \n    yend = 0.1,\n    color = \"#999999\",\n    arrow = arrow(length = unit(0.2, \"cm\"), \n                  ends = \"last\", \n                  type = \"closed\"))+\n  annotate(\"text\", \n           x= -4.2, \n           y= 0.03, \n           label= \"More frequent\", \n           color = \"#999999\")\n}\n\n#We apply the function to the plot to save the layers\nplot1980.1990<- period_annotations(plot1980.1990) \n\nplot1980.1990\n\n\n\nOnce we have that down, we can do it for all the other periods.\n\n\n\nIn these 4 plots we can already see the shift tha the original plot communicates. But again a key element will help show that better.\nReference area\nAlong the animaion, the original plot maintains a reference area filled by a lined pattern in order to show the difference in the distribution of the baseline period and all those which follow. For this, we need to create another layer on our plots.\nFirst, I’m creating a data frame with data for the shadow along using the filter function.\n\n\ndf.shadow<-\n  longdata |> \n  filter(period == \"1980.1990\")\n\n\nThe code for the shadow is as follows. Here I’m applying it over the plot1991.2001 object so we can see the reference area. Here, it now makes sense to include one annotation I had previously disregarded as it points to the reference area.\n\n\nreferenceshadow<- function(plot){\n  plot +\n  ggpattern::geom_area_pattern(data = df.shadow,\n                               stat = \"identity\", \n                 position = \"stack\", \n                 show.legend = FALSE,\n                 pattern = \"stripe\",\n                 pattern_density = 0.2,\n                 pattern_fill = \"#999999\",\n                 pattern_colour = \"#999999\",\n                 alpha = 0.09,\n                 pattern_size = 0.01,\n                 pattern_spacing = 0.01,\n                 pattern_linetype = 1)+\n  #'base period' annotation\n   geom_segment(\n    x = -1.6, \n    y = 0.11,          \n    xend = -2.1, \n    yend = 0.11,\n    color = \"#999999\")+\n  annotate(\"text\", \n           x= -3, \n           y= 0.12, \n           label= \"1980-1990\",\n           size = 3,\n           color = \"#999999\")+\n  annotate(\"text\", \n           x= -3, \n           y= 0.1, \n           label= \"Base period\",\n           size = 2.6,\n           color = \"#999999\")\n}\n\nreferenceshadow(plot1991.2001)\n\n\n\nHere is how it looks when applied to all plots.\n\n\n\nAnimation\nI redefined our baseplot to have a ylim that would be suiting to all time periods and have the lables and fons sizes adjusted accordingly. This new plot I named thewholething as it includes all the elements previously discussed in this post.\nUsing the function transition_states from the gganimate(). For the animation it’s actually not necessary to make an individual plot for each time period. Rather, we can define that we want our variable period to be what determines our transition states. The result is as follows\n\n\nlibrary(gganimate)\nlibrary(gifski)\n\n\n# Animate the plots\nanim <- thewholething + \n  transition_states(longdata$period,\n                    transition_length = 2,\n                    state_length = 1)\n\n\nanimate(anim)\n\n\n\nEnhancement\nThe main thing I’d like to improve in this plot is being able to tell the same story but without having to rely on the animation. I would like for this plot to be able to tell us that temperatures are getting hotter every decade from the first look.\nSo I have proposed 2 enhacements.\nEnhancement 1: Ridgelines\nThe first one involve changing the geom we use to geom_ridgeline_gradient.\n\n\nlibrary(ggridges)\n\n#enhancement1<-\n  longdata |> \n   ggplot(aes(y=value, \n               x=anoms.S,\n              height = value,\n              group = period,\n              fill = temptype)) +\n    geom_ridgeline_gradient(show.legend = FALSE)+\n    scale_fill_manual(values = c(\"Extremely cold\"=\"#085b84\", \n                               \"Cold\" = \"#54a5ba\",\n                               \"Normal\" = \"#dfdfdf\", \n                               \"Hot\" = \"#eb8550\",\n                               \"Extremely hot\" = \"#cc2821\"))+\n  theme_void()+\n  xlim(-8,8)+\n  annotate(\"text\", \n           x=0, \n           y=-0.04, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.04, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.04, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.04, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=5, \n           y=-0.04, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2,\n           size = 6)+\n    geom_segment(\n        x = -4.2, \n        y = 0.12,          \n        xend = -4.2, \n        yend = 0.3,\n        color = \"#999999\",\n        arrow = arrow(length = unit(0.2, \"cm\"), \n                      ends = \"last\", \n                      type = \"closed\"))+\n  annotate(\"text\", \n           x= -4.2, \n           y= 0.09, \n           label= \"More frequent\", \n           color = \"#999999\",\n           size = 4)+\n    labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\",\n                                  size = 20),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015,\n                                     size = 15))\n\n\n\nWith this alternative plot we are able to visualize the shift in the distribution of temperatures without relying on the animation. However, having all the data clustered up in the same space might not be the most efficient way of showing the shift with as much emphasis as we would like.\nEnhancement 2: Facets\nFor the second enhacement, I consider the use of facets.\n\n\nenhancement2<- \n  longdata |> \n  ggplot(aes(x = anoms.S, \n             y = value, \n             fill = temptype)) + \n#2. Adding the geom which will map our data \n  geom_area(stat = \"identity\", \n                 position = \"stack\", \n                 bins = 30) +\n#3. \n  scale_fill_manual(values = c(\"Extremely cold\"=\"#085b84\", \n                               \"Cold\" = \"#54a5ba\",\n                               \"Normal\" = \"#dfdfdf\", \n                               \"Hot\" = \"#eb8550\",\n                               \"Extremely hot\" = \"#cc2821\"),\n                    breaks = c(\"Extremely cold\", \n                               \"Cold\", \"Normal\", \n                               \"Hot\", \n                               \"Extremely hot\"),\n                    name = NULL) +\n#4. Axis limits and theme\n  xlim(c(-6, 6))+\n  ylim(c(-0.15,0.4))+\n  theme_void()+\n#Tittle and subtittle + the color we want it to have\n  labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\",\n                                  size = 20),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015,\n                                     size = 15),\n        strip.text = element_text(hjust = 0.09, \n                                  vjust = 0,\n                                  size = 15),\n         legend.position = \"bottom\")+\n  facet_wrap(~ period, \n             nrow = 4, \n             ncol = 1,\n             scales = \"free_x\")\n  \n  \nenhancement2\n\n\n\nIn this alternative plot, each period is allocated on their ‘own’ X-axis and distributed vertically. This allows for the visual comparison of the distribution to be faster for our readers.\n\n\n\n",
    "preview": "projects/2023/100481838/100481838_files/figure-html5/first_plot_with_shadow-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100483064/",
    "title": "The Evolution of the US Military Deployment",
    "description": "Visualising data on the evolution of the US military presence around the world\nfrom 1950 to 2020.",
    "author": [
      {
        "name": "Clara Fernanda Martín-Villaescusa",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nReplication process\nGetting and cleaning data\n\nBuilding the graph\nTheme\nGraph\nAnnotations and replicated graph\n\nAlternative visualization\nLimitation of stacked areas\nPreparing data\nCreating the alternative graph\n\n\nIntroduction\nThe original graph\nThe international analysis media El Orden Mundial published this graph in order to visualise “la evolución de la presencia militar de Estados Unidos en el mundo desde 1950”. This graph was made possible thanks to research data from the scientific journal Conflict Management and Peace Science. It highlights the most critical points of the US military deployment:\nBetween 1950 and 1990, the United States never had fewer than 400,000 troops outside its borders, with the Korean and Vietnam Wars marking particularly critical points in this process.\nAfter the fall of the Berlin Wall and the collapse of the USSR, military deployment dropped to 200,000.\nFollowing the 9/11 attacks, Washington attacked Afghanistan (20019 and Iraq (2003), where it is estimated that at least 2.3 million US troops have served in both countries since they were invaded.\nIn addition, the graph shows the continued presence of US troops around the world. The countries where most US troops are concentrated are Japan, where there are still more than 53,000 troops, Germany and South Korea, where there are around 34,000 and 26,400, respectively. Puerto Rico and the United Kingdom are other states where there are more bases and soldiers. These countries are not in close conflict but are fully aligned with US interests at the international level because they are protected by the United States.\nThe aim of this tutorial is to reproduce the graph and propose an alternative visualization using the same dataset.\nLa evolución del despliegue militar de EE.UU. Fuente: El Orden Mundial\n\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(troopdata)\nlibrary(dplyr)\n\nsysfonts::font_add_google(\"Outfit\", family=\"outfit\")\nshowtext::showtext_auto()\n\n\nReplication process\nGetting and cleaning data\nThe database is quite complete, in it we can see both the number of military bases and the number of US soldiers in each country and region from 1950 to 2020. First we have organised the database, putting the same identification code for the Republic of Vietnam and Vietnam, among other details. In addition to translating the name of the regions into Spanish.\n\n\ntroopdata <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(ccode = ifelse(ccode == 260, 255, ccode),\n         ccode = ifelse(countryname == \"Republic of Vietnam\", 816, ccode),\n         iso3c = ifelse(countryname == \"Republic of Vietnam\", \"VNM\", iso3c),\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\",\n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\"))\n\n\nIf you look at the graph, there are countries that are highlighted in other colours than those of their region, because in these countries the presence of US soldiers was much higher than in other countries. For instance, Germany, Vietnam or Japan.\nI will make a database without these countries, so that they are not counted twice afterwards.\n\n\ndelete <- c(\"Germany\", \n              \"West Germany\", \n              \"German Democratic Republic\", \n              \"Vietnam\", \n              \"Japan\", \n              \"South Korea\", \n              \"Iraq\")\n\nno_countries <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\", \n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\")) |> \n  filter(!(countryname %in% delete))\n\n\nSo, now we have two databases: one with regions and highlighted countries, and another without the highlighted countries. With these, we will proceed to form the necessary data frame for replicating the graph.\nRegion data\nI do the region data with troopdata without the highlighted countries.\n\n\nregional.data <- no_countries |> \n  group_by(region, year) |>  \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |>  \n  filter(region != 'Afloat') |> \n  filter(region != 'North America') \n\n\nregional.data <- subset(regional.data, year <= 2020)\n\nregional.data$region <- factor(regional.data$region , \n                               levels= c(\"Europa y Asia Central\", \n                                         \"África Subsahariana\", \n                                         \"Asia Oriental y Oceanía\", \n                                         \"Latinoamérica y Caribe\", \n                                         \"Asia Meridional\", \n                                         \"Oriente Próximo y Magreb\"))\n\n\nCountry data\nHere are only the highlighted countries. Germany is recategorised because there are several germanies in the database.\n\n\ncountry.data <- troopdata |>\n  filter((grepl(\"Vietnam\", countryname)) | \n           grepl('Germany', countryname) | \n           grepl (\"South Korea\", countryname) | \n           grepl (\"Japan\", countryname) | \n           grepl (\"Iraq\", countryname)) |>\n  mutate(countryname = ifelse(countryname == \"Republic of Vietnam\", \"Vietnam\", countryname),\n            countryname = ifelse(countryname == \"West Germany\", \"Germany\", countryname),\n         countryname = ifelse(countryname == \"German Democratic Republic\", \"Germany\", countryname))|>\n  group_by(countryname, year) |>  \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |>\n  mutate(countryname = factor(countryname, \n                              levels = c(\"Iraq\", \"Japan\", \n                                         \"South Korea\", \"Vietnam\",\n                                         \"Germany\", \n                                         setdiff(unique(countryname),\n                                                 c(\"Iraq\", \"Japan\",\n                                                   \"South Korea\",\n                                                   \"Vietnam\",\n                                                   \"Germany\")))))\n\ncountry.data$countryname <- factor(country.data$countryname , \n                                   levels=rev(c(\"Germany\",\n                                                \"Vietnam\",\n                                                \"Japan\",\n                                                \"South Korea\",\n                                                \"Iraq\")))\n\n\nCombination of region and country\nOnce we have both data frames (with and without the highlighted countries), we put them together in order to manipulate the data for the highlighted countries and the regions without the featured countries.\n\n\ncombined_data <- bind_rows(\n  mutate(regional.data, data_type = \"region\"),\n  mutate(country.data, data_type = \"country\"))\n\ncombined_data <- bind_rows(regional.data, country.data)\n\ncombined_data <- combined_data |> \n  pivot_longer(cols = c(region, countryname), names_to = \"tipo\", values_to = \"region_country\")\n\n\nWe order the categories so that the areas are stacked correctly on the graph.\n\n\ncombined_data$region_country <- factor(combined_data$region_country , \n                                       levels = c(\"Latinoamérica y Caribe\", \n                                                  \"África Subsahariana\",\n                                                  \"Iraq\", \n                                                  \"Oriente Próximo y Magreb\", \n                                                  \"Asia Meridional\",\n                                                  \"South Korea\",\n                                                  \"Japan\",\n                                                  \"Vietnam\",\n                                                  \"Asia Oriental y Oceanía\", \n                                                  \"Germany\",\n                                                  \"Europa y Asia Central\"))\n\n\nBuilding the graph\nTheme\nAn important part to replicate this graph, in the THEME, as it is the skeleton of any graph. For this, I created my own theme. Where first we adjust everything related to the texts that appear in the graphic (Title, Subtitle, Caption), then everything related to the axes, and the background of the graphic itself and finally the style of the legend.\n\n\ntheme_ok <- theme(text = element_text(family=\"outfit\", \n                                      size = 25),\n  plot.title = element_text(face = \"bold\", \n                            size = 45),\n  plot.subtitle = element_text(face = \"bold\", \n                               color = \"gray38\",\n                               size = 34),\n  plot.title.position = \"plot\",\n  plot.caption = ggtext::element_markdown(\n    size = rel(1.2),\n    hjust = 0,\n    margin = margin(0, 0, 0, 0),\n    lineheight = 0.2),\n  plot.caption.position = \"plot\",\n  strip.background = element_rect(fill = \"gray80\", \n                                  color = \"black\"),\n  panel.background = element_rect(fill = \"white\"),\n  strip.text = element_text(color = \"black\", \n                            face = \"bold\"),\n  panel.grid.major.y = element_line(color = \"lightgrey\"),\n  panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(),\n  axis.line = element_line(color = \"black\",\n                           size = 1),\n  axis.text.x = element_text(angle = 45, \n                             hjust = 1),\n  legend.position = \"top\",\n  legend.direction = \"horizontal\",\n  legend.title = element_blank(),  \n  legend.text = element_text(size = 22, \n                             hjust = 0, \n                             face = \"plain\", \n                             color = \"gray40\"),\n  legend.background = element_blank(),  \n  legend.box = \"none\",  \n   legend.justification = \"left\", \n  legend.margin = margin(t = 3, r = 0, b = 3, l = -70),\n  legend.key = element_blank(),\n  legend.key.size = unit(0.6, \"cm\"),\n  legend.key.width = unit(0.7, \"cm\"),\n  legend.key.height = unit(0.5, \"cm\"))\n\n\nHere, I create a vector to give the specific colour to each region and country.\n\n\ncolors <- c(\"Europa y Asia Central\" = \"#676B90\", \n            \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n            \"Asia Meridional\" = \"#70B3B5\", \n            \"Oriente Próximo y Magreb\" = \"#8BA629\", \n            \"África Subsahariana\" = \"#9E65A6\", \n            \"Latinoamérica y Caribe\" = \"#F2BE5C\", \n            \"Iraq\" = \"#AACE7B\", \n            \"Japan\" = \"#DEA281\", \n            \"South Korea\" = \"#E5C5B1\", \n            \"Vietnam\" = \"#DF8756\", \n            \"Germany\" = \"#7185B5\")\n\ncolors2 <- c(\"Europa y Asia Central\" = \"#676B90\", \n             \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n             \"Asia Meridional\" = \"#70B3B5\", \n             \"Oriente Próximo y Magreb\" = \"#8BA629\", \n             \"África Subsahariana\" = \"#9E65A6\", \n             \"Latinoamérica y Caribe\" = \"#F2BE5C\", \n             \"Iraq\" = \"#8BA629\", \"Japan\" = \"#DEA281\", \n             \"South Korea\" = \"#DE5A3C\", \n             \"Vietnam\" = \"#DF8756\", \n             \"Germany\" = \"#676B90\")\n\n\nGraph\nRegion graph\nTo understand what I have done above with the database, I have first created a graph with the regions, without the countries highlighted.\n\n\nregional.time <- ggplot(regional.data, \n                        aes(x = year, \n                            y = troopsum, \n                            fill = region)) +\n  geom_area() +\n  scale_x_continuous(\n    limits = c(1950, 2020),\n    breaks = seq(1950, 2020, 10),\n    expand = expansion(add = c(1.5, 0))) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), \n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0)) +\n  scale_fill_manual(values = colors) +\n  theme_ok +\n  labs(x = \"\",\n       y = \"Soldados\",\n       color = \"Region\",\n       linetype = \"Region\",\n       title = \"La evolución del despligue militar de EE.UU.\",\n       subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\") \n\nprint(regional.time)\n\n\n\nCountry graph\nIn the following graph we see the countries highlighted without the regions, clearly these countries are the ones that had/have the largest US military presence.\n\n\ncountry.time <- ggplot(country.data, aes(x = year, \n                                         y = troopsum, \n                                         fill = countryname)) +\n  geom_area() +\n  scale_x_continuous(limits = c(1950, 2020), \n                     breaks = seq(1950, 2020, 10), \n                     expand = expansion(0.02)) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), \n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0))  +\n  scale_fill_manual(values = colors) +\n  theme_ok + \n  labs(x = \"\",\n       y = \"Soldados\",\n       color = \"Region\",\n       linetype = \"Region\",\n       title = \"La evolución del despligue militar de EE.UU.\",\n       subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\")  \n\ncountry.time\n\n\n\nCombined graph\nI then created the chart with the data frame combining the regions and countries highlighted. To replicate the original graph, geom_area is used, where the position of the areas is \"stacked\", that is, the areas of the regions and the highlighted countries are stacked on top of each other, that is why the categories of both variables were previously ordered.\nWith scale_fill_manual I am creating what I want to appear inside the legend (regions only). And with scale_color_manual I am colouring the areas, indicating that I want them to be coloured with the colours of the vector colours2, and the categories of my data frame variable combinated_data.\n\n\ncombined.time <- ggplot() +\n  geom_area(data = combined_data |>  \n              filter(!is.na(region_country)), \n            mapping = aes(x = year, \n                          y = troopsum, \n                          fill = region_country, \n                          color = region_country), \n            position = \"stack\", size = 1.3) +  \n  scale_x_continuous(\n    limits = c(1950, 2020),\n    breaks = seq(1950, 2020, 5),\n    expand = expansion(add = c(0.5, 0)))+\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1),\n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0)) +\n   scale_fill_manual(name = \"Leyenda\", \n                     values = colors, \n                     breaks = c(\"Europa y Asia Central\", \n                                \"África Subsahariana\", \n                                \"Asia Oriental y Oceanía\", \n                                \"Latinoamérica y Caribe\", \n                                \"Asia Meridional\", \n                                \"Oriente Próximo y Magreb\")) +\n  scale_color_manual(values = colors2, \n                     breaks = unique(combined_data$region_country), \n                     guide = FALSE) +\n  theme_ok +\n  labs(\n    x = \"\",\n    y = \"\",\n    color = \"Data Type\",\n    fill = \"Data Type\",\n    title = \"La evolución del despliegue militar de EE.UU.\",\n    subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\",  \n    caption = \"**Gráfico:** \\nÁlvaro Merino (2021) \\n\\n**Fuente:**\n    Michael A. Allen, Michael E. Flynn y Carla Martínez Machain, Us global military deployments, 1950-2020 (2021)\" ) \n\ncombined.time\n\n\n\nAnnotations and replicated graph\nWith annotate, I have added all the labels that appear on the graph, so that the person viewing the graph can better place the data historically in his or her head. For instance, the highest peak of the graph is indicated with an arrow to indicate that it was due to the Vietnam War.\nAlso, another small detail I got with annotate, is the title of the Y-axis, where the original graph indicates that the Y-axis is about the number of soldiers by putting “Soldados” under the last figure that is displayed. I achieved it with coord_cartesian, setting clip=\"off\", to be able to place an annotation outside the graph axes.\n\n\ncombined.timeA <- combined.time + \n  annotate(\"text\",\n  label = \"Alemania\",\n  x = 1980, y = 150000, hjust = 0.3, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") + \n  annotate(\"text\",\n  label = \"Vietnam\",\n  x = 1968, y = 450000, hjust = 0.4, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Irak\",\n  x = 2006, y = 300000, hjust = 0.6, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Japón\",\n  x = 1955, y = 520000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n   annotate(\"text\",\n  label = \"11S\",\n  x = 2001, y = 440000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Colapso de la URSS\",\n  x = 1992, y = 540000, hjust = 0.09, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Caída del Muro \\nde Berlín\",\n  x = 1990, y = 700000, hjust = 0.5, vjust = -0.4, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"segment\", \n           x = 1990, xend = 1990, y = 0, yend = 700000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 1992, xend = 1992, y = 0, yend = 520000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 2001, xend = 2001, y = 0, yend = 420000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 2012, xend = 2014, y = 200000, yend = 330000, \n           color = \"gray30\", linetype = \"solid\") +\n  annotate(\"text\",\n  label = \"Afganistán\", \n  x = 2014, y = 330000, hjust = 0.3, vjust = -0.5, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"segment\", \n           x = 1953, xend = 1957, y = 700000, yend = 840000, \n           color = \"gray30\", linetype = \"solid\") +\n  annotate(\"text\",\n  label = \"Corea \\ndel Sur\",\n  x = 1958, y = 800000, hjust = 0.2, vjust = -0.2, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"curve\", \n           x = 2010, y = 210000 , xend = 2011, yend = 640000, \n           color = \"gray30\", curvature = 0.06, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 2006, y = 350000 , xend = 2007, yend = 640000, \n           color = \"gray30\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra contra \\nel terror\",\n  x = 2009, y = 660000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"curve\", \n           x = 1968, y = 850000 , xend = 1975, yend = 920000, \n           color = \"gray30\", curvature = -0.2, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam\",\n  x = 1975, y = 920000, hjust = -0.05, vjust = 0.3, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"curve\", \n           x = 1953, y = 880000 , xend = 1957, yend = 1100300, \n           color = \"gray30\", curvature = -0.3, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Corea\",\n  x = 1957, y = 1100300, hjust = -0.05, vjust = -0.3, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  coord_cartesian(xlim=c(1950, 2020), clip=\"off\") +\n  annotate(\"text\",\n           label=\"Soldados\", \n           x=1950, y=1150000, hjust = 1.3, size = 7, \n           color = \"gray30\", family=\"outfit\")\n\n\ncombined.timeA\n\n\n\nAlternative visualization\nLimitation of stacked areas\nStacking is a process in which a chart is broken down into multiple categorical variables that constitute the whole set. Each element of the categorical variable is represented by a shaded area, and these areas are stacked on top of each other.\nStacked charts are useful for studying the evolution and relative proportions of each group as a whole. In fact, the top of the areas allows for visualizing the overall behavior, similar to a classic area chart. However, they are not suitable for studying the evolution of each individual group, and this is due to two main reasons. Firstly, all groups, except those with a baseline, are challenging to read in terms of their values at each tile level.\nTherefore, as an alternative means of visualizing this dataset, I have opted to generate a line graph. This approach simplifies the information, facilitating a clearer observation of the individual evolution within each region.\nPreparing data\n\n\ntroopdata1 <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(ccode = ifelse(ccode == 260, 255, ccode),\n         ccode = ifelse(countryname == \"Republic of Vietnam\", 816, ccode),\n         iso3c = ifelse(countryname == \"Republic of Vietnam\", \"VNM\", iso3c),\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\", \n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\"))\n\n\nRegarding the data frame, I have chosen to solely utilize the regional data. Including the highlighted countries as well would have resulted in an excessive amount of information. Additionally, with the aid of subsequent annotations, we can provide the viewer with specific details about the country and historical period being represented.\n\n\nregional.data1 <- troopdata1 |> \n  group_by(region, year) |> \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |> \n  filter(region != 'Afloat') |>\n  filter(region != 'North America')\nregional.data1$region <- factor(regional.data1$region , \n                                levels= c(\"Asia Oriental y Oceanía\", \n                                          \"Europa y Asia Central\", \n                                          \"Oriente Próximo y Magreb\", \n                                          \"Asia Meridional\", \n                                          \"Latinoamérica y Caribe\", \n                                          \"África Subsahariana\"))\n\n\nAdapting the theme\nThe changes made to the theme are minor, such as altering the font style. The most significant modification has been the repositioning of the legend. When designing a line graph, it is most appropriate to place the legend on the left margin. This ensures that the viewer, after reading the line (from right to left), encounters the corresponding color for that line.\n\n\nsysfonts::font_add_google(\"Merriweather\", family=\"Merriweather\")\nshowtext::showtext_auto()\n\ntheme_ok1 <- theme(text = element_text(family=\"Merriweather\", \n                                       size = 22),\n  plot.title = element_text(face = \"bold\", \n                            size = 40),\n  plot.subtitle = element_text(face = \"bold\", \n                               color = \"gray30\" ,\n                               size = 28),\n  plot.title.position = \"plot\",\n  plot.caption = ggtext::element_markdown(size = rel(1), \n                                          lineheight = 0.9, \n                                          hjust = 0, \n                                          margin = margin(0, 0, 0, 0)),\n  plot.caption.position = \"plot\",\n  plot.margin = margin(t = 30, r = -150, b = 0, l = 2), \n  strip.background = element_rect(fill = \"gray80\", \n                                  color = \"black\"),\n  panel.background = element_rect(fill = \"white\"),\n  strip.text = element_text(color = \"black\", \n                            face = \"bold\"),\n  panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(),\n  axis.line = element_line(color = \"black\",size = 0.9),\n  axis.title.y = element_text(size = 14, \n                              color = \"gray30\", \n                              angle = 90, \n                              hjust = 0.5),\n  axis.text.x = element_text(angle = 45, hjust = 1),\n  legend.position = \"right\",\n  legend.direction = \"vertical\",\n  legend.title = element_blank(),  \n  legend.text = element_text(size = 20, \n                             color = \"gray20\", \n                             hjust = 0),\n  legend.background = element_blank(),  \n  legend.box = \"none\",  \n  legend.justification = c(-0.2, 0),  \n  legend.margin = margin(t = 0, r = 150, b = 5, l = -5),\n  legend.spacing.y = unit(0.5, \"cm\"),\n  legend.key = element_blank(),\n  legend.key.size = unit(0.6, \"cm\"), \n  legend.key.height = unit(0.7, \"cm\"))\n\n\nCreating the alternative graph\nAs mentioned earlier, the design of the graph will feature solid lines to facilitate the visualization of each region’s evolution. Simple and clean.\n\n\nregional.time1 <- ggplot() +\n  geom_line(data = regional.data1, \n            mapping = aes(x = year, \n                          y = troopsum, \n                          color = region, \n                          linetype = region), \n            linetype = \"solid\", \n            size = 0.8) +  \n  scale_x_continuous(limits = c(1950, 2020), \n                     breaks = seq(1950, 2020, 5), \n                     expand = expansion(add = c(1.5, 0))) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), breaks = seq(0, \n                                                                                1000000, \n                                                                                100000)) +\n  scale_color_manual(name = NULL, \n                     values = c(\"Europa y Asia Central\" = \"#676B90\", \n                                \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n                                \"Asia Meridional\" = \"#70B3B5\", \n                                \"Oriente Próximo y Magreb\" = \"#8BA629\", \n                                \"África Subsahariana\" = \"#9E65A6\", \n                                \"Latinoamérica y Caribe\" = \"#F2BE5C\")) +\n  theme_ok1  +\n  labs(\n    x = \"\",\n    y = \"Soldados\",\n    title = \"La evolución del despliegue militar de EE.UU.\",\n    subtitle = \"Presencia de tropas por regiones (1950-2020)\", \n    caption = \n      paste(\"Fuente: Michael A. Allen, Michael E. Flynn y Carla Martínez Machain, Us global military deployments, 1950-2020 (2021)\"))\n\n\nregional.time1\n\n\n\nAnnotations and alternative graph\nAnd finally, the annotations on the graph will assist us in overcoming the challenge of distinguishing the highlighted countries. Furthermore, these annotations provide a deeper understanding of the evolution of each country, especially with this line graph. We can observe, as mentioned at the beginning of this article, how the presence of U.S. military is sustained despite the conclusion of the conflict for which the U.S. troops were initially deployed.\n\n\nregional.time1 <- regional.time1 + annotate(\"text\",\n  label = \"11S\",\n  x = 2001, y = 250000, hjust = 0.5, vjust = 0.6, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"text\",\n  label = \"Colapso de la URSS\",\n  x = 1992, y = 360000, hjust = 0.05, vjust = -1, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"text\",\n  label = \"Caída del Muro de Berlín\",\n  x = 1990, y = 470000, hjust = 0.5, vjust = 0, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"segment\", \n           x = 1990, xend = 1990, y = 0, yend = 450000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"segment\", \n           x = 1992, xend = 1992, y = 0, yend = 365000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"segment\", \n           x = 2001, xend = 2001, y = 0, yend = 220000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"text\",\n  label = \"Guerra contra \\nel terror\",\n  x = 2013, y = 230000, hjust = 0.7, vjust = -0.7, size = 8, \n  color = \"gray30\", lineheight = 0.4, family=\"Merriweather\") +\n  annotate(\"curve\", \n           x = 2012, y = 50000 , xend = 2013, yend = 230000, \n           color = \"#70B3B5\", curvature = 0.06, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 2007, y = 150000 , xend = 2010, yend = 240000, \n           color = \"#8BA629\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 1968, y = 650000 , xend = 1971, yend = 710000, \n           color = \"#DE5A3C\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam\",\n  x = 1972, y = 720000, hjust = 0, vjust = 0, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n   annotate(\"curve\", \n            x = 1951, y = 500000 , xend = 1953, yend = 600000, \n            color = \"#DE5A3C\", curvature = -0.1, \n            arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam \\ny \\nOcupación de Japón\",\n  x = 1956, y = 680099, hjust = 0.5, vjust = 0.5, size = 6, \n  color = \"gray30\", lineheight = 0.4,family=\"Merriweather\") \n\nregional.time1\n\n\n\n\n\n\n",
    "preview": "projects/2023/100483064/100483064_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2112,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100508665/",
    "title": "Sex Gap in Life Expectancy in Spain",
    "description": "How many more years do Spanish women live compared to men? This project\nreplicates and enhaces a World in Data graph showing the evolution of the sex\ngap in life expectancy from 1908 to 2018 in Spain.",
    "author": [
      {
        "name": "Alicia Talavera-Marcos",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGetting the data ready\nWorking on the legend positioning of the plot\n\nCreating the plot\nInitial form and axis\nTheme, title and labels\nBackground lines\nStacked areas\nLegend\nFinal replicated plot\n\nPlot enhacement\nOriginal graph pros & cons\nFirst enhacement graph\nSecond enhacement graph\nFinal enhacement\n\n\nIt is known that women usually have a higher life expectancy and live longer than men. However, this life expectancy gap isn’t homogeneous and it varies significantly through different age groups. The original graph I replicated and enhances for this project shows how each age group contributes to the overall sex gap in life expectancy in Spain, from years 1908 to 2018.\nSource: https://ourworldindata.org/why-do-women-live-longer-than-menThese are the packages I used for this project.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\nGetting the data ready\nFirst, I had to import the data. It was available for download on the source website and it was very easy to find. The data were complete and it was the same used for the original graph.\n\n\nlifex <- read.csv(\"lifeexpectancy.csv\")\n\n\nThen I had to tidy up the data in order to be able to use it. I had to rename the age group columns to make it shorter and more manageable, as well as pivoting them. The database included date for many countries, so I had to filter it to work only with the data from Spain.\n\n\n#Rename columns\n\nlifex_r <-\n  lifex |> \n  rename(\n    \"Age 0 (infancy)\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..0,\n    \n    \"Ages 1-14\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..1.14,\n    \n    \"Ages 15-39\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..15.39, \n    \n    \"Ages 40-59\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..40.59,\n    \n    \"Ages 60-79\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..60.79,\n    \n    \"Ages 80+\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..80.) \n\n#Tidy the data\n\ntidy_lifex_r <- \n  lifex_r |>\n  pivot_longer(cols = \"Ages 80+\":last_col(),\n               names_to = \"Age_group\",\n               values_to = \"Contribution_to_gap\")\n\n#Spain data\n\nspain <- \n  tidy_lifex_r |> \n  filter(Entity == \"Spain\" & Contribution_to_gap >= 0) |> \n  mutate(Age_group = fct_rev(Age_group)) #Change order of groups to replicate the original\n\n\nWorking on the legend positioning of the plot\nBefore getting to work with the visualization, I created some variables regarding the positioning of the legend labels. I wanted to calculate the middle point of the areas to make each label appear just in the middle, even if then I had to make some adjustments.\n\n\nylegend_80 <- \n  spain |> \n  filter(Age_group == \"Ages 80+\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_60 <- \n  spain |> \n  filter(Age_group == \"Ages 60-79\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_40 <- \n  spain |> \n  filter(Age_group == \"Ages 40-59\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_15 <- \n  spain |> \n  filter(Age_group == \"Ages 15-39\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_1 <- \n  spain |> \n  filter(Age_group == \"Ages 1-14\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_0 <- \n  spain |> \n  filter(Age_group == \"Age 0 (infancy)\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_0_final <- ylegend_0/2\nylegend_1_final <- ylegend_1/2 + ylegend_0\nylegend_15_final <- ylegend_15/2 + ylegend_0 + ylegend_1\nylegend_40_final <- ylegend_40/2 + ylegend_0 + ylegend_1 + ylegend_15\nylegend_60_final <- ylegend_60/2 + ylegend_0 + ylegend_1 + ylegend_15 + ylegend_40\nylegend_80_final <- ylegend_80/2 + ylegend_0 + ylegend_1 + ylegend_15 + ylegend_40 + ylegend_60\n\n\nCreating the plot\nInitial form and axis\nTo begin, we define the x and y axis data by using the Year and Contribution to gap columns. As for the scales, we establish the limits for both axes and set the breaks accordingly. On the y-axis, we introduce breaks every two years of contribution to the gender gap in life expectancy. On the x-axis, we set a maximum limit extending beyond 2018, the last year of available data, reaching up to 2045. This provides additional space on the right side for including the legend. Lastly, using the coord_cartesian(expand = FALSE) function and its corresponding argument we manage to start the plot directly at the axis, eliminating a small margin.\n\n\n#Basic form\n\np <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 9.5), breaks=c(0, 2, 4, 6, 8)) +\n  scale_x_continuous(limits=c(1908, 2045), breaks=c(1908, 1920, 1940, 1960, 1980, 2000, 2018), \n                     labels=c(1908, 1920, 1940, 1960, 1980, 2000, 2018)) +\n  coord_cartesian(expand = FALSE)\n\np\n\n\n\nTheme, title and labels\nThe theme needs to resemble closer the original graph, so we use theme_classic and adjust the font size. Now it’s the time to edit the color of the axis lines as well as the ticks, their length and the family font of the text and its color.\nWe also create the text for the title and subtitle, adjust its font, color and position.\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair_display\")\n\n p <- p +\n\n#Colors of axis, axis text, title\n  theme_classic(base_size=14) +\n  theme(\n    legend.position=\"none\", #remove legend\n    axis.line = element_blank(), #axis lines, colors\n      axis.ticks.x = element_line(color = \"darkgray\"), \n      axis.ticks.length = unit(0.15, \"cm\"),\n      axis.ticks.y = element_blank(),\n      axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\")) + \n    labs(x = \"\", y= \"\", \n        \n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n         \n         subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n  \n    theme(\n        axis.title.y = element_text(size = 11, family = \"playfair_display\", color = \"#5B5B5B\", margin = margin(r=10)),\n\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      \n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\"),\n      \n      plot.title.position = \"plot\",\n      \n      plot.margin = margin(10, 0, 0, 10))\n\np\n\n\n\nBackground lines\nNow to finish setting up the plot by adding the background lines present on the original graph that help read the y values of the data. We use geom_segment and use the same values as the ones for the breaks in the y-axis. We adjust the type and color of the lines.\n\n\np <- p +\n  \n#Background lines\n    geom_segment(data = data.frame(y = c(0, 2, 4, 6, 8), yend = c(0, 2, 4, 6, 8), x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") \n\np\n\n\n\nStacked areas\nFinally we can represent our data using geom_area to create stacked areas of each age group’s contribution to the sex gap. We specify that we want the areas color to be defined by the different age group categories. We manually define the colors for each area and stablish details like a bit of transparency with alpha and the width of the exterior line of the areas.\n\n\np <- p +\n\n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#82A954\", \n                               \"Ages 15-39\" = \"#49A892\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\"))\np\n\n\n\nEven though whis is looking quite good, the exterior lines don’t match exactly the color they should have. To fix that we create a new scale_color_manual function in which we define a very similar although different color for the exterior lines of the areas.\n\n\n p <- p +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                              \"Ages 40-59\" = \"#8AAD61\", \n                               \"Ages 15-39\" = \"#62A685\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\"))\np\n\n\n\nLegend\nNow we will create the text for the legend. Instead of using any legend function in ggplot2, we create it manually using annotate since it should have a very specific position and characteristics. We add text for each age group and use our previously created legend position variables to place it. We have to adjust the placement manually to make it perfect, as well as editing the font and color for each label.\n\n\np <- p +\n\n#Legend \n   annotate(\"text\", x = 2026, y = (ylegend_80_final-0.15), hjust = 0, vjust = 0,\n            label = \"Ages 80+\", family = \"playfair_display\", size = 3, color = \"#B26257\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_60_final-0.15), hjust = 0, vjust = 0,\n           label = \"Ages 60-79\", family = \"playfair_display\", size = 3, color = \"#BE9053\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_40_final+0.9), hjust = 0, vjust = 0,\n           label = \"Ages 40-59\", family = \"playfair_display\", size = 3, color = \"#8AAD61\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_15_final+1), hjust = 0, vjust = 0,\n           label = \"Ages 15_39\", family = \"playfair_display\", size = 3, color = \"#62A685\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_1_final+0.6), hjust = 0, vjust = 0,\n           label = \"Ages 1-14\", family = \"playfair_display\", size = 3, color = \"#657EAD\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_0_final+0.1), hjust = 0, vjust = 0,\n           label = \"Age 0 (infancy)\", family = \"playfair_display\", size = 3, color = \"#5F5D75\") \n\np\n\n\n\nLastly, we have to replicate the lines connecting the legend labels with the areas. To achieve this we use geom_segment, the previously crafted position variables, and adjust their length and color. For the last age group labels we have to create three different lines that connect to each other given the reduced space left due to their small area size that don’t allow use to use just a straight line.\n\n\np <- p +\n  \n#Lines of the legend\n  #Red line\n  geom_segment(data = data.frame(y = ylegend_80_final, yend = ylegend_80_final, x = 2019, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Orange line\n  geom_segment(data = data.frame(y = ylegend_60_final, yend = ylegend_60_final, x = 2019, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\n  #Green line\n    geom_segment(data = data.frame(y = ylegend_40_final, yend = ylegend_40_final, x = 2019, xend = 2021),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_40_final+1, yend = ylegend_40_final+1, x = 2021, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_40_final, yend = ylegend_40_final+1, x = 2021, xend = 2021),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\n  #Teal line\n    geom_segment(data = data.frame(y = ylegend_15_final, yend = ylegend_15_final, x = 2019, xend = 2022),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_15_final+1.1, yend = ylegend_15_final+1.1, x = 2022, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_15_final, yend = ylegend_15_final+1.1, x = 2022, xend = 2022),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Blue line\n      geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final, x = 2019, xend = 2023),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_1_final+0.7, yend = ylegend_1_final+0.7, x = 2023, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final+0.7, x = 2023, xend = 2023),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Violet line\n      geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final, x = 2019, xend = 2024),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_1_final+0.2, yend = ylegend_1_final+0.2, x = 2024, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final+0.2, x = 2024, xend = 2024),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\")\n\n\nFinal replicated plot\n\n\np\n\n\n\nPlot enhacement\nOriginal graph pros & cons\nThe original graph is quite good, being simple enough to communicate data withouth being too confusing. It’s visually well depurated, with harmonized colors, fonts and object and place placement. However, even if it’s easy to see the big picture, the main issue is that the age groups information gets lost and it’s harder to understand.\nFirst enhacement graph\nFor this first enhacement I decided to change a few things:\nAdding a yellow color in the areas to avoid having three different blue hues\nAdding a title to the y-axis to make it more understandable\nChanging the legend to make it more visible\nAdding important historical event marks to add context to the data\n\n\n#Improvements\np <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 11), breaks=c(0, 2, 4, 6, 8)) +\n  scale_x_continuous(limits=c(1908, 2018), breaks=c(1908, 1920, 1940, 1960, 1980, 2000, 2018), \n                     labels=c(1908, 1920, 1940, 1960, 1980, 2000, 2018)) +\n  coord_cartesian(expand = FALSE) +\n  \n#Colors of axis, axis text, title\n  #ENHACEMENT - NEW LEGEND\n  theme_classic(base_size=14) +\n  theme(\n    legend.position=\"right\", \n    legend.title = element_blank(),\n    legend.text = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\"),\n    legend.key.size = unit(0.4, \"cm\"), \n    legend.key.width = unit(0.5, 'cm'),\n    axis.line = element_blank(), #axis lines, colors\n      axis.ticks.x = element_line(color = \"darkgray\"), \n      axis.ticks.length = unit(0.15, \"cm\"),\n      axis.ticks.y = element_blank(),\n      axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.title.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\", size = 12, margin = margin(r = 10))) +\n    labs(x = \"\", y= \"Sex gap years\", #ENHACEMENT - Y-AXIS TITLE\n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n         \n         subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n    theme(\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\", hjust= 0),\n      plot.title.position = \"plot\") +\n  \n#Background lines\n    geom_segment(data = data.frame(y = c(0, 2, 4, 6, 8), yend = c(0, 2, 4, 6, 8), x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") +\n  \n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", #ENHACEMENT - YELLOW COLOR\n                               \"Ages 15-39\" = \"#82A954\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\")) +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#8AAD61\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\")) +\n\n#ENHACEMENT - EVENT MARKS\n    geom_segment(aes(x = 1936, xend=1936, y=0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1936, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"CIVIL WAR\") +\n  annotate(\"text\", x=1936, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\") +\n       geom_segment(aes(x = 1918, xend = 1918, y = 0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1918, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"SPANISH FLU\") +\n    annotate(\"text\", x=1918, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\") +\n       geom_segment(aes(x = 1981, xend = 1981, y = 0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1981, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"AIDS CRISIS\") +\n    annotate(\"text\", x=1981, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\")\n\np\n\n\n\nThis graph now looks better and is easier to read. However, it doesn’t solve the main issue we stated earlier, since it’s still hard to read the contribution per each age group.\nSecond enhacement graph\nLooking to solve this issue, I decided to make facets emphasizing the information of the age groups. I decided to fix the scale to see each facet proportionally to the total. I kept the event marks to keep this historical context.\n\n\nfacets <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n    facet_wrap(Age_group ~ .) + #ENHACEMENT - FACETS\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 4.5), breaks=(4)) +\n  scale_x_continuous(limits=c(1908, 2018), breaks=c(1908, 1930, 1960, 1990, 2018), \n                     labels=c(1908, 1930, 1960, 1990, 2018)) +\n  coord_cartesian(expand = FALSE) +\n\n#Colors of axis, axis text, title\n  theme_classic(base_size=11) +\n  theme(\n    strip.text = element_text(size = 10, family = \"playfair_display\", color=\"#5B5B5B\", face= \"bold\"),\n    strip.background = element_blank(),\n    legend.position = \"null\", \n    axis.line = element_line(color = \"gray\"),\n    axis.ticks.x = element_line(color = \"darkgray\"), \n    axis.ticks.length = unit(0.15, \"cm\"),\n    axis.ticks.y = element_blank(),\n    axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n    axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n    panel.spacing.x = unit(2, \"lines\")) + \n    labs(x = \"\", y= \"\", \n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n          subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n    theme(\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\", hjust= 0),\n      plot.title.position = \"plot\",\n      plot.margin = margin(0.5, 1, 0, 0.5, \"cm\")) +\n\n#Background lines\n    geom_segment(data = data.frame(y = 4, yend = 4, x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") +\n\n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#82A954\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\")) +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#8AAD61\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\")) +\n  \n      geom_segment(aes(x = 1936, xend=1936, y=0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") +\n       geom_segment(aes(x = 1918, xend = 1918, y = 0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") +\n       geom_segment(aes(x = 1981, xend = 1981, y = 0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") \n\nfacets\n\n\n\nThis make the information of the age groups very easy to read and understand its different tendencies. However, this plot now loses the information of the big picture.\nFinal enhacement\nTo solve this, I decided to combine both plots using the R package patchwork. I merged both of them together and made a few adjustment until I got the final enhaced graph. This solves the issue of not being able to clearly distinguish trends within each age group, in addition to providing a clearer picture with the combined chart, observing the overall evolution of the life expectancy sex gap. Furthermore, the issue of the legend is resolved by having facets that allow us to understand the meaning of each color in the areas.\n\n\n\n\n\np2/facets2\n\n\n\nThanks for reading!\n\n\n\n",
    "preview": "projects/2023/100508665/100508665_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100407986/",
    "title": "Change in Abortion after Dobbs",
    "description": "Visualization of the change in abortion data after the Dobbs decision, which \ngave power of legislation over abortion to the different states of the U.S.",
    "author": [
      {
        "name": "Clara Espinosa-Acevedo",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nContext\nPreparing the data\nReplication\nColors and legend\nText\nAnnotations\n\nEnhancement\nBase\nSquares\nText\nAnnotations\nLegends\n\n\nContext\nThe right to have an abortion was protected in the U.S. after the Roe v. Wade(1973)\ndecision, taken by the U.S. Supreme Court. This decision ruled that the Constitution\nprotected the right to have an abortion. In 2022, the Supreme Court took another\ndecision (Dobbs v. Jackson Women’s Health Organization, popularly known as Dobbs),\nwhich overruled Roe v. Wade.\nThis decision gave the power to the states to decide individually about the regulation\nof the right to have an abortion. This caused a drop in abortion in Republican states\nin which abortion became fully, or almost fully illegal.\nThis project replicates a graph from FiveThirtyEight which shows the changes in\nabortion data after Dobbs:\nOriginal graph form FiveThirtyEightAfter this replication, we try to add information about the public opinion\non Roe v. Wade for the different states. This way we can see if the decisions of\nthe different governments pair with the opinion of the population.\nPreparing the data\nFirst, we prepare a data frame in which we mark the position of each state,\nthe name abreviation and the corresponding value of change in abortions.\n\n\ndf <- data.frame(\n  x = c(1, 8, 6, 3, 2, 4, 11, 11, 11, 10, 9, 1, 6, 3, 6, 7, 5, 7, 5, 11, 10, \n        12, 8, 6, 6, 7, 4, 10, 5, 5, 12, 10, 4, 3, 10, 8, 4, 2, 9, 12, 9, \n        5, 8, 5, 3, 9, 11, 2, 7, 8, 4),\n  y = c(8, 2, 2, 3, 4, 4, 5, 3, 4, 1, 2, 2, 5, 6, 4, 4, 3, 3, 2, 6, 4, 8, \n        6, 6, 3, 2, 6, 3, 6, 4, 7, 5, 3, 4, 6, 5, 2, 5, 5, 6, 3, 5, 3, 1, 5, \n        4, 7, 6, 5, 4, 5),\n  state = c(\"AK\", \"AL\", \"AR\", \"AZ\", \"CA\", \"CO\", \"CT\", \"DC\", \"DE\", \"FL\", \"GA\", \n            \"HI\", \"IA\", \"ID\", \"IL\", \"IN\", \"KS\", \"KY\", \"LA\", \"MA\", \"MD\", \"ME\", \n            \"MI\", \"MN\", \"MO\", \"MS\", \"MT\", \"NC\", \"ND\", \"NE\", \"NH\", \"NJ\", \"NM\", \n            \"NV\", \"NY\", \"OH\", \"OK\", \"OR\", \"PA\", \"RI\", \"SC\", \"SD\", \"TN\", \"TX\", \n            \"UT\", \"VA\", \"VT\", \"WA\", \"WI\", \"WV\", \"WY\"),\n  state.color = c(\"black\", \"#BE8DB7\", \"#BE8DB7\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"black\", \"black\", \"#BE8DB7\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"white\",\n                  \"#BE8DB7\", \"black\", \"black\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"white\", \"#BE8DB7\", \"black\", \"black\", \"black\",\n                  \"black\", \"#BE8DB7\", \"white\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\",\"#BE8DB7\", \"black\", \"black\"),\n  value = c(2, -100, -100, -53, 1, 33, -1, 0, 24, 10, -57, 4, -27, -48, 28,\n           15, 36, -100, -100, -3, 1, 18, 8, 14, -83, -100, 30, 37, -100, 30,\n           -6, 7, 12, 21, 12, -65, -100, 18, 6, -7, -56, -100, -78, -100, -3,\n           -4, 16, 5, -100, -8, -5))\n\n\nReplication\nColors and legend\nFirst, we create a base for the graph, using geom_tile to draw the states. We also\ntry the PRGn palette, since it looked similar to the color palette used by\nFiveThirtyEight.\n\n\nlibrary(ggplot2)\nggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"white\", linewidth=2) +\n  geom_text(aes(label=state, color=state.color), size=6) +\n  coord_fixed() +\n  scale_fill_distiller(type=\"div\", palette=\"PRGn\") +\n  scale_color_identity() +\n  theme_void()\n\n\n\nWe realised that the color pallete didn’t followed a normal “distribution”. In\norder to perfectly match the colors, we took certain values, and assign them to\nthe colors showed in the original graph for those states.\n\n\nq <- ggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"white\", linewidth=2) +\n  geom_text(aes(label=state, color=state.color), size=5) +\n  coord_fixed() +\n  scale_fill_gradientn(colors = c(\"#4A0B35\",\"#7D3F62\", \"#92597A\",\n                                  \"#AB7D99\", \"#CBA8C2\", \"#E8D0E9\",\n                                  \"#F0F0F0\", \"#DBF2D5\", \"#C1DCB8\", \n                                  \"#B4D2AB\", \"#A9C89E\", \"#9CBD8F\",\n                                  \"#7EA370\", \"#2B5F1D\"),\n                       breaks = c(-100, -78, -65, -48, -27, -8, 0, 5, 18, \n                                  24, 30, 37, 50, 100),\n                       limits = c(-100, 100)) +\n  scale_color_identity() + \n  theme_void()\nq\n\n\n\nWe change the position and direction of the legend, which consits on a color bar.\n\n\nq <- q + guides(fill = guide_colorbar(title = \"PERCENT CHANGE\",\n                                 title.position = \"top\",\n                                 title.theme = element_text(size = 10,\n                                                            family = \"Helvetica\"),\n                                 #title.hjust = 0.5,\n                                 #title.vjust = 0.5,\n                                 label = FALSE,\n                                 barheight = 0.7,\n                                 barwidth = 9,\n                                 #nbin = 100,\n                                 ticks = FALSE,\n                                 direction = \"horizontal\")) +\n  theme(legend.position = c(0.13, 1))\nq\n\n\n\nText\nWe add the title, subtitle and caption of the graph.\n\n\nq <- q + labs(\n  title = \"Several states saw a complete drop in abortions after Dobbs\",\n  subtitle = \"Percentage change in number of abortions from April to August 2022, by state\",\n  caption = paste0(\"Percent change in abortions is calculated from #WeCount's unrounded data.\", \n                  \"\\nLess-populated states might see larger\",\n                  \"percentage shifts because the raw number of abortions in\", \n                  \"those states tend to be smaller.\")\n) +\n  theme(plot.title = element_text(size = 18, color = \"#222222\", face = \"bold\", \n                                  family = \"Helvetica\", hjust = 0.1, vjust = 3)) +\n  theme(plot.subtitle = element_text(size = 14, color = \"#222222\", face = NULL, \n                                     family = \"Helvetica\", hjust = 0.1, vjust = 3)) +\n  theme(plot.caption = element_text(size = 10, color = \"#999999\", face = NULL, \n                                    family = \"Helvetica\", hjust = 0, vjust = 0.1)) +\n  ylim(0, 9) +\n  theme(legend.position = c(0.13, 0.97))\n\nq\n\n\n\nAnnotations\nWe begin with the square annotations, which surround some states.\n\n\n# Base\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 8.65, ymax = 9.65, \n                  alpha = 0, color = \"#D8726F\") + ylim(0, 10)\n\n# SD\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# WI\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# OH\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# KY\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# MO\nq <- q + annotate(\"rect\", xmin = 5.5, xmax = 6.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# TN\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# SC\nq <- q + annotate(\"rect\", xmin = 8.5, xmax = 9.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AZ\nq <- q + annotate(\"rect\", xmin = 2.5, xmax = 3.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# OK\nq <- q + annotate(\"rect\", xmin = 3.5, xmax = 4.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# LA\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AR\nq <- q + annotate(\"rect\", xmin = 5.5, xmax = 6.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# MS\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AL\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# GA\nq <- q + annotate(\"rect\", xmin = 8.5, xmax = 9.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# TX\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 0.5, ymax = 1.5, \n                  alpha = 0, color = \"#D8726F\")\n\nq\n\n\n\nNext, line annotations which point out information about some states.\n\n\n## Lines ##\n# CA\nq <- q + annotate(\"segment\", x = 2, xend = 2, y = 3.5, yend = 1, color = \"black\")\n\n# AZ\nq <- q + annotate(\"segment\", x = 3, xend = 3, y = 2.5, yend = 2, color = \"black\")\n\n# CA&AZ\nq <- q + annotate(\"segment\", x = 2, xend = 3, y = 2, yend = 2, color = \"black\")\n\n# ND\nq <- q + annotate(\"segment\", x = 5.3, xend = 5.3, y = 6.5, yend = 7.1, color = \"black\")\n\n# AR\n# AR1\nq <- q + annotate(\"segment\", x = 6, xend = 6, y = 1.5, yend = -0.2, color = \"black\") + ylim(-0.5, 10)\n# AR2\nq <- q + annotate(\"segment\", x = 6, xend = 6.3, y = -0.2, yend = -0.2, color = \"black\")\n\nq\n\n\n\nLastly, we will do text annotations, which are “on the other side” of the line\nannotations. We also add the values for the legend.\n\n\n# Base square\nlibrary(ggtext)\n\nq <- q + annotate(geom = \"richtext\", x = 7.5, y = 9.15, \n                  label = \"Outlines indicate that abortion was **fully**\n                  <br>**illegal** or **illegal after about six weeks** for\n                  <br>at least half of the two months after Dobbs\", \n                  size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n                  family = \"Helvetica\")\n\n# ND\n\nq <- q + annotate(geom = \"richtext\", x = 2.6, y = 7.7,\n             label = \"The only abortion clinic in \n             <span style = 'color:#480A34'>**North Dakota**<\/span>\n             <br> moved to <span style = 'color:#567F4D'>**Minnesota**<\/span>, \n             where the number<br>of abortions rose by \n             <span style = 'color:#567F4D'>**14%**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\")\n\n# CA & AZ\n\nq <- q + annotate(geom = \"richtext\", x = 0.5, y = 0.25,\n             label = \"Abortions in <span style = 'color:#567F4D'>**California**<\/span>\n             <br>rose by only <span style = 'color:#567F4D'>**1%**<\/span>, although\n             <br>they declined by <span style = 'color:#99607E'>**53%**<\/span> in\n             <br>neighboring <span style = 'color:#99607E'>**Arizona**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\")\n\n# AR\n\nq <- q + annotate(geom = \"richtext\", x = 6.4, y = -0.4,\n             label = \"Many Southern states saw a<\n             br><span style = 'color:#480A34'>**100% decline**<\/span> in the number\n             <br>of abortions as a result of<br>post-Dobbs legislation\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\") +\n  xlim(-0.5, 13.5) + ylim(-0.7, 9.7)\n\n# Legend\nq <- q + annotate(geom = \"richtext\", x = -0.25, y = 9.6,\n             label = \"-100%\",\n             size = 3, fill = NA, label.color = NA, hjust = 0) \n\nq <- q + annotate(geom = \"richtext\", x = 0.35, y = 9.6,\n             label = \"No change\",\n             size = 3, fill = NA, label.color = NA, hjust = 0)\n\nq <- q + annotate(geom = \"richtext\", x = 1.3, y = 9.6,\n             label = \"+100%\",\n             size = 3, fill = NA, label.color = NA, hjust = 0) \n\nq\n\n\n\nEnhancement\nWe create a new dataframe, which contains new positions for the states. We do this\nto separate them, so they don’t share the lines outside the states. This way we will\nbe able to add the information.\n\n\ndf <- data.frame(\n  x = c(1, 10.1, 7.5, 3.6, 2.3, 4.9, 14, 14, 14, 12.7, 11.4, \n        1, 7.5, 3.6, 7.5, 8.8, 6.2, 8.8, 6.2, 14, 12.7, 15.3, \n        10.1, 7.5, 7.5, 8.8, 4.9, 12.7, 6.2, 6.2, 15.3, 12.7, 4.9, \n        3.6, 12.7, 10.1, 4.9, 2.3, 11.4, 15.3, 11.4, 6.2, 10.1, 6.2, \n        3.6, 11.4, 14, 2.3, 8.8, 10.1, 4.9),\n  y = c(10.1, 2.3, 2.3, 3.6, 4.9, 4.9, 6.2, 3.6, 4.9, 1, 2.3, \n        2.3, 6.2, 7.5, 4.9, 4.9, 3.6, 3.6, 2.3, 7.5, 4.9, 10.1, \n        7.5, 7.5, 3.6, 2.3, 7.5, 3.6, 7.5, 4.9, 8.8, 6.2, 3.6, \n        4.9, 7.5, 6.2, 2.3, 6.2, 6.2, 7.5, 3.6, 6.2, 3.6, 1, \n        6.2, 4.9, 8.8, 7.5, 6.2, 4.9, 6.2),\n  state = c(\"AK\", \"AL\", \"AR\", \"AZ\", \"CA\", \"CO\", \"CT\", \"DC\", \"DE\", \"FL\", \"GA\", \n            \"HI\", \"IA\", \"ID\", \"IL\", \"IN\", \"KS\", \"KY\", \"LA\", \"MA\", \"MD\", \"ME\", \n            \"MI\", \"MN\", \"MO\", \"MS\", \"MT\", \"NC\", \"ND\", \"NE\", \"NH\", \"NJ\", \"NM\", \n            \"NV\", \"NY\", \"OH\", \"OK\", \"OR\", \"PA\", \"RI\", \"SC\", \"SD\", \"TN\", \"TX\", \n            \"UT\", \"VA\", \"VT\", \"WA\", \"WI\", \"WV\", \"WY\"),\n  state.color = c(\"black\", \"white\", \"white\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"black\", \"black\", \"white\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"white\",\n                  \"white\", \"black\", \"black\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"white\", \"white\", \"black\", \"black\", \"black\",\n                  \"black\", \"white\", \"white\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\",\"white\", \"black\", \"black\"),\n  value = c(2, -100, -100, -53, 1, 33, -1, 0, 24, 10, -57, 4, -27, -48, 28,\n           15, 36, -100, -100, -3, 1, 18, 8, 14, -83, -100, 30, 37, -100, 30,\n           -6, 7, 12, 21, 12, -65, -100, 18, 6, -7, -56, -100, -78, -100, -3,\n           -4, 16, 5, -100, -8, -5))\n\n\nBase\nWe create a new base, with a black background. We do this because if we do an\n“honest” color gradient, a lot of the states will be close to white. We also add a\nnew color pallete.\n\n\nlibrary(ggdark)\nq <- ggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"black\", linewidth=6) +\n  geom_text(aes(label=state, color=state.color), size=6) +\n  coord_fixed() +\n  scale_fill_gradientn(colors = c(\"#9b2226\",\"#F0F0F0\", \"#3a5a40\"),\n                       breaks = c(-100, 0, 100),\n                       limits = c(-100, 100)) +\n  scale_color_identity() +\n  theme_void() +\n  dark_theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.background = element_blank(),\n        panel.grid = element_blank())\n  \n\nq\n\n\n\nSquares\nWe begin with the squares that will sorround each state. This way, we can give to each\nof them an alpha value which represent the support of the population to overturning\nRoe v. Wade.\n\n\n# AK\n\nq <- q + \n  annotate(\"segment\", x = 0.43, xend = 0.43, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 9.53, yend = 9.53, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 1.57, xend = 1.57, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 10.67, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# HI\n\nq <- q + \n  annotate(\"segment\", x = 0.43, xend = 0.43, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 1.57, xend = 1.57, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# WA\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# OR\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# CA\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261)\n\n# ID\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565)\n\n# UT\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# NV\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# AZ\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# MT\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565)\n\n# WY\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870)\n\n# CO\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 4.33, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 4.33, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 5.46, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# NM\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# OK\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783)\n\n# ND\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# SD\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391)\n\n# NE\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783)\n\n# KS\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# LA\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696)\n\n# TX\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 0.43, yend = 0.43, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 1.57, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609)\n\n# MN\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# IA\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 5.63, yend = 6.77,\n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261)\n\n# IL\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# MO\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 8.06, xend = 8.06, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609)\n\n# AR\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 8.06, xend = 8.06, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1)\n\n# WI\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# IN\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696)\n\n# KY\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# MS\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652)\n\n# MI\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# OH\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# WV\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# TN\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652)\n\n# AL\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 1.73, yend = 2.87,\n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# PA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# VA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130)\n\n# SC\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n\n# GA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# NY\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# NJ\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# MD\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# NC\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# FL\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 0.43, yend = 0.43, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 1.57, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391)\n\n# VT\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 8.23, yend = 8.23, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 9.37, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217)\n\n# MA\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# CT\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# DE\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087)\n\n# DC\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# ME\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 9.53, yend = 9.53, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 9.53, yend = 10.67,\n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 10.67, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# NH\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 8.23, yend = 8.23, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 9.37, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# RI\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217)\n\nq\n\n\n\nText\nWe add a new title and complete the caption with information about the new data.\n\n\nq <- q + labs(\n  title = \"Relation between the drop in abortion after Dobbs and the public opinion\",\n  caption = paste0(\"Percent change in abortions is calculated from #WeCount's unrounded data.\",\n                  \"\\nData on opinion about overturning Roe v. Wade extracted from the \",\n                  \"PRRI American Values Atlas.\")\n) +\n  theme(plot.title = element_text(size = 15, color = \"white\", face = \"bold\", \n                                  family = \"Helvetica\", hjust = 0.1, vjust = 0)) +\n  theme(plot.subtitle = element_text(size = 14, color = \"white\", face = NULL, \n                                     family = \"Helvetica\", hjust = 0.8, vjust = 0)) +\n  theme(plot.caption = element_text(size = 10, color = \"white\", face = NULL, \n                                    family = \"Helvetica\", hjust = 0, vjust = 2))\n\nq\n\n\n\nAnnotations\nWe add the line and text annotations with information about the states and the\npublic opinion of each state\n\n\n# ANNOTATION 1: ND AND MN\n\n# ND\nq <- q + annotate(\"segment\", x = 6.5, xend = 6.5, y = 8.07, yend = 9, \n                  color = \"white\")\n\nq <- q + annotate(geom = \"richtext\", x = 3.8, y = 9.7,\n                  label = \"The only abortion clinic in \n                  <span style = 'color:#9B2226'>**North Dakota**<\/span>\n                  <br> moved to <span style = 'color:#D5DAD5'>**Minnesota**<\/span>, \n                  where the number<br>of abortions rose by \n                  <span style = 'color:#D5DAD5'>**14%**\",\n                  size = 5, fill = NA, label.color = NA, hjust = 0, \n                  color = \"white\")\n\n# ANNOTATION 2: CA AND AZ\n\n# TX\nq <- q + annotate(\"segment\", x = 3.6, xend = 5.6, y = 1, yend = 1, \n                  color = \"white\")\n\n# OK Vrt\nq <- q + annotate(\"segment\", x = 3.6, xend = 3.6, y = 2.3, yend = 0.2, \n                  color = \"white\")\n\n# OK Hzt\nq <- q + annotate(\"segment\", x = 3.6, xend = 4.3, y = 2.3, yend = 2.3, \n                  color = \"white\")\n\n# TX&OK\n\nq <- q + annotate(geom = \"richtext\", x = 1.5, y = -0.6,\n             label = \"The states in which abortion \n             <br> dropped to <span style = 'color:#9B2226'>**0**<\/span> also showed \n             <br> the strongest support to <br> overturning \n             <span style = 'color:#7DB4DE'>**Roe v. Wade**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, \n             color = \"white\") \n\n# ANNOTATION 3: AR\n\n# AR\n# AR1\nq <- q + annotate(\"segment\", x = 7.5, xend = 7.5, \n                  y = 1.65, yend = -0.5)\n# AR2\nq <- q + annotate(\"segment\", x = 7.5, xend = 7.9, \n                  y = -0.5, yend = -0.5)\n\n# AR\n\nq <- q + annotate(geom = \"richtext\", x = 8, y = -0.7,\n                  label = \"<span style = 'color:#9B2226'>**Arkansas**<\/span> \n                  is the state in which<br>more people are in favor of\n                  <br>overturning Roe v. Wade:<span style = 'color:#7DB4DE'> **48%**\",\n                  size = 5, fill = NA, label.color = NA, hjust = 0,\n                  color = \"white\") \nq\n\n\n\nLegends\nWe start withe the first legend, which represent the colors for the filling of the\nstates.\n\n\nq <- q + guides(fill = guide_colorbar(#title = \"PERCENT CHANGE\",\n                                      #title.position = \"top\",\n                                      #title.theme = element_text(size = 10,\n                                                                 #family = \"Helvetica\"),\n                                      #title.hjust = 0.5,\n                                      #title.vjust = 0.5,\n                                      label = FALSE,\n                                      barheight = 0.7,\n                                      barwidth = 11,\n                                      #nbin = 100,\n                                      ticks = FALSE,\n                                      direction = \"horizontal\", )) +\n  theme(legend.position = c(0.28, 0.915),\n        legend.title = element_blank()) + ylim(-1.3, 12) +\n  annotate(geom = \"richtext\", x = 2.8, y = 12, \n                  label = \"Percent change in abortions <br> from April to August of 2022\", \n                  size = 4, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 2.8, y = 11.1, \n                  label = \"-100%\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 3.9, y = 11.1, \n                  label = \"No change\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 5.4, y = 11.1, \n                  label = \"+100%\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") \nq\n\n\n\nThe second legend explains the squares that sorround the states.\n\n\nq <- q + \n annotate(geom = \"richtext\", x = 9.5, y = 12, \n                  label = \"Percent of population who \n                  <br>would like Roe v. Wade overturned\", \n                  size = 4, fill = NA, label.color = NA, hjust = 0, \n          family = \"Helvetica\", color = \"white\") +\n  annotate(\"rect\", xmin = 9.55, xmax = 9.85, ymin = 11.3, \n           ymax = 11.6, alpha = 0, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 9.86, xmax = 10.16, ymin = 11.3, \n           ymax = 11.6, alpha = 0.1, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.17, xmax = 10.47, ymin = 11.3, \n           ymax = 11.6, alpha = 0.2, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.48, xmax = 10.78, ymin = 11.3, \n           ymax = 11.6, alpha = 0.3, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.79, xmax = 11.09, ymin = 11.3, \n           ymax = 11.6, alpha = 0.4, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.10, xmax = 11.40, ymin = 11.3, \n           ymax = 11.6, alpha = 0.5, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.41, xmax = 11.71, ymin = 11.3, \n           ymax = 11.6, alpha = 0.6, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.72, xmax = 12.02, ymin = 11.3, \n           ymax = 11.6, alpha = 0.7, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.03, xmax = 12.33, ymin = 11.3, \n           ymax = 11.6, alpha = 0.8, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.34, xmax = 12.64, ymin = 11.3, \n           ymax = 11.6, alpha = 0.9, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.65, xmax = 12.95, ymin = 11.3, \n           ymax = 11.6, alpha = 1, fill = \"#7DB4DE\") +\n  annotate(geom = \"richtext\", x = 9.5, y = 11.1, \n                  label = \"25%\", \n                  size = 3, fill = NA, label.color = NA, \n           hjust = 0, family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 11.07, y = 11.1, \n                  label = \"36%\", \n                  size = 3, fill = NA, label.color = NA, \n           hjust = 0, family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 12.64, y = 11.1, \n                  label = \"48%\", \n                  size = 3, fill = NA, label.color = NA, \n            hjust = 0, family = \"Helvetica\", color = \"white\")\n  \nq\n\n\n\n\n\n\n",
    "preview": "projects/2023/100407986/100407986_files/figure-html5/unnamed-chunk-15-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 2112
  },
  {
    "path": "projects/2023/100507500/",
    "title": "Post-COVID Wallet Woes: The High Cost of Living",
    "description": "COVID-19 had a major impact on the economy and effectively affected the\nconsumption patterns of European households.",
    "author": [
      {
        "name": "Phong Duong",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nCollecting and processing data\nLoading packages\nGetting the data\nTransforming data\n\nReplicating the plot\nBuilding the basic elements\nBuilding icon graph (second graph)\nPatching things up…\n\nAlternative graph\nLoading libraries\nFont\nLoad and transform data\nBuilding the graph\nSecond plot\nFinal result\n\n\nIntroduction\nEurostat provided comprehensive statistical indicators and data visualisations on key figures on the overall economic situation of the Europe Union in 2023 in the sixth edition of Key figures on Europe. One interesting graph was about the household consumption spending in which the author demonstrated the difference in choices in spending of European households between 2022 and 2023. The author also detailed the changes in spending behaviours since the pandemic of COVID-19 in 2020.\nEurostat also provides the source of the data and we will use it to replicate the graph in this project. Later, an alternative graph will be presented as a suggestion for improving the original graph.\nHere is the original graph:\nHousehold consumption expenditure by EurostatCollecting and processing data\nLoading packages\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(extrafont)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggimage)\nlibrary(patchwork)\n\n\nGetting the data\nLike previously said, Eurostat includes a link in the graph to find the source data. It is possible to include more data from other years as well as from specific countries.\n\n\ndata <- read_csv(\"EU_data.csv.gz\")\n\n\nThe data file only included coded names for the categories so we will need to create a new column with the names similarly to the graph. The guidelines for the names according to the coded names are also provided by Eurostat (link. We will also add a percent column for more ease to work with as the original data column (OBS_VALUE) is on the scale of 1000. Finally, we only need the data from year 2022 and 2023 so we will filter the data accordingly and select the necessary columns to build the graph.\nTransforming data\n\n\ndataset <- data %>% \n  select(coicop, TIME_PERIOD, OBS_VALUE) %>% \n  mutate(coicop_name = case_when(\n    coicop == \"CP00\" ~ \"All-items HICP\",\n    coicop == \"CP01\" ~ \"Food and non-alcoholic beverages\",\n    coicop == \"CP02\" ~ \"Alcoholic beverages, tobacco and narcotics\",\n    coicop == \"CP03\" ~ \"Clothing and footwear\",\n    coicop == \"CP04\" ~ \"Housing, water and energy\", #change to fit the graph\n    coicop == \"CP05\" ~ \"Household equipment and maintenance\", #Change to fit the graph\n    coicop == \"CP06\" ~ \"Health\",\n    coicop == \"CP07\" ~ \"Transport\",\n    coicop == \"CP08\" ~ \"Communications\",\n    coicop == \"CP09\" ~ \"Recreation and culture\",\n    coicop == \"CP10\" ~ \"Education\", \n    coicop == \"CP11\" ~ \"Restaurants and hotels\",\n    coicop == \"CP12\" ~ \"Miscellaneous goods and services\"\n    ),\n    percent = OBS_VALUE / 1000 * 100) %>% \n  filter((!coicop %in% c(\"CP00\")) & between(TIME_PERIOD, 2022, 2023)) %>% \n  select(coicop, coicop_name, TIME_PERIOD, percent)\n\n\nReplicating the plot\nBuilding the basic elements\nNow we already have the data set ready, we will start reproducing the graph, first by the basic elements (bar chart, correct axes’ positions and scales, and theme). We need to customise the labels on the y axis so that we would not have to rewrite the names on the data set. The colors of the bars also need to be manually picked, this can be done by using a third party web application to identify the color and then simply plug them into manual scale in ggplot (scale_fill_manual).\n\n\np_main <- ggplot(dataset, aes(x = percent,y = reorder(coicop_name, percent))) +\n  geom_col(position = position_dodge2(reverse = TRUE), aes(fill = as.character(TIME_PERIOD)), width = 0.6) +\n  #Axes and scales\n  scale_x_continuous(name = NULL, limits = c(0,20), breaks = seq(0,20,5), position = \"top\") +\n  scale_fill_manual(values = c(\"#ad9000\", \"#2a46aa\"), labels = c(\"Jan 2022\", \"Jan 2023\")) +\n  #Theme\n  theme(#Background and grid line\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_line(\n          colour = \"grey\", \n          linetype = \"dashed\", \n          size = 0.3),\n        plot.margin = margin(0,185,5,10),\n        #Axes\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        #Legend \n        legend.title = element_blank(),\n        legend.position = c(1.3, 0.97),\n        legend.key.height = unit(0.68, \"char\"),\n        legend.key.width = unit(1.25, \"char\"),\n        legend.spacing.y = unit(0.3, \"char\")\n        ) +\n  guides(fill = guide_legend(byrow = TRUE)) #helps spacing elements in legend\n\n#Y axis labels\nlabels <- c(\n  \"Food and\\nnon-alcoholic\\nbeverages\",\n  \"Housing,\\nwater\\nand energy\",\n  \"Transport\",\n  \"Miscellaneous\\ngoods and\\nservices\",\n  \"Restaurants\\nand hotels\",\n  \"Recreation\\nand culture\",\n  \"Household\\nequipment and\\nmaintenance\",\n  \"Health\",\n  \"Clothing\\nand footwear\",\n  \"Alcoholic\\nbeverages,\\ntobacco\\nand narcotics\",\n  \"Communications\",\n  \"Education\"\n) %>% rev()\n\n\np_main <- p_main + scale_y_discrete(name = NULL,labels = labels) \n\np_main\n\n\n\nIt is noted that in this project, we are replicating the original graph by building 2 separate graphs then later patch them together to achieve a similar look to the original graph. This is because using graphic icons (on the axis label) is not native to ggplot2. Additionally, there was no package that could directly attach the illustrations exactly in the manner of the original graph. Therefore, we will manually create a graph that only has a vector of the icons then attach it to the graph we just created above to achieve the same effect of the original graph.\nFirst we will complete replicating the first part of the graph by adding the annotation text on the right side of the plot.\n\n\ncaption_text <- \"In January 2023, the largest categories of\nhousehold consumption expenditure in the\nEU were: food and non-alcoholic beverages;\nhousing, water and energy; and transport.\nTogether they accounted for close to half\n(47.1 %) of total expenditure. All three of these\ncategories were characterised by high price\nincreases during 2022, underlying their role in\nrelation to the cost-of-living crisis.\\n\nThe COVID-19 crisis impacted not only\noverall economic activity, but also household\nconsumption patterns. Across the EU, the share\nof household expenditure on several categories\ncommonly related to eating and living at home\nincreased between January 2020 and January\n2021. However, with COVID-19 restrictions\nlifted, there was some evidence that household\nconsumption was returning to its pre-pandemic\nstructure. There was a rebound in the share\nof expenditure for activities outside the home\nbetween January 2022 and January 2023, most\nnotably an increase of 2.1 percentage points for\nrestaurants and hotels; there were also notable\ngains for recreation and culture and for transport\n(up 0.7 and 0.5 points, respectively).\"\n\np_main <- p_main +\n  labs(tag = caption_text) +\n  coord_cartesian(clip = \"off\") +\n  theme(plot.tag.position = c(1.060, 0.51),\n        plot.tag = element_text(hjust = 0, \n                                size = 9,\n                                colour = \"grey50\", \n                                lineheight = 1.25)) \np_main\n\n\n\nNow we already have all the elements of the main part of the original graph, we can adjust the text so that it looks like the original one. The original graph used an Adobe font, which is also not openly available, therefore we will use another font from Google fonts that closely resembles it (Open Sans).\n\n\n#Fonts\nfont_add_google(\"Open Sans\", family=\"opensans\")\nshowtext_auto()\nfont <- \"opensans\"\n\np_main <- p_main +\n  theme(\n    legend.text = element_text(vjust = 0.5, margin = margin(0,0,0,-3), face = \"bold\", \n                               size = 9, family = font),\n    plot.tag = element_text(family = font),\n    axis.text.y = element_text(margin = margin(0,0,0,-22),vjust = 0.4, \n                               family = font, size = 9, lineheight = 1.02),\n    axis.text.x = element_text(family = font, size = 9)\n  )\n\np_main\n\n\n\nBuilding icon graph (second graph)\nWe now create the second part of the graph which is the icons. To do this, we would first need to cut out the icons manually from the original graph and process them into appropriate file type (e.g. png). This can be done by using different third-party applications (such as Photoshop, Illustrator, Affinity Designer, etc.). We then use ggimage to turn the pictures into usable R object and plot them on a ggplot graph. We also need to remove all other elements (i.e. axis, grid, text, background, etc.) to have a singular graphic vector of the icons.\n\n\n#Add images path\ndataset <- dataset %>% \n  mutate(path = case_when(\n    coicop == \"CP01\" ~ \"images/Food@2x.png\",\n    coicop == \"CP02\" ~ \"images/Alcoholic@2x.png\",\n    coicop == \"CP03\" ~ \"images/Clothing@2x.png\",\n    coicop == \"CP04\" ~ \"images/Housing@2x.png\",\n    coicop == \"CP05\" ~ \"images/Householdequip@2x.png\",\n    coicop == \"CP06\" ~ \"images/Health@2x.png\",\n    coicop == \"CP07\" ~ \"images/Transport@2x.png\",\n    coicop == \"CP08\" ~ \"images/Communications@2x.png\",\n    coicop == \"CP09\" ~ \"images/Recreation@2x.png\",\n    coicop == \"CP10\" ~ \"images/Education@2x.png\", \n    coicop == \"CP11\" ~ \"images/Restaurant@2x.png\",\n    coicop == \"CP12\" ~ \"images/Miscellaneous@2x.png\"\n  ))\n\np_icon <- ggplot(dataset, aes(x = percent,y = reorder(coicop_name, percent))) +\n  geom_image(aes(image = path, x = 0), size=.12) +\n  theme(\n    axis.text = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    panel.background = element_blank()\n  ) + \n  labs(x = NULL, y = NULL, fill = NULL)\n\np_icon\n\n\n\nPatching things up…\nHaving 2 parts of the graph created, we now only need to merge them together to create a unified graph. Using patchwork package, we can adjust the size of the 2 graphs so that they look similar to the original graph. We also need to add the title and subtitle, along with the source of the data at the foot of the plot. Since the original graph has a second subtitle with a different color (which is also not native to ggplot2), we will write it as an html element using ggtext package.\n\n\ncaption_source = \"Source: Eurostat (online data code: <span style = 'color:#2a46aa'>prc_hicp_inw<\/span>)\"\n\np_replicated <- wrap_plots(list(p_icon, p_main), widths = c(8,16)) &\n  plot_annotation(\n    title = \"Household<br>consumption expenditure\",\n    subtitle = \"<span><b>Household budget structure<b><\/span><br>\n    <span style = 'font-size: 10pt; color:#878586'>\n    (%,share of total household consumption expenditure, EU, January 2022 and 2023)\n    <\/span>\",\n    caption = caption_source,\n    theme = theme(\n      plot.margin = margin(15,50,15,15),\n      plot.title = element_markdown(\n        colour = \"#2a46aa\", \n        size = 27,  \n        family = font,\n        face = \"bold\",\n        lineheight = 0.8),\n      plot.subtitle = element_markdown(\n        colour = \"#2a46aa\", size = 13,\n        family = font, lineheight = 1.3),\n    #caption / source\n    plot.caption.position = \"plot\",\n    plot.caption = element_markdown(\n      hjust = 0, \n      size = 8, \n      colour = \"#878586\")\n    )\n  )\np_replicated\n\n\n\nAlternative graph\nThe graph from Eurostat is fairly simple to understand and the visualisation issues are minimal. The text on the right of the graph is a little lengthy and quite misses the point of creating a graph (putting words and data into graphs and charts for quick understanding). The icons used also make the graph less reproducible and consequently less apt for sharing or scaling. We will consider these issues and make an alternative graph that presents the same information but is potentially better for interpretation.\nLoading libraries\n\n\nlibrary(scales)\nlibrary(ggstance)\nlibrary(fontawesome) #For icons in table in second plot\nlibrary(gt) #For creating nice tables\nlibrary(gtExtras) #For icons in gt\nlibrary(emojifont) #For easy plotting fontawesome\n\n\nFont\n\n\nfont_add_google(\"Montserrat\", family=\"montserrat\")\nshowtext_auto()\nfont <- \"montserrat\"\n\n\nWe are using a google font for easy access and reproducibility. Montserrat also looks modern and easy to read.\nLoad and transform data\n\n\ndata <- read_csv(\"custom_data.csv\")\ndata <- data %>% \n  select(coicop, geo, TIME_PERIOD, OBS_VALUE)\n\neu <- data %>% filter(geo == \"EU27_2020\" & coicop != \"CP00\" & TIME_PERIOD >= 2015) %>%\n  mutate(coicop_name = case_when(\n    coicop == \"CP01\" ~ \"Food and non-alcoholic beverages\",\n    coicop == \"CP02\" ~ \"Alcoholic beverages, tobacco and narcotics\",\n    coicop == \"CP03\" ~ \"Clothing and footwear\",\n    coicop == \"CP04\" ~ \"Housing, water and energy\", #change to fit the graph\n    coicop == \"CP05\" ~ \"Household equipment and maintenance\", #Change to fit the graph\n    coicop == \"CP06\" ~ \"Health\",\n    coicop == \"CP07\" ~ \"Transport\",\n    coicop == \"CP08\" ~ \"Communications\",\n    coicop == \"CP09\" ~ \"Recreation and culture\",\n    coicop == \"CP10\" ~ \"Education\", \n    coicop == \"CP11\" ~ \"Restaurants and hotels\",\n    coicop == \"CP12\" ~ \"Miscellaneous goods and services\"\n    ),\n    percent = OBS_VALUE / 10) %>% \n  select(coicop, coicop_name, TIME_PERIOD, percent) %>% \n  rename(year = TIME_PERIOD) %>% \n  group_by(coicop) %>% \n  mutate(\n    change = percent - lag(percent)\n  ) %>% ungroup()\n\n\nWe need to pull out more data from Eurostat so that we have the data from the previous years to turn the long text into a graph. The data transformation process is the same. Since we are turning the text into a graph, we will have to create 2 separate plots then patch them up together to create a whole graph.\nBuilding the graph\nWe start by building the background for the first graph (alternative version of the main plot in the original graph). We are keeping some elements of the original graph (vertical dashed-lines for grid-line, x-axis label on the top, etc.) so it does not look too different from the original but rather an enhancement based on the original graph.\nAlso, the original graph’s x-axis labels might be a bit unclear so we will put a ‘%’ sign next to the number so the graph is easier to read.\nMain plot background\n\n\nbg <- ggplot(eu, aes(y = reorder(coicop_name, percent), x = percent)) +\n  scale_x_continuous(limits = c(0,20),breaks = c(0,5,10,15,20), position = \"top\",\n                     labels = function(x) paste0(x, \"%\")) +\n  labs(subtitle = \"Share of total household consumption expenditure, European Union\") +\n  theme(\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey\",linetype = \"dashed\"),\n    panel.background = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(size = 12),\n    plot.title.position = \"plot\",\n    plot.subtitle = element_text(family = font, colour = \"grey60\", \n                                   size = 16 ,face = \"bold\")\n  ) \nbg\n\n\n\nMain Plot\nNow, we can plot the data onto the graph. I believe using 2 circles on the graph instead of the bar chart can deliver the same information but at the same time uses less space and has a more modern, sleek look that the old bar chart.\n\n\n#Data for plot\ny2223 <- eu %>% filter(year >= 2022)\n#Colours\np_color = \"blue\"\n\n\n\n\np_main <- bg +\n  geom_point(data = y2223,\n             aes(percent, \n                 reorder(coicop_name,percent), \n                 shape = as.factor(year)),\n             size = 5,\n             colour = p_color) +\n  scale_shape_manual(values = c(1, 19)) +\n  theme(\n    plot.margin = margin(10,10,10,10),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.title = element_blank(),\n    legend.key = element_blank(),\n    legend.text = element_text(size = 12, family = \"montserrat\"),\n    legend.direction = \"horizontal\",\n    axis.text = element_text(family = \"montserrat\"),\n    axis.text.y = element_text(colour = p_color, size = 13) \n  )\np_main\n\n\n\nSecond plot\nFor the second plot, the message of the annotation text from the original graph is about the changes of the household spending categories since the incident of COVID-19. After the virus spread had subdued and curfew and restrictions had been lifted, people seemed to resume to normal activities (going to restaurant, travelling, etc.). Instead of writing in text, I thought that we can turn it into a table like graph that shows the trend of the spending compared to the previous year (up or down). With this, we can sort of see the story of how life unfolded after COVID-19 for each category.\n\n\n#Dataframe for second plot\np2_df <- eu %>% filter(year >= 2020) %>% \n  mutate(icon = if_else(change < 0, \"fa-angle-down\", \"fa-angle-up\"))\n\n# Icon size\nicon_size <- 8\ny_label_pos <- filter(p2_df, year == 2023) %>% arrange(desc(percent)) %>% pull(coicop_name) %>% rev()\n\np2 <- ggplot(p2_df, aes(x = year, y = factor(coicop_name, levels = factors))) +\n  scale_x_discrete(limits = c(2020, 2021, 2022, 2023),position = \"top\") +\n  geom_text(data = filter(p2_df, year == 2020),\n            aes(x = 2020, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size)+\n  geom_text(data = filter(p2_df, year == 2021),\n            aes(x = 2021, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  geom_text(data = filter(p2_df, year == 2022),\n            aes(x = 2022, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  geom_text(data = filter(p2_df, year == 2023),\n            aes(x = 2023, y = reorder(coicop_name, percent), label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  scale_colour_manual(values = c(\"red\", \"blue\")) +\n  scale_y_discrete(limits = y_label_pos) +\n  theme(\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.background = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(size = 12, family = font, face = \"bold\"),\n    axis.text.y = element_blank(),\n    legend.position = \"none\"\n  ) \np2\n\n\n\nFinal result\n\n\nwrap_plots(list(p_main, p2), widths = c(17,6.5)) & \n  plot_annotation(\n    title = \"Household Consumption Expenditure\",\n    theme = theme(\n      plot.title = element_text(size = 26, family = font, \n                                colour = \"blue\", face = \"bold\")\n    )\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2023/100507500/100507500_files/figure-html5/out-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 1728
  },
  {
    "path": "projects/2023/100507931/",
    "title": "Public Trust in Government Hits Historic Lows",
    "description": "Using Pew Research data to visualize the evolution of public trust towards \ndifferent U.S. governments between 1972 and 2023.",
    "author": [
      {
        "name": "Ana Pérez-Barrera",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nLooking closely at the U.S.\n\nCleaning the data\nBuilding the chart\nThe background\nLet’s fill it\nAdding text\nAnnotations\n\nDefining the theme\nGoogle fonts\nArranging the final plot\n\nAlternative visualization\nManaging the data\nSeparate plots!\nKey data points\nFinal theme\n\nConclusions\nLimitations\n\nBibliography\n\nIntroduction\nAccording to the OECD (2013), Public Trust in Government represents the confidence of citizens and businesses in the actions of government to do what is right and perceived as fair. While levels of trust in institutions vary significantly across countries, opinion surveys suggest that there has been a decline in trust in public institutions in recent decades (United Nations, 2021). For instance, in the United States, overall trust in the national government has declined from 73% in 1958 to 24% in 2021. Western Europe has seen a similar steady decline in public trust since the 1970s.\nWhy should we care about public trust? Firstly, it is a fundamental indicator upon which the legitimacy and sustainability of political systems are built. Secondly, greater public trust has been found to improve compliance in regulations and tax collections, as well as to be a crucial determinant for successful government responses. Finally, increasing concerns suggest that the crisis of public confidence may contribute to support for extreme political views, rising public discontent, protests and, in some cases, violent conflict.\nLooking closely at the U.S.\nThe Pew Research Center has published an article showing the evolution of trust along 4 ideological lines between 1972 and 2023 in the U.S.: Public Trust in Government: 1958-2023 (2023). The report includes data on different trends in trust among party members, races or ideological leanings. This post will be based on the following graph by party and ideology:\nPublic Trust in Government: 1958-2023 (Pew Research Center, 2023).In line with the Pew Research Center findings, the U.S. is currently experiencing historic lows in levels of public trust. Consequently, fewer than two-in-ten Americans say they trust the government in Washington to do what is right “just about always” (1%) or “most of the time” (15%). This is among the lowest trust measures in nearly seven decades of polling.\nThe following ideas are extracted from the article:\nPublic trust reached a three-decade high shortly after the 9/11 terrorist attacks.\nSince 2007, the shares saying they can trust the government has not surpassed 30%.\nWhile Republicans express more pronounced levels of trust, Democrats’ attitudes have tended to be somewhat more consistent.\nThe aim of this post is to replicate the original graph, while proposing an alternative form of visualization that illustrates the main takeaways.\nCleaning the data\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggtext)\n\n\nData on surveys was obtained through different sources, such as the National Election Studies, Gallup, ABC/Washington Post, CBS/New York Times, CNN Polls, and Pew Research Center (from 2020 onward, data is collected through Pew Research Center’s online American Trends Panel; whereas data before 2020 was obtained through traditional telephone surveys). This data is available in csv format and consists on 134 observations representing public trust levels over time among 4 ideological lines.\n\n\ndata <-\n  read_csv(file = \"chart-export-6dcaa713-b94d-4cb5-b91e-e8d433400438.csv\",\n           skip = 3, quote = \"\\\\.\") |>\n  mutate(Date = mdy(str_remove_all(Date, \"\\t|\\\"\")),\n         `Conservative Rep/Lean Rep` =\n           as.numeric(str_remove_all(`Conservative Rep/Lean Rep`, '\"'))) |>\n  rename(pollster = .) \n\ndata<-na.omit(data)\n\ncolnames(data)[3] <- \"Liberal_Dem\"\ncolnames(data)[4] <- \"Cons_Dem\"\ncolnames(data)[5] <- \"Liberal_Rep\"\ncolnames(data)[6] <- \"Cons_Rep\"\n\nsummary(data)\n\n      Date              pollster          Liberal_Dem   \n Min.   :1972-10-15   Length:134         Min.   : 8.00  \n 1st Qu.:1991-03-02   Class :character   1st Qu.:24.25  \n Median :1999-02-08   Mode  :character   Median :30.00  \n Mean   :1999-05-25                      Mean   :29.61  \n 3rd Qu.:2009-04-29                      3rd Qu.:36.00  \n Max.   :2023-06-11                      Max.   :58.00  \n    Cons_Dem      Liberal_Rep       Cons_Rep    \n Min.   :12.00   Min.   : 9.00   Min.   : 4.00  \n 1st Qu.:26.00   1st Qu.:22.00   1st Qu.:15.25  \n Median :32.00   Median :31.00   Median :27.00  \n Mean   :31.69   Mean   :34.81   Mean   :30.49  \n 3rd Qu.:38.00   3rd Qu.:50.00   3rd Qu.:46.75  \n Max.   :56.00   Max.   :66.00   Max.   :69.00  \n\nBuilding the chart\nThe background\nSince the background of the graph is divided by presidential terms, the first step implies creating a vector of date strings for the start and end dates. I firstly established the intervals for the terms of Presidents Ford, Reagan, Clinton, Obama, and Biden. These intervals are then organized into a data frame named colored. Additionally, a vector assigns distinct colors to each president name, which will be later used for the annotations.\nSimilarly, I created a second set of intervals for Presidents Nixon, Carter, H.W. Bush, W. Bush, and Trump, saving them into a data frame named white. These are later used for coloring specific background areas of the plot.\n\n\ncolored_xmin <- c(\"1974-12-01\", \"1980-11-07\", \"1993-01-17\",  \n                  \"2008-12-21\",\"2021-04-11\")\ncolored_xmax <- c(\"1977-04-25\", \"1989-01-15\",\"2001-01-17\", \n                  \"2017-04-11\",\"2023-06-11\")\ncolored <- data.frame(xmin = as.Date(colored_xmin),\n                        xmax = as.Date(colored_xmax),\n                        interval = c(\"Ford\",\"Reagan\",\n                                    \"Clinton\", \"Obama\",\"Biden\" ))\ncolored_interval <-  c(\"Ford\" = \"#C81518\", \"Reagan\" = \"#C81518\",\n                         \"Clinton\" = \"#2E5A87\", \"Obama\" = \"#2E5A87\", \n                         \"Biden\" = \"#2E5A87\")\n  \nwhite_xmin <- c(\"1972-10-15\", \"1977-04-25\", \"1989-01-15\",\n                \"2001-01-17\",\"2017-04-11\")\nwhite_xmax <- c(\"1974-12-01\",\"1980-11-07\",\"1993-01-17\",\n                  \"2008-12-21\",\"2021-04-11\")\nwhite <- data.frame(xmin = as.Date(white_xmin),\n                      xmax = as.Date(white_xmax),\n                      interval = c(\"Nixon\", \"Carter\",\"H.W.Bush\", \n                                   \"W.Bush\", \"Trump\"))\nwhite_interval <- c(\"Nixon\" = \"#C81518\",\"Carter\" = \"#2E5A87\",\n                      \"H.W.Bush\" = \"#C81518\",\"W.Bush\" = \"#C81518\",\n                      \"Trump\" = \"#C81518\")\n\n\nSubsequently, the geom_rect function applies a rectangular shape using the intervals defined in the colored data frame. This is necessary to ensure that the rectangles do not overlap on the lines.\n\n\nPlot <- ggplot(data, aes(x = Date)) +\n  geom_rect(aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = 100),\n            data = colored,\n            fill = \"#E8e8da\", \n            alpha = 0.3,\n            inherit.aes = FALSE, na.rm = TRUE) +\n  guides(fill = FALSE)  +\n  theme_minimal()\n\nPlot\n\n\n\nLet’s fill it\nEach geom_line function is used to plot a line for a specific variable (Liberal Democrat, Cons-Moderate Democrat, Moderate-Lib Republican, and Conservative Republican) to represent the evolution of trust across ideological leanings.\n\n\nPlot <- Plot +\n   \n  geom_line(aes(y = Liberal_Dem, color = \"Liberal Dem/Lean Dem\"), \n             linetype=\"solid\", size=1.75, \n             alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Cons_Dem, color = \"Cons-Moderate Dem/Lean Dem\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Liberal_Rep, color = \"Moderate-Lib Rep/Lean Rep\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Cons_Rep, color = \"Conservative Rep/Lean Rep\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  scale_color_manual(values = c(\"Conservative Rep/Lean Rep\" = \"#BF3B27\",\n                                \"Liberal Dem/Lean Dem\" = \"#456A83\",\n                                \"Cons-Moderate Dem/Lean Dem\" = \"#82A6BF\",\n                                \"Moderate-Lib Rep/Lean Rep\" = \"#E37F73\"),\n                     breaks = c(\"Conservative Rep/Lean Rep\", \n                                \"Moderate-Lib Rep/Lean Rep\", \n                                \"Cons-Moderate Dem/Lean Dem\", \n                                \"Liberal Dem/Lean Dem\"),\n                     name= \"\") +\n  scale_y_continuous(limits = c(0, 100), \n                     breaks = seq(0, 100,by = 20),\n                     expand = expansion(0)) + \n  scale_x_date(date_labels = \"%Y\",\n               limits = c(as.Date(\"1972-10-15\"),\n                          max(data$Date)),\n                breaks = seq(as.Date(\"1975-01-01\"),  \n                            max(data$Date), by = \"5 years\"),\n               expand = expansion(0)) + \n  geom_vline(xintercept = as.Date(\"1972-10-15\"), \n            color = \"darkgrey\", \n            size =0.5) \n \nPlot\n\n\n\nAdding text\n\n\nPlot <- Plot +\n  labs(title = \"Trust in government by party and ideology\",\n       subtitle = \"% who say they trust the government to do what is right just about always/most of the time\",\n       caption = \"PEW RESEARCH CENTER\",\n        x = \"\",\n        y = \"\") \n\nPlot\n\n\n\nAnnotations\nIn order to include the names of the Presidents at the top of the chart, I used the annotate function based on the colored and white data frames initially created. Here, I indicated the intervals for the presidential terms and the assigned colors depending on the political party. The text is then rotated in -90 degrees to place the names vertically.\n\n\nPlot <- Plot + annotate(\"text\", x = as.Date(colored_xmin) + \n                            (as.Date(colored_xmax) -\n                               as.Date(colored_xmin))/7, \n                        y = 94, \n                        label = colored$interval, \n                        size = 4, \n                        angle = -90,  \n                        color = colored_interval[colored$interval])\n  \nPlot <- Plot + annotate(\"text\", x = as.Date(white_xmin) +\n                            (as.Date(white_xmax) - \n                               as.Date(white_xmin))/7, \n                         y = 94, \n                        label = white$interval, \n                        angle = -90, \n                        color = white_interval[white$interval])\nPlot\n\n\n\nDefining the theme\nGoogle fonts\nI downloaded the specific types of font from Google Fonts and added them to my library. This will be later used within the theme to achieve an accurate replication of the overall graph.\n\n\nlibrary(showtext)\nlibrary(sysfonts)\nlibrary(showtextdb)\n\nsysfonts::font_add_google(\"Libre Franklin\", family=\"franklin\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Lato\", family=\"lato\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Almarai\", family=\"almarai\")\n\n\nArranging the final plot\nUltimately, I still needed to make some changes on the final theme. First of all, to place the legend where is originally located in the bottom, I used the argument legend.position. Subsequently, I indicated the specific attributes of the letter with legend.text. Then, I modified the axis attributes (line, text and ticks). The specifications are mostly based on the color and the size. I also had to set the margins for the axis.text.x.\nOn the other hand, I set the panel.grid as element_blank () to remove the grid lines from the plot. Finally, I specified the font, the color, the margins, and the size of the element_text for the title, subtitle and caption elements.\n\n\nPlot <- Plot +\n   \n   theme (legend.position = \"bottom\",\n          legend.key.height = unit(0.01, \"cm\"), \n          legend.key.width = unit(1, \"lines\"), \n          legend.text = element_text(family = \"almarai\", size = 16, \n                                      face = \"plain\", color =\"#4b4647\"),\n          axis.line.x =  element_line(color = \"#696969\",size = 0.7),\n          axis.line.y =  element_line(color = \"#a1a1a1\",  size = 0.5),\n          axis.text.y = element_text(margin = margin(r=0),size=16, \n                                   colour = \"#696969\"),\n          axis.text.x = element_text(margin = margin(t=7), size=16, \n                                   colour = \"#696969\"),\n          axis.ticks.x = element_line(size = 0.7, color = \"#696969\"), \n          axis.ticks.y = element_line(size =0.7,color= \"#696969\"),\n          axis.ticks.length.x = unit(0.15, \"cm\"),\n          axis.ticks.length.y = unit(0.15, \"cm\"), \n          panel.grid = element_blank(),\n          panel.grid.major.y = element_line(color = \"#E5E5E5\"),\n          plot.margin = margin(t=5,b=5,r=5,l=5), \n          plot.title = element_text( face = \"bold\", family = \"franklin\", \n                                    size = 22, hjust = -0.04), \n          plot.subtitle = element_text(face = \"italic\",colour = \"#8d8f8e\",\n                                      family = \"playfair\", margin = margin\n                                     (t = 9, b= 30, l=),\n                                     size = 17, hjust = -.05),\n          plot.caption = element_text(face = \"bold\",hjust = 0,\n                                     margin = margin ( 2,  0, 0, 1),\n                                     family = \"lato\", size = 14)) \n \n Plot <- Plot + theme(aspect.ratio = 1/3.3)\n Plot\n\n\n\nAlternative visualization\nMy purpose here is to present an alternative form of visualization to the previous graph. However, I want to ensure that key elements of the original plot remain recognizable in order to facilitate a straightforward comparison. The ultimate goal is to enhance the interpretation and ensure that the information is better presented through data visualisation.\nMy first thought when analyzing the original graph was that there was a lot of noise concentrated in the centre of the graph, which resulted in visual confusion and hindered a clear understanding of the message. Has public trust been declining? Is there a difference among ideologies? Where is this difference? Let’s improve it!\n\n\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(showtext)\nlibrary(MetBrewer)\nlibrary(scico)\nlibrary(ggtext)\nlibrary(patchwork)\nlibrary(gghighlight)\nlibrary(lubridate)\nlibrary(dplyr)\n\n\nManaging the data\nI believe that creating smoother evolution lines would help to avoid noise within the graph. For that purpose, I had to reshape the data (tidy_data) using the pivot_longer function. Then, I calculated the average trust for each combination of year and ideology using the group_by and summarise functions. The resulting data-frame has columns for “year,” “ideology,” and “mean_cases,” which shows the rounded average of public trust.\n\n\ntidy_data <- data |> \n  pivot_longer(cols=\"Liberal_Dem\":\"Cons_Rep\", \n               names_to = \"ideology\",values_to = \"cases\") |> \n  \n  group_by(year = lubridate::year(Date), ideology) |> \n  summarise(mean_cases = round(mean(cases, na.rm = TRUE)))\n  tidy_data$year <- as.numeric(tidy_data$year)\n  \nglimpse(tidy_data)\n\nRows: 184\nColumns: 3\nGroups: year [46]\n$ year       <dbl> 1972, 1972, 1972, 1972, 1974, 1974, 1974, 1974, 1…\n$ ideology   <chr> \"Cons_Dem\", \"Cons_Rep\", \"Liberal_Dem\", \"Liberal_R…\n$ mean_cases <dbl> 53, 66, 44, 62, 40, 40, 36, 39, 37, 40, 32, 44, 4…\n\nSeparate plots!\nI believe that the original graph has room for improvement, whether through simplification, by emphasizing key data points, or reducing visual clutter.Therefore, I used the facet_wrap function to visualize each ideological category individually. Subsequently, the geom_line function plots a line to represent the evolution of each ideology, with different colors assigned.\nThe geom_hline draws a horizontal dashed line at y = 60. The aim of highlighting only this line is to emphasize when public trust reached levels around 60%. Finally, gghighlight is used to display the other ideologies in the background, but nicely faded out. This is included to enhance the visual aesthetics of the plot. The plots are previously arranged to facilitate the comparison among ideologies in the final visualization chart.\n\n\n  tidy_data <- tidy_data |>\n  mutate(ideology = factor(ideology, \n                           levels = c(\"Liberal_Rep\", \n                                      \"Cons_Rep\", \n                                      \"Cons_Dem\",\n                                      \"Liberal_Dem\"))) |> \n  arrange(ideology, year)\n  \n  Plot2 <- ggplot(tidy_data, aes(x = year)) +\n  geom_hline(yintercept =  60,\n             linetype= \"dashed\", \n             size=.3, \n             color=\"#696969\") +\n  geom_line(aes(x=year, y=mean_cases, color=ideology),\n            linetype=\"solid\", \n            size=1.3, alpha = 1, \n            linejoin = \"round\", lineend= \"round\") +\n  gghighlight(use_direct_label = FALSE, \n              unhighlighted_params = list(colour = alpha(\"white\", .8))) +\n  facet_wrap(~ideology, labeller = labeller\n              (ideology = c (\"Liberal_Rep\" = \"Moderate Republican\",\n                             \"Liberal_Dem\" = \"Liberal Democrat\",\n                             \"Cons_Dem\" = \"Conservative Democrat\",    \n                             \"Cons_Rep\" =\"Conservative Republican\")))  +\n  scale_color_manual(values = c(\"Cons_Rep\" = \"#BF3B27\",\n                                \"Liberal_Dem\" = \"#456A83\",\n                                \"Cons_Dem\" = \"#82A6BF\",\n                                \"Liberal_Rep\" = \"#E37F73\")) +\n  scale_x_continuous(breaks = seq(min(tidy_data$year), \n                                 max(tidy_data$year), by = 10)) + \n  scale_y_continuous(breaks = c(0,20,40,60,80,100),\n                     labels = c(\"\", \"20\",\"40\",\"60\",\"\",\"\")) +\n  theme_minimal( ) +\n  labs(title = \"Trust in government by party and ideology\",\n       \n       subtitle = \"% who say they trust the government to do what is right just about always/most of the time\")\n  \n  Plot2 \n\n\n\nKey data points\nThe story I want to tell is that public trust has declined over time, reaching historic lows in the recent history of the U.S. For that purpose, i used both functions geom_point and geom_text to highlight the data points where public trust reached both its highest and lowest levels.\nThis way, the message is clear: public trust has indeed declined in recent years. In three of the four ideological leans, the maximum level of trust was only reached in 1972, i.e. 50 years ago. In the case of the liberal democrats, the maximum was reached in the begining of the 2000s. All four ideological leans tend to share a decline in public trust that seems to worsen from 2020 onward. A crisis in public trust!\n\n\n  Plot2 <- Plot2 +\n  geom_point(data = tidy_data  |> \n               group_by(ideology) |> \n               slice(which.min(mean_cases)),\n             aes(x = year, y = mean_cases,\n                 color = ideology),\n             shape = 16,size = 3) +\n  geom_text(data = tidy_data |> \n               group_by(ideology)  |> \n               slice(which.min(mean_cases)),\n             aes(x = year, y = mean_cases, \n                 color = ideology, \n                 label = mean_cases),\n             hjust = -1, vjust = 1, size= 5,  fontface=\"bold\")  +\n  geom_point(data = tidy_data |> \n                 group_by(ideology) |> \n                 slice(which.max(mean_cases)),\n               aes(x = year, y = mean_cases,\n                   color = ideology),\n               shape = 16,size = 3) +\n  geom_text(data = tidy_data |>\n               group_by(ideology) |> \n                slice(which.max(mean_cases)),\n              aes(x = year, y = mean_cases, \n                  color = ideology,\n                  label = mean_cases),\n              hjust = -.7, vjust = 0, size= 5,  fontface=\"bold\")\n\n  Plot2\n\n\n\nFinal theme\nThe main inspiration for the final theme was based on the Consumer Confidence Around the World chart from the R Gallery. Within the theme, the strip.text.x function adjusts the appearance of the text in the facet labels along the x-axis, the legend is removed, the axis.text adjusts the appearance of the y and x axis text, including margin, size, and color; plot.background sets the color of the background, and plot.(sub)title adjusts the appearance of both the title and subtitle, including font face, color, margin, and size.\nAs a result, a cleaner theme is achieved, where unnecessary noise is removed and only the key elements are maintained to tell the story that public trust is reaching historic lows. Moreover, the evolution of the target ideology is more obvious and it is possible to put in perspective with other ideologies.\n\n\n  Plot2 <- Plot2 + \n  theme(axis.title =element_blank(), \n        strip.text.x = element_text(face=\"bold\",size=15, ),\n        legend.position = \"none\",\n        axis.text.y = element_text(margin = margin(r=0),size=12, \n                                   colour = \"#696969\"),\n        axis.text.x = element_text(margin = margin(t=7),size=12, \n                                   colour = \"#696969\"),\n        plot.background = element_rect(color=\"#F4F5F1\",\n                                       fill=\"#F4F5F1\"),\n        plot.margin = margin(10,10,10,10),\n        plot.title = element_text(face = \"bold\", family = \"franklin\", \n                                  size = 22),\n        plot.subtitle = element_text(face = \"bold\",colour = \"#8d8f8e\",  \n                                     margin = margin(t = 8, b= 30), \n                                     size =17)) \n\n  Plot2\n\n\n\nConclusions\nThe final visualization allows to extract some information that was perhaps not so obvious in the original graph. The main conclusions I draw are as follows:\nRepublican trust appears to be more polarized, exhibiting extremes in confidence levels. Republicans tend to express either high or very low levels of trust in government.\nDemocrats, on the other hand, tend to be consistently skeptical in their trust towards government. Even in instances where trust is expressed, it rarely surpasses the 50%.\nThere is a general trend of declining political trust in the United States, affecting citizens across the ideological spectrum.\nLimitations\nThe main limitation of the improved chart is that some information from the original chart has been removed to maintain a clean theme. For example, the presidential terms and the names of the presidents, which allowed to track trust according to who was in power. On the other hand, including additional information on crucial events in history would have helped to contextualize such evolution, like the Vietnam War, the 9/11 terrorist attacks or the COVID-19 pandemic. In this case, I have opted for a clean theme following the less is more norm.\nBibliography\nBell, P. (2023). Public Trust in Government: 1958-2023 | Pew Research Center. Pew Research Center - U.S. Politics & Policy. https://www.pewresearch.org/politics/2023/09/19/public-trust-in-government-1958-2023/\nOECD (2013), “Trust in government”, in Government at a Glance 2013, OECD Publishing, Paris. DOI: https://doi.org/10.1787/gov_glance-2013-7-en\nPerry, J. (2021). Trust in public institutions: Trends and implications for economic security | Division for Inclusive Social Development - U.N. https://www.un.org/development/desa/dspd/2021/07/trust-public-institutions/\n\n\n\n",
    "preview": "projects/2023/100507931/100507931_files/figure-html5/unnamed-chunk-9-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2112,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100510783/",
    "title": "With Whom Did We Spend Our Time in 2020?",
    "description": "This article goes through the steps of recreating a bar chart with small\nmultiples using the ggplot2 package in R. The original chart shows the\ndistributions, by age, with whom we spend our time. The replication and\nenhanced versions include new data from the year 2020.",
    "author": [
      {
        "name": "Eric Hausken-Brates",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nOriginal chart\nReplication\nCollecting the data\nColor theme of the plot\nBuilding the chart\nFormatting the theme\nAnnotations\nSaved chart\n\nEnhanced version\nSaved chart\n\n\n\n\nlibrary(tidyverse)\n\n\nOriginal chart\nI found this chart in an article called “Who We Spend Time with as We Get Older” by Nathan Yau. This article includes data from the American Time Use Survey from 2011 to 2019. Yau did not include 2020 data because they did not include a couple months due to the COVID-19 pandemic.\nThe chart in Figure 1 stood out because it had a lot of information broken down in static small multiples. The X-axis measures the age, from 15 to 80 years old, of the survey respondents. The Y-axis measures the percentage of respondents for each age group who spent time with the person titled in each bar chart. While the X-axis is fixed, the Y-axis is free so you cannot compare one chart to another.\nThe point of the chart is to compare the distributions by age. The facets are sorted by peak age from youngest to oldest, meaning that “Parent” has a peak at minimum age. Meanwhile, the peak for “Neighbors or Acquaintances” is at the maximum age of 80, which is why its bar chart is positioned at the bottom right corner.\nComparing the different charts, I noticed that the work-related facets– including co-workers, clients, managers, and customers– have similar distributions and peak around late 20s. The other work-related person, “Person Whom I Supervise,” peaks later but maintains a similar distribution.\n\n\n\nFigure 1: Source: FlowingData\n\n\n\nReplication\nCollecting the data\nThe most difficult aspect of putting together the plot was collecting and transforming the data. Instead of using the website that Nathan Yau linked in the article, I went to the U.S. Bureau of Labor Statistics website, which has all the data for the American Time Use Survey.\nAfter combining three datasets downloaded from the BLS.gov site using tidyverse joins and transformations 1, I exported the data to a csv file. You can see an overview of the data below.\n\n\ndata <- read_csv(\"data.csv\")\n\ndata$whofct <- forcats::fct_reorder(\n  .f = data$who, data$Y, min\n  ) \n\nglimpse(data)\n\nRows: 6,432\nColumns: 9\n$ who      <chr> \"Alone\", \"Alone\", \"Alone\", \"Alone\", \"Alone\", \"Alone…\n$ TEAGE    <dbl> 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18,…\n$ category <chr> \"Alone\", \"Family\", \"Friend\", \"Work\", \"Alone\", \"Fami…\n$ n        <dbl> 287, 0, 0, 0, 390, 0, 0, 0, 508, 0, 0, 0, 357, 0, 0…\n$ N        <dbl> 1071, 0, 0, 0, 1391, 0, 0, 0, 1561, 0, 0, 0, 1028, …\n$ p        <dbl> 0.2679739, 0.0000000, 0.0000000, 0.0000000, 0.28037…\n$ X        <dbl> 0.7260842, 0.7260842, 0.7260842, 0.7260842, 0.72608…\n$ Y        <dbl> 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1…\n$ whofct   <fct> Alone, Alone, Alone, Alone, Alone, Alone, Alone, Al…\n\nColor theme of the plot\nTo obtain the colors for the plot, I uploaded the screenshot of the plot to an online color generator. These are the codes for the four colors in the original article.\n\n\ncolors <- c(\"#CCCCCC\", \"#A8A0D6\", \"#C4BA81\", \"#7AB486\" )\n\n\n\n\n\nFigure 2: Color Theme\n\n\n\nBuilding the chart\nFirst step was to set up the ggplot with the right coordinates and axes.\n\n\nplt <- data |> \n  ggplot(aes(x = TEAGE, y = p, fill = category))\nplt\n\n\n\nSecond step was to incorporate the small multiples using facet_wrap and rename the axes.\nThe code scales = \"free\" removes the restriction that all the axes are on the same scale. You can see that the Y-axis has a different scale for each facet. Since the range of the X-axis (variable TEAGE) in the data goes from 15 to 80 for all the facets (whofct), this code does not affect the X-axis’s scale.\n\n\nplt <- plt +\n  facet_wrap(\n    ~ whofct , scales = \"free\", ncol = 5, \n  )\n\nplt\n\n\n\nThird step was to add the geom_col.\n\n\nplt <- plt + \n  geom_col(\n    width = .8, \n  ) +\n  geom_hline(yintercept = 0, linewidth = .4)\n  \nplt\n\n\n\nFormatting the theme\nI used theme_void() to remove all the formatting.\n\n\nplt <- plt +\n  theme_void() \n\n\nThe chunk below shows the various formatting code to set the theme. I tried to set the font to be as close to the orignal chart as possible using the available fonts in the system.\nFont\nAxis text, facet title, caption -> “Menlo”\nTitle -> “Optima”\nSubtitle -> “Publico Text”\nNote that strip.clip = \"off\" is used to allow the facet titles to go beyond the strict border of the “strip background.” I also added vjust = -.2 to the facet settings so that the titles would be aligned slightly below the strip background and onto the chart, as does the original chart.\n\n\nplt <- plt +\n  theme(\n    \n    # axis settings\n    axis.text = element_text(\n      family = \"Menlo\", \n      size = 6, \n      color = \"gray30\"\n      ),\n    axis.ticks = element_line(\n      color = \"gray30\"\n      ),\n    axis.ticks.length = unit(-1.0, \"mm\"),\n    \n    # set spacing and margins\n    panel.spacing.x = unit(4, \"mm\"),\n    panel.spacing.y = unit(1, \"mm\"),\n    plot.margin = margin(4, 4, 4, 4, \"mm\"),\n    plot.title.position = \"plot\",\n    \n    # strip/facet placement and format\n    strip.text = element_text(\n      family = \"Menlo\", \n      hjust = 0.3, \n      vjust = -.2,  \n      size = 10, \n      face = \"bold\"\n      ),\n    strip.clip = \"off\", \n    \n    #  background color\n    plot.background = element_rect(fill = \"white\"), \n    \n    # remove legend\n    legend.position = \"none\",\n    \n    # format title, subtitle, and caption\n    plot.title = element_text(\n      family = \"Optima\", \n      size = 18, \n      hjust = 0.5, \n      margin = margin(4,4,1,4, \"mm\")\n    ), \n    plot.subtitle = element_text(\n      size = 12, \n      margin = margin(1,4,4,4, \"mm\"), \n      family = \"Publico Text\", \n      hjust = 0.5\n      ),\n    plot.caption = element_text(\n      family = \"Menlo\", \n      color = \"gray30\", \n      size = 6, \n      margin = margin(8,0,0,0, unit = \"mm\"))\n  )\n\nplt\n\n\n\nAnnotations\nI created a table for the annotations with the X and Y coordinates, the facet title (whofct) and category, the label text, and the horizontal justification.\n\n\nTable 1: annotations\n\n\nx\n\n\ny\n\n\nwhofct\n\n\nlabel\n\n\ncategory\n\n\nhj\n\n\n20\n\n\n0.30\n\n\nAlone\n\n\nMost people get some alone\ntime during a day.\n\n\nAlone\n\n\n0\n\n\n20\n\n\n0.04\n\n\nGrandchild\n\n\nGrandkids\nenter the\npicture.\n\n\nFamily\n\n\n0\n\n\n60\n\n\n0.30\n\n\nOwn household child\n\n\nKids enter\nthe picture.\n\n\nFamily\n\n\n0\n\n\n85\n\n\n0.04\n\n\nCo-Worker\n\n\nGotta pay\nthe bills.\n\n\nWork\n\n\n1\n\n\n85\n\n\n0.18\n\n\nParent\n\n\nWhile young, we commonly\nspend time with\nimmediate family.\n\n\nFamily\n\n\n1\n\n\n85\n\n\n0.07\n\n\nFriends\n\n\nTime with friends\nis also most common\nat a younger age.\n\n\nFriend\n\n\n1\n\n\nI made the whofct variable a factor so that it is consistent with the same variable of the main dataset.\n\n\nannotations$whofct <- factor(annotations$whofct)\n\n\nI added annotations using geom_text and set the color scale to the variable colors using scale_fill_manual(...).\n\n\nplt <- plt +\n  aes() +\n  geom_text(data = annotations, \n            aes(x = x, y = y, label = label), \n            color = \"gray10\",\n            size = 3,\n            family = \"Publico Text\",\n            fontface = \"italic\",\n            hjust = annotations$hj, \n            vjust = 1\n  ) +\n  scale_y_continuous(\n    label = scales::label_percent(accuracy = .1)\n  ) +\n  scale_fill_manual(\n    values = colors \n  ) +\n  labs(\n    \n    # TITLES \n    title = \"WHO WE SPEND TIME WITH, BY AGE\",\n    subtitle = \"Sorted by peak age from youngest to oldest.\",\n    caption = \"Created by Eric Hausken | Data source: American Time Use Survey 2020\\n\n    Chart inspired by: FlowingData\",\n    x = \"YEARS OLD\"\n    ) \n\n\nSaved chart\nFinally, I saved the chart using ggsave() to a .png with width and height of 11 and 8 inches.\n\n\nggsave(filename = \"Replication_plot.png\", \n       plot = plt, \n       width = unit(11, \"in\"), \n       height = unit(8, \"in\"))\n\n\n\n\n\nFigure 3: Replication\n\n\n\nEnhanced version\nFor the enhanced version, I replaced the color scheme to represent the magnitude of each column in percentage points. Instead of fill = category, the code now shows fill = p.\n\n\nplt_2 <- data |> \n  ggplot(aes(x = TEAGE, y = p, fill = p)) \n\n\n\n\n\nMost of the theme and code is the same for the enhanced version. The differences are in the color scale and legend. Here is the code for those enhancements.\n\n\nplt_2 <- plt_2 +\n  labs(\n    \n    # TITLES \n    title = \"WHO WE SPEND TIME WITH, BY AGE\",\n    subtitle = \"Sorted by peak age from youngest to oldest.\n    Color coded by percentage of age group that spent time with this person.\",\n    caption = \"Created by Eric Hausken | Data source: American Time Use Survey 2020\\n\n    Chart inspired by: FlowingData\") +\n  \n  theme(\n    \n    # legend format\n    legend.position = c(.95, 0.08),\n    legend.justification = 1,\n    legend.direction = \"vertical\",\n    legend.title = element_text(size = 8, family = \"Menlo\"),\n    legend.text = element_text(size = 6, family = \"Menlo\" ),\n    legend.title.align = 1,\n    legend.key.height = unit(.15, \"in\"),\n    ) +\n  \n  # color scale for columns and legend\n  scale_fill_gradient2(\n    low = colors[1], \n    mid = colors[3], \n    high = colors[4], \n    midpoint = .1,\n    guide = guide_colorbar(\n    title.position = \"left\",\n    title = \"Percentage\\nof Age Group\"),\n    labels = c(\"0.0%\", \"20.0%\", \"40.0%\", \"60.0%\"),\n    breaks = c(0, .2, .4, .6)\n  )  \n\n\nSaved chart\nOnce again, I saved it to a .png file with dimensions 11x8 inches.\n\n\nggsave(filename = \"Enhanced_version_plot.png\", \n       plot = plt_2, \n       width = unit(11, \"in\"), \n       height = unit(8, \"in\"))\n\n\n\n\n\nFigure 4: Enhanced version\n\n\n\n\nR code inspired by: Henrick Lindberg↩︎\n",
    "preview": "projects/2023/100510783/Replication_plot.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 3300,
    "preview_height": 2400
  },
  {
    "path": "projects/2023/100385252/",
    "title": "Life Expectancy Increased in All Countries of the World",
    "description": "The aim of this project is to reproduce, layer by layer, a chart on Life\nExpectancy evolution from Our World in Data.",
    "author": [
      {
        "name": "Alejandra Costa",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGetting and preparing the data\nObtaining the data\nData transformation\nAdjusting country data\nPreliminary adjustments\n\nCreate Graph\nInitial elements\nManaging labels\nAppearance adjustments\nAnnotations, background segments and arrows\n\nEnhancement and alternative graphs\nEnhanced graph\nAlternative graph\n\n\nAcross the world, people are leaving longer. In 1800, the average global life expectancy was 32 years. Nevertheless, by 2012 this figure had more than doubled, reaching 70 years. But when and where has this improvement in life expectancy occurred?\nIn order to understand such worldwide increase in longevity, we can look at the “Life Expectancy of the World Population in 1800, 1950 and 2012” chart, sourced from Our World in Data. Using information on population and life expectancy at birth from Gapminder.org, the mentioned chart shows how living standards have increased over the long run through the visualization of life expectancy evolution over the world.\nOriginal chartAccordingly, this post aims to replicate the provided chart, as well as to propose potential enhancements and alternatives.\nGetting and preparing the data\n\n\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(readxl)\nlibrary(ggstream)\nlibrary(ggtext)\n\n\nObtaining the data\nAll information used in the chart is obtained from Gapminder.org. The data consist of population and life expectancy observations, both by country and by year. Since the raw data sets contain information that will not be needed for our project, just data on life expectancy at birth, population, year and country is selected.\n\n\npop_data <- read.csv(file = \"Pop_country.csv\", sep = \";\") |> \n  select(\"Country\", \"Year\", \"Population\") \n\nlife_data <- read.csv(\"LifeExpect.csv\", sep = \";\") |> \n  select(\"Country\", \"Year\", \"LifeExpectAtBirth\")\n\n\nData transformation\nNow, both life expectancy and population information can be joined by country and year into a single data set. The plot only displays information for 1800, 1950 and 2012, therefore, data are filtered according to the mentioned years.\nSince the x-axis of the original plot represents the cumulative share of the world population, where countries are ordered by ascending life expectancy, some transformations are needed to compute it. This way, data are ordered by increasing life expectancy for each of the years and subsequently the cumulative share of the world population is computed.\n\n\ndataset <- inner_join(pop_data, life_data, by = c(\"Country\", \"Year\")) |> \n  filter(Year %in% c(\"1800\", \"1950\", \"2012\")) |> \n  mutate(Year = factor(Year, levels = c(2012, 1950, 1800))) |>\n  drop_na() |> \n  arrange(Year, LifeExpectAtBirth) |>\n  group_by(Year) |> \n  mutate(share = cumsum((as.numeric(Population)))/ sum(as.numeric(Population))) |> \n  mutate(share = round(share, digits = 5))\n\n\nAdjusting country data\nIn order to align the countries names of the data set with the way they are displayed in the labels of the plot, we need to apply some specific transformations.\n\n\ndataset <- dataset |> \n  mutate(Country = ifelse( Country == \"Russia\" & Year ==\"1950\", \"URSS\", Country))|>\n  mutate(Country = ifelse( Country == \"United States\", \"USA\", Country)) \n\n\nOne particularity of the original plot is that for each of the years displayed, a different group of countries is highlighted. Therefore, specific lists containing the groups of countries to be labelled are created for each of the three years.\n\n\nlist_2012 <- c(\"Sierra Leone\", \"Mozambique\", \"Nigeria\", \"Somalia\", \"Afghanistan\",\n               \"Rwanda\", \"India\", \"Pakistan\", \"Russia\", \"Indonesia\", \"Brazil\",\n               \"China\", \"Mexico\", \"Costa Rica\", \"South Korea\", \"USA\", \"Australia\",\n               \"Germany\", \"Spain\", \"Japan\") \n\nlist_1950 <- c(\"Bhutan\", \"Somalia\", \"India\", \"China\",\"South Korea\", \"Brazil\",\n               \"URSS\", \"Cuba\", \"Japan\", \"Germany\", \"Canada\", \"USA\", \"Norway\") \n\nlist_1800 <- c(\"India\", \"South Korea\", \"Nigeria\", \"Spain\", \"Russia\", \"China\",\n               \"France\", \"Germany\", \"Netherlands\", \"Belgium\", \"USA\") \n\n\nIn line with the lists above, an additional column is included in the data set to indicate whether the country should be labelled or not.\n\n\ndataset <- dataset |> \n  mutate(label = \n           ifelse( (Country %in% list_2012 & Year == \"2012\") | \n                   (Country %in% list_1950 & Year == \"1950\") | \n                   (Country %in% list_1800 & Year == \"1800\"), \"Yes\", \"No\")) \n\n\nPreliminary adjustments\nBefore starting to build the graph, we can work on some preliminary steps, that will be applied not only to the replication chart, but also to the enhanced and alternative versions, which will allow us to keep the code cleaner. This way, we create several character vectors containing the caption and the right side notes to be included later in the plot.\n\n\nsubtitle_text <-str_wrap(\n      \"Countries are ordered along the x-axis ascending by the life expectancy of the population. Data for almost all countries is shown in this chart, but not all data points are labelled with the country name.\", \n      width =124)\ncaption_text = paste(\n  \"Data Source: The data on life expectancy by country and population are taken from Gapminder.org.\",\n  \"The interactive data viusalization is available at OurWolrdData.org. There you find the raw data and more viusalizations on this topic.                                                          Licensed under CC-BY-SA by the author Max Roser.\", \n  sep=\"\\n\")\n\ncaption_2012 <- paste(\" Global Average\", \"Life Expectancy:\", \"      70 years\", sep= \"\\n\") \n\ncaption_1950 <- paste(\" Global Average\", \"Life Expectancy:\", \"      48 years\", sep= \"\\n\") \n\ncaption_1800 <- paste(\" Global Average\", \"Life Expectancy:\", \"      32 years\", sep= \"\\n\")  \n\n\nAfter these steps, our data set is ready in order to start with the creation of the plot.\nCreate Graph\nInitial elements\nTo begin, the chart is plotted using geom_line() and geom_area(), enabling the representation of life expectancy in stacked areas for each of the years. To match the plot with the original graph’s palette, two vectors are created, one containing the specific colors to fulfill the areas, and other to draw the lines.\nTo adjust the scale of the plot and stick as much as possible to the shape of the original plot, breaks in the axes are manually introduced along with th axis labels. However, later on, we will need to include some annotations in the right side of the plot. Therefore, the x-limits are set beyond 1 to create additional space.\n\n\narea_color <- c(\"#84A98C\", \"#FFD399\",\"#FFCAD3\") \nline_color <- c(\"#238B45\", \"#ff6900\", \"#99000d\") \n\nplot <- \n  ggplot(dataset, \n         aes(x = share, y = LifeExpectAtBirth,\n             label= as.factor(Year), \n             color = as.factor(Year))) +\n  geom_line() +\n  geom_area(aes(fill = as.factor(Year)), \n            position = position_dodge(width = 0), \n            alpha = 0.8) +\n  scale_fill_manual(values = area_color) +\n  scale_color_manual(values = line_color) +\n  scale_x_continuous(\n    breaks = c(0.0, 0.25, 0.5, 0.75, 1), \n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1.1)) +\n  scale_y_continuous(\n    breaks = seq(0, 90, by = 10), \n    labels = c(\"\",\"10\",\"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\"),\n    expand=c(0,0),\n    limits = c(0, 95)) +\n  guides(color = FALSE, fill = FALSE)\n\nplot  \n\n\n\nManaging labels\nOur next step is to include the labels of the countries for each year along the x-axis. To achieve this, we consider the subset formed by those countries with “Yes” in the label column.\nSince the plot involves a large number of labels inside the graph, geom_text_repel() is used to adjust the position of the countries and minimize overlap. Another advantage is that it allows for constraining the labels within specified limits, avoiding them from extending beyond the graph.\n\n\nplot <- \n  plot + \n  geom_text_repel(data = subset(dataset, label == \"Yes\"), aes(label = Country),\n                  xlim = c(0, 1),\n                  nudge_y = 0.05,  \n                  max.overlaps = 10, \n                  colour = \"black\",\n                  size = 2, \n                  segment.size = 0, \n                  segment.color = NA) \n  \n\nplot\n\n\n\nAppearance adjustments\nWe proceed by adding the corresponding title, subtitle and caption to the plot, as well as adjusting the graph appearance, where the font used is “Playfair Display”, downloadable from Google Fonts.\n\n\nsysfonts::font_add_google(\"Playfair Display\") \n\nplot <- plot +\n   labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = subtitle_text,\n    caption = caption_text,\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\")\n\n\nUntil now, the panel grid extended beyond our chart due to the larger x-limits we have set. To address this, the grid is removed and the background is set transparent, since, later on, we will manually add horizontal segments specifically adjusted to the established. Accordingly, we just include a vertical black line to represent the y-axis.\n\n\nplot <- plot + \n  theme(\n    axis.line.y = element_line(colour = \"black\", linewidth = 0.05),  \n    axis.line.x = element_blank(),\n    plot.background = element_rect(fill = \"white\"),\n    panel.background = element_rect(fill  = \"white\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 15, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 1, color = \"#525252\"),\n    plot.caption = element_text(size = 5, hjust = 0, vjust = -1, color = \"#525252\",lineheight = 0.8),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 5)),\n    axis.title.y = element_text(size = 8, margin = margin(r = 8), vjust = 0.05),\n    axis.text.x = element_text(size = 9, color = \"black\"), \n    axis.text.y = element_text(size = 6, color = \"black\"),\n    plot.margin= margin(t = 10, r = 3, b = 10, l = 6))\n\n\nplot\n\n\n\nAnnotations, background segments and arrows\nThe last step is to work on the annotations, the background grid and the arrows.\nOnce the background of the plot has been removed, independent segments are manually included in the background as a substitute of the grid in order to stick to the aesthetics of the original graph.\n\n\n#include background lines\n\nplot <- plot +\n  annotate(\"segment\", x=1, xend = 1, y=0, yend=93,  \n           color = \"black\",linewidth = 0.05, alpha= 1) +\n  annotate(\"segment\", x=0, xend = 1, y=10, yend=10, \n           color = \"#969696\",linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=20, yend=20, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\",x=0, xend = 1, y=30, yend=30, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=40, yend=40, \n           color = \"#666666\", linewidth = 0.002, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=50, yend=50, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=60, yend=60, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=70, yend=70, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=80, yend=80, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=90, yend=90, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=0, yend=0, \n           color = \"black\", linewidth = 0.05, alpha= 1)\n\n\nNow we include the right margin notes specifying the global average life expectancy and the corresponding year.\n\n\nnote_2012 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      70 years\", sep= \"\\n\") \n\nnote_1950 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      48 years\", sep= \"\\n\") \n\nnote_1800 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      32 years\", sep= \"\\n\")  \n\nplot <- plot +\n  annotate(\"text\", x = 1.018, y = 86,\n           label = \"2012\",\n           hjust=0,\n           size=5,\n           color=\"#005824\") +\n    annotate(\"text\", x = 1.013, y = 81,\n           label = caption_2012,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 67,\n           label = \"1950\",\n           hjust=0,\n           size=5,\n           color=\"#ffa600\") +\n  annotate(\"text\", x = 1.013, y = 62,\n           label = caption_1950,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 40,\n           label = \"1800\",\n           hjust=0,\n           size=5,\n           color=\"#99000d\") +\n  annotate(\"text\", x = 1.013, y = 35,\n           label = caption_1800,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\")\n\n\nLastly, geom_segment() is used to include the two big arrows inside the graph, as well as the two arrows between the notes of the right margin.\n\n\nplot <-\n  plot +\n  geom_segment(x = 1.05, y = 70,\n             xend = 1.05, yend = 77, \n             linewidth = 0.6,\n             color = \"#737373\", \n             arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 1.052, y = 43,\n               xend = 1.052, yend = 58, linewidth = 0.6,\n               color = \"#737373\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 0.9, y = 41,\n               xend = 0.9, yend = 61,linewidth = 1.4,\n               color = \"#e68600\",\n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) +\n  geom_segment(x = 0.3, y = 44,\n               xend = 0.3, yend = 64,linewidth = 1.4,\n               color = \"#38B200\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) \n\nplot\n\n\n\nEnhancement and alternative graphs\nEnhanced graph\nOne of the inconsistencies I found in the original graph is that the setting of the labels does not follow a fixed criterion, since different groups of countries are labelled for each of the years – some countries appear in the three different years, while other just appear once. Consequently, my first proposal in an enhanced plot based on the replication of the original plus an additional small modification, in which the same group of countries is highlighted in each line, which makes the plot more coherent\nTo achieve this, a common list for the three countries is created, which subsequently will be used to subset the data when using geom_text_repel. The remaining code is kept as in the replication section.\n\n\nlist_improved <- c(\"Mozambique\", \"Nigeria\", \"Pakistan\", \"India\", \"USA\", \"Spain\",\n                   \"China\", \"Mexico\", \"Brazil\", \"Cuba\", \"Japan\", \"Belgium\", \"Norway\")\n\ndataset <- dataset |> \n  mutate(label_improved = \n           ifelse((Country %in% list_improved), \"Yes\", \"No\")) \n\n\nplot2 <- \n  ggplot(dataset, \n         aes(x = share, y = LifeExpectAtBirth,\n             label= as.factor(Year), \n             color = as.factor(Year))) +\n  geom_line() +\n  geom_area(\n    aes(fill = as.factor(Year)), \n    position = position_dodge(width = 0), \n    alpha = 0.9\n    ) +  \n  geom_text_repel(\n    data = subset(dataset, label_improved == \"Yes\"),\n    aes(label = Country), \n    xlim = c(0, 1),\n                  nudge_x = 0.01,  \n                  max.overlaps = 10, \n                  colour = \"black\",\n                  size = 2, \n                  segment.size = 0, \n                  segment.color = NA) +\n  guides(color = FALSE, fill = FALSE) +\n  scale_fill_manual(values = area_color) +\n  scale_color_manual(values = line_color) +\n  scale_x_continuous(\n    breaks = c(0.0, 0.25, 0.5, 0.75, 1), \n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1.1)\n   )+\n  scale_y_continuous(\n    breaks = seq(0, 90, by = 10), \n    labels = c(\"\",\"10\",\"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\"),\n    expand=c(0,0),\n    limits = c(0, 95)) +\n   labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = subtitle_text,\n    caption = caption_text,\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\") +\n  theme(\n    axis.line.y = element_line(colour = \"black\", linewidth = 0.05),  \n    axis.line.x = element_blank(),\n    plot.background = element_rect(fill = \"white\"),\n    panel.background = element_rect(fill  = \"white\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 16, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 1, color = \"#525252\"),\n    plot.caption = element_text(size = 5, hjust = 0, vjust = -1, color = \"#525252\",lineheight = 0.8),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 5)),\n    axis.title.y = element_text(size = 8, margin = margin(r = 8), vjust = 0.05),\n    axis.text.x = element_text(size = 9, color = \"black\"), \n    axis.text.y = element_text(size = 6, color = \"black\"),\n    plot.margin= margin(t = 10, r = 3, b = 10, l = 3)) \n\nplot2 <- plot2 +\n  annotate(\"segment\", x=1, xend = 1, y=0, yend=93,  \n           color = \"black\",linewidth = 0.05, alpha= 1) +\n  annotate(\"segment\", x=0, xend = 1, y=10, yend=10, \n           color = \"#969696\",linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=20, yend=20, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\",x=0, xend = 1, y=30, yend=30, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=40, yend=40, \n           color = \"#666666\", linewidth = 0.002, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=50, yend=50, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=60, yend=60, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=70, yend=70, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=80, yend=80, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=90, yend=90, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n   annotate(\"segment\", x=0, xend = 1, y=0, yend=0, \n           color = \"black\", linewidth = 0.05, alpha= 1)\n\nplot2 <- plot2 +\n annotate(\"text\", x = 1.018, y = 86,\n           label = \"2012\",\n           hjust=0,\n           size=5,\n           color=\"#005824\") +\n    annotate(\"text\", x = 1.013, y = 81,\n           label = caption_2012,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 67,\n           label = \"1950\",\n           hjust=0,\n           size=5,\n           color=\"#ffa600\") +\n  annotate(\"text\", x = 1.013, y = 62,\n           label = caption_1950,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 40,\n           label = \"1800\",\n           hjust=0,\n           size=5,\n           color=\"#99000d\") +\n  annotate(\"text\", x = 1.013, y = 35,\n           label = caption_1800,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") \n\nplot2 <- plot2 +\n\n  geom_segment(x = 1.046, y = 70,\n             xend = 1.046, yend = 77, \n             linewidth = 0.6,\n             color = \"#737373\", \n             arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 1.046, y = 43,\n               xend = 1.046, yend = 58, linewidth = 0.6,\n               color = \"#737373\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 0.9, y = 41,\n               xend = 0.9, yend = 61,linewidth = 1.4,\n               color = \"#e68600\",\n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) +\n  geom_segment(x = 0.3, y = 44,\n               xend = 0.3, yend = 64,linewidth = 1.4,\n               color = \"#38B200\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) \n\nplot2\n\n\n\nAlternative graph\nThe alternative proposed is an entirely new plot that represents the same information from another perspective. This new proposal aims to make the plot simpler, making it more understandable.\nAdditionally, information regarding the world region to which each country belongs is included, providing a more comprehensive plot and allowing the identification of potential patterns between areas. Also, with this kind of chart, by observing the slopes, we can observe the level of inequality across countries for each year in terms of living standards and life expectancy. For instance, in 1950, we observe a steep slope, meaning that there was a high inequality between countries, despite life expectancy levels were higher than in 1800.\nIn order to create the proposal, the chart is plotted using geom_jitter() along with faced_grid(), therefore, an independent subplot is displayed for each of the years, where countries are represented by the data points.\n\n\ncolors_faced <- c(\"orange\", \"#7570b3\",\"#7fc97f\", \"#43a2ca\")\n\ndata_regions <- read.csv(file = \"Geographies.csv\", sep = \";\") |> \n  select(\"name\", \"four_regions\")\n\ndata <- full_join(dataset, data_regions, by = c(\"Country\"=\"name\")) |> \n  drop_na() |> \n  mutate(Year_f = factor(Year, levels = c(\"1800\", \"1950\", \"2012\")))\n\nunique_regions <- unique(data$four_regions)\n\nplot3 <-\n  ggplot(\n    data, \n    aes(x=share,y=LifeExpectAtBirth, \n        color = as.factor(four_regions), \n        group = Year_f)\n    ) +\n  geom_jitter(\n    data= data,\n    position = position_jitter(width = 0.3), \n    alpha = 0.8\n    ) +\n  scale_color_manual(values = colors_faced)  +\n  facet_grid(~Year_f) \n\n\nBy using geom _smooth(), a curve is added to the data points, whose slope serves as an indicator of he inequality in terms of life expectancy across countries.\n\n\nplot3 <- plot3 + geom_smooth(method = \"lm\", se = TRUE, \n              formula = y ~ x, \n              color = \"darkgrey\",linewidth = 0.001, linetype = \"dashed\") \n\nplot3\n\n\n\nNow, we work on the scale adjustments and set the appearance setting.\n\n\nplot3 <- plot3 +\n  scale_x_continuous(\n    breaks = c(0, 0.25, 0.5, 0.75, 1),\n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1))+\n  scale_y_continuous(\n    breaks = seq(0, 100, by = 20),\n    labels = c(\"\",\"20\",\"40\", \"60\", \"80\", \"100\"),\n    expand=c(0,0),\n    limits = c(0, 100)) +\n  labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = \"Countries are ordered along the x-axis ascending by the life expectancy of the population.\",\n    caption = \"Data Source: The data on life expectancy by country and population are taken from Gapminder.org.\",\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\") +\n  theme(\n    plot.background = element_rect(fill = \"transparent\"),\n    panel.background = element_rect(fill  = \"#F0F0F0\"),\n    strip.text.x = element_text(size = 10, face = \"bold\"),\n    panel.grid.major.x = element_line(color = \"white\", linewidth = 0.0000001),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"white\", linewidth = 0.0000001),\n    plot.title = element_text(size = 14, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 0.5, color = \"#525252\"),\n    plot.caption = element_text(size = 6, hjust = 0, vjust = -0.5, color = \"#737373\"),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 10)),\n    axis.title.y = element_text(size = 10, margin = margin(r = 8)),\n    panel.spacing = unit(0.5, \"cm\"),\n    legend.text=element_text(size=8,family = \"Playfair Display\"),\n    legend.position = \"right\",\n    legend.title = element_blank(),\n    legend.key = element_blank(),\n    legend.key.height = unit(0.5, \"cm\"),\n    plot.margin= margin(t = 10, r = 10, b = 10, l = 5))\n\n\nplot3\n\n\n\nFinally, following the same procedure as in the previous graphs, we create an specific list containing the countries to be highlighted and subsequently, such information is included in a new column in the data set, that will allows us to create a subset when applying geom_text_repel().\n\n\nlist_alternative <- c(\"Mozambique\", \"India\", \"Pakistan\", \"USA\", \"Spain\", \"China\", \"Mexico\", \"Brazil\", \"Cuba\")\n\ndata <- data |> \n  mutate(label_alternative = \n           ifelse((Country %in% list_alternative), \"Yes\", \"No\"))\n\nplot3 <- plot3 +\n   geom_text_repel(\n     data = subset(data, label_alternative == \"Yes\"), \n     aes(label = Country), \n     xlim = c(0, 1),max.overlaps = 50,\n     nudge_y = 0.05, nudge_x = -0.01, \n     colour = \"black\",size = 2, \n     segment.size = 0, \n     segment.color = NA)  \nplot3\n\n\n\nThe final step is to include the annotations indicating the average global life expectancy for each of the years. In order to place the notes inside each of the subplots, a data frame is created, in which the position along the y- and x-axis is specified. Subsequently, geom_text() is used to include such notes in our final plot.\n\n\ndata_text <- data.frame(\n  Year_f = c(1800, 1950, 2012),\n  label = c(caption_1800, caption_1950, caption_2012),\n  x  = c(0.35, 0.35, 0.35),\n  y = c(92, 92, 92))\n\n\nplot3 <- plot3 +\n  geom_text(\n    data = data_text,\n    aes(x = x, y = y,label = label), lineheight = 1,\n    hjust = 0, size = 2, color = \"black\")\n\n\nplot3\n\n\n\n\n\n\n",
    "preview": "projects/2023/100385252/100385252_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 960
  },
  {
    "path": "projects/2023/100407614/",
    "title": "Cigarettes Sales and Lung Cancer Mortality in the US",
    "description": "Every year, around 8 million people die prematurely as a result of smoking.\nIn this case, examining the relationship across the cigarettes sales in men in the United States.",
    "author": [
      {
        "name": "Andrea Baños-Ramos",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction and Motivation\nReplication work\nLoad the main files\nLoad the libraries\nData Generating Process\nSetting the individual axes, coordinates and scales\nPerforming simple linear graphs\nEstablishing the axes, coordinates and scales\nRescaling of age_males_death variable\nIntersecting charts and filtering the data\nSelecting the suitable font style\nModifying the appearance of the axes by altering the color and size of their titles\nIncorporating annotations on the most relevant dates\n\nEnhancement Chart\n\nIntroduction and Motivation\nThe selected chart from Our World in Data explains the relationship that may exist between daily cigarette sales per adult and the lung cancer death rate per 100,000 men in the United States.\nThe consumption of cigarettes significantly increased in wealthy countries, including the United States, in the early 20th century. Similarly, lung cancer trends closely mirror those of smoking, although with a delay. We can observe how, from the second half of the 20th century, possibly reaching its peak, until now, the daily sales of cigarettes and the lung cancer death rate attributed to smoking have significantly decreased. Finally, the choice of this chart was driven by my concern for global health, aiming to investigate risk factors that significantly impact health and may even cause the death of millions of people.\nSmoking and lung cancer mortality in the US. Source: Our World in Data.Replication work\nLoad the main files\n\n\ncsv_file <- read.csv(\"sales-of-cigarettes-per-adult-per-day.csv\")\ncsv_file2 <- read.csv(\"lung-cancer-deaths-per-100000-by-sex-1950-2002.csv\")\n\n\nLoad the libraries\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggtext)\n\n\nData Generating Process\nIn order to carry out the replication process, I will clean the two databases, taking into account numerous variables such as entity (in this case, the country is the United States), year (ranging from 1900 to 2017), sales_cig (representing daily cigarette sales per adult), and age_males_death (indicating the rate of deaths in men attributed to lung cancer).\n\n\nsales <- data.frame(csv_file[1:2767, 1:4]) # Data Frame (rectangular data structures)\nsales_daily <- sales |> filter(Entity == \"United States\") |> \n  rename(sales_cig = Sales.of.cigarettes.per.adult.per.day..International.Smoking.Statistics..2017..,\n         entity = Entity, year = Year) |> \n  select(entity, year, sales_cig)\n\ncancer <- data.frame(csv_file2[1:4572, 1:5])\ncancer_deaths <- cancer |> filter(Entity == \"United States\") |> \n  rename(age_males_death = age.standardized_death_rate_per_100k_male,\n         entity = Entity, year = Year) |> \n  select(entity, year, age_males_death)\n\n\nSetting the individual axes, coordinates and scales\n\n\np <- ggplot(sales_daily) +\n  aes(year, sales_cig)\np\n\n\nq <- ggplot(cancer_deaths) +\n  aes(year, age_males_death)\nq\n\n\n\nPerforming simple linear graphs\nWith ggplot, we can create a line chart using the sales_daily database, plotting the year on the x-axis and sales_cig on the y-axis, without any explanatory legend. The same approach is applied to ages_males_death using the cancer_deaths database.\n\n\np <- ggplot(sales_daily) +\n  aes(year, sales_cig) +\n  geom_line(aes(color = \"#800080\")) +\n  theme(legend.position = \"none\")\np\n\n\nq <- ggplot(cancer_deaths) +\n  aes(year, age_males_death) +\n  geom_line(aes(color = \"#CC0000\")) +\n  theme(legend.position = \"none\")\nq\n\n\n\nEstablishing the axes, coordinates and scales\n\n\ncross_chart <- ggplot() +\n  theme_minimal() +\n  coord_cartesian(clip = \"off\") +\n  scale_x_continuous(\n    expand = c(0, 0), limits = c(1900, 2015), breaks = seq(1900, 2010, by = 10)) +\n  theme(axis.text.y = element_blank(),\n        axis.text.y.right = element_blank()) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 1,\n    label = \"1\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 2,\n    label = \"2\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 3,\n    label = \"3\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 4,\n    label = \"4\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 5,\n    label = \"5\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 6,\n    label = \"6\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 7,\n    label = \"7\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 8,\n    label = \"8\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 9,\n    label = \"9\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 10,\n    label = \"10\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 11,\n    label = \"11\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 1,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 2,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 3,\n    label = \"15\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 4,\n    label = \"20\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 5,\n    label = \"25\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 6,\n    label = \"30\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 7,\n    label = \"35\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 8,\n    label = \"40\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 9,\n    label = \"45\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 10,\n    label = \"50\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 11,\n    label = \"55\",\n    vjust = -0.5, hjust = 1, size = 6\n  )\ncross_chart\n\n\n\nRescaling of age_males_death variable\n\n\nnew_min <- 19.56\nnew_max <- 55\nage_males_death <- cancer_deaths$age_males_death\nold_min <- min(age_males_death)\nold_max <- max(age_males_death)\nage_males_death <- (((age_males_death-old_min) / (old_max - old_min))\n                    * (new_max - new_min)) + new_min\ncancer_deaths$age_males_death <- age_males_death\n\n\nIntersecting charts and filtering the data\nTo overlay the line charts, we scale them by dividing the maximum value of sales_cig and age_males_death. As we can observe, there is a small peak in the raw data, specifically in the series representing cigarette sales, indicating that the authors who generated this graph likely underwent some standardization process to address it.\n\n\nscale <- max(sales_daily$sales_cig)/\n  max(cancer_deaths$age_males_death)\n\ncancer_deaths <- cancer_deaths |> \n  mutate(age_males_death = if_else(year >= 2016, NA, age_males_death))\n\ncross_chart <- ggplot() +\n  geom_line(\n    data = sales_daily,\n    aes(x = year, y = sales_cig, color = \"Sales of Cigarettes\"),\n    size = 1\n  ) +\n  geom_line(\n    data = cancer_deaths,\n    aes(x = year, y = age_males_death * scale, color = \"Cancer Deaths\"),\n    size = 1\n  ) +\n  labs(\n    title = \"Cigarette sales and lung cancer mortality in the US\",\n    x = \"Year\",\n    y = \"Cigarettes sold per adult per day\"\n  ) +\n  scale_color_manual(\n    values = c(\"Sales of Cigarettes\" = \"#800080\", \n               \"Cancer Deaths\" = \"#CC0000\")\n  ) +\n  scale_y_continuous(\n    sec.axis = sec_axis(\n      ~./scale,\n      breaks = seq(0, 55, by = 5),\n      name = \"Rate of lung cancer deaths per 100,000 men\",\n      labels = scales::number_format()\n    ),\n    breaks = seq(min(0), max(11), by = 1)\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\ncross_chart\n\n\n\nSelecting the suitable font style\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"font_title\")\nsysfonts::font_add_google(\"Lato\", family=\"font_y_axis\")\nshowtext::showtext_auto()\n\n\nModifying the appearance of the axes by altering the color and size of their titles\nTo change the color of specific words in the title, we use the command span style, followed by theme(plot.title = element_markdown). To eliminate the distance between the first value on the x-axis and the origin, I use scale_x_continuous(expand = c(0, 0)). This setting removes the padding or expansion on the x-axis. Additionally, theme_minimal() is employed to eliminate non-essential elements in the plot, creating a clean and simple design. The breaks command is used to display numbers on each axis at intervals of 1, 5, or 10. Sec_axis is employed to align the second y-axis (on the right) to a scale that approximates the first y-axis (on the left). Finally, annotate is used to place the axis titles at the top left and top right.\n\n\ncross_chart <- ggplot() +\n  geom_line(\n    data = sales_daily,\n    aes(x = year, y = sales_cig, color = \"Sales of Cigarettes\"),\n    size = 1\n  ) +\n  geom_line(\n    data = cancer_deaths,\n    aes(x = year, y = age_males_death * scale, \n        color = \"Cancer Deaths\"),\n    size = 1\n  ) +\n  labs(\n    title = \"<span style='color:#800080'>Cigarette sales<\/span> <span style='color:black'>and<\/span> <span style='color:#CC0000'>lung cancer mortality<\/span> <span style='color:black'>in the US<\/span>\",\n    x = \"\",\n    y = \"\",\n    caption = \"Data sources: International Smoking Statistics (2017): WHO Cancer Mortality Database (IARC). The death rate from lung-cancer is age-standardized.\"\n  ) +\n  scale_color_manual(\n    values = c(\"Sales of Cigarettes\" = \"#800080\", \n               \"Cancer Deaths\" = \"#CC0000\")\n  ) +\n  scale_y_continuous(\n    sec.axis = sec_axis(\n      ~./scale,\n      breaks = seq(0, 55, by = 5),\n      name = \"\",\n      labels = scales::number_format()\n    ),\n    breaks = seq(min(0), max(11), by = 1)\n  ) +\n  scale_x_continuous(\n    expand = c(0, 0),\n    limits = c(1900, 2018),\n    breaks = seq(1900, 2010, by = 10)\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n      color = \"#800080\",\n      hjust = 0,\n      size = 40,\n      margin = margin(l = -20),\n      family = \"font_title\"\n    ),\n    plot.margin = margin(t = 10, r = 10, b = 10, l = 20, \n                         unit = \"pt\"),\n    axis.text.x = element_text(size = 15, hjust = 0.25, \n                               family = \"font_y_axis\"),\n    axis.text.y = element_blank(),\n    axis.text.y.right = element_blank(),\n    plot.caption = element_text(\n      size = 12,\n      hjust = 0,\n      color = \"#5b5b5b\",\n      margin = margin(l = -20),\n      family = \"font_y_axis\"\n    )\n  ) +\n  annotate(\n    \"text\",\n    x = Inf,\n    y = 12.5,\n    label = \"Rate of lung cancer deaths\\nper 100,000 men\",\n    vjust = 1,\n    hjust = 1,\n    size = 6,\n    color = \"#CC0000\",\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, \n    y = 12.5,\n    label = \"Cigarettes sold\\nper adult per day\",\n    vjust = 1,\n    hjust = 0.17,\n    size = 6, \n    color = \"#800080\", \n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) + coord_cartesian(clip = \"off\") +\n  annotate(\n    \"text\",\n    x = -Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 1,\n    label = \"1\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 2,\n    label = \"2\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 3,\n    label = \"3\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 4,\n    label = \"4\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 5,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 6,\n    label = \"6\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 7,\n    label = \"7\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 8,\n    label = \"8\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 9,\n    label = \"9\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 10,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 11,\n    label = \"11\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 1,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 2,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 3,\n    label = \"15\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 4,\n    label = \"20\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 5,\n    label = \"25\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 6,\n    label = \"30\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 7,\n    label = \"35\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 8,\n    label = \"40\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 9,\n    label = \"45\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 10,\n    label = \"50\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 11,\n    label = \"55\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  )\ncross_chart + theme(plot.title = element_markdown())\n\n\n\nIncorporating annotations on the most relevant dates\nAnnotations are included using annotate(“text”), and arrows are added with annotate(“curve” or “segment”), depending on the shape of the arrow. The arrow command is used to specify the dimension and type of the arrowhead, in this case, it is a closed arrow. Finally, lineheight is used to determine the spacing between lines.\n\n\ncross_chart + theme(plot.title = element_markdown()) +\n  annotate(\n    \"curve\",\n    x = 1926.5, xend = 1929,\n    y = 5, yend = 4.4,\n    curvature = -0.2,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n    )\n  ) +\n  annotate(\n    \"text\",\n    x = 1926, y = 5,\n    hjust = 1,\n    label = \"1929: The Great Depression\",\n    color = \"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x = 1941.5, xend = 1944.5,\n    y = 9.2, yend = 8.2,\n    curvature = -0.2,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n    )\n  ) +\n  annotate(\n    \"text\",\n    x=1941, y=9.2,\n    hjust=1,\n    label =\"1945: The Second World War ends\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1946.5, xend = 1949,\n    y=10.6, yend= 9.6,\n    curvature = -0.2,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1946, y=10.5,\n    hjust=1,\n    label =\"In the late 1940s and early 50s epidemiologists\\n establish that smoking is harmful to people's health\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1960.5, xend = 1964,\n    y=11.65, yend= 10.9,\n    curvature = -0.5,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1960, y=11.5,\n    hjust=1,\n    label =\"1964: Surgeon General's report links smoking\\n to deaths from cancer and heart disease\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1968.5, xend = 1970,\n    y=12.2, yend= 10.3,\n    curvature = -0.2,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1968, y=12.2,\n    hjust=1,\n    label =\"1970: the US bans cigarette ads on radio and television\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1983, xend = 1983,\n    y=8.35, yend= 9,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1983, y=8.3,\n    hjust=0.9, vjust=1,\n    label =\"1983: federal tax on\\n cigarettes doubles\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1986, xend = 1986,\n    y=7.05, yend= 8.4,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1986, y=7.0,\n    hjust=0.97, vjust=1,\n    label =\"1986: Surgeon General's\\n report on secondhamd-smoke\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1991, xend = 1991,\n    y=6.05, yend= 6.9,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1991, y=6,\n    hjust=0.97, vjust=1,\n    label =\"Increasing bans on inflight smoking\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1995, xend = 1995,\n    y=5.05, yend= 6.3,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1995, y=5,\n    hjust=0.97, vjust=1,\n    label =\"Nicotine replacement medications\\n become widely available over the counter\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1998, xend = 1998,\n    y=4.05, yend= 5.8,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1998, y=4,\n    hjust=0.97, vjust=1,\n    label =\"1998: California bans smoking in restaurants\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 2009, xend = 2009,\n    y=2.8, yend= 3.5,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=2009, y=2.75,\n    hjust=0.97, vjust=1,\n    label =\"2009: federal tax increased again\\n from $0.39 to $1.01 per pack\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  )\n\n\n\nEnhancement Chart\nAs an improvement to the chart or an alternative visualization of these data, I have created a Correlation Connected Scatter to display the correlation between both series. As we can observe, it addresses the major issue we had previously, as all milestones are now marked on the same series, allowing us to attribute the effects correctly. This is achieved visually with the viridis color scale.\n\n\nmerged_data <- merge(sales_daily, cancer_deaths, \n                     by = c(\"entity\", \"year\"))\n\nmin(merged_data$sales_cig)\n\n[1] 3.2\n\nmax(merged_data$sales_cig)\n\n[1] 11\n\nmin(merged_data$age_males_death)\n\n[1] 19.56\n\nmax(merged_data$age_males_death)\n\n[1] 55\n\nviridis_color <- viridisLite::viridis(5)\n\nenhanc_chart <- ggplot(merged_data) +\n  aes(sales_cig, age_males_death, color = year) +\n  scale_color_viridis_c() +\n  geom_path(\n    arrow=arrow(\n    angle=15, type=\"closed\",\n    length=unit(0.1, \"inches\"))) +\n  geom_label(\n    data = subset(merged_data,\n                  year %in% c(1929, 1945, 1949, 1964,\n                              1970, 1983, 1986, 1992,\n                              1995, 1998, 2009)), \n    aes(label = as.character(year)), \n    family = \"font_y_axis\") +\n  coord_cartesian(clip = \"off\") +\n  theme_minimal() +\n  theme(legend.position=c(0, 1),\n        legend.justification=c(0, 1)) +\n  labs(\n    title = \"Correlation between Cigarette sales and Lung cancer mortality in the US\",\n    x = \"Cigarettes sold\\nper adult per day\",\n    y = \"Rate of lung cancer deaths\\nper 100,000 men\") +\n  scale_x_continuous(breaks = seq(3, 11, by = 1)) +\n  scale_y_continuous(breaks = seq(20, 55, by = 5)) +\n  theme(legend.position = \"none\",\n        plot.title = element_text(hjust = 0,\n                                  size = 30,\n                                  family = \"font_title\"),\n        plot.margin = margin(t = 10, \n                             r = 20, \n                             b = 10,\n                             l = 20,\n                             unit = \"pt\"),\n        axis.text.x = element_text(size = 20,\n                                   color = \"black\"),\n        axis.text.y = element_text(size = 20, \n                                   color = \"black\"),\n        axis.title.x = element_text(size = 20, \n                                    family = \"font_y_axis\"),\n        axis.title.y = element_text(size = 20,\n                                    family = \"font_y_axis\")) \nenhanc_chart\n\n\n\nAdding the milestones in the same series:\n\n\nenhanc_chart +\n  geom_rect(\n    aes(xmin = 8.5, xmax = 10.78, ymin = 32.5, ymax = 35),\n    fill = \"transparent\", color = viridis_color[2], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.55, y = 33.75,\n    label = \"Surgeon General's report links smoking\\nto deaths from cancer and heart disease\",\n    color = viridis_color[2], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 8.5, xmax = 10, ymin = 42.4, ymax = 44.9),\n    fill = \"transparent\", color = viridis_color[2], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.55, y = 43.65,\n    label = \"The US bans cigarette ads\\non radio and television\",\n    color = viridis_color[2], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 8.9, xmax = 10, ymin = 54.3, ymax = 56.8),\n    fill = \"transparent\", color = viridis_color[3], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.95, y = 55.55,\n    label = \"Federal tax on\\ncigarettes doubles\",\n    color = viridis_color[3], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 7.35, xmax = 8.8, ymin = 50.5, ymax = 53),\n    fill = \"transparent\", color = viridis_color[3], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 7.4, y = 51.75,\n    label = \"Surgeon General's report\\non secondhand smoke\",\n    color = viridis_color[3], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 5.85, xmax = 7, ymin = 53.7, ymax = 56.2),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 5.9, y = 54.95,\n    label = \"Increasing bans\\non inflight smoking\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 3.95, xmax = 6.35, ymin = 49.55, ymax = 52.05),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 4, y = 50.8,\n    label = \"Nicotine replacement medications\\nbecome widely available over the counter\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 5.9, xmax = 7.3, ymin = 44.75, ymax = 47.25),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 5.95, y = 46,\n    label = \"California bans smoking\\nin restaurants\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 3.65, xmax = 5.35, ymin = 33.7, ymax = 36.2),\n    fill = \"transparent\", color = viridis_color[5], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 3.7, y = 34.95,\n    label = \"Federal tax increased again\\nfrom $0.39 to $1.01 per pack\",\n    color = \"#DAA520\", size = 5, hjust = 0, lineheight = 0.75, \n    family = \"font_y_axis\"\n  )\n\n\n\nFurthermore, it is easier to observe in this graph that there is a strong positive correlation between daily cigarette sales and deaths attributed to lung cancer in the United States. The arrows start moving upward to the right and then downward to the left, indicating a positive correlation. In addition, the alignment and clear direction of the arrows suggest a strong correlation.\nTo sum up, it is evident that both the death rate and daily cigarette sales have decreased significantly from the second half of the 20th century to the present. For instance, we transitioned from approximately 9.1 daily cigarettes sold with a 53.61% lung cancer death rate in men in 1983 to 3.7 daily cigarettes sold with a 36.85% lung cancer death rate in men in 2009.\n\n\n\n",
    "preview": "projects/2023/100407614/100407614_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100430912/",
    "title": "Annual Global Corporate Investment in AI by Type",
    "description": "This project replicates a graph from Our World in Data and proposes an improvement.",
    "author": [
      {
        "name": "María Jurado-Millán",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\nCleaning and preparing data\nBuilding the graph and scales\nLabs and themes\n\nImprovement\n\nIntroduction\nThis graph was published by Our World in Data in June 2023 and shows the evolution of investment in artificial intelligence by type from 2013 to 2022. The unit of measure is US dollars adjusted by inflation. This is important because it allow us to make comparisons across time, taking into account that prices change over time. Data is adjusted according the US Consumer Price Index (CPI).\nI chose this chart because nowadays, artificial intelligence is a very trending topic and it is interesting to see how the investment market has behaved the past years. It is not surprising that the investment trend is increasing because it is a booming sector, but it is interesting that it reached a peak in 2021 and decreased in 2022. Does the pandemic have anything to do with this?\nThe purpose of this project is to replicate the original graph shown below and propose an improvement using the same data.\nAnnual global corporate investment in artificial intelligence, by type. Figure from ourworldindata.org.Replication\nThe first step is to run necessary libraries and the database.\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\nCleaning and preparing data\nThe original database contains 50 observations from 2013 to 2022 and 5 variables, Merger/Acquisition, Public Offering, Private Investment, Minority Stake and Total. The names of the columns are modified to simplify the coding and rows names are reordered to follow the graph’s structure. Since the graph doesn’t show the Total investment, these information can be omitted, as well as the “Code” column that only has NA’s an as is not giving any information at all, can be eliminated.\nSteps:\nOpen the database and rename columns to simplify the code.\n\n\ndata<-read_csv(file=\"corporate-investment-in-artificial-intelligence-by-type.csv\")\nhead(data)\n\n# A tibble: 6 × 4\n  Entity             Code   Year Total corporate investment - inflat…¹\n  <chr>              <lgl> <dbl>                                 <dbl>\n1 Merger/Acquisition NA     2022                           77173925249\n2 Merger/Acquisition NA     2021                          119660000000\n3 Merger/Acquisition NA     2020                           27284262020\n4 Merger/Acquisition NA     2019                           33821216045\n5 Merger/Acquisition NA     2018                           23621530919\n6 Merger/Acquisition NA     2017                           27282738242\n# ℹ abbreviated name:\n#   ¹​`Total corporate investment - inflation adjusted`\n\ndata<-data |> \n  rename(entity = Entity, year = Year,\n         amount = \"Total corporate investment - inflation adjusted\")\n\n\nEliminate non useful information.\n\n\ndata<- data |> \n  select(-Code) |> \n  filter(entity != \"Total\")\n\n\nConvert year column into a date variable instead of numeric.\n\n\ndata<- data |>\n  mutate(year=make_date(year=year, month=1, day=1),\n         year=as.Date(year))\n\n\nOrder data in the same structure as the graph.\n\n\ndata<-data |> \n  mutate(entity=factor(entity, levels=c(\n    \"Merger/Acquisition\", \"Public Offering\", \"Private Investment\", \"Minority Stake\")))\nhead(data)\n\n# A tibble: 6 × 3\n  entity             year             amount\n  <fct>              <date>            <dbl>\n1 Merger/Acquisition 2022-01-01  77173925249\n2 Merger/Acquisition 2021-01-01 119660000000\n3 Merger/Acquisition 2020-01-01  27284262020\n4 Merger/Acquisition 2019-01-01  33821216045\n5 Merger/Acquisition 2018-01-01  23621530919\n6 Merger/Acquisition 2017-01-01  27282738242\n\nBuilding the graph and scales\nNow that data is cleaned and prepared,we can start building the graph. This graph is plotted using geom_col function, which is the R function used for bar charts in ggplot2 package.The fill aesthetic is set to the variable “entity”, and the color palette is introduced manually with the function rgb() that allow us to find the exact color from the HTML format in R.\nSteps:\nCreate the plot and define the axes.\n\n\ng<-ggplot(data,\n       aes(x=year,y=amount, fill=entity))\n\n\nProperly scale the axes, including the breaks and renaming these breaks.\n\n\ng<- g + \n  scale_x_date(date_breaks=\"year\",\n               date_labels = \"%Y\")+\n  scale_y_continuous(breaks=c(0,50000000000,100000000000,150000000000,200000000000,250000000000),\n                     labels = c(\"$0\",\"$50 billion\",\"$100 billion\",\"$150 billion\",\"$200 billion\",\"$250 billion\"))\n\n\nInclude the dotted lines.\n\n\ng<- g +\n  geom_hline(yintercept=c(50000000000,100000000000,150000000000,200000000000,250000000000),\n             linetype=\"dotted\")\n\n\nAdd the necessary information to fill the plot with and their corresponding color.\n\n\ng<- g +\n  geom_col() + scale_fill_manual(values = c(\n    \"Merger/Acquisition\" = \"#B13507\",\n    \"Public Offering\" = \"#4C6A9C\",\n    \"Private Investment\" = \"#578145\",\n    \"Minority Stake\" = \"#883039\"\n  ))\ng\n\n\n\nLabs and themes\nThis section is formed by the final retouches. The tittle and subtitle are added in the same font as the original graphic and located at the right position and size. The background and the legend are also modified.\nSteps:\nInclude the necessary fonts.\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair_display\")\nsysfonts::font_add_google(\"Roboto\", family=\"roboto\")\nshowtext::showtext_auto()\n\n\nAdd the tittle and subtitle.\n\n\ng<- g+\n  labs(x=NULL, y=NULL, \n       title=\"Annual global corporate investment in artificial intelligence, by type\", \n       subtitle=\"This data is expressed in US dollars, adjusted for inflation.\")\n\n\nAdjust them to the exact font, size and location.\n\n\ng<- g+\ntheme(plot.title = element_text(color=\"#5b5b5b\", size=20, family = \"playfair_display\"),\n        plot.subtitle=element_text(color=\"#5b5b5b\", size=15, family = \"roboto\"),\n        plot.title.position = \"plot\")\n\n\nEliminate the title of the legend.\n\n\ng<- g+\n  theme(legend.title = element_blank())\n\n\nChange the background of the graph to the same color as the original one.\n\n\ng<- g+\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\"))\ng\n\n\n\nImprovement\nThe suggested improvement involves transitioning from a bar chart to a line chart. This change is motivated by the current graphical representation’s limitations, particularly because in year 2021 we can not see if Merger/Acquisition sector invested more than Private Investment. Given that data is a time series, I consider that a line chart would be more appropriate because it captures better the evolution over time. The objective of this adjustment is to enhance the clarity and interpretability of the presented data, providing a better overview of the evolution by type across the years.\nSteps:\nReorder data to show the variables from higher to lower investment.\n\n\ndata<-data |> mutate(entity=factor(entity, levels=c(\n  \"Private Investment\", \"Merger/Acquisition\", \"Public Offering\", \"Minority Stake\"))) |> \n  arrange(data)\n\n\nCreate the line chart and specify the axes.\n\n\np<- ggplot(data) +\n  aes(x=year,y=amount)+\n  geom_line(aes(color=entity))\n\n\nProperly scale the axes, including the breaks and renaming these breaks.\n\n\np<- p +\n  scale_x_date(date_breaks=\"year\",\n               date_labels = \"%Y\")+\n  scale_y_continuous(breaks = c(0,20000000000,40000000000,60000000000,80000000000,100000000000,120000000000),\n                     labels = c(\"$0\",\"$20 billion\",\"$40 billion\",\"$60 billion\",\"$80 billion\",\"$100 billion\", \"$120 billion\"))\n\n\nInclude the dotted lines.\n\n\np<- p +\n  geom_hline(yintercept=c(0,20000000000,40000000000,60000000000,80000000000,100000000000,120000000000),\n             linetype=\"dotted\",color=\"#5b5b5b\")\n\n\nAdd the title and subtitle.\n\n\np<- p +\n  labs(x=NULL, y=NULL,\n       title=\"Annual global corporate investment in artificial intelligence, by type\", \n       subtitle=\"This data is expressed in US dollars, adjusted for inflation.\")\n\n\nAdjust them to the proper font, size and location.\n\n\np<- p +\n  theme(plot.title = element_text(color=\"#5b5b5b\", size=20, family = \"playfair_display\"),\n        plot.subtitle=element_text(color=\"#5b5b5b\", size=15, family = \"roboto\"),\n    plot.title.position = \"plot\")\n\n\nEliminate the title of the legend\n\n\np<- p +\n  theme(legend.title = element_blank())\n\n\nChange the background of the graph.\n\n\np<- p +\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\"))\n\np\n\n\n\nThis graph illustrates the evolution of Artificial Intelligence investments by type over time. In 2021, private investment surpasses Merger and Acquisition funding, a detail not evident in the original graph. This improvement makes the graph considerably more informative as it now displays the investment amounts for each type, enhancing clarity and ease of interpretation.\n\n\n\n",
    "preview": "projects/2023/100430912/100430912_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508332/",
    "title": "Women's Suffrage Across Time",
    "description": "The recreation of a graph illustrating the development of the women's suffrage\nmovement throughout the years.This graph is replicated and then improved by\nadding data describing the development of women's political participation.",
    "author": [
      {
        "name": "Alexandra Salo",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nEurope, Asia-Pacific regions were front-runners in women’s suffrage\nCleaning and inputting the data\nCreating the graph\n\nImprovements to the graph\n\nEurope, Asia-Pacific regions were front-runners in women’s suffrage\nI chose a filled area chart illustrating the women’s suffrage movement globally throughout the years. Here is the original chart by the Pew Research Center:\n\n\n\nFigure 1: Original graph\n\n\n\nYou can find the graph originally here.\nCleaning and inputting the data\nView and input the data set. Set up the packages I will use in this project.\n\n\n#packages and reading data\nlibrary(ggplot2)\nlibrary(readxl)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(countrycode)\nlibrary(ggh4x)\nsysfonts::font_add_google(\"Lato\", family=\"lato\")\n\ndata_right_to_vote_unclean <- read.csv(\"country-field_suffrage-field_right_to_vote.csv\", header = 7)\n\n\nI got my data from this website: https://data.ipu.org/historical-women. Too late into the project, I realised that this data set doesn’t give me the total data that the original graph did, so they must have made their own data set.\nFirstly I need to set my data correct. The data is in groups according to region, which I could not find already readily made in any package, so I had to do it manually. So here I clean and trim the data, while also adding a new column specifying the region.\n\n\n#remove unnecessary rows and columns\ncolnames(data_right_to_vote_unclean) <- data_right_to_vote_unclean[6, ]\ndata_right_to_vote <- data_right_to_vote_unclean[-c(1:6), ]  # Remove the rows\n\n#put all the countries into Regions (as in the original graph)\ndata_right_to_vote <- data_right_to_vote |> \n  mutate(Region = case_when(\n    Country %in% c(\"Angola\", \"Benin\", \"Botswana\", \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cabo Verde\", \n                   \"Gambia (The)\", \"Central African Republic\", \"Chad\", \"Comoros\", \"Democratic Republic of the Congo\",\n                   \"Congo\", \"Côte d'Ivoire\", \"Djibouti\", \"Eritrea\", \"Eswatini\", \"Ethiopia\", \"Gabon\",\n                   \"Gambia\", \"Ghana\", \"Guinea\", \"Equatorial Guinea\", \"Guinea-Bissau\", \"Kenya\", \"Lesotho\", \n                   \"Liberia\", \"Madagascar\", \"Malawi\", \"Mali\", \"Mauritania\", \"Mauritius\", \"Mayotte\", \"Mozambique\", \n                   \"Namibia\", \"Niger\", \"Nigeria\", \"Rwanda\", \"Senegal\", \"Seychelles\", \"Sierra Leone\", \n                   \"Somalia\", \"South Africa\", \"South Sudan\", \"Sudan\", \"United Republic of Tanzania\", \"Togo\", \n                   \"Uganda\", \"Zambia\", \"Zimbabwe\", \"Sao Tome and Principe\") \n    ~ \"Sub-Saharan Africa\",\n    Country %in% c(\"United States of America\", \"Mexico\", \"Canada\") \n    ~ \"North America\",\n    Country %in% c(\"Algeria\", \"Bahrain\", \"Djibouti\", \"Egypt\", \"Iraq\", \"Jordan\", \"Kuwait\", \"Lebanon\", \n                   \"Libya\", \"Mauritania\", \"Morocco\", \"Oman\", \"Qatar\", \"Saudi Arabia\", \"Somalia\", \"Sudan\", \n                   \"Syrian Arab Republic\", \"Tunisia\",  \"United Arab Emirates\", \"Yemen\", \"Islamic State of Afghanistan\", \n                   \"Afghanistan\", \"Iran (Islamic Republic of)\", \"Pakistan\", \"Israel\", \"West Bank and Gaza\") \n    ~ \"Middle East-North Africa\",\n    Country %in% c(\"Aruba\", \"Argentina\", \"Antigua and Barbuda\", \"Bahamas\", \"Belize\", \"Bolivia (Plurinational State of)\", \n                   \"Brazil\", \"Barbados\", \"Chile\", \"Colombia\", \"Costa Rica\", \"Cuba\", \"Cayman Islands\", \n                   \"Dominica\", \"Dominican Republic\", \"Ecuador\", \"Grenada\", \"Guatemala\", \"Guyana\", \"Honduras\", \n                   \"Haiti\", \"Jamaica\", \"Saint Kitts and Nevis\", \"Saint Lucia\", \"Nicaragua\", \"Panama\", \n                   \"Peru\", \"Puerto Rico\", \"Paraguay\", \"El Salvador\", \"Suriname\", \"Turks and Caicos Islands\", \n                   \"Trinidad and Tobago\", \"Uruguay\", \"Saint Vincent and the Grenadines\", \"Venezuela (Bolivarian Republic of)\") \n    ~ \"Latin America-Caribbean\",\n    Country %in% c(\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\", \"Belarus\", \"Belgium\", \n                   \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\", \"Czech Republic\", \"Denmark\", \n                   \"Estonia\", \"Finland\", \"France\", \"Georgia\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\", \n                   \"Ireland\", \"Italy\", \"Kazakhstan\", \"Kosovo\", \"Latvia\", \"Liechtenstein\", \"Lithuania\", \"Luxembourg\", \n                   \"Malta\", \"Republic of Moldova\", \"Monaco\", \"Montenegro\", \"Netherlands\", \"North Macedonia\", \n                   \"Norway\", \"Poland\", \"Portugal\", \"Romania\", \"Russian Federation\", \"San Marino\", \"Serbia\", \"Slovakia\", \n                   \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\", \"Türkiye\", \"Ukraine\", \"United Kingdom\", \"Vatican City\") \n    ~ \"Europe\",\n    Country %in% c(\"Cambodia\", \"Indonesia\", \"Lao People's Democratic Republic\", \"Malaysia\", \"Myanmar\", \n                   \"Japan\",  \"Democratic People's Republic of Korea\", \"Republic of Korea\", \"Singapore\", \n                   \"Philippines\", \"Thailand\", \"Timor-Leste\", \"Viet Nam\", \"China\", \"Mongolia\", \"Armenia\", \n                   \"Azerbaijan\", \"Georgia\", \"Kyrgyzstan\", \"Tajikistan\", \"Uzbekistan\", \"Turkmenistan\" , \n                   \"Bangladesh\", \"Bhutan\", \"India\", \"Maldives\", \"Nepal\", \"Pakistan\", \"Sri Lanka\", \n                   \"Micronesia (Federated States of)\", \"Fiji\", \"French Polynesia\", \"Kiribati\", \n                   \"Marshall Islands\", \"Nauru\", \"New Caledonia\", \"New Zealand\", \"Palau\", \"Solomon Islands\", \n                   \"Tonga\", \"Tuvalu\", \"Vanuatu\", \"Samoa\" ,  \"Papua New Guinea\", \"Wallis and Futuna\") \n    ~ \"Asia-Pacific\",\n    TRUE ~ \"Other\"))\n\n#remove and rename columns\ndata_right_to_vote <-  data_right_to_vote |> \n  relocate(Region, .after = Country) |> \n  relocate(`Women’s right to vote`, .after = Region) |> \n  select(2:4) |> \n  rename(Year = `Women’s right to vote`)\n\n\nHere I widen the data and get a column for each year between 1882 and 2020. During the year that women got the right to vote in each country we assign TRUE.\n\n\nfor(i in 1882:2020) {\n  data_right_to_vote[[as.character(i)]] <- 0\n}\n\nfor(i in 1:nrow(data_right_to_vote)) {\n  data_right_to_vote[[data_right_to_vote[i, \"Year\"]]][i] <- TRUE\n}\n\n\nHere I removing all the duplicates, and keeping the row with the lowest value for year. As this is how I chose to define the data, in some countries they have multiple rows for different stages of women’s suffrage (eg. in 1912 women got the right to vote in local elections and in 1920 national elections).\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  arrange(Country, Year) |> \n  distinct(Country, .keep_all = TRUE) |> \n  select(-Year)\n\n\nThen I bring in the data to be narrow, so we are left with an obervation for every year and country, and the year that women had gotten the first initial taste of suffrage, returns TRUE.\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  pivot_longer( cols = c(\"1882\":\"2020\"), names_to = \"Year\", \n    values_to = \"Right_to_vote\"\n  )\n\n\nHere I transform the data so that for for every year that women had the right to vote, it returns true. It returns false for every year they did not in each country.\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  group_by(Country) |> \n  mutate(Right_to_vote = cumsum(Right_to_vote > 0) > 0) \n\n\nHere I create a new data set that tells us how many countries had given women the right to vote in each region in every year.\n\n\ndata_right_to_vote$Year <- as.numeric(data_right_to_vote$Year)\n\nvoting_data <- data_right_to_vote |> \n  group_by(Year, Region) |> \n  summarize(count_right_to_vote_region = sum(Right_to_vote) ) |> \n  ungroup() \n\n\nCreating the graph\nWe start by lagging the valuables so that we can get the effect of the steps in the graph. Then we create the first step of the graph and get the main graph characteristics. So the filled area of each region, this was surprisingly difficult to get, because I tried using geom_area() and geom_step() in the same function but I couldn’t combine them. Then I was able to achieve the result with the lagging of the values (to get the step like borders).\n\n\n# generate new points (lagged values) to \"hold\" the value until the next step\ndf <- voting_data |> \n  group_by(Region) |> \n  mutate(count_right_to_vote_region = lag(count_right_to_vote_region)) |> \n  na.omit() |> \n  rbind(voting_data) \n\nn <-  ggplot() +\n  geom_area(data = df, aes(Year, count_right_to_vote_region, \n                           fill = factor(Region, levels = c(\"Sub-Saharan Africa\", \"North America\", \"Middle East-North Africa\", \"Latin America-Caribbean\", \"Europe\", \"Asia-Pacific\")))) + \n  scale_fill_manual(values=c(\"#c7c3cc\", \"#756b80\", \"#e5cb84\", \"#edddae\", \"#df996b\", \"#e9ba9b\")) +\n  theme_gray(base_size = 10, base_family=\"lato\") \n\nn\n\n\n\nHere we add on to main characteristics of the graph and add the top line showing total numbers of countries that have given women the right to vote.\n\n\nsumdf <- voting_data |> \n  group_by(Year) |> \n  mutate(sum_count_right_to_vote = sum(count_right_to_vote_region)) |> \n  ungroup()\n  \nn <- n + \n  geom_step(data = sumdf, aes(Year, sum_count_right_to_vote), linewidth = 0.3)\n\nn\n\n\n\nHere I take steps to format the axis and all the details of the axes and the labs. The most difficult part here was figuring out the ticks, but once I found the ggh4x package, it was pretty straight forward.\n\n\nn <- n + theme(legend.position = \"none\", \n               axis.title.x = element_blank(),\n               axis.title.y = element_blank())\n\nx_break <- c(1893, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020 )\nx_break_names <- c(\"1893          \", \"1900\", \"'10\", \"'20\", \"'30\", \"'40\", \"'50\", \"'60\", \"'70\", \"'80\", \"'90\", \"2000\", \"'10\", \"'20\")\n\nminor_breaks_v <- c(1893:2020)\n\n n <-  n  +  \n   scale_x_continuous(\n     name = NULL, \n     breaks = x_break, \n     labels = x_break_names, \n     limits = c(1893, 2020), \n     minor_breaks = seq(1893,2020, by= 1), \n     expand = c(0, 0), \n     guide = \"axis_minor\" )  +\n   scale_y_continuous(\n     limits = c(0, 200), \n     expand = c(0, 0)) +\n   theme(\n     axis.text.x = element_text(size = 6), \n     axis.text.y = element_text(size = 6),\n     axis.ticks = element_line(size = 0.1),\n     axis.ticks.length = unit(7, \"pt\"),\n     ggh4x.axis.ticks.length.minor = rel(0.5)) + \n   labs(\n  title = \"Europe, Asia-Pacific regions were front-runners in\\nwomen's suffrage\", \n  subtitle = \"Number of nations allowing women the right to vote in national\\nelections, by year\", \n  caption = \"Note: Women in Afghanistan had the right to vote beginning 1929, but this right\\nwas taken away several times before being restored in 2004. Saudi Arabia and\\nBrunei do not hold national elections, and Hong Kong and Macau do not participate\\nin China's elections. Women vote in local elections in all 4 areas.\\nSource: Pew Research Center analysis of government publications, historical\\ndocuments from organizations like the United Nations and the Inter-Parliamentary\\nUnion, and various news reports to determine women's enfranchisement history in\\n198 countries and self-administering territories.\") +\n   geom_hline(\n     yintercept = 0, color = \"black\", size= 0.2) \n \n n\n\n\n\nHere I further adjust the formatting of the graph, so that the titles and caption matched the original as closely as possible. I chose the font Lato from google fonts to achieve this effect.\n\n\nn1 <-  n +\ntheme(\n  plot.title = element_text(face = \"bold\", \n                            size = 13, \n                            hjust = 0, \n                            vjust = 1.5, \n                            lineheight = 1), \n  plot.title.position = \"plot\",\n  plot.subtitle = element_text(\n    face = \"italic\", \n    color = \"#8f9092\", \n    size = 11, \n    hjust = 0, \n    vjust = 1.8, \n    lineheight = 1), \n  plot.caption = element_text(\n    color = \"#8f9092\", \n    size = 8, \n    hjust = 0), \n  plot.caption.position = \"plot\"\n  )\n\nn1\n\n\n\nHere I adjust the background formatting and the clipping of the graph. I turn off clipping in the coord_fixed, to allow my future annotations to continue past the limits.\n\n\nn2 <- n1 + theme(\n  panel.background = element_rect(fill = \"white\"),  \n  panel.grid.major.y = element_line(color = \"gray\", linetype = \"dotted\"), \n  panel.grid.minor.y = element_blank(),  # Remove minor grid lines)\n  text = element_text(family = \"lato\"), \n  aspect.ratio = 1.4\n  ) + \n  coord_fixed(0.8, clip = \"off\") \nn2\n\n\n\nHere I add the annotations for each region.\n\n\n#Africa label\nn3 <-  n2 + annotate(\n    \"text\", \n    x = 1998,  # X-coordinate\n    y = 145,   # Y-coordinate\n    label = \"Sub-Saharan Africa\",  # Text to display\n    size = 2,  # Text size\n    color = \"#6f6673\"  # Text color\n  ) \n#North America\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 2012,  \n    y = 130,  \n    label = \"North America\",  \n    size = 2, \n    color = \"#4c4852\"  \n  )\n\n#Middle East- North Africa\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 2014,  \n    y = 118,   \n    label = \"Middle East-\", \n    size = 2,  \n    color = \"#88723b\") + annotate(\n    \"text\", \n    x = 2014, \n    y = 112,   \n    label = \"North Africa\",\n    size = 2,  \n    color = \"#88723b\")\n    \n#Latin America- Caribbean\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 1995,  \n    y = 96,   \n    label = \"Latin America-\", \n    size = 2,  \n    color = \"#88723b\" , \n    vjust = 2\n    ) + annotate(\n    \"text\", \n    x = 1995, \n    y = 90,   \n    label = \"Caribbean\", \n    size = 2,  \n    color = \"#88723b\" , \n    vjust = 2\n    ) \n\n#Europe\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 1980,  \n    y = 47,   \n    label = \"Europe\",  \n    size = 2,  \n    color = \"#965a31\"  \n  )\n\nn3\n\n\n\nHere I add the annotations (point and text) for y=1 and y=73 (the final total value).\n\n\nn4 <- n3 +\n  geom_point(data = subset(data_right_to_vote, Year == 2020), aes(x = 2020, y = 173), color = \"black\", size = 0.4) +\n  geom_text(data = subset(data_right_to_vote, Year == 2020),\n            aes(label = \"Total\\n 173\", x= 2014, y=166), \n            vjust = -1.2, hjust = 0, size = 2, lineheight = 1) +\n  geom_point(data = subset(data_right_to_vote, Year == 1893), aes(x = 1893, y = 2), color = \"black\", size = 0.4) +\n  geom_text(data = subset(data_right_to_vote, Year == 1893),\n            aes(label = \"1\", x= 1893, y=1), \n            vjust = -1, hjust = 0.5, size = 2, lineheight = 1) + \n  geom_segment(aes(x = 1893, y =220, xend = 2020, yend = 220,\n               color = \"black\", size = 1))  \n\n# adding last annotation, Asia-Pacific\nn5 <-  n4 + annotate(\n    \"text\", \n    x = 1990,  \n    y = 15,   \n    label = \"Asia-Pacific\",  \n    size = 2,  \n    color = \"#b97648\" )\n\n\nAnd I am finally led to the final graph, which is as close as I can get it to the original!\n\n\nn5\n\n\n\nImprovements to the graph\nOriginally I considered different ways to improve the graph. I made some different iterations of the graph, most notably trying to make the graph proportional to each region. But once I had come to the main idea, the overall outlook and shape looked quite similar, and the message of the graph got a little lost in my opinion. It was not clear what the graph’s message was in this form I had experimented with.\nTo me, the main information the graph is trying to convey is when and which general regions were at the forefront of the women’s suffrage movement. I wanted to maintain this, but add another element, showing the interaction between women’s suffrage and women’s political participation (in the form of % of women in politics).\nSo I was able to obtain data on the amount of women in parliament/ highest chambers of all nations. Here I read and format the data to be appropriate for my use.\n\n\ndata_women_in_parliament_unclean <- read_xlsx(\"women_in_parliament-historical_database-1945_to_2018.xlsx\")\n\ndata_women_in_parliament <-  data_women_in_parliament_unclean |> \n  select(1,4,9) |> \n  rename(Women_in_parliament = '% Of Women in Chamber') \n\ndata_women_in_parliament$Women_in_parliament <- as.numeric(data_women_in_parliament$Women_in_parliament)\n\n\nOriginally I wanted to explore how the average % of women in their nations’ highest chambers developed over time. However, since I had the scale 0-200 in use for the y-axis, I decided to change my approach to avoid a dual axis.\nI decided to explore and graph the amount of nations having 20% or more of women represented in their highest chamber. Here I mutate the data to find the number of countries each year with 20% or over.\n\n\n#finding the amount of countries with over 20% women in parliament for each year\nimproved_data <-  data_right_to_vote |> \n  left_join(data_women_in_parliament, by = c(\"Country\", \"Year\"))\n\nimproved_data <-improved_data |> \n  mutate(\n    more_20_perc = case_when\n    (Women_in_parliament >= 0.2 ~ TRUE,\n      Women_in_parliament < 0.2 ~FALSE, \n      is.na(Women_in_parliament) ~ NA))\n\nimproved_data <- improved_data |> \n  group_by(Year) |> \n  mutate(count_20_perc = sum(more_20_perc, na.rm = TRUE))\n\n\nHere I add the line to visualize the amount of countries having more than 20% female highest chambers.\n\n\ng <- n4\n\ng <- g + \n  geom_step(data = improved_data, aes(Year, count_20_perc), size = 0.4)\ng\n\n\n\nSince the data only goes to 2018, I changed the axes slightly. Then I also go on to update the other information in the graph, for eg. the titles, captions etc.\n\n\nx_break <- c(1893, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2018 )\nx_break_names <- c(\"1893          \", \"1900\", \"'10\", \"'20\", \"'30\", \"'40\", \"'50\", \"'60\", \"'70\", \"'80\", \"'90\", \"2000\", \"'10\", \"2018\")\n\ng <-  g  +  \n   scale_x_continuous(name = NULL, breaks = x_break, labels = x_break_names, limits = c(1893, 2018), minor_breaks = minor_breaks_v, expand = c(0, 0) ) +\n   scale_y_continuous(limits = c(0, 200), expand = c(0, 0)) +\n  theme(axis.text.x = element_text(size = 6), \n         axis.text.y = element_text(size = 6),\n         axis.ticks = element_line(size = 0.1),\n         axis.ticks.length = unit(7, \"pt\"),\n         ggh4x.axis.ticks.length.minor = rel(0.5))\n\ng <-  g + labs(\n  title = \"Europe, Asia-Pacific regions were front-runners in\\nwomen's suffrage, women still underrepresented in politics\", \n  subtitle = \"Number of nations allowing women the right to vote in national elections,\\nand number of nations with +20% of women in their highest chamber, by year\", \n  caption = \"Note: Women in Afghanistan had the right to vote beginning 1929, but this right was taken\\naway several times before being restored in 2004. Saudi Arabia and Brunei do not hold\\nnational elections, and Hong Kong and Macau do not participate in China's elections. Women\\nvote in local elections in all 4 areas. Source: IPU Parline, Global data on national\\nparliaments- historical data on women.\"\n)\n\ng\n\n\n\nFinally I add the annotations and labels to this to illustrate the addition better.\n\n\ng <- g +\n  geom_point(data = subset(voting_data, Year == 2018), aes(x = 2018, y = 173), color = \"black\", size = 0.7) +\n  geom_point(data = subset(voting_data, Year == 2016), aes(x = 2016.5, y = 51), color = \"black\", size = 1) + \n  geom_text(data = subset(voting_data, Year == 2016), aes(label = \"Maximum\\n51 \", x = 2016.5, y = 60), size = 2, lineheight = 1) +\n  annotate(\n    \"text\",\n    x = 2018, y = 20,\n    label = \"  Number of countries\\n  with their highest\\n  chamber consisting\\n of + 20% women\",\n    hjust = 0, vjust = 0.5,\n    color = \"#8f9092\", size = 3) + \n  annotate(\n    \"text\", \n    x = 1975,  \n    y = 12,   \n    label = \"Asia-Pacific\",  \n    size = 2,  \n    color = \"#b97648\" )\n\n\nFinally we have the final graph with improvements.\n\n\ng\n\n\n\n\n\n\n",
    "preview": "projects/2023/100508332/100508332_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 998
  },
  {
    "path": "projects/2023/100516517/",
    "title": "Bipartisanship Unveiled: The Evolution of Recent History in the Spanish Congress",
    "description": "Replication and alternative rendition of a streamgraph sourced from El Orden Mundial,\nutilizing data on congressional deputies available on the official website of the Spanish Congress.",
    "author": [
      {
        "name": "Candela Gómez-Blanco",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nPreparing the data base\nCollecting the data\nCleaning the database\nDefinite graph data base\n\nReplication: stream_graph\nSetting the actual colors\nAnnotations\n\nA different representation of the data\nLimitations of the original graph\nAlternative graph\n\n\nIntroduction\nThis project is based on the graph posted in the article “El desfile político en la democracia española” (The Political Parade in Spanish Democracy), published by El Orden Mundial in 2023. In this piece, the authors delve into the evolution of the Spanish Congress of Deputies throughout its democratic history. Specifically, they analyze the distribution of seats among major political parties and ideologies, emphasizing the development of bipartisanship from the 1977 elections to the present.\nThe article includes the following graph, which effectively illustrates this evolution. At a glance, it becomes evident that, since the first democratic elections, the composition of the Congress has been characterized by a dominant two-party system and consistent support for peripheral nationalist parties. This trend is largely influenced by an electoral system that favors major parties in smaller constituencies, to the detriment of minority formations at the national level.\nOriginal graphI encountered this graph worth replicating, being a comprehensive representation of the data. Given that it seemed to encapsulate a significant amount of information effectively, suggesting improvements could pose a considerable challenge.\nPreparing the data base\nCollecting the data\nPreparing the database involved collecting data on the deputies who have served in Congress over the years. I obtained this information from the official website of the Congress of Deputies (https://www.congreso.es/es/opendata/diputados) by downloading the Excel files corresponding to the 15 legislatures. Combining the data from each of these legislatures into a unified Excel file, I stored it in this project’s Git-Hub folder. The subsequent task involved cleaning and preparing this database.\n\n\n#Load these libraries\n\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(lubridate)\nlibrary(stringr)\n\n#Read the database\ngraph_db<-read_xlsx(\"terms-unified.xlsx\")\n\n\nCleaning the database\nCleaning the database involved making adjustments over the original dataset, which comprised 6470 rows, each representing an individual deputy in Congress, and 9 columns containing specific deputy-related information.\nThe primary task, and the most challenging aspect of the entire assignment, was determining the characteristics our database needed to have to enable the creation of our graph. This involved identifying the necessary variables and how the data should be organized. Our interest did not lie in individualized deputy information, but rather in aggregating deputies based on their political affiliations. Additionally, we needed to ascertain the distribution of deputies for each year in which general elections were held. Once we clarified our objective, these were the next steps and encountered difficulties:\nSelecting the essential variables was required to achieve this goal. That is, we needed the name of the deputies (for an individualized register of each record), the political party to which each deputy belonged, and the start and end dates of their tenure as deputies.\nIt’s worth noting that some deputies conclude their tenure before the legislature ends, while others assume office midway through the term. Consequently, none of the available variables in the original database served our graph’s purpose. To address this, after determining the precise dates of each general election, a new column labeled “Elections” was created, narrowing down the dates to those in which general elections were celebrated.\nFurthermore, another variable called “num_deputies” was established. This variable calculated the cumulative count of deputies per political party. Each new enrollment contributed +1 in the most recent election, while each termination date deducted -1 in the subsequent legislature, enabling a comprehensive tally of deputies per political party over time.\n\n\nclean_data <- graph_db |>\n  # Selecting the variables of interest and converting to date\n  select(NOMBRE, FORMACIONELECTORAL, FECHAALTA, FECHABAJA) |>\n  mutate(across(c(FECHAALTA, FECHABAJA), ymd)) |> \n  # Removing duplicate values (changes in parliamentary groups)\n  distinct() |> \n  # Pivoting the date, sorting, and converting to year, removing NAs\n  tidyr::pivot_longer(c(FECHAALTA, FECHABAJA), values_to = \"FECHA\") |> \n  arrange(FECHA) |> \n  mutate(\n    Elections = case_when(\n      FECHA >= as.Date(\"1977-06-15\") & FECHA < as.Date(\"1979-03-01\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1977-06-15\"),\n      FECHA >= as.Date(\"1977-06-15\") & FECHA < as.Date(\"1979-03-01\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1979-03-01\"),\n      FECHA >= as.Date(\"1979-03-01\") & FECHA < as.Date(\"1982-10-28\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1979-03-01\"),\n      FECHA >= as.Date(\"1979-03-01\") & FECHA < as.Date(\"1982-10-28\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1982-10-28\"),\n      FECHA >= as.Date(\"1982-10-28\") & FECHA < as.Date(\"1986-06-22\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1982-10-28\"),\n      FECHA >= as.Date(\"1982-10-28\") & FECHA < as.Date(\"1986-06-22\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1986-06-22\"),\n      FECHA >= as.Date(\"1986-06-22\") & FECHA < as.Date(\"1989-10-29\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1986-06-22\"),\n      FECHA >= as.Date(\"1986-06-22\") & FECHA < as.Date(\"1989-10-29\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1989-10-29\"),\n      FECHA >= as.Date(\"1989-10-29\") & FECHA < as.Date(\"1993-06-06\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1989-10-29\"),\n      FECHA >= as.Date(\"1989-10-29\") & FECHA < as.Date(\"1993-06-06\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1993-06-06\"),\n      FECHA >= as.Date(\"1993-06-06\") & FECHA < as.Date(\"1996-03-03\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1993-06-06\"),\n      FECHA >= as.Date(\"1993-06-06\") & FECHA < as.Date(\"1996-03-03\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1996-03-03\"),\n      FECHA >= as.Date(\"1996-03-03\") & FECHA < as.Date(\"2000-03-12\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1996-03-03\"),\n      FECHA >= as.Date(\"1996-03-03\") & FECHA < as.Date(\"2000-03-12\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2000-03-12\"),\n      FECHA >= as.Date(\"2000-03-12\") & FECHA < as.Date(\"2004-03-14\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2000-03-12\"),\n      FECHA >= as.Date(\"2000-03-12\") & FECHA < as.Date(\"2004-03-14\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2004-03-14\"),\n      FECHA >= as.Date(\"2004-03-14\") & FECHA < as.Date(\"2008-03-09\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2004-03-14\"),\n      FECHA >= as.Date(\"2004-03-14\") & FECHA < as.Date(\"2008-03-09\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2008-03-09\"),\n      FECHA >= as.Date(\"2008-03-09\") & FECHA < as.Date(\"2011-11-20\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2008-03-09\"),\n      FECHA >= as.Date(\"2008-03-09\") & FECHA < as.Date(\"2011-11-20\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2011-11-20\"),\n      FECHA >= as.Date(\"2011-11-20\") & FECHA < as.Date(\"2015-12-20\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2011-11-20\"),\n      FECHA >= as.Date(\"2011-11-20\") & FECHA < as.Date(\"2015-12-20\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2015-12-20\"),\n      FECHA >= as.Date(\"2015-12-20\") & FECHA < as.Date(\"2016-06-26\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2015-12-20\"),\n      FECHA >= as.Date(\"2015-12-20\") & FECHA < as.Date(\"2016-06-26\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2016-06-26\"),\n      FECHA >= as.Date(\"2016-06-26\") & FECHA < as.Date(\"2019-04-28\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2016-06-26\"),\n      FECHA >= as.Date(\"2016-06-26\") & FECHA < as.Date(\"2019-04-28\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2019-04-28\"),\n      FECHA >= as.Date(\"2019-04-28\") & FECHA < as.Date(\"2019-11-10\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2019-04-28\"),\n      FECHA >= as.Date(\"2019-04-28\") & FECHA < as.Date(\"2019-11-10\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2019-11-10\"),\n      FECHA >= as.Date(\"2019-11-10\") & FECHA < as.Date(\"2023-07-23\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2019-11-10\"),\n      FECHA >= as.Date(\"2019-11-10\") & FECHA < as.Date(\"2023-07-23\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2023-07-23\"),\n      FECHA >= as.Date(\"2023-07-23\") &\n        name == \"FECHAALTA\" ~ as.Date(\"2023-07-23\"),\n      FECHA >= as.Date(\"2023-07-23\") &\n        name == \"FECHABAJA\" ~ as.Date(\"2023-07-23\")\n    )\n  ) |>\n  na.omit() |>\n  # Cumulative sum by electoral formation: +1 for STARTDATE, -1 for ENDDATE\n  group_by(FORMACIONELECTORAL) |> \n  mutate(num_deputies = cumsum(if_else(name == \"FECHAALTA\", 1, -1))) |>   \n  # We keep the last value per date and party\n  select(Elections, FORMACIONELECTORAL, num_deputies) |> \n  group_by(Elections, FORMACIONELECTORAL) |> \n  slice_tail() |>\n  # Removing transient records, where the total sum per date is less than 340\n  group_by(Elections) |> \n  filter(sum(num_deputies) > 300) |>\n  ungroup() |> \n  # Removing zeros\n  filter(num_deputies > 0)\n\n\nWithin the electoral formations, there were inconsistencies in the representation of party names. For instance, parties like VOX, Junts, or CiU, among others, were written in different formats regarding capitalization. Additionally, some parties were represented by their acronyms (such as “UP”) in some instances and by their full names in others for (“Unidas Podemos”). These variations needed standardization. Moreover, there were various coalitions of parties that, for graphing purposes, needed to be considered as deputies of only one party. For instance, the acronym “PSOE-A” should be counted as deputies of the PSOE party. To streamline this process and avoid addressing each party individually, the ‘str_detect’ function was used. However, certain party names shared letters and the order of some acronyms, such as ‘UP’ and ‘UPyD.’ Therefore, specific recategorizations were established without employing the previously mentioned function.\n\n\nclean_data <- clean_data |> \n  mutate(recat = case_when(\n    FORMACIONELECTORAL == \"CD\" ~ \"UCD\",\n    FORMACIONELECTORAL == \"UP\" ~ \"PODEMOS\",\n    FORMACIONELECTORAL == \"CP\" ~ \"PP\",\n    FORMACIONELECTORAL == \"PSUC\" ~ \"Otros catalanes\",\n    str_detect(FORMACIONELECTORAL, \"CIU|CiU|CDC|UDC\") ~ \"CiU\",\n    str_detect(FORMACIONELECTORAL, \"Junts|JUNTS\") ~ \"Junts\",\n    str_detect(FORMACIONELECTORAL, \"ERC\") ~ \"ERC\",\n    str_detect(FORMACIONELECTORAL, \"PODEMOS|POD|EN COMÚ|ECP\") ~ \"PODEMOS\",\n    str_detect(FORMACIONELECTORAL, \"MÁS PAÍS\") ~ \"Más País\",\n    str_detect(FORMACIONELECTORAL, \"PCE\") ~ \"PCE\",\n    str_detect(FORMACIONELECTORAL, \"IU\") ~ \"IU\",\n    str_detect(FORMACIONELECTORAL, \"PSOE|PSE|PSC\") ~ \"PSOE\",\n    str_detect(FORMACIONELECTORAL, \"US\") ~ \"US\",\n    str_detect(FORMACIONELECTORAL, \"SUMAR\") ~ \"SUMAR\",\n    str_detect(FORMACIONELECTORAL, \"Cs\") ~ \"Cs\",\n    str_detect(FORMACIONELECTORAL, \"CDS\") ~ \"CDS\",\n    str_detect(FORMACIONELECTORAL, \"UCD\") ~ \"UCD\",\n    str_detect(FORMACIONELECTORAL, \"UPyD\") ~ \"UPyD\",\n    str_detect(FORMACIONELECTORAL, \"AP|PP\") ~ \"PP\",\n    str_detect(FORMACIONELECTORAL, \"Vox|VOX\") ~ \"VOX\",\n    str_detect(FORMACIONELECTORAL, \"PNV\") ~ \"PNV\",\n    str_detect(FORMACIONELECTORAL, \"HB\") ~ \"HB\",\n    str_detect(FORMACIONELECTORAL, \"EH Bildu\") ~ \"EH Bildu\",\n    str_detect(FORMACIONELECTORAL, \"CC\") ~ \"CC\",\n    TRUE ~ \"Otros\"\n  ))\n\n\nDefinite graph data base\nTo proactively manage potential errors I might face, I opted to create a new database at this stage, which will be the definitive one used for our graph.\nI organized the data by grouping it based on the ‘Elections’ and ‘recat’ columns. Then, I summarized the data by calculating the total number of deputies (‘num_deputies’ column) for each category and stored this information in a new column named ‘total_deputies’.\nTwo crucial adjustments were necessary to ensure the graph’s accurate representation:\nTransforming the ‘recat’ column into a factor specifying a certain order for its levels. This order was structured to mirror the original graph’s arrangement: regional parties on the left, followed by a progressive ideological sequence from left-leaning parties to right-leaning formations.\nTypically, graphs displaying an evolving trend have years or dates plotted along the X-axis. However, our graph’s design was oriented differently with dates on the Y-axis. Attempting to flip the graph using ‘coord_flip’ resulted in an inverted orientation, placing the most recent years at the bottom. To resolve this, I converted the dates into decimal values, facilitating the reversal of their order. This adjustment ensured that the ticks representing election dates on the Y-axis were proportionally spaced according to the time between each election.\n\n\n#Creating the final graph database\ngraph_base <- clean_data |> \n  group_by(Elections, recat) |> \n  summarise(total_deputies = sum(num_deputies)) |> \n  ungroup() \n\n#Ordering the political parties by their ideology\ngraph_base$recat <- factor(graph_base$recat,\n                           levels = c(\"VOX\", \"PP\", \"Cs\", \"UCD\", \"CDS\", \n                                      \"UPyD\", \"US\", \"PSOE\", \"SUMAR\", \n                                      \"Más País\", \"PODEMOS\", \"PCE\", \n                                      \"IU\", \"Otros catalanes\", \"CiU\", \n                                      \"ERC\", \"Junts\", \"PNV\", \"HB\", \n                                      \"EH Bildu\", \"CC\", \"Otros\"))\n\n#Adding the DECIMAL_DATE column\ngraph_base$DECIMAL_DATE <- decimal_date(graph_base$Elections)\nfechas_unicas <- unique(graph_base$DECIMAL_DATE)\n\n\nReplication: stream_graph\nThe graph we aim to replicate is a stream graph. These visualizations demonstrate changes in the composition and distribution of multiple variables over time. They prove useful in depicting time series data and how the distribution of different categories or groups within these series evolves over time. In this instance, it’s a proportional stream graph, meaning the width of the bands varies based on each category’s proportion at a specific moment in time. Hence, although the number of deputies in the Congress can fluctuate between 300 and 400, our graph will have a constant width, because it considers the proportion of deputies from each electoral party concerning the total number of deputies at any given time.\nThe following code accomplishes the following:\nCreates the proportional flow graph using the “ggplot2” package.\nFlips the graph to make it vertical.\nAdjusts the axis limits to accommodate annotations.\nEstablishes themes and styles, refining the appearance of the graph, including titles, subtitles, and axis formatting to mimic the original graph.\n\n\n#Loading needed libraries\nlibrary(ggstream)\nlibrary(ggplot2)\n\n# Creating a ggplot object with the new database\n\ngraph <- ggplot(data = graph_base, aes(x = DECIMAL_DATE, y = total_deputies)) +\n  # Adding a stream plot with recat as fill and proportional type\n  geom_stream(aes(fill = recat), type = \"proportional\") +\n  # Formatting y-axis labels as percentages\n  scale_y_continuous(labels = scales::percent_format(), breaks = NULL) +\n  # Formatting x-axis labels and reversing the scale\n  scale_x_continuous(trans = \"reverse\", \n                     breaks = fechas_unicas,\n                     labels = function(x) floor(x)) + \n  # Flipping coordinates to create a vertical plot\n  coord_flip(ylim = c(0, 1.2), \n             xlim = c(2023.556, 1975)) +  \n  # Adding axis labels and titles\n  labs(x = \"\", y = \"350 diputados\", fill = \"Orientación ideológica\",\n       title = \"**El desfile político en la democracia española**\",\n       subtitle = \"**Composición del Congreso (1977-2023)**\",\n       caption = paste(\"**Autor:**\", \"Álvaro Merino (2023)\", sep = \"<br>\")) +\n  # Modifying the appearance of various plot elements using theme settings\n  theme(\n    plot.title = ggtext::element_markdown(size = 10, color = \"#272727\"), \n    plot.title.position = \"plot\", \n    plot.subtitle = ggtext::element_markdown(size = 9, color = \"#6A6A6A\"), \n    plot.caption = ggtext::element_markdown(size = 4, color = \"#6A6A6A\"), \n    axis.ticks.y = element_line(size = 0.5, color = \"#6A6A6A\"), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.text.y = element_text(size = 4, color = \"#6A6A6A\"),\n    axis.title.x = element_text(size = 5, color = \"#6A6A6A\", hjust = 0.43), \n    panel.grid.major.x = element_blank(),\n    aspect.ratio = 4/2,\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"none\"\n  )\n\ngraph\n\n\n\nSetting the actual colors\nTo precisely establish the same colors as the target graph, I utilized the eyedropper tool available in Paint to extract the exact code for each color. Then, I manually assigned specific colors to each of the categories represented in the graph.\n\n\ngraph <- graph + \n  scale_fill_manual(values = c(\n    \"VOX\" = \"#1F3D71\",\n    \"PP\" = \"#4D76BF\",\n    \"Cs\" = \"#E89433\",\n    \"UCD\" = \"#E6A55B\",\n    \"CDS\" = \"#C98B2C\",\n    \"UPyD\" = \"#FFC38D\",\n    \"US\" = \"#E2706D\",\n    \"PSOE\" = \"#BE4D4C\",\n    \"SUMAR\" = \"#A61918\",\n    \"PODEMOS\" = \"#D07F7F\",\n    \"PCE\" = \"#650904\",\n    \"Más País\" = \"#650904\",\n    \"IU\" = \"#9B2E33\",\n    \"CiU\" = \"#EAC659\",\n    \"Junts\" = \"#EAC659\",\n    \"ERC\" = \"#DDAB0B\",\n    \"Otros catalanes\" = \"#DDAB0B\",\n    \"PNV\" = \"#46862C\",\n    \"HB\" = \"#ABD894\",\n    \"EH Bildu\" = \"#A1B944\",\n    \"CC\" = \"#3B3D40\",\n    \"Otros\" = \"#E0E3E0\"\n  ))\n\ngraph\n\n\n\nAnnotations\nThe chosen graph required numerous annotations to provide a comprehensive representation. To achieve this, the ggannotate library was employed. This library significantly simplifies the process of placing labels and annotations on ggplot2-generated graphs. One of its notable advantages is its capability to swiftly and easily insert labels. With ggannotate, we can position labels precisely which expedites the process while ensuring accurate placement of annotations.\nParty labels\nThe initial step involved establishing labels linked to the names of electoral formations and their respective segments.\n\n\n# remotes::install_github(\"mattcowgill/ggannotate\")\nlibrary(ggannotate)\n#For adding each annotation run: ggannotate(graph)\n\ngraph <- graph + \n  geom_text(\n    data = data.frame(x = 1981.458, y = 0.638, label = \"UCD\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.116, y = 0.912, label = \"VOX\"), \n    mapping = aes(x = x, y = y, label = label), \n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1986.226, y = 0.912, label = \"Alianza \\n Popular\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1989.632, y = 0.850, label = \"Coalición \\n Popular\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2011.771, y = 0.7889, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1997.00, y = 0.788, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1982.820, y = 0.19, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2005.130, y = 0.310, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1994.571, y = 0.15, label = \"IU\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1979.2, y = 0.1, label = \"PCE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2021.989, y = 0.3, label = \"Sumar\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, angle = 30L, colour = \"white\", \n    fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2015.177, y = 0.23, \n                      label = \"Podemos y \\n confluencias\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2019.321, y = 0.465, label = \"Más País\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2019.4, xend = 2019.4, y = 0.41, yend = 0.39, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 1987.078, y = 0.381, label = \"CDS\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1987.2, xend = 1987.2, y = 0.43, yend = 0.50, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1978.1, y = 0.15, label = \"Unidad \\n Socialista\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 1978.1, xend = 1978.1, y = 0.2, yend = 0.25, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 2016.938, y = 0.65, label = \"Ciudadanos\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, angle = -105L, colour = \"white\", \n    fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2010.388, y = 0.343, label = \"UPyD\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 2010.388, xend = 2010.388, y = 0.41, yend = 0.475, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1989, y = 0.139, \n                      label = \"PNV \\n Herri Batasuna\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, hjust = 0L, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1988.6, xend = 1988.6, y = 0.05, yend = 0.12, \n           color = \"white\", size = 0.1) +\n  annotate(\"segment\", x = 1989.5, xend = 1989.5, y = 0.043, yend = 0.12, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 1998.173, y = 0.192, label = \"Coalición Canaria\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, hjust = 0L, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1998.18, xend = 1998.18, y = 0.024, yend = 0.17, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 2004.546, y = 0.166, label = \"ERC\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2004.65, xend = 2004.65, y = 0.06, yend = 0.13, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 2017.8, y = 0.16, \n                      label = \"Junts \\n ERC \\n PNV \\n Bildu\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2016.6, xend = 2016.6, y = 0.055, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2017.4, xend = 2017.4, y = 0.048, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2018.2, xend = 2018.2, y = 0.03, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2019, xend = 2019, y = 0.02, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1992.154, y = 0.1, label = \"CiU\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)\n\ngraph\n\n\n\nX and Y axes\nFollowing that, annotations related to the X and Y axes were established, since they had a specific format that wasn’t available in any predefined theme.\n\n\ngraph <- graph + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 2023.556, \n                      ymin = -0.06, ymax = -0.06),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.67, xmax = 2024.67, ymin = 0, ymax = 1),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.4, xmax = 2024.67, ymin = 0, ymax = 0), \n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.4, xmax = 2024.67, ymin = 1, ymax = 1), \n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)\n\ngraph\n\n\n\nThird Axis: Presidencies\nThe third axis, parallel to the Y-axis, was crafted using annotations. This axis informs about the succession of presidencies over the years, and was done by connecting points with segments and specifying the president’s name and their affiliated party.\n\n\ngraph <- graph + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 1980.5, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1977.425, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1980.5, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  geom_rect(\n    data = data.frame(xmin = 1981, xmax = 1982.322, ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1981, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1982.322 , y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 1982.822, xmax = 1995.669, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1982.822, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 1995.669 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1996.169, xmax = 2003.699, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1996.169, y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2003.699 , y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2004.199, xmax = 2011.385, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2004.199, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2011.385 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2011.885, xmax = 2018.821, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2011.885, y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2018.821 , y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2019.321, xmax = 2023, ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2019.321, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2023 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  geom_text(\n    data = data.frame(x = 1978.5, y = 1.094, label = \"Adolfo\\nSuárez\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.532, y = 1.1, \n                      label = \"Leopoldo\\nCalvo-Sotelo\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1988.61, y = 1.1, label = \"Felipe\\nGonzález\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1999.235, y = 1.1, label = \"José María\\nAznar\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2007.202, y = 1.1, \n                      label = \"José Luis\\nRodríguez\\nZapatero\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2014.991, y = 1.1, label = \"Mariano\\nRajoy\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.833, y = 1.1, label = \"Pedro\\nSánchez\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)\n\ngraph \n\n\n\nLegend\nLastly, since the colors of each stream had to be manually defined, there wasn’t an automated way for R to show the color transitions based on the ideological orientation in which the parties of the graph are organized. To mimic these color transitions in the legend, I assembled small squares representing the colors I used.\n\n\ngraph <- graph +  \n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.06, ymax = -0.05),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#650904\", alpha = 1, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.05, ymax = -0.04),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#A61918\", alpha = 1 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.04, ymax = -0.03),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#9B2E33\", alpha = 0.9, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.03, ymax = -0.02),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#BE4D4C\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.02, ymax = -0.01),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#D07F7F\", alpha = 0.7, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.01, ymax = 0),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E2706D\", alpha = 0.4, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.01, label = \"Izquierda\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.15, ymax = 0.17),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#C98B2C\", alpha = 1, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.17, ymax = 0.19),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E89433\", alpha = 1 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.19, ymax = 0.21),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E6A55B\", alpha = 0.9, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.22, label = \"Centro\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.34, ymax = 0.37),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#1F3D71\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.37, ymax = 0.40),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#4D76BF\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.41, label = \"Derecha\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.55, ymax = 0.58),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#DDAB0B\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.58, ymax = 0.61),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#EAC659\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.62, label = \"Partidos\\ncatalanes\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE) +\n  geom_rect(data = data.frame(xmin = 1975.4, xmax = 1976, \n                              ymin = 0.76, ymax = 0.78),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#46862C\", alpha = 0.7, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.78, ymax = 0.8),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#A1B944\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.8, ymax = 0.82),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#ABD894\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.83, label = \"Partidos\\nvascos\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE) +\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.95, ymax = 0.98),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#3B3D40\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.99, \n                      label = \"Otros partidos\\nregionales\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE)\n\ngraph\n\n\n\nA different representation of the data\nLimitations of the original graph\nGeom_streams are a very eye-catching option and, truth be told, the chosen plot it is a quite good representation of the data meant for graphical visualization. However, a limitation I would like to highlight is that it seems that the beauty of the composition is put before the accuracy of the data. For example, if we take a look in the original graph to the emergence of the parties that appeared in the last decade we see how:\nVox seems to gradually appear in the congress since 2016 in the geom_streams plot, when in reality, it gained parliamentary representation in 2019.\nSimilarly, SUMAR gained parliamentary seats in 2023, yet in the plot, it seems to have been present in the congress since 2019.\nIn the same way, Podemos gained representation in 2014, not 2011.\nAlternative graph\nTo counteract these discrepancies, I opted for an alternative representation using a line graph. While it might lack the visual appeal of geom_streams, it offers a more accurate portrayal. This line graph provides exact deputy counts for each party, accurately displaying the appearance and disappearance of parties over time.\nThe previous graph showcased the constant number of seats secured by regional parties over the years studied. To ensure clarity and concentrate on parties taking turns in power, regional parties were deliberately excluded to eliminate unnecessary noise. This strategy focuses attention on parties that alternate in power, enabling a more streamlined analysis of the evolving trends in bipartisanship over the years.\n\n\n#Selected parties\npartidos_seleccionados <- c(\"VOX\", \"PP\", \"Cs\", \"UCD\", \"CDS\", \"UPyD\",\n                            \"US\", \"PSOE\", \"SUMAR\", \"PODEMOS\",  \"PCE\",\n                            \"Más País\", \"IU\")\n\ngraph_base_filtered <- graph_base |> \n  filter(recat %in% partidos_seleccionados)\n\n#Alternative graph\np<- ggplot(graph_base_filtered, aes(DECIMAL_DATE, total_deputies)) +\n  scale_x_continuous(breaks = fechas_unicas, \n                     labels = function(x) floor(x), \n                     expand = c(0,0)) +\n  scale_y_continuous(breaks = c(176), \n                     expand = c(0,0), \n                     name = \"Diputados\") +\n  geom_line(aes(color = recat), linewidth = 1.5) +\n  labs(x = \"\", y = \"\", fill = \"Orientación ideológica\",\n       title = \"**Evolución del bipartidismo en la democracia española**\",\n       subtitle = \"**Composición del Congreso (1977-2023)**\",\n       caption = paste(\"**Autora:**\", \"Candela Gómez Blanco (2023)\", \n                       sep = \"<br>\")) +\n  theme(\n    plot.title = ggtext::element_markdown(size = 13, color = \"#272727\"),\n    plot.subtitle = ggtext::element_markdown(size = 11, color = \"#6A6A6A\"),\n    plot.caption = ggtext::element_markdown(size = 5, color = \"#6A6A6A\"),\n    axis.text.x = element_text(angle = 90, hjust = 1),\n    axis.ticks.y = element_line(color = \"#272727\"), \n    axis.text.y = element_text(color = \"#272727\"),\n    plot.background = element_rect(color = \"white\", fill = \"white\"),\n    axis.title.x = element_blank(),\n    axis.title.y = element_text(size = 8, color = \"#6A6A6A\"),\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"white\", color = \"white\")) +\n  scale_color_manual(\n    values = c(\n    \"VOX\" = \"#4D76BF\", \"PP\" = \"#4D76BF\", \"Cs\" = \"#FFC38D\", \"UCD\" = \"#FFC38D\",\n    \"CDS\" = \"#FFC38D\", \"UPyD\" = \"#FFC38D\", \"US\" = \"#E2706D\", \"PSOE\" = \"#E2706D\",\n    \"SUMAR\" = \"#E2706D\", \"PODEMOS\" = \"#E2706D\", \"PCE\" = \"#E2706D\", \n    \"Más País\" = \"#650904\", \"IU\" = \"#E2706D\")) +\n  coord_cartesian(\n    xlim = c(1977.452, 2029), \n    ylim = c(0, 280), \n    clip = \"off\") \n\np\n\n\n\nAnnotations\nLabels\nUsing ggannotate once again, annotations for all the selected parties were included, ensuring the text and segments retain consistent colors in order to prevent confusion\n\n\n#ggannotate(p)\n\np <- p + \n  geom_rect(\n    data = data.frame(xmin = 1977.718, xmax = 1977.718, \n                      ymin = 7.363, ymax = 32.993),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 1978.232, y = 48.203, \n    label = \"US\"), mapping = aes(x = x, y = y, label = label), \n    inherit.aes = FALSE, colour = \"#BE4D4C\")+\n  geom_rect(\n    data = data.frame(xmin = 1981.237, xmax = 1981.237, \n                      ymin = 10.19, ymax = 50.103),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.16, y = 62.457, label = \"PCE\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1991.669, xmax = 1991.669, \n                      ymin = 19.694, ymax = 40.6),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1991.589, y = 48.203, label = \"IU\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\")+\n  geom_rect(\n    data = data.frame(xmin = 2013.289, xmax = 2016.063, \n                      ymin = 71.01, ymax = 71.01),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2008.1, y = 71.96, label = \"Podemos y confluencias\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2012.595, xmax = 2015.754, \n                      ymin = 38.7, ymax = 38.7),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2009.899, y = 39.65, label = \"Ciudadanos\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 2012.441, xmax = 2018.836, \n                      ymin = 28.246, ymax = 28.246),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2010.746, y = 27.296, label = \"VOX\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 1978.0, xmax = 1978.0, \n                      ymin = 173.485, ymax = 193.44),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1978.5, y = 204.053, label = \"UCD\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\" ) +\n  geom_rect(\n    data = data.frame(xmin = 1986.785, xmax = 1986.785, \n                      ymin = 188.848, ymax = 211.655),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1986.707, y = 217.357, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2000.037, xmax = 2000.037, \n                      ymin = 190.749, ymax = 205.953),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1999.96, y = 214.348, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 1987.94, xmax = 1987.94, \n                      ymin = 19.694, ymax = 43.45),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1987.863, y = 51.054, label = \"CDS\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\") +\n  annotate(\n    \"curve\", x = 2008.3 , y = 3  , xend = 2001 , yend = 40 , \n    color = \"#E6A55B\", curvature = -0.2, \n    arrow = arrow(length = unit(0.01, \"npc\"), angle = 20, type = \"closed\")) +\n  geom_text(\n    data = data.frame(x = 2000.459, y = 47.849, label = \"UPyD\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\")\n\np\n\n\n\nPresidencies axis\nI opted to retain the axis relative to the presidencies of the original axis, as it provides pertinent information that I didn’t want to lose. I simply adjusted the coordinates appropriately to visualize it horizontally.\nMoreover, these segments were utilized as a legend to keep the graph as uncluttered as possible.\n\n\n#Presidencies axis\np <- p + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 1980.5, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1977.425, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1980.5, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  geom_rect(\n    data = data.frame(xmin = 1981, xmax = 1982.322, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1981, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1982.322 , y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 1982.822, xmax = 1995.669, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1982.822, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 1995.669 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1996.169, xmax = 2003.699, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1996.169, y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2003.699 , y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2004.199, xmax = 2011.385, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2004.199, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2011.385 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2011.885, xmax = 2018.821, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75,\n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2011.885, y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2018.821 , y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2019.321, xmax = 2023, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2019.321, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2023 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  geom_text(\n    data = data.frame(x = 1978.5, y = 250, label = \"Adolfo\\nSuárez\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.3, y = 250, \n                      label = \"Leopoldo\\nCalvo-Sotelo\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1988.613, y = 250, \n                      label = \"Felipe\\nGonzález\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1999.235, y = 250, label = \"José María\\nAznar\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2007.202, y = 248, \n                      label = \"José Luis\\nRodríguez\\nZapatero\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2014.991, y = 250, label = \"Mariano\\nRajoy\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.833, y = 250, label = \"Pedro\\nSánchez\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) \n\np\n\n\n#Legend\n\np <- p + \n  geom_text(\n    data = data.frame(x = 1978.847, y = 266.886, label = \"Centro\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE, colour = \"#6A6A6A\") +\n  geom_text(\n    data = data.frame(x = 1989.169, y = 265.925, label = \"Izquierda\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE,  colour = \"#6A6A6A\")+\n  geom_text(\n    data = data.frame(x = 1999.975, y = 265.925, label = \"Derecha\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE, colour = \"#6A6A6A\")\n\np\n\n\n\nRelevant milestones\nFinally, I decided to include annotations pointing specific important events that, when reading the article, stand out prominently.\nThis line graph distinctly showcases the shifts between the right and left since the 90s and allow us to visualize the emergence of other parties in 2015. As detailed in the article, this pivotal juncture marked the end of the prevailing two-party model, culminating in the establishment of the first coalition government in Spanish democracy in 2020.\nAdditionally, a horizontal line indicating the 176 deputies, the minimum required for an absolute majority, has been included. Every party surpassing this threshold managed to govern independently.\n\n\np <- p +\n  geom_rect(\n    data = data.frame(xmin = 2015, xmax = 2015, ymin = 0, ymax = 240),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE,\n    linetype = \"dashed\") +\n  geom_text(\n    data = data.frame(x = 2015.136, y = 214.048, \n                      label = \"Ruptura del bipartidismo\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE) +\n   geom_rect(\n     data = data.frame(xmin = 2020, xmax = 2020, ymin = 200, ymax = 240),\n     mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n     colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE,\n     linetype = \"dashed\") +\n  geom_text(\n    data = data.frame(x = 2020.2, y = 190, \n                      label = \"Primer gobierno\\n de coalición\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE) +\n  geom_rect(\n    data = data.frame(xmin = 1977.452, xmax = 2023, ymin = 176, ymax = 176),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE)+ \n  geom_text(\n    data = data.frame(x = 2024.652, y = 177.382, label = \"Mayoría\\nabsoluta\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE)\n\np\n\n\n\n\n\n\n",
    "preview": "projects/2023/100516517/100516517_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 672,
    "preview_height": 1248
  },
  {
    "path": "projects/2023/100505771/",
    "title": "Mexico's Export Dynamics from 1996 to 2020 by Sector",
    "description": "Replication and alternative version of the over time graph sector exports of Mexico by the Growth Lab at Harvard University.",
    "author": [
      {
        "name": "Valeria Contreras",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplica\nEnhacement\nConclusion\n\nIntroduction\nThe Atlas of Economic Complexity, developed by the Growth Lab at Harvard University, introduced a comprehensive profile of countries in the year 2019. Where users are invited to embark enter on an interactive exploration, navigating through the economic structures and growth dynamics of over 130 nations. Within this context, our focus turns to México, where we start our visual journey through its economic landscape, observing the details of export dynamics across diverse sectors in the previous years.\nThis tutorial aims to replicate the existing graph and present an alternative visualization using the identical dataset.\nOriginal graph from the Atlas of Economic Complexity.The x-axis represents the timeline from 1996 to 2020, offering a chronological journey through the years. Meanwhile, the y-axis measures the current gross export in billions of dollars, serving as a measure for the economic impact of each sector where each sector is distinguished by a unique color.\nReplica\nStarting with the journey of replication, we start by recreating the above plot and below you will find the complete code along with some insights into the challenges I faced while recreating it.\n\n\nlibrary(ggplot2)\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(ggthemes)\nlibrary(ggstream)\nlibrary(ggrepel)\nlibrary(RColorBrewer)\n\n\nexportmex <- read_xlsx(\"EXPORTS-MEXICO.xlsx\")\n\n\ncolors <-\n  c(\n    \"#b33d6d\",\n    \"#2b607c\",\n    \"#7cdada\",\n    \"#7ba2d9\",\n    \"#8c7ad7\",\n    \"#c47cda\",\n    \"#d87b7a\",\n    \"#bb9689\",\n    \"#dab57c\",\n    \"#f4d025\",\n    \"#7cdaa0\"\n  )\n\nlegend_colors <-\n  c(\n    \"#b33d6d\",\n    \"#7cdaa0\",\n    \"#f4d025\",\n    \"#dab57c\",\n    \"#bb9689\",\n    \"#d87b7a\",\n    \"#c47cda\",\n    \"#8c7ad7\",\n    \"#7ba2d9\",\n    \"#7cdada\",\n    \"#2b607c\"\n  )\n\nsysfonts::font_add_google(\"Noto Sans JP\", family = \"sans-serif\")\n\nexportmex <-\n  exportmex |> mutate(`Current Gross Export` = sub(\"\\\\$\", \"\", `Current Gross Export`))\nCurrent_Gross_Export <- as.numeric(exportmex$`Current Gross Export`)\nyear <- as.numeric(exportmex$Year)\n\n\nexclude_value <- 550\nlabel_positions <- data.frame(\n  Sector = c(\n    \"Agriculture\",\n    \"Minerals\",\n    \"Vehicles\",\n    \"Machinery\",\n    \"Electronics\"\n  ),\n  Position = c(30, 60, 170, 250, 330)\n)\n\n\n\n\nexportmex |> ggplot() +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    breaks = seq(0, 550, 50),\n    labels = function(x) \n      paste0(\"$\", x, \"B\")\n  ) +\n  coord_cartesian(ylim = c(0, exclude_value), expand = FALSE) +\n  scale_x_continuous(\n    name = \" \",\n    breaks = seq(1996, 2020, 2),\n    limits = c(min(exportmex$Year), max(exportmex$Year))\n  ) +\n  scale_fill_manual(values = colors) +\n  geom_stream(aes(fill = Sector),\n              type = \"ridge\",\n              bw = .60,\n              n_grid = 200) +\n  theme_gray() +\n  theme(\n    text = element_text(family = \"sans-serif\"),\n    panel.background = element_rect(fill =  \"#f5f5f5\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey80\", size = .3),\n    axis.ticks.length = unit(0.2, \"cm\"),\n    axis.ticks = element_line(color = \"grey80\", size = .3),\n    plot.margin = margin(l = 5, t = -15),\n    axis.text = element_text(color = \"#616161\"),\n    axis.text.x = element_text(\n      angle = 60,\n      hjust = 1,\n      size = 5,\n      margin = margin(5, 0, 0, 0)\n    ),\n    axis.text.y = element_text(\n      size = 5,\n      family = \"sans-serif\",\n      margin = margin(0, 0, 0, 5)\n    ),\n    axis.title.y = element_text(\n      size = 8,\n      family = \"sans-serif\",\n      color = \"#616161\",\n      margin = margin(r = 1)\n    ),\n    legend.position = \"bottom\",\n    legend.text = element_blank(),\n    legend.spacing.x = unit(0.1, \"cm\"),\n    legend.text.align = 10,\n    legend.box.spacing = unit(1, \"cm\"),\n    legend.key.height = unit(0.35, \"cm\"),\n    legend.key.width = unit(0.35, \"cm\"),\n    legend.title = element_text(color = \"#616161\", size = 6),\n    legend.justification = c(0.3, 0),\n    legend.margin = margin(t = -25)\n  ) +\n  labs(title = \" \",\n       fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) +\n  guides(fill = guide_legend(nrow = 1, override.aes = list(fill = legend_colors))) +\n  geom_text(\n    data = label_positions,\n    aes(x = Inf, y = Position, label = Sector),\n    color = \"#E8E9EB\",\n    angle = ifelse(\n      label_positions$Sector == \"Electronics\",\n      15,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        8,\n        ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n      )\n    ),\n    hjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        2.1,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          5.2,\n          ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n        )\n      )\n    ),\n    vjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      -2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        -.9,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          -5,\n          ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n        )\n      )\n    ),\n    size = ifelse(\n      label_positions$Sector == \"Electronics\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        4,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          3,\n          ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n        )\n      )\n    ),\n    na.rm = TRUE\n  )\n\n\n\nThere were some series of challenged that added both complexity and valuable lessons, to start with, the first challenge was on the current gross export amounts, since the original data set already had the sign “$” and the letter “B” on the numbers, the ggplot didn’t organize well the amounts, I had to remove those characters from the “Current Gross Export” variable and then convert it to number as below,\n\n\nexportmex <-\n  exportmex |> mutate(`Current Gross Export` = sub(\"\\\\$\", \"\", `Current Gross Export`))\nCurrent_Gross_Export <- as.numeric(exportmex$`Current Gross Export`)\n\n\nIn second place, I must mention the sectors, since ggplot2 order alphabetically by default I needed to modify them so I can give them the same order as on the original graph.\n\n\ncolors <-\n  c(\n    \"#b33d6d\",\n    \"#2b607c\",\n    \"#7cdada\",\n    \"#7ba2d9\",\n    \"#8c7ad7\",\n    \"#c47cda\",\n    \"#d87b7a\",\n    \"#bb9689\",\n    \"#dab57c\",\n    \"#f4d025\",\n    \"#7cdaa0\"\n  )\n\n\nAn aesthetic where I invested a lot of time was, setting up the correct angles and direction of each label per sector, I used if else function so I can move the label of each sector separately, I had to be very meticulous on this because if I move the angle the other aesthetics of the label would change, and to set them up exactly as the original plot was a challenge.\n\n\ngeom_text(\n  data = label_positions,\n  aes(x = Inf, y = Position, label = Sector),\n  color = \"#E8E9EB\",\n  angle = ifelse(\n    label_positions$Sector == \"Electronics\",\n    15,\n    ifelse(\n      label_positions$Sector == \"Minerals\",\n      8,\n      ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n    )\n  ),\n  hjust = ifelse(\n    label_positions$Sector == \"Electronics\",\n    2,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      2.1,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        5.2,\n        ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n      )\n    )\n  ),\n  vjust = ifelse(\n    label_positions$Sector == \"Electronics\",\n    -2,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      -.9,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        -5,\n        ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n      )\n    )\n  ),\n  size = ifelse(\n    label_positions$Sector == \"Electronics\",\n    4,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        3,\n        ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n      )\n    )\n  ),\n  na.rm = TRUE\n)\n\n\nThe last thing that was also complicated for me to recreate was the legend, even though I did not put the images as the original plot, I spent a lot of time investigating on how to set up the colors horizontally and just in 1 row, and finally came up with below setting,\n\n\nlabs(title = \" \",\n     fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) + guides(fill = guide_legend(\n       nrow = 1,\n       override.aes = list(fill = legend_colors)\n     ))\n\n\nI adjusted the number of rows within the “guides” function to reflect the changes. Additionally, I redefined the order of the key legend colors, aligning the legend with the same color sequence as in the original plot.\n\n\nlegend_colors <-\n  c(\n    \"#b33d6d\",\n    \"#7cdaa0\",\n    \"#f4d025\",\n    \"#dab57c\",\n    \"#bb9689\",\n    \"#d87b7a\",\n    \"#c47cda\",\n    \"#8c7ad7\",\n    \"#7ba2d9\",\n    \"#7cdada\",\n    \"#2b607c\"\n  )\n\n\nI opted to not include the images in the legend and the arrow in the Y-axis title, as these are interactive elements, they weren’t considered for the replication plot.\nThe curves deviate slightly from those in the original plot. Despite experimenting with the parameters “bw” and “n_grid” in the geom_stream, I couldn’t achieve the exact smoothness of the original plot. Consequently, I changed from geom_stream to geom_area, resulting in the plot shown below,\n\n\nexportmex |> ggplot() +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    breaks = seq(0, 550, 50),\n    labels = function(x)\n      paste0(\"$\", x, \"B\")\n  ) +\n  coord_cartesian(ylim = c(0, exclude_value), expand = FALSE) +\n  scale_x_continuous(\n    name = \" \",\n    breaks = seq(1996, 2020, 2),\n    limits = c(min(exportmex$Year), max(exportmex$Year))\n  ) +\n  scale_fill_manual(values = colors) +\n  geom_area() +\n  theme_gray() +\n  theme(\n    text = element_text(family = \"sans-serif\"),\n    panel.background = element_rect(fill =  \"#f5f5f5\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey80\", size = .3),\n    axis.ticks.length = unit(0.2, \"cm\"),\n    axis.ticks = element_line(color = \"grey80\", size = .3),\n    plot.margin = margin(l = 10),\n    axis.text = element_text(color = \"#616161\"),\n    axis.text.x = element_text(\n      angle = 60,\n      hjust = 1,\n      size = 5,\n      margin = margin(5, 0, 0, 0)\n    ),\n    axis.text.y = element_text(\n      size = 5,\n      family = \"sans-serif\",\n      margin = margin(0, 0, 0, 5)\n    ),\n    axis.title.y = element_text(\n      size = 8,\n      family = \"sans-serif\",\n      color = \"#616161\",\n      margin = margin(r = 10)\n    ),\n    legend.position = \"bottom\",\n    legend.text = element_blank(),\n    legend.spacing.x = unit(0.1, \"cm\"),\n    legend.text.align = 10,\n    legend.box.spacing = unit(1, \"cm\"),\n    legend.key.height = unit(0.4, \"cm\"),\n    legend.key.width = unit(0.4, \"cm\"),\n    legend.title = element_text(color = \"#616161\", size = 6),\n    legend.justification = c(0.3, 0)\n  ) +\n  labs(title = \" \",\n       fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) +\n  guides(fill = guide_legend(nrow = 1, override.aes = list(fill = legend_colors))) +\n  geom_text(\n    data = label_positions,\n    aes(x = Inf, y = Position, label = Sector),\n    color = \"#E8E9EB\",\n    angle = ifelse(\n      label_positions$Sector == \"Electronics\",\n      15,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        8,\n        ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n      )\n    ),\n    hjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        2.1,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          5.2,\n          ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n        )\n      )\n    ),\n    vjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      -2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        -.9,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          -5,\n          ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n        )\n      )\n    ),\n    size = ifelse(\n      label_positions$Sector == \"Electronics\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        4,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          3,\n          ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n        )\n      )\n    ),\n    na.rm = TRUE\n  )\n\n\n\nThe curves closely resemble those of the original plot, although they may lack the same level of smoothness. However, their distinct features are as pronounced as those in the original plot.\nGiven that Geom stream is not perfect, I chose to include both plots in the project. This allows us to observe the replication that most closely aligns with the original plot.\nEnhacement\nAs I aimed to illustrate the evolution of each sector, I transitioned from a stream graph to a geom_area, applying facet wrap to assign each sector to a distinct grid. I originally contemplate a line graph, and reconsidered due to the 11 sectors, realizing it might result in a spaghetti chart, making it visually overwhelming and challenging to interpret. Opting for facet wrap, I allocated a dedicated section to each sector, improving the graphic’s clarity and making it more accessible to recognize individual sector patterns.\n\n\ndisplay.brewer.all()\n\n\nmy_palette <- brewer.pal(11, \"Paired\")\nprint(my_palette)\n\n [1] \"#A6CEE3\" \"#1F78B4\" \"#B2DF8A\" \"#33A02C\" \"#FB9A99\" \"#E31A1C\"\n [7] \"#FDBF6F\" \"#FF7F00\" \"#CAB2D6\" \"#6A3D9A\" \"#FFFF99\"\n\nBelow is the code,\n\n\nexportmex |> ggplot()  +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  geom_area() +\n  facet_wrap (\n    ~ factor(\n      Sector,\n      levels = c(\n        \"Vehicles\",\n        \"Machinery\",\n        \"Electronics\",\n        \"Minerals\",\n        \"Agriculture\",\n        \"Other\",\n        \"Services\",\n        \"Chemicals\",\n        \"Metals\",\n        \"Textiles\",\n        \"Stone\"\n      )\n    ),\n    scales = \"free_y\",\n    nrow = 3,\n    strip.position = \"top\"\n  ) +\n  theme(strip.background = element_blank(),\n        legend.position = \"none\") +\n  scale_fill_manual(\n    values = my_palette\n  ) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    expand = c(0, 0),\n    labels = function(x)\n      paste0(\"$\", x, \"B\")\n  ) +\n  scale_x_continuous(\n    name = \" Years\" ,\n    breaks = seq(1996, 2020, 6),\n    limits = c(min(exportmex$Year),\n               max(exportmex$Year))\n  ) +\n  ggtitle(\"Export Trends (1996-2020) in Mexico by Sector in Current Gross $ \") +\n  theme(\n    axis.text.y = element_text(\n      size =  5,\n      family = \"sans-serif\",\n      margin = margin(l = 10)\n    ),\n    axis.title.y = element_text(\n      size = 10,\n      family = \"sans-serif\",\n      color = \"#616161\"\n    ),\n  ) +\n  theme(\n    legend.position = \"none\",\n    strip.text = element_text(size = 10, family = \"sans-serif\"),\n    axis.ticks = element_line(color = \"grey80\"),\n    plot.margin = margin (l = 10, b = 8, t = 10),\n    plot.title = element_text(\n      face = \"bold\",\n      hjust = 0,\n      size = 11,\n      vjust = 3\n    ),\n    axis.text.x = element_text(margin = margin(b = 10), size = 5)\n  )\n\n\n\nFirstly, my goal was to change the color palette of the original graph, as certain colors give challenges for individuals with color blindness. I discovered the “Viridis” library in R, which allows us to implement a colorblind-friendly palette. This palette became the foundation for the enhanced graph. It’s essential to consider inclusivity in data visualization since color plays an important role. By accommodating color-blind individuals, we expand our audience and amplify the impact of our work.\n\n\nlibrary(RColorBrewer)\nmy_palette <- brewer.pal(11, \"Paired\")\nprint(my_palette)\n\nscale_fill_manual(\n  values = my_palette)\n\n\nSecondly, I arranged each sector in descending order based on their current gross export values. This deliberate arrangement places the sector with the highest current gross export impact at the top left, gradually descending to the sector with the lowest impact at the bottom right. The objective behind this strategic organization is to offer readers a more structured and intuitive visualization of the data.\nTo achieve this, I employed a systematic approach by establishing specific levels for the “Sector” variable and ordering them according to the desired organization, as mentioned earlier. The relevant code part for this configuration is provided below,\n\nfacet_wrap ( ~ factor(\n  Sector,\n  levels = c(\n    \"Vehicles\",\n    \"Machinery\",\n    \"Electronics\",\n    \"Minerals\",\n    \"Agriculture\",\n    \"Other\",\n    \"Services\",\n    \"Chemicals\",\n    \"Metals\",\n    \"Textiles\",\n    \"Stone\"\n  )\n)\n\nConclusion\nIn the journey of replicating the existing graph, I navigated through data and visualization challenges, where tested my analytic and coding skills, ultimately, I’m proud of the progress made on ggplot2 and R. The replica thought me how to handle complex data sets to address them into a visual representation and to critically evaluate the choices of the creators so I could improve the graph according to my criteria, and for the enhancement, I provide an illustrate representation of my intended improvement representing the Current Gross Export for each sector over the years with spontaneity and clarity of each sector.\nAnd lastly, I would like to thank Iñaki for all the help I receive to be able to recreate this plot and to learn all about ggplot2.\n\n\n\n",
    "preview": "projects/2023/100505771/100505771_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100506380/",
    "title": "The Phenomenon of Poverty",
    "description": "Visualizing the global distribution of disposable income between 1990 and 2019- Our World in Data.",
    "author": [
      {
        "name": "Frederick Peña-Sims",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nGetting the data right\nPackages\nGetting the data\nCleaning the data\n\nBuilding the graph\nThe theme\nLabeling the Axes\nFilling the plot\nLabeling the… Labels\nWhat’s the name again?\nLimitations\n\nIs there a better way?\nInitial idea\nFocusing on development\nAdapting the theme\nCreating the alternative plot\nGive it a title…\nand make it move\n\n\nIntroduction\nPoverty is a longstanding issue of known human societies ingrained into the logic of ‘Capital and Ideology’. Be it out of colonial motivation, the United Nations, after the great catastrophe that was the second world war, set out its aim to diminish poverty globally and is now prominently presented as the first of 17 Sustainable Development Goals for 2030. While progress has been made, the Covid-19 pandemic, certainly, undid previously made progress. This project takes a look at the historical development of global distribution of the population between different poverty thresholds.\nThe original graph\nThe original graph can be found on the web page of Our World in Data. It, visually, portrays how daily disposable income has been globally distributed between 1990 and 2019. One major strength of this graph is that, at a glance, one is able to see, tentatively, historical developments of each disposable income bracket in relation to each other.\nOriginal chart from Our World in Data.Getting the data right\nPackages\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(forcats)\nlibrary(ggrepel)\n\n\nGetting the data\nThe data is easily accessible under the integrated download button below the graph on the previously indicated web page of Our World in Data.\n\n\ndata_raw <- read.csv(\"data/distribution-of-population-between-different-poverty-thresholds-up-to-30-dollars.csv\")\ndata_raw <- as_tibble(data_raw)\n\n\nCleaning the data\nA first step, I cleaned the data adhering to the tidy data principle that one variable should be stored in one column. To achieve that, the pivot_longer command is used. Before, the previous column names are renamed to render them more intuitive to understand. Finally, we end up with to new columns, ‘disp_inc’ expressing the classification of the poverty threshold (daily disposable income) and ‘am_people’ allocating the amount of people.\n\n\nsum(is.na(data_raw))\n\n[1] 0\n\ndata <-\n  data_raw |> \n  rename(\n    b_40_dollars_and_more = X.40...total.number.of.people.above.poverty.line,\n    b_30_40_dollars = X.30..40...total.number.of.people.between.poverty.lines,\n    b_20_30_dollars = X.20..30...total.number.of.people.between.poverty.lines,\n    b_10_20_dollars = X.10..20...total.number.of.people.between.poverty.lines,\n    b_6.85_10_dollars = X.6.85..10...total.number.of.people.between.poverty.lines,\n    b_3.65_6.85_dollars = X.3.65..6.85...total.number.of.people.between.poverty.lines,\n    b_2.15_3.65_dollars = X.2.15..3.65...total.number.of.people.between.poverty.lines,\n    b_1_2.15_dollars = X.1..2.15...total.number.of.people.between.poverty.lines,\n    below_1_dollar = X.1...total.number.of.people.below.poverty.line) |> \n  pivot_longer(cols = 4 :12,\n               names_to = \"disp_inc\",\n               values_to = \"am_people\") \n\n\nAs the final graph is based on the ‘natural’ order of the poverty thresholds, this logic must be replicated in the data. As such, the variable on (daily) disposable income is reverted into an ordered factor variable, with specified levels.\n\n\ndata <-\n  data |> \n  mutate(disp_inc = factor(disp_inc, \n                           levels = c(\n                             \"b_40_dollars_and_more\",\n                             \"b_30_40_dollars\",\n                             \"b_20_30_dollars\",\n                             \"b_10_20_dollars\",\n                             \"b_6.85_10_dollars\",\n                             \"b_3.65_6.85_dollars\",\n                             \"b_2.15_3.65_dollars\",\n                             \"b_1_2.15_dollars\",\n                             \"below_1_dollar\"),ordered = T))\n\n\nFinally, the original data set contains data not only on the global scale but also per country and even sometimes on the sub-country level. As such, only the data pertaining to the entity ‘World’ is kept in the final data set.\nNote, that a lot of country level data is missing for a considerable amount of years. This will be of great importance when an alternative graph is proposed.\n\n\ndata_world <-\n  data |> \n  filter(Entity == \"World\") |> \n  mutate(Year = as.numeric(Year),\n         am_people = as.numeric(am_people))\n\n\nBuilding the graph\nThe theme\nA major part of this graph is Our World in Data’s distinctive theme. To replicate the theme, I developed my own theme function based on the theme ‘minimal’, allowing me to easily draw the required plot background. Using the ‘%+replace%’ function, I allowed myself to easily change the base theme manually. The entire function code is provided down below. Bits and pieces of the function code were added throughout the coding process.\n\n\ntheme_owid <- function(){ \n  font <- \"Etoile\"   \n  \n  theme_minimal() %+replace%    \n    \n    theme(\n      panel.grid.minor = element_blank(),\n      panel.grid.major = element_blank(),\n      \n      axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"),\n      axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11),\n      axis.text.y = element_text(size = 11,\n                                 vjust = 0.5),\n      \n      legend.position = \"none\",\n      \n      plot.title = element_text(size = 16, \n                                hjust = 0,\n                                color = \"#444444\"),\n      plot.title.position = \"plot\",\n      plot.subtitle = element_text(size = 9.5,\n                                   color = \"grey\",\n                                   hjust = 0,\n                                   margin = margin(b = 20, t = 2.5)), \n      plot.caption = element_text(hjust = 0, \n                                  margin = margin(t = 20),\n                                  size = 8.5),\n      plot.caption.position = \"plot\",\n      \n      plot.margin = margin(t = 5, r = 5, b = 5, l = 5)\n      \n    )\n}\n\n\nThe preliminary theme function was based on the subsequent lines of code. First, all lines (called grid), part of the original theme are redacted with the command ‘element_blank()’. Subsequently, the x-axis ticks were adjusted in size and color, and the x-axis labels were assigned there correct position. The legend was disbanded as labels will replace it subsequently.\n\ntheme(\n      panel.grid.minor = element_blank(),\n      panel.grid.major = element_blank(),\n      \n      axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"),\n      axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11),\n      axis.text.y = element_text(size = 11),\n      \n      legend.position = \"none\")\nThe final theme background is accomplished by manually creating grid lines with the ‘geom_segment’ argument. To encompass the subsequent incorporation of the labels, the ‘coord_cartesian’ function extends the plot space to the imaginative x-axis spot 2025. With the application of the theme function and the removal of the axes labels, the subsequent basic structure is attained.\n\n\np <- \n  ggplot() +\n  coord_cartesian(xlim= c(1990, 2029), expand = T) +\n  geom_segment(aes(x = 1990, xend = 2019, y = 0, yend = 0),\n               linetype = \"solid\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 1000000000, yend = 1000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 2000000000, yend = 2000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 3000000000, yend = 3000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 4000000000, yend = 4000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 5000000000, yend = 5000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 6000000000, yend = 6000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 7000000000, yend = 7000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  theme_owid() +\n  labs(x = NULL,\n       y = NULL)\np\n\n\n\nLabeling the Axes\nQuite obviously, the axes labeling is skewed (look at the ‘2020’), badly positioned (the space between x-axis labels and the actual x-axis), and simply illegibly labeled (y-axis labels). The subsequent code rectifies these issues.\n\n\np <-    \n  p +\n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n                     expand= c(0, 0)) +\n  scale_y_continuous(breaks = c(0, 1000000000, 2000000000, 3000000000,4000000000\n                                ,5000000000, 6000000000, 7000000000, 8000000000),\n                     labels = c(\"0\", \"1 billion\", \"2 billion\", \"3 billion\", \n                                \"4 billion\",\"5 billion\", \"6 billion\",\n                                \"7 billion\", \"8 billion\"),\n                     expand = c(0, 0)) \np\n\n\n\nAs can be seen on the x-axis, the labels ‘2000’ and ‘2019’ were adjusted concerning their placement relative to the x-axis tick. For this the subsequent code was used, manually setting the positioning of the x-axis labels.\ntheme(axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11))\nFilling the plot\nFINALLY, it is time to fill the plot. I use the ‘geom_area’ function to create a stacked plot with filled areas. The areas are stacked according to the levels assigned to each category of disposable income in the data cleaning procedure. The colors of the areas were manually set according to the colors in the original plot. Also, the areas are slightly transparent, also replicated in this code (‘alpha = 0.8’).\n\n\np <-    \n  p + \n  geom_area(data = data_world,\n            aes(x = Year, y = am_people, group = disp_inc, fill = disp_inc),\n            alpha = 0.85) +\n  scale_fill_manual(values = c(b_40_dollars_and_more = \"#6494c5\",\n                               b_30_40_dollars = \"#7cb4d5\",\n                               b_20_30_dollars = \"#b3d7e8\",\n                               b_10_20_dollars = \"#deecf4\",\n                               b_6.85_10_dollars = \"#fafafa\",\n                               b_3.65_6.85_dollars = \"#fee6d8\",\n                               b_2.15_3.65_dollars= \"#f7bfa7\",\n                               b_1_2.15_dollars = \"#e39083\",\n                               below_1_dollar = \"#ca5e6b\")) \np\n\n\n\nLabeling the… Labels\nNow onto the labels. These gave me the biggest problems. First and foremost, aligning labels with their correct position in the plot was a mess to say the least. Either the labeling was bunched up in the bottom right indicating where each area would end as if they were not stacked or labels were inverted, were the lowest category ‘below 1$ a day’ was displayed at the top of the plot. Both these problems were solved within the geom_text_repel function delineating the ‘y =’ option. After subsetting the data set to only values for the year 2019, the aes function provides information on the labels properties. To label each area correctly, I had to create the total sum of people from which I would subtract the accumulated sum of the variable ‘am_people’. As the original labeling was inverted this would correct this initial malfunction. Furthermore, labels were supposed to be ‘attached’ to the middle of the geom_area. To solve this issue, the previously described score was combined (through addition) with the mathematical expression halving the amount of people variable. Label names were adjusted within a ‘case_when’ function and nudged so they do not overlap. Unfortunately, I was not able to recreate the exact shape and arrangement of the labels and their according lines.\n\n\ndata_world_2019 <-   \n  data_world |>    \n  filter(Year == 2019)\n\ntotal_sum_people <- sum(data_world_2019$am_people)\n\n\n\n\np <-   \n  p +\n  geom_text_repel(data = filter(data_world, Year == 2019),\n                  aes(x = Year,\n                      y = total_sum_people - cumsum(am_people) + 0.5 * am_people,\n                      label = case_when(\n                        disp_inc == \"b_40_dollars_and_more\" ~ \"above $40 a day\",\n                        disp_inc == \"b_30_40_dollars\" ~ \"$30-$40 a day\",\n                        disp_inc == \"b_20_30_dollars\" ~ \"$20-$30 a day\",\n                        disp_inc == \"b_10_20_dollars\" ~ \"$10-$20 a day\",\n                        disp_inc == \"b_6.85_10_dollars\" ~ \"$6.85-$10 a day\",\n                        disp_inc == \"b_3.65_6.85_dollars\" ~ \"$3.65-$6.85 a day\",\n                        disp_inc == \"b_2.15_3.65_dollars\" ~ \"$2.15-$3.65 a day\",\n                        disp_inc == \"b_1_2.15_dollars\" ~ \"$1-$2.15 a day\",\n                        disp_inc == \"below_1_dollar\" ~ \"below $1 a day\",\n                        TRUE ~ disp_inc),\n                      color = disp_inc),\n                  direction = \"y\",\n                  nudge_x = 3,  \n                  size = 3.25,\n                  vjust = 0,\n                  hjust = 0,\n                  segment.size = 0.5,\n                  segment.linetype = \"solid\",\n                  segment.color = \"grey\") +\n  scale_color_manual(values = c(b_40_dollars_and_more = \"#2f6cad\",\n                                b_30_40_dollars = \"#4c9ac7\",  \n                                b_20_30_dollars = \"#80abc3\", \n                                b_10_20_dollars = \"#afb3bd\", \n                                b_6.85_10_dollars = \"#bdb5b5\",\n                                b_3.65_6.85_dollars = \"#c1aea7\",\n                                b_2.15_3.65_dollars= \"#d39393\", \n                                b_1_2.15_dollars = \"#e39083\", \n                                below_1_dollar = \"#ca5e6b\")) \np\n\n\n\nWhat’s the name again?\nI added labels with ‘labs’ function. I was unable to create three different captions with varying text sizes.\n\n\np <-   \n  p +\n  theme_owid() +\n  labs(title = \"Distribution of population between different poverty\\nthresholds, World, 1990 to 2019\",\n       subtitle = \"This data is adjusted for inflation and for differences in the cost of living between countries.\",\n       caption = paste(\"Data source: World Bank Poverty and Inequality Platform (2022) – Learn more about\", \n                       \"this data\\nNote: This data is expressed in international-$ at 2017 prices.\", \n                       \"Depending on the country and year,\\nit relates to income measured after\", \n                       \"taxes and benefits, or to consumption, per capita.\\nOurWorldInData.org/poverty | CC BY\"))\np\n\n\n\nLimitations\nAs already pointed out, a key limitation of my graph are the labels that are not perfectly replicated concerning their position and the shape of the lines. Moreover, the website allows to dynamically look at the changing distribution over time, from 1990 to 2019. I was not able to recreate this function. However, the benefit of this visualization is also very limited due to the lack of information one can draw from it because of the ‘free’ x-axis.\nIs there a better way?\nInitial idea\nInstead of differently visualizing the given data, I wanted to use additional data to tell a different story. The story I wanted to tell is closely linked to Lakner and Milanovic’ (2013) working paper (found here), the first contribution visualizing the so called elephant curve. It show per capita income growth for every income percentile globally. One of the main takeaways is the accelerated growth for the lower global middle class, stagnation for the upper global middle class, and exponential growth for the global elite. Concerning the first, Lakner and Milanovic already pointed out the driving force India and China played in propelling millions out of poverty and into accelerated income growth in the lower global middle class. Piggy backing on these findings, I wanted to visually incorporate data for India and China into the visualization, distinguishing the proportion for every disposable income category. As such, one could see the contribution of China and India to the developments. Unfortunately, both, data for China and India is very limited in the data set for multiple years.\nFocusing on development\nAs my initial idea for an alternative was not possible, I wanted to focus on improving the alternative graph provided by Our World in Data. Their alternative uses facets to portray the development of every metric over time. The underlying notion is that developments over time become more apparent, as developments in a stacked graph are less palpable for the spectator. This is also why I decided against a distributive stacked graph, where areas are defined by the share they make up at point x.\nHowever, Our World in Data’s version has some shortcomings. First, there is no scale on the y-axis of each of the facets. This renders it more difficult to draw information from the graph. Moreover, the animation - as is true for the previous graph - is not fixed in the animation, adding some degree of awkwardness to the animation. As such, I made sure to incorporate some improvements.\nAdapting the theme\nTo create a more informative plot background, I adjusted my own Our World in Data inspired function to the requirements of a facet plot. This included the code for the position for the x-axes labels, which I reduced to four and the placement and color of each facet’s title. Additionally, the spacing between facets was adjusted manually and the properties of the strip titles were defined.\n\n\ntheme_owid_facet <- \n  function(){font <- \"Etoile\"    \n  theme_minimal() %+replace%   \n    theme(panel.grid.minor = element_blank(), \n          panel.grid.major = element_blank(), \n          axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"), \n          axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 1), size = 11), \n          axis.text.y = element_text(size = 11),\n          \n          legend.position = \"none\",\n          plot.title = element_text(size = 16,\n                                    hjust = 0,\n                                    colour = \"#444444\",\n                                    margin = margin(b = 2.5)),\n          plot.title.position = \"plot\",\n          plot.subtitle = element_text(size = 9.5,\n                                       color = \"grey\",\n                                       hjust = 0,\n                                       margin = margin(b = 10)),\n          plot.caption = element_text(hjust = 0,    \n                                      margin = margin(t = 7.5), \n                                      size = 8.5),\n          plot.caption.position = \"plot\",\n          plot.margin = margin(t = 5, r = 5, b = 5, l = 5),\n          strip.placement = \"outside\",\n          strip.text = element_text(colour = \"#002147\",\n                                    hjust = -0.005),\n          strip.background = element_blank(),\n          panel.spacing.x = unit(1.5, \"lines\"),\n          panel.spacing.y = unit(1, \"lines\")\n    )\n  }\n\n\nCreating the alternative plot\nTo create the plot, first the labels of the facets were created and stored in an object, which was subsequently included in the function ‘facet_wrap’. The remainder remains similar to the replication graph, with some minor distinct changes. The y-axis was replaced with an inscription in only the first facet describing the most upper line (1.5 billion). This caused me a bit of a headache, because just using ‘geom_text’ to only annotate in one facet (‘annotate’ annotates in every facet) messed up the order of the facets.\nSo I had to create a workaround. First, I created an object (‘custom_levels’), storing the levels of the variable about to be faceted. This was then plugged into a data frame, created to only select the first level from the ‘custom_levels’ object in an ‘if_else’ structure to assign the label ‘1.5 billion’ storing it under the variable ‘label’. If the label for the variable for disposable income equals the first level of the custom levels object, ‘1.5 billion’ is pasted, else nothing is specified. This would generate a facet plot, where the remainder of the facets are allocated ‘geom_text’ according to their ‘custom_levels’. To prevent this from happening, the label variable of created data frame is altered, setting the label for every disposable income variable to empty except for the first level in the ‘custom_levels’ object. Lastly, I ensured that there is only 9 options for the ‘geom_text’ to be applied with the ‘unique’ function.\n\n\nlabels <- c(\"b_40_dollars_and_more\" = \"above $40 a day\", \n            \"b_30_40_dollars\" = \"$30-$40 a day\",      \n            \"b_20_30_dollars\" = \"$20-$30 a day\",    \n            \"b_10_20_dollars\" = \"$10-$20 a day\",  \n            \"b_6.85_10_dollars\" = \"$6.85-$10 a day\", \n            \"b_3.65_6.85_dollars\" = \"$3.65-$6.85 a day\",\n            \"b_2.15_3.65_dollars\" = \"$2.15-$3.65 a day\", \n            \"b_1_2.15_dollars\" = \"$1-$2.15 a day\",     \n            \"below_1_dollar\" = \"below $1 a day\") \n\n\ncustom_levels <- c(\n  \"b_40_dollars_and_more\",\n  \"b_30_40_dollars\",\n  \"b_20_30_dollars\",\n  \"b_10_20_dollars\",\n  \"b_6.85_10_dollars\",\n  \"b_3.65_6.85_dollars\",\n  \"b_2.15_3.65_dollars\",\n  \"b_1_2.15_dollars\",\n  \"below_1_dollar\")\n\ndat_text <- data.frame(\n  label = ifelse(data_world$disp_inc == custom_levels[1], \"1.5 billion\", \"\"),\n  disp_inc = data_world$disp_inc)\n\ndat_text$label[dat_text$disp_inc %in% custom_levels[-1]] <- \"\"\n\ndat_text <- unique(dat_text)\n\n\nThis data frame information is then plugged into the ‘geom_text’ function in the final code, using the label column to label each facet (with only the first facet being visually labeled).\n\n\na <- \n  data_world |> \n  ggplot(aes(x = Year, y = am_people, group = disp_inc)) +\n  facet_wrap(~ disp_inc, labeller = labeller(disp_inc = labels)) +\n  geom_segment(aes(x = 1990, xend = 2019, y = 0, yend = 0),\n               linetype = \"solid\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 500000000, yend = 500000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 1e9, yend = 1e9),\n               linetype = \"dashed\", color = \"grey\")+\n  geom_segment(aes(x = 1990, xend = 2019, y = 1500000000, yend = 1500000000),\n               linetype = \"dashed\", color = \"grey\") +\n  coord_cartesian(xlim = c(1990, 2019), expand = TRUE) +\n  theme_owid_facet() +\n  scale_y_continuous(breaks = c(0, \n                                500000000 , \n                                1000000000, \n                                1500000000, \n                                2000000000),\n                     labels = c(),\n                     expand = c(0, 0)) +\n  scale_x_continuous(breaks = c(1990, 2000, 2010, 2019),\n                     expand= c(0, 0)) +\n  labs(x = NULL,\n       y = NULL) +\n  geom_area(stat = \"identity\", fill = \"#002147\", alpha = 0.8) +\n  geom_text(data = dat_text,\n            mapping = aes(x = 1994.5, y = 1370000000, label = label),\n            color = \"grey\", show.legend = FALSE)\n\na\n\n\n\nGive it a title…\nTitle, subtitle, and caption were again included by simply adding the ‘labs’ function.\n\n\na <-  \n  a +  \n  labs(\n    title = \"Distribution of population between different poverty\\nthresholds, World, 1990 to 2019\",  \n    subtitle = \"This data is adjusted for inflation and for differences in the cost of living between countries.\",\n    caption = paste(\"Data source: World Bank Poverty and Inequality Platform (2022) – Learn more about\", \n                       \"this data\\nNote: This data is expressed in international-$ at 2017 prices.\", \n                       \"Depending on the country and year,\\nit relates to income measured after\", \n                       \"taxes and benefits, or to consumption, per capita.\\nOurWorldInData.org/poverty | CC BY\")) + \n  coord_cartesian(clip = \"off\")\na\n\n\n\nand make it move\nFor the facet wrap, I was able to animate it. Instead of leaving the x-axis free, it is fixed in my animation, making it easier to to understand the relationship between year and amount of people pertaining to a certain category of disposable income. To only create one loop, the gifski package provides to opportunity to manually set ‘looping’ to false.\n\n\na_fluid <-  \n  a + \n  transition_reveal(Year) \n\nanimate(a_fluid, renderer = gifski_renderer(loop = FALSE))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100506380/100506380_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  },
  {
    "path": "projects/2023/100513254/",
    "title": "Energy Generation by Fuel Type",
    "description": "Using the Energy Institute’s data to reproduce Bloomberg’s chart and to provide an alternative representation.",
    "author": [
      {
        "name": "Giorgio Rivoli",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nLibraries and data\nReplicating the chart\nConstruction of the circular chart\nColored areas\nAnnotate\nFlags\nComments\nTitle and legend\nTheme\n\nAlternative version\nLibraries and data\nCoordinates and axes\n\n\nIn September 2023, Bloomberg published an article titled “Apple’s Supply Chain Is on a Collision Course With Climate Change”. Within this article, the supplier countries of the Cupertino-based company are examined. Specifically, for each of these countries, based on data from the Energy Institute, the resources used to produce their energy are highlighted. The results are depicted in the following graph:\nEnergy generation by fuel type. Source: BloombergThe purpose of this project is to replicate this graph as faithfully as possible and subsequently provide an alternative representation of the data.\nLibraries and data\nRegarding the libraries used, we aimed to limit the use primarily to “ggplot2”. However, due to specific aspects of the graph, it was necessary to import additional libraries. As for the data, as previously mentioned, we referred to the “Statistical Review of World Energy” report by the Energy Institute. Given that this report spans over 60 pages and includes data not only for the countries featured in our graph, we proceeded to transcribe the relevant data into an Excel file. Nonetheless, the imported data serves solely an informative purpose because constructing the graph required manually inputting this data, albeit relying on the aforementioned Excel file.\n\n\nlibrary(ggplot2)\nlibrary(png)\nlibrary(grid)\nlibrary(readxl)\n\ndata <- read_excel(\"Data.xlsx\")\n\n\nReplicating the chart\nConstruction of the circular chart\nFirst of all, we need to build the base of our chart. This consists of a larger circumference with three concentric circles inside, each progressively smaller. Additionally, there are also 13 equidistant spokes, one for each of the countries of interest. Initially, we assign three different variables to the number of circumferences, the number of points for each circumference, and the number of spokes. Additionally, we create a variable to which we assign a vector containing the names of the countries that will be displayed in our chart.\n\n\nnum_circles <- 4\nnum_points <- 100\nnum_rays <- 13\n\ncountries <- c(\"Indonesia\", \"India\", \"Mainland China\", \n               \"Mexico\", \"South Korea\", \"Japan\", \n               \"US\", \"Vietnam\", \"Germany\", \n               \"UK\", \"Thailand\", \"Taiwan\", \"Malaysia\")\n\n\nAfterwards, we use a function that allows us to generate our concentric circles.\n\n\ngenerate_concentric_circles <- function(num_circles, num_points) {\n  circles_data <- lapply(1:num_circles, function(i) {\n    r <- i / (num_circles + 1)\n    data.frame(\n      x = r * cos(seq(0, 2 * pi, length.out = num_points)),\n      y = r * sin(seq(0, 2 * pi, length.out = num_points)),\n      radius = r\n    )\n  })\n  do.call(rbind, circles_data)\n}\n\n\nIn the following code, we have a function that displays equidistant spokes originating from the center of the circle. Moreover, each spoke is associated with the name of a country from the ‘countries’ vector.\n\n\ngenerate_rays <- function(num_rays, max_radius, countries) {\n  angle <- seq(0, 2 * pi, length.out = num_rays + 1)[-1]\n  data.frame(\n    x = cos(angle) * max_radius,\n    y = sin(angle) * max_radius,\n    country = rev(countries)  # Inverte l'ordine dei paesi\n  )\n}\n\n\nAfter that, we store within three different variables the data necessary to construct our circular chart.\n\n\ncircles_data <- generate_concentric_circles(num_circles, num_points)\nmax_radius <- max(circles_data$radius)\nrays_data <- generate_rays(num_rays, max_radius, countries)\n\n\nFinally, we proceed with the graphical representation of what has been done so far.\n\n\ngg_circle <- ggplot() +\n  geom_polygon(data = circles_data, aes(x, y, group = radius), fill = \"gray92\", \n               color = \"gray\") +\n  geom_path(data = circles_data, aes(x, y), color = \"gray\") +\n  geom_segment(data = subset(rays_data, sqrt(x^2 + y^2) <= max_radius), \n               aes(x = 0, y = 0, xend = x, yend = y), color = \"white\")\n\ngg_circle\n\n\n\nColored areas\nWe now proceed with constructing the chart, adding colored areas that represent the resources used by various countries for energy production. This phase has been the most complex of the project. In fact, we experimented with several approaches, including the ‘geom_area’ option, for creating the colored areas, but none of them yielded satisfactory results. Ultimately, we chose to use “geom_polygon.” However, the main issue with using geom_polygon is that each colored area is composed of numerous small sections. This not only made the code inevitably longer but also resulted in the areas being slightly more square-shaped and less rounded compared to the original.\nTo create the aforementioned areas, we first created four lists, one for each colored area. Within each list, there are coordinates for each country that represent the individual colored sections. These, when summed together, will constitute the entire area.\n\n\nblack_areas <- list(\n  thailand_coal = data.frame(x = c(0, 0.023, 0.18), y = c(0, 0.15, 0.275)),\n  taiwan_coal = data.frame(x = c(0, 0.18, 0.275), y = c(0, 0.275, 0.14)),\n  malaysia_coal = data.frame(x = c(0, 0.275, 0.5), y = c(0, 0.14, 0)),\n  indonesia_coal = data.frame(x = c(0, 0.5, 0.53), y = c(0, 0, -0.277)),\n  india_coal = data.frame(x = c(0, 0.53, 0.275), y = c(0, -0.277, -0.4)),\n  china_coal = data.frame(x = c(0, 0.275, 0.008), y = c(0, -0.4, -0.035)),\n  mexico_coal = data.frame(x = c(0, 0.008, -0.082), y = c(0, -0.035, -0.225)),\n  south_korea_coal = data.frame(x = c(0, -0.082, -0.177), y = c(0, -0.225, -0.16)),\n  japan_coal = data.frame(x = c(0, -0.177, -0.152), y = c(0, -0.16, -0.04)),\n  us_coal = data.frame(x = c(0, -0.152, -0.3), y = c(0, -0.04, 0.075)),\n  vietnam_coal = data.frame(x = c(0, -0.3, -0.18), y = c(0, 0.075, 0.162)),\n  germany_coal = data.frame(x = c(0, -0.18, -0.01), y = c(0, 0.162, 0.025)),\n  uk_coal = data.frame(x = c(0, -0.01, 0.023), y = c(0, 0.025, 0.15))\n)\n\ngray_area <- list(\n  thailand_gas = data.frame(x = c(0.023, 0.18, 0.362, 0.075), \n                            y = c(0.15, 0.275, 0.525, 0.65)),\n  taiwan_gas = data.frame(x = c(0.18, 0.275, 0.55, 0.362), \n                          y = c(0.275, 0.14, 0.28, 0.525)),\n  malaysia_gas = data.frame(x = c(0.275, 0.5, 0.625, 0.55), \n                            y = c(0.14, 0, 0, 0.28)),\n  indonesia_gas = data.frame(x = c(0.5, 0.53, 0.53, 0.625), \n                             y = c(0, -0.277, -0.285, 0)),\n  india_gas = data.frame(x = c(0.53, 0.275, 0.3, 0.53), \n                         y = c(-0.277, -0.4, -0.4, -0.285)),\n  china_gas = data.frame(x = c(0.275, 0.008, 0.06, 0.3), \n                         y = c(-0.4, -0.035, -0.5, -0.4)),\n  mexico_gas = data.frame(x = c(0.008, -0.082, -0.175, 0.06), \n                          y = c(-0.035, -0.225, -0.475, -0.5)),\n  south_korea_gas = data.frame(x = c(-0.082, -0.177, -0.37, -0.175), \n                               y = c(-0.225, -0.16, -0.33, -0.475)),\n  japana_gas = data.frame(x = c(-0.177, -0.152, -0.45, -0.37), \n                          y = c(-0.16, -0.04, -0.117, -0.33)),\n  us_gas = data.frame(x = c(-0.152, -0.3, -0.38, -0.45), \n                      y = c(-0.04, 0.075, 0.095, -0.117)),\n  vietnam_gas = data.frame(x = c(-0.3, -0.18, -0.28, -0.38), \n                           y = c(0.075, 0.162, 0.25, 0.095)),\n  germany_gas = data.frame(x = c(-0.18, -0.01, -0.14, -0.28), \n                           y = c(0.162, 0.025, 0.35, 0.25)),\n  uk_gas = data.frame(x = c(-0.01, 0.023, 0.075, -0.14), \n                      y = c(0.025, 0.15, 0.65, 0.35))\n)\n\nblue_area <- list(\n  thailand_ren = data.frame(x = c(0.075, 0.362, 0.4, 0.097), \n                            y = c(0.65, 0.525, 0.575, 0.78)),\n  taiwan_ren = data.frame(x = c(0.362, 0.55, 0.7, 0.4), \n                          y = c(0.525, 0.28, 0.37, 0.575)), \n  malaysia_ren = data.frame(x = c(0.55, 0.625, 0.77, 0.7), \n                            y = c(0.28, 0, 0, 0.37)),\n  indonesia_ren = data.frame(x = c(0.625, 0.525, 0.675, 0.77), \n                             y = c(0, -0.285, -0.35, 0)),\n  india_ren = data.frame(x = c(0.525, 0.26, 0.425, 0.675), \n                         y = c(-0.285, -0.415, -0.62, -0.35)),\n  china_ren = data.frame(x = c(0.26, 0.06, 0.076, 0.425), \n                         y = c(-0.415, -0.5, -0.67, -0.62)),\n  mexico_ren = data.frame(x = c(0.06, -0.175, -0.242, 0.076), \n                          y = c(-0.5, -0.475, -0.625, -0.67)),\n  south_korea_ren = data.frame(x = c(-0.175, -0.40, -0.5, -0.23), \n                               y = c(-0.475, -0.30, -0.45, -0.625)),\n  japan_ren = data.frame(x = c(-0.376, -0.45, -0.625, -0.5), \n                         y = c(-0.32, -0.117, -0.15, -0.45)),\n  us_ren = data.frame(x = c(-0.45, -0.38, -0.775, -0.625), \n                      y = c(-0.117, 0.1, 0.186, -0.15)),\n  vietnam_ren = data.frame(x = c(-0.38, -0.28, -0.55, -0.775), \n                           y = c(0.1, 0.25, 0.482, 0.186)),\n  germany_ren = data.frame(x = c(-0.28, -0.141, -0.242, -0.55), \n                           y = c(0.25, 0.35, 0.63, 0.482)),\n  uk_ren = data.frame(x = c(-0.141, 0.075, 0.097, -0.242), \n                      y = c(0.35, 0.65, 0.78, 0.63))\n)\n\nyellow_ocra_area <- list(\n  indonesia_nuc = data.frame(x = c(0.77, 0.675, 0.707, 0.77), \n                             y = c(0, -0.35, -0.37, 0)),\n  india_nuc = data.frame(x = c(0.675, 0.425, 0.45, 0.707), \n                         y = c(-0.35, -0.62, -0.65, -0.37)),\n  china_nuc = data.frame(x = c(0.425, 0.076, 0.081, 0.45), \n                         y = c(-0.62, -0.67, -0.68, -0.65)),\n  mexico_nuc = data.frame(x = c(0.076, -0.255, -0.275, 0.081), \n                          y = c(-0.67, -0.615, -0.735, -0.68)),\n  japan_nuc = data.frame(x = c(-0.24, -0.5, -0.54, -0.275), \n                         y = c(-0.615, -0.45, -0.475, -0.725)),\n  us_nuc = data.frame(x = c(-0.5, -0.625, -0.76, -0.54), \n                      y = c(-0.45, -0.15, -0.183, -0.475)),\n  vietnam_nuc = data.frame(x = c(-0.625, -0.775, -0.775, -0.76), \n                           y = c(-0.15, 0.186, 0.186, -0.183)),\n  germany_nuc = data.frame(x = c(-0.775, -0.55, -0.575, -0.775), \n                           y = c(0.186, 0.482, 0.51, 0.186)),\n  uk_nuc = data.frame(x = c(-0.55, -0.242, -0.275, -0.575), \n                      y = c(0.482, 0.63, 0.72, 0.51)),\n  thailand_nuc = data.frame(x = c(-0.242, 0.097, 0.097, -0.275), \n                            y = c(0.63, 0.78, 0.78, 0.72)),\n  taiwan_nuc = data.frame(x = c(0.097, 0.4, 0.44, 0.097), \n                          y = c(0.78, 0.575, 0.645, 0.78)),\n  malaysia_nuc = data.frame(x = c(0.4, 0.7, 0.7, 0.44), \n                            y = c(0.575, 0.37, 0.37, 0.645))\n)\n\n\nAfter doing this, we can visualize the graphical outcome.\n\n\ngg_areas <- gg_circle + lapply(black_areas, function(area) {\n  geom_polygon(data = area, aes(x = x, y = y), fill = \"black\", color = \"black\", alpha = 0.9)\n}) +\n  lapply(gray_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"dimgray\", color = \"dimgray\", alpha = 0.9)  \n  }) +\n  lapply(blue_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"blue1\", color = \"blue1\", alpha = 0.9)\n  }) +\n  lapply(yellow_ocra_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"gold3\", color = \"gold3\", alpha = 0.9)  \n  })\n\ngg_areas\n\n\n\nAnnotate\nGiven that we have created the main core of our graph, let’s now proceed by adding all the details. Before doing so, in order to avoid potential display issues with some elements, we will adjust the dimensions of our graph by expanding the axes.\n\n\ngg_exp <- gg_areas + coord_fixed(expand = FALSE) +\n  scale_x_continuous(expand = c(0, 0), limits = c(-1.2, 1.2), \n                     breaks = seq(-1.2, 1.2, by = 0.1)) +\n  scale_y_continuous(expand = c(0, 0), limits = c(-1.2, 1.2), \n                     breaks = seq(-1.2, 1.2, by = 0.1))\n\ngg_exp\n\n\n\nOnce done, let’s proceed to add various elements using ‘annotate’. Initially, we’ll add country names outside the circumference, near the reference radius. Then, we’ll add points and lines to highlight a particular energy resource. Finally, above each respective circumference, we’ll add the percentages 25%, 50%, 75%, and 100%, enhancing the interpretability of the graph.\n\n\ngg_det <- gg_exp +  \n  annotate(\"text\", x = -0.415, y = -0.795, label = \"South Korea\", \n           size = 3.7, color = \"black\") + \n  annotate(\"text\", x = -0.68, y = -0.557, label = \"Japan\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.162, y = -0.848, label = \"Mexico\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.62, y = -0.7, label = \"Mainland China\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.79, y = -0.395, label = \"India\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.088, y = 0.843, label = \"Thailand\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.325, y = 0.794, label = \"UK\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.71, y = 0.575, label = \"Germany\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.884, y = 0.215, label = \"Vietnam\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.843, y = -0.188, label = \"US\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.52, y = 0.71, label = \"Taiwan\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.818, y = 0.407, label = \"Malaysia\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.92, y = 0.0079, label = \"Indonesia\", \n           size = 3.7, color = \"black\")+\n  annotate(\"point\", x = -0.27, y = -0.73, size = 2, color = \"black\") + \n  annotate(\"point\", x = -0.37, y = -0.33, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.078, y = -0.67, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.275, y = -0.395, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.525, y = -0.276, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.075, y = 0.645, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.242, y = 0.63, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.55, y = 0.482, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.775, y = 0.186, size = 2, color = \"black\") +\n  annotate(\"segment\", x = -0.27, y = -0.73, xend = -0.29, \n           yend = -0.775, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.37, y = -0.33, xend = -0.61, \n           yend = -0.54, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.078, y = -0.67, xend = 0.1, \n           yend = -0.815, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.275, y = -0.395, xend = 0.47, \n           yend = -0.67, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.525, y = -0.276, xend = 0.732, \n           yend = -0.38, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.075, y = 0.645, xend = 0.0935, \n           yend = 0.81, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.242, y = 0.63, xend = -0.29, \n           yend = 0.765, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.55, y = 0.482, xend = -0.61, \n           yend = 0.54, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.775, y = 0.186, xend = -0.798, \n           yend = 0.192, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.76, y = -0.183, xend = -0.8, \n           yend = -0.196, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.44, y = 0.645, xend = 0.462, \n           yend = 0.68, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.7, y = 0.37, xend = 0.722, \n           yend = 0.383, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.77, y = 0, xend = 0.816, \n           yend = 0, color = \"black\", size = 0.5)\n\ngg_det\n\n\n\nFlags\nNow that we’ve added the country names, we can also include the flags. In this regard, the following code aims to import and position the flags correctly next to their respective country names. After saving the flag images in PNG format within a folder, we import them using ‘readPNG’. Subsequently, for each flag, we specify the desired coordinates on both the X and Y axes. Finally, we also indicate the dimensions we want to assign to each image.\n\n\nuk_flag<- readPNG(\"flags/UK.png\")\nuk_flag_x <- -0.403\nuk_flag_y <- 0.803\nuk_flag_width <- 0.08\n\nthai_flag <- readPNG(\"flags/Thailand.png\")\nthai_flag_x <- 0.21\nthai_flag_y <- 0.843\nthai_flag_width <- 0.08\n\ntaiwan_flag <- readPNG(\"flags/Taiwan.png\")\ntaiwan_flag_x <- 0.635\ntaiwan_flag_y <- 0.715\ntaiwan_flag_width <- 0.08\n\nmal_flag <- readPNG(\"flags/Malaysia.png\")\nmal_flag_x <- 0.95\nmal_flag_y <- 0.41\nmal_flag_width <- 0.084\n\nindia_flag <- readPNG(\"flags/India.png\")\nindia_flag_x <- 0.89\nindia_flag_y <- -0.397\nindia_flag_width <- 0.08\n\nchina_flag <- readPNG(\"flags/China.png\")\nchina_flag_x <- 0.814\nchina_flag_y <- -0.7\nchina_flag_width <- 0.077\n\nmex_flag <- readPNG(\"flags/Mexico.png\")\nmex_flag_x <- 0.285\nmex_flag_y <- -0.85\nmex_flag_width <- 0.08\n\nsk_flag <- readPNG(\"flags/South Korea.png\")\nsk_flag_x <- -0.588\nsk_flag_y <- -0.796\nsk_flag_width <- 0.094\n\njap_flag <- readPNG(\"flags/Japan.png\")\njap_flag_x <- -0.79\njap_flag_y <- -0.557\njap_flag_width <- 0.085\n\nus_flag <- readPNG(\"flags/USA.png\")\nus_flag_x <- -0.93\nus_flag_y <- -0.19\nus_flag_width <- 0.085\n\nviet_flag <- readPNG(\"flags/Vietnam.png\")\nviet_flag_x <- -1.012\nviet_flag_y <- 0.217\nviet_flag_width <- 0.08\n\nger_flag <- readPNG(\"flags/Germany.png\")\nger_flag_x <- -0.848\nger_flag_y <- 0.574\nger_flag_width <- 0.08\n\nindonesia_flag <- readPNG(\"flags/Indonesia.png\")\nindonesia_flag_x <- 1.06\nindonesia_flag_y <- 0.01\nindonesia_flag_width <- 0.08\n\n\nOnce that’s done, with ‘annotate_custom’, we can display the flags within our graph.\n\n\ngg_flag <- gg_det + annotation_custom(\n    rasterGrob(uk_flag, interpolate = TRUE),\n    xmin = uk_flag_x - uk_flag_width / 2,\n    xmax = uk_flag_x + uk_flag_width / 2,\n    ymin = uk_flag_y - uk_flag_width / 2, \n    ymax = uk_flag_y + uk_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(thai_flag, interpolate = TRUE),\n    xmin = thai_flag_x - thai_flag_width / 2,\n    xmax = thai_flag_x + thai_flag_width / 2,\n    ymin = thai_flag_y - thai_flag_width / 2, \n    ymax = thai_flag_y + thai_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(taiwan_flag, interpolate = TRUE),\n    xmin = taiwan_flag_x - taiwan_flag_width / 2,\n    xmax = taiwan_flag_x + taiwan_flag_width / 2,\n    ymin = taiwan_flag_y - taiwan_flag_width / 2, \n    ymax = taiwan_flag_y + taiwan_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(mal_flag, interpolate = TRUE),\n    xmin = mal_flag_x - mal_flag_width / 2,\n    xmax = mal_flag_x + mal_flag_width / 2,\n    ymin = mal_flag_y - mal_flag_width / 2, \n    ymax = mal_flag_y + mal_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(india_flag, interpolate = TRUE),\n    xmin = india_flag_x - india_flag_width / 2,\n    xmax = india_flag_x + india_flag_width / 2,\n    ymin = india_flag_y - india_flag_width / 2, \n    ymax = india_flag_y + india_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(china_flag, interpolate = TRUE),\n    xmin = china_flag_x - china_flag_width / 2,\n    xmax = china_flag_x + china_flag_width / 2,\n    ymin = china_flag_y - china_flag_width / 2, \n    ymax = china_flag_y + china_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(mex_flag, interpolate = TRUE),\n    xmin = mex_flag_x - mex_flag_width / 2,\n    xmax = mex_flag_x + mex_flag_width / 2,\n    ymin = mex_flag_y - mex_flag_width / 2, \n    ymax = mex_flag_y + mex_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(sk_flag, interpolate = TRUE),\n    xmin = sk_flag_x - sk_flag_width / 2,\n    xmax = sk_flag_x + sk_flag_width / 2,\n    ymin = sk_flag_y - sk_flag_width / 2, \n    ymax = sk_flag_y + sk_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(jap_flag, interpolate = TRUE),\n    xmin = jap_flag_x - jap_flag_width / 2,\n    xmax = jap_flag_x + jap_flag_width / 2,\n    ymin = jap_flag_y - jap_flag_width / 2, \n    ymax = jap_flag_y + jap_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(us_flag, interpolate = TRUE),\n    xmin = us_flag_x - us_flag_width / 2,\n    xmax = us_flag_x + us_flag_width / 2,\n    ymin = us_flag_y - us_flag_width / 2, \n    ymax = us_flag_y + us_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(viet_flag, interpolate = TRUE),\n    xmin = viet_flag_x - viet_flag_width / 2,\n    xmax = viet_flag_x + viet_flag_width / 2,\n    ymin = viet_flag_y - viet_flag_width / 2, \n    ymax = viet_flag_y + viet_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(ger_flag, interpolate = TRUE),\n    xmin = ger_flag_x - ger_flag_width / 2,\n    xmax = ger_flag_x + ger_flag_width / 2,\n    ymin = ger_flag_y - ger_flag_width / 2, \n    ymax = ger_flag_y + ger_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(indonesia_flag, interpolate = TRUE),\n    xmin = indonesia_flag_x - indonesia_flag_width / 2,\n    xmax = indonesia_flag_x + indonesia_flag_width / 2,\n    ymin = indonesia_flag_y - indonesia_flag_width / 2, \n    ymax = indonesia_flag_y + indonesia_flag_width / 2\n  )\n\ngg_flag\n\n\n\nComments\nAfter doing that, let’s add comments related to nine out of the thirteen countries present in the graph. To do this, first, we’ll save the textual descriptions in different variables. Then, using ‘annotate’, we’ll position the comments next to their respective countries.\n\n\ntext_thai <- \"Thailand generates 84% of its energy     \\nfrom fossil fuels, mostly from natural gas\"\n\ntext_indonesia <- \"Coal comprises 62% of \\nIndonesia's energy mix \"\n\ntext_india <- \"India and China get most of their  \\nenergy from coal at 74% and 61%\"\n\ntext_mexico <- \"Mexico uses very little col and  \\ngets is energy from gas at 56%\\nand renewables at 24%           \"\n\ntext_sk <- \"Nuclear makes up 28% \\nSouth Korea's energy generation               \"\n\ntext_japan <- \"Nearly two thirds of Japan's \\nenergy is from gas and coal\"\n\ntext_viet <- \"Half of Vietnam's energy         \\nis from renewables\"\n\ntext_germany <- \"41% of UK's and 44% of Germany's \\n           energy are from renewables\"\n\ngg_com <- gg_flag +   annotate(\"text\", x = 0.298, y = 0.94, label = text_thai, \n                     size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.995, y = -0.085, label = text_indonesia, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.955, y = -0.525, label = text_india, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.312, y = -0.95, label = text_mexico, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.455, y = -0.897, label = text_sk, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.821, y = -0.65, label = text_japan, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.952, y = 0.111, label = text_viet, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.87, y = 0.68, label = text_germany, \n           size = 2.7, color = \"black\")\n\ngg_com\n\n\n\nTitle and legend\nTo properly position and display the title and legend, let’s first move the graph a bit downwards. Once done, using ‘gg_title,’ we’ll add our title. Then, due to the complex nature of the original graph, we were compelled to manually add the legend using ‘annotate’. In fact, we started by listing the names of the energy sources, and then we placed a square of the corresponding color next to each name. Below is the code and the resulting graph.\n\n\ngg_plot1 <- gg_com + theme(plot.margin = margin(t = 50, r = 0, b = 0, \n                                    l = 0, unit = \"pt\")) +\n  ggtitle(\"Energy Generation by Fuel Type\") + \n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, \n                                  size = 27, face = \"bold\")) +\n  annotate(\"text\", x = -0.49, y = 1.167, label = \"Coal\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = -0.266, y = 1.167, label = \"Natural gas\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.03, y = 1.167, label = \"Renewables\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.28, y = 1.167, label = \"Nuclear\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.465, y = 1.167, label = \"Other\", \n           size = 3.5, color = \"black\") +\n  annotate(geom = \"rect\", xmin = -0.55, xmax = -0.58, \n           ymin = 1.15, ymax = 1.18, fill = \"black\") +\n  annotate(geom = \"rect\", xmin = -0.39, xmax = -0.42, \n           ymin = 1.15, ymax = 1.18, fill = \"dimgray\") +\n  annotate(geom = \"rect\", xmin = -0.1, xmax = -0.13, \n           ymin = 1.15, ymax = 1.18, fill = \"blue1\") +\n  annotate(geom = \"rect\", xmin = 0.16, xmax = 0.19, \n           ymin = 1.15, ymax = 1.18, fill = \"gold3\") +\n  annotate(geom = \"rect\", xmin = 0.37, xmax = 0.4, \n           ymin = 1.15, ymax = 1.18, fill = \"gray92\")\n\ngg_plot1\n\n\n\nTheme\nFinally, all that remains is to remove the axes and gridlines, achieving a cleaner result.\n\n\ngg_fin <- gg_plot1 + theme_void() +\n  ggtitle(\"Energy Generation by Fuel Type\") + \n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, \n                                  size = 27, face = \"bold\"))\n\ngg_fin\n\n\n\nAlternative version\nIn this section, we present a different representation of the same data. We deemed it preferable to opt for an entirely different type of visualization rather than making improvements to the original graph. In fact, we don’t see valid reasons to use a circular chart for this data, as it makes interpretation considerably more complex. In our alternative version, we chose to represent the data using a simple stacked bar plot, which undoubtedly allows for a more immediate understanding. Further changes we made will be presented within this section.\nLibraries and data\nAlso in this case, we begin by importing the necessary libraries and the Excel file that we will use to access the data, which we will then manually enter. Compared to the previous graph, we have chosen to group the available data differently. In this version, we include coal and natural gas under the broader category of ‘fossil fuels.’ We haven’t made any changes to either the ‘renewable’ sources or ‘nuclear’ energy. Although many consider nuclear energy a clean source, according to the European Union, due to the use of uranium, it cannot be classified as renewable energy. Finally, we have also retained the ‘Other’ category as residual energy sources. We have made this reclassification because, in the current era, rather than detailing the various sources, it is more important to distinguish between polluting fossil fuels and renewable ones. This way, it will be easier to immediately understand which countries are more virtuous and which ones still need to take steps towards a greener energy approach.\n\n\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(readxl)\n\ndata <- read_excel(\"Data.xlsx\")\n\ndati <- data.frame(\n  Country = c(\"China\", \"Germany\", \"India\", \"Indonesia\", \"Japan\", \"Malaysia\", \n              \"Mexico\", \"South Korea\", \"Taiwan\", \"Thailand\", \"United Kingdom\", \n              \"United States\", \"Vietnam\"),\n  Other = c(1, 4, 0, 3, 14, 1, 11, 1, 4, 1, 3, 1, 0),\n  Nuclear = c(5, 5, 3, 0, 4, 0, 4, 9, 8, 0, 11, 19, 0),\n  Renewables = c(30, 44, 21, 19, 21, 21, 24, 28, 8, 15, 41, 21, 50),\n  Fossil_fuels = c(64, 47, 76, 78, 61, 78, 61, 62, 80, 84, 45, 59, 50)\n)\n\n\nCoordinates and axes\nNow, let’s proceed with creating our graph. We’ll begin by plotting a Cartesian plane, where numerical values will be represented on the X-axis, while we’ll list the thirteen countries on the Y-axis. These countries have been ordered based on the data so that those primarily generating energy from fossil fuel sources are positioned lower, and as we move upwards, we find those utilizing a more substantial percentage of renewable sources and other sources, besides the more polluting ones.\n\n\ncustom_order <- c(\n  \"Thailand\", \"Taiwan\", \"Indonesia\", \"Malaysia\", \"India\", \n  \"China\", \"South Korea\", \"Mexico\", \"Japan\", \"United States\", \"Vietnam\", \n  \"Germany\", \"United Kingdom\"\n)\ndati_long <- melt(dati, id.vars = \"Country\")\ndati_long$Country <- factor(dati_long$Country, levels = custom_order)\n\np <- ggplot(dati_long, aes(x = value, y = Country, fill = variable))\np\n\n\n\nNow let’s continue building the graph by adding the bars with the legend.\n\n\np + geom_bar(stat = \"identity\", width = 0.95)\n\n\n\nAfterward, we’ll change the colors associated with each energy source. Compared to the original graph, we have chosen different colors that are more visible and distinguishable from each other. Specifically, we relied on the ‘YlGnBu’ palette from the RColorBrewer package.\n\n\np <- p +\n  geom_bar(stat = \"identity\", width = 0.83) +\n  scale_fill_manual(values = c(\n    Other = \"#474a35\",\n    Nuclear = \"#edf8b1\",\n    Renewables = \"#7fcdbb\",\n    Fossil_fuels = \"#2c7fb8\"\n  ), labels = c(\n    Other = \"Other\",\n    Nuclear = \"Nuclear\",\n    Renewables = \"Renewables\",\n    Fossil_fuels = \"Fossil fuels\"\n  ))\np\n\n\n\nThen, we simplified the graph by removing the axis titles and changing the theme.\n\n\np <- p +\n  labs(title = \"\", x = \"\", y = \"\") +\n  theme_minimal()\np\n\n\n\nLater on, we made some minor adjustments to enhance the visual appearance. Initially, we changed the font of the axis labels, making them bold for better visibility, and additionally italicized the country names to give them a more refined look. Then, we highlighted both axes to facilitate data interpretation. Finally, we made some modifications to the legend, moving it to the top center in a horizontal position, and changing the text font.\n\n\np <- p +\n  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust = 1, family = \"Arial\", face = \"bold\"),\n        axis.text.y = element_text(family = \"Arial\", face = \"bold.italic\"),\n        axis.title = element_text(family = \"Arial\", face = \"bold\"),\n        axis.line = element_line(color = \"black\"),\n        panel.grid = element_blank(),\n        legend.title = element_text(face = \"bold\", family = \"Arial\"),\n        legend.text = element_text(family = \"Arial\"),\n        legend.position = \"top\",  \n        legend.box = \"horizontal\")\np\n\n\n\nAfterward, we made some changes to the X-axis, displaying the percentages, which undoubtedly makes interpretation easier, and limiting its length.\n\n\np <- p + \n  scale_x_continuous(\n    labels = c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\"),\n    breaks = c(0, 25, 50, 75, 100),\n    limits = c(0, 100),  \n    expand = c(0, 0)\n  )\np\n\n\n\nFurthermore, in order to make interpreting the graph even simpler, especially concerning the percentage of energy from sources other than fossil fuels, we added dashed vertical lines corresponding to the 25%, 50%, and 100% percentages.\n\n\np <- p +\n  geom_vline(xintercept = c(25, 50, 75), linetype = \"dashed\", color = \"black\", alpha = 0.4)\np\n\n\n\nLet’s proceed further by refining some details, removing the title from the legend.”\n\n\np <- p +\n  guides(fill = guide_legend(reverse = TRUE, title = NULL))\np\n\n\n\nFinally, let’s complete the graph by adding the title in the appropriate position.\n\n\np +\n  ggtitle(\"Energy Generation by Fuel Type\") +\n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, size = 27, face = \"bold\"))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100513254/100513254_files/figure-html5/unnamed-chunk-15-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1910,
    "preview_height": 1881
  },
  {
    "path": "projects/2023/100516910/",
    "title": "Club Convergence Graphs",
    "description": "Visual representation of Convergence Clubs for European countries in terms of R&D spending following KMeans and Phillips&Sul methodologies.",
    "author": [
      {
        "name": "Bernard Banyuls",
        "url": {}
      }
    ],
    "date": "2024-01-08",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nData\nMethodology\nKMeans\nClub Convergence\n\nKMeans\nOriginal graph\nReplication\nAlternative\n\nClub Convergence\nOriginal graph\nReplication\nAlternative\n\n\nIntroduction\nThese project is divided in two parts following the idea of convergence clubs, the first part focuses on applying KMeans algorithm following the data that formal Beta-convergence uses, and the second part will be regarding the methodology proposed by Phillips and Sul to study the existence of Convergence Clubs.\nThe project does not focuses on how KMeans and ClubConvergence methodologies work but rather how we could replicate the graphs that different libraries show the results and its respective improvement or alternative representation.\nData\nThe data used comes from the eurostat database, and is the Research and Development spending per capita of European countries from 2005-200. In which for the KMeans representation we have the base value of 2005, and the growth in percentage terms in that range. For the case of club convergence we used the annual values of each country.\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\n\n#kmeans dataframe\nkmeans <- data.frame(\n  RD2005 = c(6.275703, 2.624669, 4.833102, 6.847262, 6.518114, \n             4.338597, 6.201928, 4.655863, 5.461711, 6.358016, \n             4.283587, 5.596568, 3.475067, 3.845883, 6.930886, \n             4.417635, 4.213608, 6.395762, 6.600143, 3.591818, \n             4.739701, 2.727853, 5.331268, 3.589059, 6.952059, \n             7.070979),\n  Growth = c(0.92375108, 1.69681154, 1.16036030, 0.52391288, \n             0.63775027, 1.55277085, 0.62851413, 0.79388677, \n             0.34673183, 0.31490307, 0.75596008, 0.44273349, \n             1.21811383, 1.46337410, 0.09846755, 0.99757606, \n             0.90737537, 0.57252347, 0.62278834, 1.66619833, \n             1.01064686, 1.24432410, 0.84397491, 1.44594353, \n             0.18259257, 0.32154540),\n  Classes = c(1, 0, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 0, 0, 1, \n              2, 2, 1, 1, 0, 2, 0, 2, 0, 1, 1)\n)\n\nkmeans$Classes <- factor(kmeans$Classes)\n\n#Club Convergence Club 1 dataframe\nRD_c1 <- data.frame(\n  country = rep(c(\"Austria\", \"Belgium\", \"Denmark\", \n                  \"Finland\", \"Germany\", \"Luxembourg\", \n                  \"Netherlands\", \"Sweden\"), each = 16),\n  year = rep(2005:2020, times = 8),\n  value = c(\n    1.2636954, 1.2597917, 1.2560107, 1.2523861, \n    1.2489316, 1.2456249, 1.2424396, 1.2393501, \n    1.2362968, 1.2332214, 1.2300758, 1.2268392, \n    1.2234943, 1.2200762, 1.216634, 1.2132162,\n    1.1931131, 1.1917045, 1.1903862, 1.1892365, \n    1.1883264, 1.1876866, 1.1873416, 1.1873075, \n    1.1875762, 1.1881236, 1.188915, 1.1899046, \n    1.1910207, 1.1922126, 1.1934391, 1.1946641,\n    1.3207855, 1.3145264, 1.3084158, 1.3024538, \n    1.2966115, 1.2908368, 1.285117, 1.2794547, \n    1.2738372, 1.2682436, 1.2626524, 1.2570401, \n    1.2513862, 1.2457252, 1.2401036, 1.2345612,\n    1.3467373, 1.3342167, 1.3219579, 1.3099375, \n    1.2981126, 1.2864238, 1.2748457, 1.2633862, \n    1.2520707, 1.2409227, 1.2299724, 1.2192528, \n    1.2087581, 1.1984812, 1.188409, 1.1785213,\n    1.2454659, 1.2415035, 1.2376704, 1.234019, \n    1.2305783, 1.2273345, 1.2242728, 1.2213699, \n    1.2185924, 1.2159016, 1.2132533, 1.2106106, \n    1.2079341, 1.20522, 1.2024912, 1.19978,\n    1.3466198, 1.3334351, 1.3205158, 1.307873, \n    1.2955232, 1.2834622, 1.271719, 1.260325, \n    1.249302, 1.2386057, 1.2281681, 1.2179158, \n    1.2077794, 1.1977508, 1.1878533, 1.1781052,\n    1.2124217, 1.2072734, 1.2023008, 1.1975962, \n    1.1932373, 1.1892418, 1.1856002, 1.1822699, \n    1.179186, 1.1762552, 1.1734111, 1.1706133, \n    1.1678222, 1.1650372, 1.1622778, 1.1595588,\n    1.3522649, 1.3423129, 1.3326128, 1.3232417, \n    1.314261, 1.3056945, 1.2975129, 1.2896621, \n    1.282073, 1.2746767, 1.2674274, 1.2602729, \n    1.2531619, 1.2460934, 1.2391038, 1.2322215\n  )\n)\n\n\nMethodology\nKMeans\nThere are several algorithms for clustering, but the standard one is the Hartigan-Wong algorithm in which the total variance of the individuals within a cluster is defined as the sum of the squared Euclidean distances between the elements and the corresponding centroid.\nThe centroid of each group is the center of the group that corresponds to the mean value of each individual in that cluster.\nThe clustering algorithm follows the following processes:\nThe algorithm randomly places \\(k\\) centroids in the data as initial centroids. And then, each individual \\(x_i\\) is assigned to the nearest centroid using the Euclidean distance.\nThe next step is to calculate the average value of each cluster that becomes the new centroid and the individuals \\(x_i\\) are reassigned to the new centroids \\(μ_k\\).\nThe previous step is repeated until the centroids do not change, thus achieving that the total variation of individuals within a cluster is the minimum possible.\nClub Convergence\nFor the analysis of convergence clubs, we will apply the methodology developed by Phillips and Sul (2007) through Stata program and RStudio of Du (2017). This methodology allows us to study the existence of convergence clubs without having to separate our data sample into subgroups through several variables in common.\nDue to the word count limit, the mathematical development cannot be presented. However, for details, you can follow the work of Phillips and Sul (2007, 2009) and Du (2017). However, the following t-regression model will be the one studied in the present work:\nThe following t regression model developed by Phillips and Sul (2007) is used:\n\\[log⁡(H_1/H_t )-2log⁡{log⁡(t)}=a+blog⁡(t)+ε_t for t=[rT],[rT]+1,…,T\";  \" r>0 \\]\nIn which, if there is convergence \\(H_i\\) will be 0 and, therefore \\(log⁡(H_1/H_t)\\) will tend to infinity. For this to occur \\(b\\) has to be greater than or equal to zero, in case it is negative the hypothesis of absolute convergence would be rejected and we would proceed to analyze if there are convergence clubs.\nFor convergence clubs, Phillips and Sul (2007) developed an algorithm to identify the various clubs that might be in a sample.\nThe following process represents how this algorithm works:\nCross-section classification: The different countries are ordered in decreasing order, i.e., from highest to lowest, taking into account the values of the last period.\nClub formation: We start by forming groups from the country with the highest value in the last period. Then we look for the first k such that when we do the log \\(t\\) regression test statistic, we are left with \\(t_k\\) being greater than -1.65. This is done for the first two countries, and in case it is not satisfied, it is performed for the second and third countries, and so on until a pair of countries is found that does satisfy the test. In case there is no pair of countries, i.e., there is no \\(k\\) that meets this requirement, there would be no convergence subgroups in our data sample.\nScreening of individuals to create convergence clubs: In the event that in the club formation, we have encountered a pair, we proceed to perform the same test by adding countries in the order we previously classified. When the criterion is no longer met, we would have our first club.\nRecursion and stopping rule: A subgroup is made with the individuals that have not been screened in the previous step. The log \\(t\\) regression test is performed and if it is greater than -1.65, another group is formed. Otherwise, the three previous steps would be performed with this subgroup.\nKMeans\nOriginal graph\nThe original graph represents the R&D spending per capita growth from 2005 to 2020, and the base value in 2005 in an scatter plot with three different background areas colored representing the different classes obtained using the kmeans algorithm for these two features. The graph was done by myself in python using mathplotlib and the kmeans algorithm to obtain the graph.\nR&D spending per capita - Clustering. Source: Own elaboration.Replication\nThe first thing we have to do to replicate this graph is to do a simple scatterplot in which we have to plot the points twice, one with the color of the “class” and another point in the same place but a little bit wider in a white color.\nThis first step is pretty straight forward as we only have to graph the points of each country, and then we have to plot the centroids manually with the same idea of plotting the point twice to give a wider border to each point.\nThen, the next step is to put the legend inside the graph rather than outside. Although there are still some minor changes that we should focus before plotting the colored areas indicating each different class such as removing the grid lines among other things.\n\n\nggplot(kmeans) +\n  geom_point(aes(x = RD2005, y = Growth), color = \"white\", \n             size = 7, shape = 16) +\n  geom_point(aes(x = RD2005, y = Growth, color = Classes), \n             size = 6, shape = 16) +\n  geom_point(x = 3.3, y = 1.5, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 3.3, y = 1.5, size = 12, color = \"#440154\", shape = 16) +\n  geom_point(x = 4.8, y = 0.9, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 4.8, y = 0.9, size = 12, color = \"#fde725\", shape = 16) +\n  geom_point(x = 6.6, y = 0.45, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 6.6, y = 0.45, size = 12, color = \"#21918c\", shape = 16) +\n  scale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\")) +\n  labs(x = \"RD2005\", y = \"Growth\") + \n  theme(\n    legend.position = c(.95, .95),\n    legend.justification = c(\"right\", \"top\"),\n    legend.box.just = \"right\",\n    legend.margin = margin(6, 6, 6, 6)\n    )\n\n\n\nThe complicated part while replicating the plot is how we create the background which is composed of three different colored areas representing each class the countries are part of.\nWe will use the geom_polygon() to color these areas, and for that matter we have to create three temporary dataframes as we can observe in the code that shows which points it will cross the polygon before coloring the area of the shape.\nThen, in this part we have also removed all the information that is not shown in the original graph such as the axis ticks and improving the legend to match the original graph.\n\n\nviolet <- data.frame(x = c(2.1, 2.1, 3.2, 4.3), y = c(2, -1, -1, 2))\nyellow <- data.frame(x = c(3.2, 4.3, 6.3, 5.5, 3.5), y = c(-1, 2, 2, -1, -1))\nblue  <- data.frame(x = c(6.1, 5.3, 8, 8), y = c(2, -1, -1, 2))\n\n\nggplot(kmeans) +\nscale_y_continuous(breaks = c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6), \n                   minor_breaks = NULL) +\nscale_x_continuous(breaks = c(3, 4, 5, 6, 7), minor_breaks = NULL) +  \ntheme(axis.title = element_text(face =\"italic\", size=15)) +\ntheme(\n  legend.position = c(0.99, 0.99),\n  legend.justification = c(\"right\", \"top\"),\n  legend.box.just = \"right\",\n  legend.margin = margin(11, 5, 5,11),\n  legend.spacing.x = unit(0.8, \"cm\"), \n  legend.text = element_text(size = 16),\n  legend.title = element_text(size = 15),\n  legend.background = element_rect(fill = \"#f0f6f7\", size = 0.3, \n                                   color =\"gray\")) +\nguides(color = guide_legend(override.aes = list(size = 8))) +\nggtitle(\"k-means with 3 cluster(s)\") +\ntheme(plot.title = element_text(hjust = 0.5, size=17)) +\ntheme(legend.spacing.x = unit(0.5, 'cm')) +\ntheme(legend.text.align = 0.5) +\ntheme(\n  axis.line = element_blank(),      \n  axis.text = element_blank(),     \n  axis.ticks = element_blank(),      \n  panel.grid.major = element_blank(),  \n  panel.grid.minor = element_blank()) +\ntheme(axis.title = element_text(face =\"italic\", size=14, color = \"black\")) +\nlabs(y = \"RDGROWTH\", x=\"RD2005\") +\ncoord_cartesian(xlim = c(min(kmeans$RD2005), max(kmeans$RD2005)), \n                ylim = c(min(kmeans$Growth), max(kmeans$Growth))) +\ngeom_polygon(aes(x = x, y = y), data = violet, fill = \"#c1b0cb\") +\ngeom_polygon(aes(x = x, y = y), data = yellow, fill = \"#eee9bf\") +\ngeom_polygon(aes(x = x, y = y), data = blue, fill = \"#b8d3d8\") +\ngeom_point(aes(x = RD2005, y = Growth), color = \"white\", size = 7, shape = 16) +\ngeom_point(aes(x = RD2005, y = Growth, color = Classes), size = 6, shape = 16) +\ngeom_point(x = 3.3, y = 1.5, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 3.3, y = 1.5, size = 10, color = \"#440154\", shape = 16) +\ngeom_point(x = 4.8, y = 0.9, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 4.8, y = 0.9, size = 10, color = \"#fde725\", shape = 16)+\ngeom_point(x = 6.6, y = 0.52, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 6.6, y = 0.52, size = 10, color = \"#21918c\", shape = 16)+\nscale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\"))\n\n\n\nAlternative\nOne of the main problems that this graph has is that first the colored background may confuse readers thinking that a country different from the original set of countries falls into certain color it would be part of that class, although how kmeans work it would not be exactly like that, for that matter although in the original graph and its replication the colored area makes the graph more enhancing it may confuse the reader.\nAnother problem is that the graph does not give so much information as there is no axis ticks, we do not fully know which is the range of the R&D spending and its unit measure. Although a better version of the replication would be the first step shown above one alternative is to represent the scatter plot using a facet_wrap to differentiate better between the classes.\nTo complicate the graph I decided to color the facet label to match the color of the class. Although there is a library called ggh4x, that allows us to do this thing easily, there is another way using geom_rect() which is better explained here.\nIn order to do this, we have to create a dataset that contains a column with all the facet names, in this case the different classes we have for the countries. Followed by another column that contains the labels we have for each class. We then specify the color using scale_fill_manual() and it is important that we use coord_cartesian() for two reasons:\nTo cut the panel area in the plot to only contain the points so the panel does not change to accomodate the geom_rect.\nTo turn clipping off, so layers outside the panel can be seen.\nAnd finally, it is important to turn strip.background to transparent so we can see the color of each box.\n\n\ntemp_df <- data.frame(\n  Classes = c(0,1,2),\n  var_color = c(\"Class 0\", \"Class 1\", \"Class 2\"))\n\nggplot(kmeans) + \n  geom_rect(\n    data = temp_df,\n    aes(\n      xmin = -Inf, xmax = Inf,\n      ymin = 2.1, ymax = 2.6,     \n      fill = var_color, alpha = 0.4\n    )\n  ) +     \n  coord_cartesian(clip = \"off\", ylim = c(0, 2))  + \n  geom_point(aes(x = RD2005, y = Growth, color = factor(Classes)), size = 5) +  \n  scale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\"\n  )) + \n  facet_wrap(~ factor(Classes, labels = c(\"Class 0\", \"Class 1\", \"Class 2\")), \n             ncol = 1 ) +\n  scale_fill_manual(\n    values = c(\"Class 0\" = \"#440154\", \"Class 1\" = \"#21918c\", \n               \"Class 2\" = \"#fde725\")) +\n  theme_bw() +\n  theme(\n    strip.background = element_rect(fill = NA),\n    strip.text = element_text(size = 12, face = \"bold\"),\n    legend.position = \"none\",\n    axis.text.x = element_text(color = \"black\", size = 12),\n    axis.text.y = element_text(color = \"black\", size = 12),\n    axis.title.x = element_text(color = \"black\", size = 14),\n    axis.title.y = element_text(color = \"black\", size = 14),\n    axis.ticks = element_line(color = \"black\")\n  ) +   \n  labs(\n    title = \"Kmeans with 3 cluster(s)\",\n    x = \"log(RD2005percapita)\",\n    y = \"Growth(%)\",\n    subtitle = \"European clusters in terms of R&D spending\",\n    caption = \"Kmeans algorithm has been applied to EU countries in terms of \nthe log of the R&D spending per capita and its respective growth from 2005-2020\"\n  ) \n\n\n\nClub Convergence\nOriginal graph\nThe original graph is a representation of the countries of the three different clubs obtained and a fourth graph that takes into account the average of each club. The graph has been done using the ClubConvergence package in R in which the four graphs are shown in the same figure using only one line of code to get the result once the clubs were calculated.\nFor that matter as the four graphs are exactly the same only changing the club representing I will only replicate one of the clubs in order to show a better alternative to represent a club visually. Although the way to replicate the exact figure would be creating four graphs, one for each club and another one with the average of each club and then using patchwork to create the figure.\n\nReplication\nThe graph is pretty simple to replicate it only takes time to assign each color, shape and type of line to each country.\nThe point shape options in ggplot are the ones we can observe in the following picture:\nPoint Shape Options in ggplot. Source:Albert’s BlogAnd the line shape options in ggplot are the ones we can observe in the following picture:\n\nThe following scheme of colors, shapes and linetype for each country is assigned using this code:\n\n\ncountry_colors <- c(\n  \"Austria\" = \"#61d04f\",\n  \"Belgium\" = \"#28e2e5\",\n  \"Denmark\" = \"#080404\",\n  \"Finland\" = \"#df536b\",\n  \"Germany\" = \"#9e9e9e\",\n  \"Luxembourg\" = \"#f5c710\",\n  \"Netherlands\" = \"#2297e6\",\n  \"Sweden\" = \"#cd0bbc\"\n)\n\ncountry_shapes <- c(\n  \"Austria\" = 17,\n  \"Belgium\" = 16,\n  \"Denmark\" = 15,\n  \"Finland\" = 16,\n  \"Germany\" = 18,\n  \"Luxembourg\" = 1,\n  \"Netherlands\" = 0,\n  \"Sweden\" = 16\n)\n\n\ncountry_linetypes <- c(\n  \"Austria\" = \"dotted\",\n  \"Belgium\" = \"longdash\",\n  \"Denmark\" = \"solid\",\n  \"Finland\" = \"dotdash\",\n  \"Germany\" = \"dotdash\",\n  \"Luxembourg\" = \"solid\",\n  \"Netherlands\" = \"dashed\",\n  \"Sweden\" = \"dashed\"\n)\n\n\nTo replicate the graph is really straightforward as we only have two represent the lines and points using geom_line() and geom_point respectively, assign the line types, shape types and colors for each country.\n\n\nggplot(RD_c1, aes(x = year, y = value, color = country, shape = country, \n                  linetype = country)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw() +\n  scale_x_continuous(breaks = RD_c1$year, labels = RD_c1$year) +\n  scale_y_continuous(breaks = c(1.20, 1.25, 1.30, 1.35)) +\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), \n        axis.title.x = element_blank()) +\n  ylab(\"h\") +\n  scale_color_manual(values = country_colors) +\n  scale_shape_manual(values = country_shapes) +\n  scale_linetype_manual(values = country_linetypes)+ \n  theme(legend.position = \"none\") +\n  theme(panel.border = element_rect(colour = \"black\", fill=NA, size=0.7),\n        axis.text.y = element_text(angle = 90, colour = \"black\"),\n        axis.title.y=element_text(colour=\"black\"),\n        axis.text.x = element_text(colour = \"black\")\n        )\n\n\n\nAlternative\nOne of the main issues with the graph is that there is no legend and we do not know which is country is which although it would just deleting theme(legend.position = “none”) from the previous code, although a better alternative would be representing the graph using facet_wrap and gghighlight mainly.\n\n\nlibrary(gghighlight)\n\nggplot(RD_c1) +\n  geom_line(aes(x=year, y=value, color=country, linetype = country)) +\n  geom_point(aes(x=year, y=value, color = country, shape = country)) +\n    gghighlight(use_direct_label = FALSE,\n              unhighlighted_params = list(colour = alpha(\"grey85\", 0.5), \n                                          shape=1, linetype = \"solid\")) +\n  theme_bw() +\n  scale_x_continuous(breaks = seq(min(RD_c1$year), max(RD_c1$year), by = 5)) +  \n  scale_y_continuous(breaks = c(1.20, 1.25, 1.30, 1.35)) +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title.x = element_blank(),\n    axis.text.x = element_text(size = 8)  \n  ) +\n  ylab(\"h\") +\n  scale_color_manual(values = country_colors) +\n  scale_shape_manual(values = country_shapes) +\n  scale_linetype_manual(values = country_linetypes) +\n  facet_wrap(~country, scales = \"fixed\") +  # Facet by country\n  theme(legend.position = \"none\")+\n  theme(\n    axis.text = element_text(color=\"black\", size=7),\n    strip.text.x = element_text(face=\"bold\"),\n    plot.background = element_rect(color=\"#F4F5F1\", fill=\"#F4F5F1\"),\n    legend.position = \"none\",\n    legend.title = element_text(face=\"bold\")\n  ) + theme(strip.background = element_blank(),\n             panel.spacing=unit(1,\"lines\"))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100516910/100516910_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 3264,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100481433/",
    "title": "The world is progressively embracing democracy",
    "description": "A reproduction of the Our World in Data visualization, which is based on the\nclassification and assessment of countries' political regimes by Skaaning et al. (2015).",
    "author": [
      {
        "name": "Sofia Villamil Erosa",
        "url": {}
      }
    ],
    "date": "2023-12-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nDemocracy\nDefinitions\n\nGetting the data\nBuilding the chart\nData\nStarting with the graphic\nFinal touches\n\nImproving the chart\nBuilding the new chart\n\n\nDemocracy\nThe graphic I choose shows how democracy has spread across countries, how it differs between them, and whether we are moving\ntowards a more democratic world. The variables denoted in the chart shows the number of electoral democracies in the world based\non the Lexical Index of Electoral Democracy-classification from Skaaning et al. (2015).\nThe Lexical Index definition attained from Our World in Data establishes that it is a classification system that categorizes\npolitical systems or regimes based on easily observable characteristics. It aims to avoid difficult evaluations by experts or\nresearchers and relies on its own teams to assess specific criteria. These criterions are used to identify democracies and\nnon-democracies. The index is able to track political systems over time, measured since the year 1789, and includes 242 countries.\nThe index prioritizes straightforward and objective factors, making it a tool for quick assessments and comparisons.\nDefinitions\nTypes of Democracy in the Lexical Index:\nNon-Electoral Autocracy: A political system characterized by a single entity or a small group holding power without\nelections, often with a single autocrat or ruling elite.\nOne-Party Autocracy: A system where a single political party maintains absolute control over the government, suppressing\nthe opposition and competitive elections.\nMulti-Party Autocracy without Elected Executive: A political system with multiple parties, but the executive leader is\nnot elected democratically.\nMulti-Party Autocracy: Features multiple political parties, but the political system still retains autocratic elements.\nExclusive Democracy: Inclusive of elections but excludes certain groups or individuals from political participation.\nMale Democracy: A democracy where only male citizens are allowed to participate in elections.\nElectoral Democracy: A political system with regular elections where citizens can choose their leaders, but this may not\nguarantee full democratic rights.\nPolyarchy: A comprehensive democracy with competitive elections, civil liberties, political pluralism, and broad\nparticipation.\nThese definitions reflect the categorization of political systems within the Lexical Index, based on specific characteristics and\nlevels of inclusiveness attained from Skaaning et al. (2015), with “Polyarchy” representing the highest level of democracy and\ninclusivity.\nGetting the data\nThe dataset, obtained from Our World in Data and based on research by Skaaning et al. (2015), categorizes the world’s nations\ninto democracies and autocracies. This graphic dynamically captures the shifts in these counts from 1789 through 2022, offering\ninsights into the evolving landscape of global political systems nowadays. All the data needed for this chart can be downloaded\ndirectly from the Our World in Data website in the topic Democracy\n(https://ourworldindata.org/grapher/countries-democracies-autocracies-lexical).\n\n\ndata <- read.csv(\"data_world.csv\", sep = \";\", dec = \",\")\n\n\nBuilding the chart\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n\nData\nThe data scoured from Our World in Data needed to be converted to frequency tables . The graph’s vertical axis, which I aimed to\nreplicate, utilized cumulative frequency as a metric, necessitating the data’s conversion. Subsequently, I identified and chose\nthe specific columns needed for the replication, resulting in the creation of a new data-set named df_reduced.\n\n\ndf_reduced <- data %>%\n  select(Year, Frec.Non.electoral.autocracies, Frec.One.party.autocracies,\n         Frec.Multi.party.autocracies.without.elected.executive,\n         Frec.Multi.party.autocracy, Frec.Exclusive.democracies, \n         Frec.Male.democracies, Frec.Electoral.democracies, \n         Frec.Polyarchies) \n\ncustom_order <- c(\"Frec.Non.electoral.autocracies\", \"Frec.One.party.autocracies\", \n                  \"Frec.Multi.party.autocracies.without.elected.executive\",\n                  \"Frec.Multi.party.autocracy\", \"Frec.Exclusive.democracies\",\n                  \"Frec.Male.democracies\", \"Frec.Electoral.democracies\",\n                  \"Frec.Polyarchies\")\n\n\nTo enhance accessibility and facilitate the chart-building process, I converted the new dataset into tidy data. During this\nconversion, several changes were implemented, and intervals were established for the axis.\n\n\ndf_long <- df_reduced %>%\n  pivot_longer(cols = -Year, names_to = \"Democracy_Type\", values_to = \"n\")\n\ndf_long <- df_long %>%\n  mutate(Democracy_Type = factor(Democracy_Type, levels = custom_order))\n\ninterval_x <- c(1789, 1850, 1900, 1950, 2000, 2022)\n\ninterval_y <- seq(0, 100, by = 0.2)   \n\n\nDue to each variable having an associated color. The following color vector was created for each value.\n\n\ndemocracy_colors <- c(\n  \"Frec.Non.electoral.autocracies\" = \"#d73027\",\n  \"Frec.One.party.autocracies\" = \"#f46d43\", \n  \"Frec.Multi.party.autocracies.without.elected.executive\" = \"#fdae61\", \n  \"Frec.Multi.party.autocracy\" = \"#fee090\", \n  \"Frec.Exclusive.democracies\" = \"#e0f3f8\",\n  \"Frec.Male.democracies\" = \"#abd9e9\",\n  \"Frec.Electoral.democracies\" = \"#74add1\", \n  \"Frec.Polyarchies\" = \"#4575b4\"\n)\n\n\nStarting with the graphic\nTo construct the visual representation, I utilized the geom_area function from ggplot, tailored for generating\nStacked Area Charts.\n\n\nplot <- ggplot(df_long, aes(x = Year, y = n, fill = Democracy_Type)) +\n  geom_area(alpha = 0.8, size = 0.2, aes(color = Democracy_Type)) +\n  labs(x = NULL, y = NULL, fill = NULL) +\n  scale_x_continuous(limits = c(1789, 2085), breaks = interval_x, minor_breaks = NULL) +\n  scale_y_continuous(labels = scales::percent_format(scale = 100), breaks = interval_y) +\n  scale_fill_manual(values = democracy_colors) +\n  scale_color_manual(values = democracy_colors) +\n  coord_cartesian(expand=0) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(\n      color=\"#5b5b5b\", size = 10, family = \"Lato\", angle = 0, \n      hjust = c(0.1, 0.3, 0.5, 0.5, 0.5, 1), margin = margin(t = 0)),\n    axis.ticks.x = element_line(color=\"#5b5b5b\", size = 0.2),\n    axis.ticks.length = unit(0.1, \"cm\"),\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.y = element_text(\n      color=\"#5b5b5b\", size = 10, family = \"Lato\", margin = margin(r = 0))\n  ) +\n  ggtitle(\n    \"Countries that are democracies and autocracies, World\", \n    subtitle = \"Political regimes based on the classification and assessment by Skaaning et al. (2015).\") +\n  theme(plot.title = element_text(\n    color=\"#5b5b5b\", family = \"serif\", size = 15, face = \"bold\", hjust = -0.27),\n        plot.subtitle = element_text(\n          color=\"#5b5b5b\", family = \"Lato\", size = 9, hjust = -0.24)\n  )\nplot\n\n\n\nI employed the intervals created during the data organization for both the x-axis and the y-axis in constructing the graphic.\nGiven that the y-axis represents frequencies in percentage, the code was modified to reflect this in the visualization. The year\nlimits were adjusted to fit the dimensions required for displaying custom labels for each democratic type. While the code’s limits\nspan from 1789 to 2085, the graphic displays the period from 1789 to 2022 on the x-axis.\nTo achieve a custom separation between each year on the x-axis, adjustments were made in the theme section, specifically in\naxis.text.x, where the spacing between each year was manually configured in order to be exactly the distance displayed\nin the graphic of reference.\nFinal touches\nI generated custom labels with corresponding colors and segments, mirroring the structure observed in the graphic that I aimed\nto replicate.\n\n\ncustom_legend <- data.frame(\n  Democracy_Type = levels(df_long$Democracy_Type),\n  x = rep(2022, length(levels(df_long$Democracy_Type))),\n  y = seq(0, 1, length.out = length(levels(df_long$Democracy_Type))),\n  label = c(\"Polyarchies\",\n            \"Electoral\\ndemocracies\",\n            \"Male\\ndemocracies\",\n            \"Exclusive\\ndemocracies\",\n            \"Multi-party\\nautocracy\",\n            \"Multi-party\\nautocracies\\nwithout elected\\nexecutive\",\n            \"One-party\\nautocracies\",\n            \"Non-electoral\\nautocracies\"\n  ),\n  label_distance = c(11, 11, 11, 21, 4, 31, 4, 8),\n  segment_distance = c(10, 10, 10, 20, 3, 30, 3, 7), \n  vertical_offset_segment = c(0.20, 0.33, 0.338, -0.16, 0.15, 0.09, 0.01, -0.04),\n  vertical_offset_label = c(0.20, 0.33, 0.338, -0.16, 0.15, 0.09, 0.01, -0.04)\n)\n\ncorrected_Democracy_Type <- rev(custom_legend$Democracy_Type)\n\n\nTo replicate the specific placement of labels and segments in the target graphic, I modified the code to permit manual\nadjustments for the angle, vertical, and horizontal placement of both text and segments. Thus, segment_distance makes\nreference to the horizontal placement of the segment and vertical_offset_segment\nis for the vertical placement.\nFurthermore, I introduced a custom legend to the plot and fine-tuned the size parameters to precisely match the dimensions of\nthe desired graphic.\n\n\nplot2 <- plot +\n  geom_text(\n    data = custom_legend,\n    aes(x = x + label_distance, \n        y = y + vertical_offset_label, \n        label = label, \n        color = corrected_Democracy_Type),\n    size = 2.5,\n    family = \"Lato\",\n    hjust = 0\n  ) +\n  geom_segment(\n    data = custom_legend,\n    aes(x = x + segment_distance, \n        xend = x + 1, \n        y = y + vertical_offset_segment, \n        yend = y + vertical_offset_segment, \n        color = \"#5b5b5b\"),\n    size = 0.5\n  ) +\n  theme(\n    plot.margin = margin(0.3, 0.3, 0.3, 0.3, \"cm\")\n  )\n\nplot2\n\n\n\nImproving the chart\nUpon careful consideration, I determined that there was no apparent need for enhancements in the replicated graphic. Consequently,\nI opted to generate a new visual representation utilizing the same dataset.\nBuilding the new chart\nIn an effort to retain as much of the original code as possible, I generated a new custom color palette to address perceived\ndeficiencies in the previous one. This adjustment was made to enhance visibility, ensuring that all colors are easily discernible.\nAdditionally, I maintained the code for creating custom labels in the process as I wanted to highlight that code and expand the\nuse of it to improve the new graphic.\n\n\ndemocracy_colors <- c(\n  \"Frec.Non.electoral.autocracies\" = \"#081d58\",\n  \"Frec.One.party.autocracies\" = \"#253494\",\n  \"Frec.Multi.party.autocracies.without.elected.executive\" = \"#225ea8\",\n  \"Frec.Multi.party.autocracy\" = \"#41b6c4\",\n  \"Frec.Exclusive.democracies\" = \"#7fcdbb\",\n  \"Frec.Male.democracies\" = \"#c7e9b4\",\n  \"Frec.Electoral.democracies\" = \"#1d91c0\",\n  \"Frec.Polyarchies\" = \"black\"\n)\ncustom_legend <- data.frame(\n  Democracy_Type = levels(df_long$Democracy_Type),\n  x = rep(2022, length(levels(df_long$Democracy_Type))),\n  y = seq(0, 1, length.out = length(levels(df_long$Democracy_Type))),\n  label = c(\n    \"Polyarchies\",\n    \"Electoral democracies\",\n    \"Male democracies\",\"Exclusive democracies\",\n    \"Multi-party autocracy\",\n    \"Multi-party autocracies without elected executive\",\n    \"One-party autocracies\",\n    \"Non-electoral autocracies\"\n  ),\n  label_distance = c(3, -20, 3, 3, -60, -220  , 3, -220),\n  vertical_offset_label = c(0.38, 0.17,-0.28, -0.27, -0.59, -0.32, -0.76, 0)\n)\n\ncorrected_Democracy_Type <- rev(custom_legend$Democracy_Type)\n\n\nThe chosen type of chart for improvements was a Parallel Plot utilizing the geom_line function from ggplot. I chose this\napproach as it provides a clearer representation of the evolution of each democracy type throughout the analysis period.\nIn trying to create the new graphic, I aimed for a fresh look while retaining the essence of the original one I sought to\nreplicate. To achieve this, I employed much of the existing code I had created for the previous graphic. Additionally, I\nintroduced some modifications to add distinctive elements that I deemed necessary, resulting in a new and improved interpretation\nof the same data set.\n\n\nplot_parallel_custom <- ggplot(df_long, aes(x = Year, y = n, color = Democracy_Type)) +\n  geom_line(aes(group = Democracy_Type), alpha = 0.8, size = 1) +\n  scale_x_continuous(limits = c(1789, 2065), breaks = interval_x, minor_breaks = NULL) +\n  scale_y_continuous(labels = scales::percent_format(scale = 100), breaks = interval_y) +\n  geom_text(\n    data = custom_legend,\n    aes(x = x + label_distance, \n        y = y + vertical_offset_label, \n        label = label, \n        color = corrected_Democracy_Type),\n    size = 2.8,\n    family = \"Playfair Display ExtraBold\",\n    hjust = 0) +\n  scale_color_manual(values = democracy_colors) +\n  labs(\n    x = \"Years\",\n    y = \"Percentage of Countries\",\n    title = \"Countries that are democracies and autocracies, World.\",\n    subtitle = \"Political regimes based on the classification and assessment by Skaaning et al. (2015).\"\n  ) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(\n      color = \"#252525\", family = \"serif\", size = 15, face = \"bold\", \n      hjust = -0.1, vjust = 0),\n    axis.title.x = element_text(\n      color = \"#252525\", family = \"serif\", size = 12, hjust = 0.44, vjust = -1),   \n    axis.title.y = element_text(\n      color = \"#252525\", family = \"serif\", size = 12,vjust = 3), \n    plot.subtitle = element_text(\n      color = \"#252525\", family = \"Lato\", size = 9, hjust = -0.1, \n      vjust = 0, face = \"italic\"),\n    axis.text.x = element_text(\n      color = \"#5b5b5b\", size = 9, family = \"Playfair Display ExtraBold\", \n      vjust = 0 , hjust = c(0, 0, 0, 0, 0.5, 1), margin = margin(t = -9)),\n  axis.text.y = element_text(\n    color = \"#5b5b5b\", size = 9, family = \"Playfair Display ExtraBold\", \n    vjust = 0, hjust = 0, margin = margin(r = -22 )\n    )\n  ) +\n  theme(\n    plot.margin = margin(0.4, 0.4, 0.5, 0.7, \"cm\"), \n  ) +\n  guides(color = \"none\")\n\nplot_parallel_custom\n\n\n\nRecognizing the need for enhanced interpretability, I decided to include legends for both the x-axis and y-axis, making it easier\nto understand the various measures depicted in the plot. To improve readability, I made adjustments such as changing the font\ncolor to black. Moreover, I relocated the labels inside the graphic instead of just using segments, believing that this\nmodification would enhance comprehension of each type of democracy and its evolution over time.\n\n\n\n",
    "preview": "projects/2023/100481433/100481433_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100482711/",
    "title": "What Future for Amazon - Some Lessons from the Past",
    "description": "Evolution of Amazon Deforestation (1988 - 2021) with Basis on Inpe - Sistema PRODES Data.",
    "author": [
      {
        "name": "Artem Urlapov",
        "url": {}
      }
    ],
    "date": "2023-06-09",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nReplica\nEnhancement\nConclusion\n\nIntroduction\nShortly after 2022 Brazilian General Election, which was transcendental for a whole series of reasons: namely, Luiz Inácio Lula da Silva had not only promised ‘to unite a divided Brazil and to seek fair global trade’—turning away from Jair Bolsonaro’s divisive and populist rhetoric—, but he was also fairly adamant in his pledge to protect the Amazon, vowing ‘to crack down on illegal deforestation and rebuild relationships with countries financing the protection of the rainforest’.\nThus, observing closely the election—not least because of my own sense of concern about the environment—, I came across the following article (in Portuguese) published by BBC on November the 18th of 2021, which outlines the fact that the government of Jair Bolsonaro had registered in 2021 the largest rate of Amazon deforestation since 2006, as can be seen in the aforementioned article.\nAmazon deforestation since 2006. Source: BBC.Replica\nIn what follows, I will provide the R code in its entirety and will also comment on some of the challenges that I came across when trying to reproduce the BBC graph.\nIt must be remarked that all data needed for this task is available here.\nAs such, the full code for the replication part is, as follows:\n\n\nlibrary(readr)\nlibrary(ggplot2)\n\nAmazoniaDeforestation <- read_delim(\"AmazoniaDeforestation.csv\", delim = \";\", show_col_types = FALSE)\n\nAmazoniaDeforestation <- as.data.frame(AmazoniaDeforestation)\n\ntext <- paste(\"O governo Bolsonaro\", \"registrou o maior\", \"desmatamento\", \"desde 2006\", sep=\"\\n\")\n\nAmazonia <- ggplot(AmazoniaDeforestation, aes(x = Year, y = Total)) +\n  geom_histogram(stat = \"identity\", fill = \"turquoise4\", width = 0.5, position = position_dodge(2.5)) +\n  scale_x_continuous(breaks = c(1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2021)) +\n  scale_y_continuous(breaks = c(0, 5000, 10000, 15000, 20000, 25000, 30000)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ggtitle (\"Desmatamento Anual da Amazônia em km2\") +\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\")) +\n  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +\n  geom_hline(yintercept=c(5000, 10000, 15000, 20000, 25000, 30000), linetype=\"dotted\") +\n  geom_hline(yintercept = 0) +\n  annotate(\"text\", x = 2008, y = 20500, label = text, hjust=0, lineheight=1) +\n  geom_rect(aes(xmin = 2018.6, xmax = 2022, ymin = 0, ymax = 35000), fill = \"navajowhite2\", alpha = 0.01) +\n  geom_curve(aes(x = 2018, y = 17000, xend = 2021, yend = 13500), colour = \"black\",\n             arrow = arrow(length = unit(0.02, \"npc\"), type = \"open\"), curvature = -0.6) +\n  labs(caption = c(\"BBC\", \"Fonte: Inpe/Sistema PRODES\")) +\n  theme(plot.caption = element_text(hjust=c(1, 0)))\n\nAmazonia\n\n\n\nWhile I must certainly say that it has not been exceedingly hard for me to replicate the original graph, there have been some caveats here and there, nevertheless.\nIn first place, I had to address with utmost care the following line of code:\n\n\ngeom_rect(aes(xmin = 2018.6, xmax = 2022, ymin = 0, ymax = 35000), fill = \"navajowhite2\", alpha = 0.01)\n\n\nThis is because there was a risk that the chosen colour could possibly “eclipse” the colour of the bars.\nIn second place, having mentioned the colour of the bars, it took me quite a lot of time to find out which colour could most faithfully represent the bars. In the end, I ended up settling for ‘turquoise4’, as illustrated in the piece of code below:\n\n\ngeom_histogram(stat = \"identity\", fill = \"turquoise4\", width = 0.5, position = position_dodge(2.5))\n\n\nIn third place, while this may be deemed a rather inconsequential issue (though I believe that it is certainly not), I had to rigourously add the lines of text in exactly the right place—as they appear in the original graph:\n\n\ngeom_text(aes(x = 2012, y = 20500, label = \"O governo Bolsonaro\"), colour = \"black\") +\ngeom_text(aes(x = 2011.25, y = 19000, label = \"registrou o maior\"), colour = \"black\") +\ngeom_text(aes(x = 2010.9, y = 17500, label = \"desmatamento\"), colour = \"black\") +\ngeom_text(aes(x = 2010.25, y = 16000, label = \"desde 2006\"), colour = \"black\")\n\n\nPlease, note that I had to be very meticulous indeed in what to the choice of ‘x’ and ‘y’ coordinates it concerns.\nWith regard to this approach, I must say that—following Professor Iñaki Ucar’s kind suggestion—I ended up introducing a much more elegant ‘workaround’.\nThus, I first proceeded to define the text that I was going to use for the annotation, and after that I used the ‘annotate’ function:\n\n\ntext <- paste(\"O governo Bolsonaro\", \"registrou o maior\", \"desmatamento\", \"desde 2006\", sep=\"\\n\")\n\n\n\n\nannotate(\"text\", x = 2008, y = 20500, label = text, hjust=0, lineheight=1)\n\n\nIn fourth and final place, as trivial as it could possibly seem to some, I actually invested a lot of time in “getting the arrow right” in the following line of code:\n\n\ngeom_curve(aes(x = 2018, y = 17000, xend = 2021, yend = 13500), colour = \"black\",\n           arrow = arrow(length = unit(0.02, \"npc\"), type = \"open\"), curvature = -0.6)\n\n\nHere, especially, I had to be very attentive in what to “unit”, “type”, and “curvature” it refers, so that once again the obtained result could perfectly resemble the original graph.\nEnhancement\nRegarding the enhancement part, truth be told, I had a number of possible ideas in mind. On purpose of this, all credit is due to Professor Iñaki Ucar for his kind suggestions, meaningful reflections, and the time he took to discuss with me what the best outcome could be.\nAs such, I could have opted, for instance, to maintain the ‘bar structure’, while differentiating distinct time periods by means of a number of colours with basis on the colour of the ruling government at each point in time, in order to see under which government/-s deforestation was more or less prevalent.\nBut, in the end, I decided to elaborate a dynamic map of the evolution of deforestation for 1988 - 2021 period. This choice was made primarily for 2 reasons:\nNot all 9 Brazilian States have been impacted in equal measure; hence, it was—I much believe—interesting to see which ones bore more impact and which ones bore less (and also when—in time—).\nSince I had already replicated a piece of time series, I thought that it would be more challenging; hence, I would be able to learn more about Data Visualisation in R by settling for a map.\nThe code in question for the enhancement part is, as follows:\n\n\nlibrary(tidyverse) \nlibrary(gganimate)\nlibrary(sf)\nlibrary(geobr)\n\nDeforestation_Long <- \n  AmazoniaDeforestation %>%\n  select(-Total) %>%\n  pivot_longer(-Year, names_to = \"name_state\", values_to = \"Deforestated Area\") %>%\n  mutate(name_state = trimws(name_state))\n  \nAmazon <- read_amazon(showProgress = FALSE)\n\nStates <- read_state(showProgress = FALSE) %>% \n  mutate(name_state = stringi::stri_trans_general(str = name_state, id = \"Latin-ASCII\"))\n\nStates_Deforestation <- left_join(States, Deforestation_Long, by = \"name_state\") %>% \n  drop_na()\n\nDeforestation_Cumulative <- States_Deforestation %>% \n  group_by(name_state) %>% \n  mutate(\"Desmatamento Acumulado\" = cumsum(`Deforestated Area`)) %>% \n  mutate(\"Desmatamento Acumulado (%)\" = `Desmatamento Acumulado` / as.numeric(sf::st_area(geom)) * 1e6)\n\nAmazoniaStateDeforestation <- ggplot() +\n  labs(caption = \"\\n Fonte: Sistema PRODES\") +\n  geom_sf(data = st_simplify(States), colour = \"darkgrey\") +\n  geom_sf(data = st_simplify(Deforestation_Cumulative),\n          aes(fill = `Desmatamento Acumulado`, group = interaction(`Desmatamento Acumulado`, Year))) +\n  geom_sf(data = st_simplify(Amazon), colour = \"darkred\", size = 6, fill = NA) +\n  ggtitle(\"\\n Desmatamento Anual da Amazônia em km2: \\n Ano {round(frame_time)}\") +\n  scale_fill_viridis_c(option = \"D\")\n\nAnimatedMap <- AmazoniaStateDeforestation + transition_time(Year)\n\nanimate(AnimatedMap, fps = 10, nframes = 100, duration = 10)\n\n\n\nNeedless to say, the enhancement part proved to be quite more difficult for me rather than the replication part.\nNext, I will proceed to illustrate some of the challenges that I faced:\nFirst of all, it took me a while (and several attempts in the meantime) to find the right ‘library’ for Brazil. For instance, I had initially intended to visualise the 9 Brazilian States that belong to the Amazon by means of a ‘library’ called ‘brazilmaps’. Much unfortunately, I discovered that this ‘library’ in question is very much outdated, and has a very limited number of functions. But, luckily, after some rather extensive search, I managed to find a really great ‘library’ called ‘geobr’, which suited my requirements just fine.\nIn second place, as it stems quite naturally from what has been mentioned above, I had to study all the commands that are provided in this ‘library’ before proceeding to start elaborating the map: these include, for instance, ‘read_amazon’, ‘read_meso_region’ or ‘read_states’.\nIn third place, I made a mistake when it came to the function ‘trimws()’. Thus, what I did initially was to add ‘drop_na’ after ‘left_join’ in order to discard NAs. However, the correct version is, as follows:\n\n\nmutate(name_state = trimws(name_state))\n\n\nIn fourth place, I had initially used the command ‘read_meso_region’, which turned out to not be the right one; since I was very much interested in States and not Regions. Consequently, the right piece of code is this one:\n\n\nDeforestation_Cumulative <- States_Deforestation %>% \ngroup_by(name_state)\n\n\nIn fifth place, something that I did not know was that I had to use ... (‘backticks’) instead of “…” or ‘…’ in order for R to be able to recognise that I was referring to a variable. This is very much what happened to me in the two following lines of code:\n\n\nDeforestation_Cumulative <- States_Deforestation %>% \n  group_by(name_state) %>% \n  mutate(\"Desmatamento Acumulado\" = cumsum(`Deforestated Area`)) %>% \n  mutate(\"Desmatamento Acumulado (%)\" = `Desmatamento Acumulado` / as.numeric(sf::st_area(geom)) * 1e6)\n\n\n\n\nAmazoniaStateDeforestation <- ggplot() +\n  labs(caption = \"\\n Fonte: Sistema PRODES\") +\n  geom_sf(data = st_simplify(States), colour = \"darkgrey\") +\n  geom_sf(data = st_simplify(Deforestation_Cumulative),\n          aes(fill = `Desmatamento Acumulado`, group = interaction(`Desmatamento Acumulado`, Year)))\n\n\nAs such, when I had initially put “Desmatamento Acumulado”, R was not able to recognise that what I had in my mind was a variale; but it did perfectly recognise Desmatamento Acumulado, of course.\nIn sixth place, an additional problem that I encountered was that due to the update of ‘sf’ R ‘library’, the animated map was not loading, due to some incompatibility between ‘sf’ and ‘transformr’ R libraries. On purpose of this, I did manage to find a temporary workaround at the end of this GitHub post. Also, as I discovered after some rather extensive search, in order to use the previous version of ‘transformr’, it was necessary to install ‘RTools’ in first place.\nIn seventh and final place, I must say that I did somewhat struggle insofar that I intended to reach the final goal (a dynamic visualisation) instead of pausing to pay more attention to the intermediate step (making sure that I had a good static visualisation in first place). In this sense, had I done that from the beginning, I much believe that some of the aforementioned mistakes could have been avoided. But I am here to learn, after all… so, no regrets!\nConclusion\nAll in all, I am very happy with what I managed to achieve: the first (replica) part is quite faithful indeed to the original BBC graph, while the second (enhancement) part does clearly show exactly what I had intended to illustrate—the unequal impact of deforestation, namely how some Amazon States were more affected than the others in time.\nThis leads me to the logical reasoning that, if I were to give a sound economic and environmental piece of advice, then I am quite convinced that Brazil would certainly be better off by enhancing its governance (concretely, its environment protection laws) on a State—rather than Nation—level.\nThis is much because, as can be seen from the map that I elaborated, while we tend to speak of the issue of deforestation of the Amazon in general terms, the root of the problem actually lies in the fact that deforestation is—and has historically been—very much concentrated in only a handful of States out of the total number of 9 States that comprise the Amazon.\nLast but not least, I am deeply grateful to Professor Iñaki Ucar for having led me in the way of acquisition of knowledge in the sphere of Data Visualisation in R.\n\n\n\n",
    "preview": "projects/2022/100482711/100482711_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2023-06-09T10:22:53+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100392586/",
    "title": "HDI - What a time to be alive",
    "description": "Using the United Nation's Human Development Index (HDI) data to produce The Economist's map and other visualizations.",
    "author": [
      {
        "name": "Emma Perez Hernandez",
        "url": {}
      }
    ],
    "date": "2023-02-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting and cleaning data\nBasic elements\nMap and main legend\nSecond legend\n\nProjection and annotations\nProjection\nSpatial coordinates\nAnnotations\n\nFinal result\nAlternative visualization\nPreparing data\nAxes and annotations\nData\nFinal static result\nMoving the wrong direction? 1990 VS 2021\nAdding motion\nAnd finally… a GIF\n\n\nThe Economist published this map in September 2022 in order to highlight that ‘living standards are moving in the wrong direction’.\nIt is striking how most countries in the world have worsened their scores in the Human Development Index (HDI) between 2019 and 2021, which makes the map mainly red. The HDI, calculated by the United Nations since 1990, is a summary measure of average achievement in three key dimensions of human development: life expectancy, education and have a decent standard of living (income per person.)\nThe aim of this tutorial is to reproduce the map and propose an alternative visualization using the same dataset.\nHDI map. Source: The Economist.\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(sf)\nlibrary(giscoR)\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(patchwork)\n\n\n\n\nsysfonts::font_add_google(\"Open Sans\", family = \"Open Sans\")\nshowtext::showtext_auto()\n\n\nGetting and cleaning data\nAll the data needed for this map can be downloaded directly from the UNDP website.\nThey provide a complete data set with the latest ranking (2021), the index value for each country since 1990 and its components. Since the map only shows the change between 2019 and 2021, I select a subset of the data to compute the growth change in the required period, the country name and the ISO3 code.\n\n\nHDI <- read.csv(\"HDR21-22_Composite_indices_complete_time_series.csv\")\n\nmy_data <- HDI %>%\n  select(country, iso3, hdi_2019, hdi_2021) %>%\n  mutate(change = ((hdi_2021 / hdi_2019) - 1) * 100) %>%\n  mutate(change = round(change, 1))\n\n\nTo draw the world map, the giscoR packaged is used to get the geographic information of each country in an sf format, which is required to use geom_sf in ggplot.\n\n\nworld <- giscoR::gisco_get_countries()\nclass(world)\n\n[1] \"sf\"         \"data.frame\"\n\nNow, the geographical information and the HDI data can be joined by the ISO3 code to form the complete dataset. This dataset must also be class sf, so I use st_as_sf to keep this format. Then, the Antarctica is removed from the final data, since this region does not appear in the original map.\n\n\n# checking that both data sets contain the same countries\nhdi_data <- HDI %>%\n  distinct(iso3) %>%\n  as_vector()\nnat_data <- world$ISO3_CODE\ndiffer <- as.data.frame(setdiff(hdi_data, nat_data))\n\nall_data <- st_as_sf(left_join(world, my_data, by = c(\"ISO3_CODE\" = \"iso3\")))\n\nall_data <- all_data %>% filter(!ISO3_CODE %in% c(\"ATA\"))\n\nsummary(all_data)\n\n   CNTR_ID           NAME_ENGL          ISO3_CODE        \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n  CNTR_NAME             FID              country         \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n    hdi_2019         hdi_2021          change       \n Min.   :0.3930   Min.   :0.3850   Min.   :-5.2000  \n 1st Qu.:0.6105   1st Qu.:0.5995   1st Qu.:-1.5000  \n Median :0.7460   Median :0.7390   Median :-0.9000  \n Mean   :0.7275   Mean   :0.7206   Mean   :-0.9838  \n 3rd Qu.:0.8435   3rd Qu.:0.8350   3rd Qu.:-0.3000  \n Max.   :0.9620   Max.   :0.9620   Max.   : 2.6000  \n NA's   :65       NA's   :65       NA's   :65       \n          geometry  \n MULTIPOLYGON :134  \n POLYGON      :122  \n epsg:4326    :  0  \n +proj=long...:  0  \n                    \n                    \n                    \n\nBasic elements\nMap and main legend\nTo start with, the map is plotted by using geom_sf, which automatically interprets the geographical data.\nThe fill aesthetic is set to the variable “change”, and the proper scale fill is added to fix the same breaks and colors than The Economist. The guide for it is guide_colorsteps.\nColor is fixed in white and the size in 0.1 to generate the lines for countries’ contour.\nTheme_map is added, since it sets all chart elements in blank but for the map.\n\n\nm <- ggplot(data = all_data) +\n  geom_sf(aes(fill = change), color = \"white\", size = 0.1) +\n  scale_fill_stepsn(\n    breaks = c(-4, -2, 0, 2),\n    colors = c(\"#be0f08\", \"#f6423c\", \"#ffa9a6\", \"#a4bfd6\", \"#1e5c98\"),\n    na.value = \"#e0ded4\",\n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 1,\n      direction = \"horizontal\",\n      title = NULL,\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  theme_map()\n\nm\n\n\n\nSecond legend\nSince the previous legend does not show the missing values, another legend has to be configured for them. To do so, I get a very small region (Gibraltar), and add it as another map layer with color aesthetic in blank. For this aes, a scale color is defined in which a guide_legend is added specifying the proper color in the override.aes argument.\n\n\nGibraltar <- all_data %>% filter(ISO3_CODE == \"GIB\")\n\nm <- m + geom_sf(data = Gibraltar, aes(color = \"\")) +\n  scale_color_discrete(guide = guide_legend(\n    axis = FALSE,\n    label = FALSE,\n    title = \"No data\",\n    title.position = \"right\",\n    title.vjust = 0.5,\n    title.hjust = 0,\n    title.theme = element_text(\n      size = 8,\n      color = \"grey50\"),\n    override.aes = list(color = \"#e0ded4\", fill = \"#e0ded4\"),\n    order = 2,\n    direction = \"horizontal\"))\nm\n\n\n\nNow that we have both legends, we adjust them with themeoptions to place them in their correct positions and with the same spaces in between\n\n\nm <- m + theme(\n  legend.position = c(0.63, 0.95),\n  legend.key = element_rect(color = \"white\"),\n  legend.key.height = unit(2.2, \"mm\"),\n  legend.key.width = unit(4.7, \"mm\"),\n  legend.margin = margin(0, 0, 0, 0),\n  legend.direction = \"horizontal\",\n  legend.box = \"horizontal\",\n  legend.spacing = unit(4.7, \"mm\"),\n  legend.spacing.y = unit(1, \"mm\"),\n  legend.background = element_blank())\nm\n\n\n\nProjection and annotations\nTo add the black points placed in the center of each of the countries annotated, we can filter them from the\ndataset and get their geographical centers with st_point_on_surface\nAnother dataframe is created for Australia\n\n\npoints <- all_data %>% filter(ISO3_CODE %in% c(\"LBN\", \"BGD\", \"VEN\", \"NAM\"))\ncountries_center <- st_point_on_surface(points)\n\naustralia <- all_data %>% filter(ISO3_CODE == \"AUS\")\n\n\nThen, we can add them in two different layers\n\n\nm <- m + geom_sf_text(\n  data = australia, aes(label = paste(NAME_ENGL, \"1.1\")),\n  size = 2.5,\n  color = \"#1e5c98\") +\n  geom_sf(data = countries_center, size = 0.5)\n\nm\n\n\n\nProjection\nTo this point, all the geographic information available in our dataset has been used, but the map does not look the same than the original because by default the projection used by geom_sf is the standard latitude and longitude coordinates.\nSince the one used by The Economist is the Robinson projection, the coordinate system of the map has to be changed in accordance.\n\n\nm <- m +\n  coord_sf(crs = st_crs(\"+proj=robin\"))\n\nm\n\n\n\nSpatial coordinates\nAfter changing the projection, all the following annotations must be in the same Coordinate Reference System, so a new sf object is created with the standard coordinates (latitude and longitude) of each country to be annotated and other for the end of the segment linked to it. Then, they are transformed to the Robinson projection.\n\n\nlebanon <- st_sfc(st_point(c(35.49, 33.9)), crs = 4326)\nlebanon <- st_transform(lebanon, \"+proj=robin\")\nlebanon_end <- st_sfc(st_point(c(-14, 33.9)), crs = 4326)\nlebanon_end <- st_transform(lebanon_end, \"+proj=robin\")\n\nnamibia <- st_sfc(st_point(c(17.7, -23)), crs = 4326)\nnamibia <- st_transform(namibia, \"+proj=robin\")\nnamibia_end <- st_sfc(st_point(c(8, -23)), crs = 4326)\nnamibia_end <- st_transform(namibia_end, \"+proj=robin\")\n\nvenezuela <- st_sfc(st_point(c(-65, 6.5)), crs = 4326)\nvenezuela <- st_transform(venezuela, \"+proj=robin\")\nvenezuela_end <- st_sfc(st_point(c(-85, 6.5)), crs = 4326)\nvenezuela_end <- st_transform(venezuela_end, \"+proj=robin\")\n\nbangladesh <- st_sfc(st_point(c(90, 23.7)), crs = 4326)\nbangladesh <- st_transform(bangladesh, \"+proj=robin\")\nbangladesh_end <- st_sfc(st_point(c(130, 23.7)), crs = 4326)\nbangladesh_end <- st_transform(bangladesh_end, \"+proj=robin\")\n\n\nAnnotations\nWith the elements above, segments and text annotations can be put in place using annotate. The name and the change value of each country are used as labels, and their corresponding colors are also added.\n\n\nm <- m + annotate(\"segment\",\n  x = lebanon[[1]][1], y = lebanon[[1]][2],\n  xend = lebanon_end[[1]][1], yend = lebanon_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = lebanon_end[[1]][1], y = lebanon_end[[1]][2],\n    label = \"Lebanon -5.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = namibia[[1]][1], y = namibia[[1]][2],\n    xend = namibia_end[[1]][1], yend = namibia_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = namibia_end[[1]][1], y = namibia_end[[1]][2],\n    label = \"Namibia -3.8\",\n    hjust = 1.05,\n    color = \"#f6423c\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = venezuela[[1]][1], y = venezuela[[1]][2],\n    xend = venezuela_end[[1]][1], yend = venezuela_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = venezuela_end[[1]][1], y = venezuela_end[[1]][2],\n    label = \"Venezuela -4.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = bangladesh[[1]][1], y = bangladesh[[1]][2],\n    xend = bangladesh_end[[1]][1], yend = bangladesh_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = bangladesh_end[[1]][1], y = bangladesh_end[[1]][2],\n    label = \"Bangladesh 2.6\",\n    hjust = -0.05,\n    color = \"#1e5c98\",\n    size = 2.5)\n\nm\n\n\n\nFinal result\nLastly, adding the proper title, subtitle and caption, and placing them in the same positions, the final map is achieved. The font used is “Open Sans”, which can be downloaded from Google Fonts.\n\n\nm + labs(\n  title = \"What a time to be alive\",\n  subtitle = \"Change in UN Human Development Index, 2019-21, %\",\n  caption = \"Source: United Nations\") +\n  theme(\n    plot.title = element_text(\n      face = \"bold\",\n      family = \"Open Sans\",\n      size = 8,\n      hjust = 0.14,\n      margin = margin(10, 0, 5, 0)),\n    plot.title.position = \"panel\",\n    plot.subtitle = element_text(\n      size = 8,\n      family = \"Open Sans\",\n      hjust = 0.195,\n      margin = margin(0, 0, 1, 0)),\n    plot.caption = element_text(\n      size = 6.5,\n      family = \"Open Sans\",\n      hjust = 0.14,\n      color = \"grey50\",\n      margin = margin(0, 0, 0, 0)),\n    plot.caption.position = \"panel\")\n\n\n\nAlternative visualization\nThe Economist’s map shows just a narrow time span of the evolution of living standards, and it does not allow to see which areas are better off worldwide either. Since the data provided by UN does contain all this information, I want to produce a chart that convey regional disparities and temporal evolution.\nAdditionally, as the HDI index is also produce separately for men and women, it is possible to compute the difference between them for each country and year (if available). In this way, a measure of the gender gap is generated as HDI male - HDI female, whose evolution in time can also be tracked. In this way, a gender perspective is added to the alternative visualization.\nPreparing data\nThe UN’s dataset is in a wide format, with years added to the name of each variable, having more than 1000 columns.\nIn order to produce a tidy dataset with only the required information, I compute it by joining 3 different sub dataframes (main index, male and female) by country and year.\n\n\nHDI <- HDI %>% rename(ranking_2021 = hdi_rank_2021)\n\np <- HDI %>%\n  select(matches(\"^(hdi)(_)([0-9]+)$\"), iso3, country, ranking_2021, region, hdicode) %>%\n  pivot_longer(contains(\"hdi_\"),\n    names_sep = \"_\",\n    names_to = c(\"hdi\", \"year\"), values_to = \"value\"\n  )\n\n\nf <- HDI %>%\n  select(contains(\"hdi_f\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_f\") %>%\n  mutate(year = str_remove(year, \"hdi_f_\"))\n\nm <- HDI %>%\n  select(contains(\"hdi_m\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_m\") %>%\n  mutate(year = str_remove(year, \"hdi_m_\"))\n\nhditotal <- left_join(p, m, by = c(\"year\" = \"year\", \"country\" = \"country\"))\nhditotal <- left_join(hditotal, f, by = c(\"year\" = \"year\", \"country\" = \"country\"))\n\n\nOnce the data is ready, I generate the gender gap variable and convert year to numeric.\nIn addition, I remove the observations related to aggregated areas () and create a Region variable based on the original one used to classify developing regions, where missing values correspond to developed countries.\n\n\nhditotal <- hditotal %>%\n  mutate(\n    f_m_diff = hdi_m - hdi_f,\n    year = as.numeric(year)\n  ) %>%\n  filter(!startsWith(iso3, \"ZZ\")) %>%\n  mutate(Region = case_when(\n    region == \"AS\" ~ \"Arab States\",\n    region == \"EAP\" ~ \"East Asia & Pacific\",\n    region == \"ECA\" ~ \"Europe & Central Asia\",\n    region == \"LAC\" ~ \"Latin America & Caribbean\",\n    region == \"SA\" ~ \"South Asia\",\n    region == \"SSA\" ~ \"Sub-Saharan Africa\",\n    TRUE ~ \"Developed\"))\n\n\nAxes and annotations\nTo start with, I create a vector with the different levels of HDI according to UNDP, which will be used to mark the Y axis.\n\n\nhdi_levels <- c(0.5, 0.7, 0.8, 1)\nhdi_text_levels <- c(\"Low\", \"Medium\", \"High\", \"Very High\")\n\n\nThe axes are fix in a way that maximize the ink ratio, so I first analyze the range of the variables to be displayed in all available years\n\n\nrange(hditotal$value, na.rm = TRUE)\n\n[1] 0.216 0.962\n\nrange(hditotal$f_m_diff, na.rm = TRUE)\n\n[1] -0.0373798  0.2707924\n\nThe year 1990 is selected to create the static plot. The Y axe starts in 0.2 since is the lowest value achieved by HDI, and maximum 1.\nThe X axis’ limits allow to show the maximum and minimum values of HDI Gender Gap.\n\n\na <- hditotal %>%\n  filter(year == 1990) %>%\n  ggplot() +\n  scale_y_continuous(limits = c(0.2, 1), breaks = hdi_levels) +\n  scale_x_continuous(limits = c(-0.08, 0.28), expand = c(0, 0)) +\n  xlab(\"HDI Gender gap\") +\n  ylab(\"Human Development Index (HDI)\")\na\n\n\n\nNotice that countries in which women are better off than men have a negative value, so they will appear on the left size of 0. To highlight this fact, I add a dashed line in 0. I also add dashed lines in each of the levels of HDI to differentiate them clearly. Additionally, I add an annotation showing the corresponding level under the dashed line. To do so, I specify its position just two decimals below the HDI level mark.\n\n\nhdi_pos_levels <- c(0.48, 0.68, 0.78, 0.98)\n\na <- a + geom_hline(yintercept = c(0.5, 0.7, 0.8, 1), linetype = \"dashed\", color = \"grey\") +\n  geom_vline(xintercept = c(0), linetype = \"dashed\", color = \"grey50\") +\n  annotate(\"text\",\n    y = hdi_pos_levels, x = -0.08,\n    color = \"darkgray\", vjust = 1.3, hjust = 0, size = 3.5,\n    label = hdi_text_levels)\na\n\n\n\nSince I want the background to be blank and other visual details differently, I adjust the elements in theme in accordance.\n\n\na <- a + theme(\n  text = element_text(family = \"Open Sans\"),\n  axis.line.y = element_blank(),\n  axis.line.x = element_line(color = \"gray50\"),\n  axis.ticks = element_blank(),\n  axis.text = element_text(size = 9),\n  axis.title = element_text(size = 9),\n  axis.text.y.left = element_text(margin = margin(10, 10, 10, 10)),\n  panel.grid.major.x = element_line(linetype = 1, color = \"grey\", size = 0.05),\n  panel.grid.minor = element_blank(),\n  panel.background = element_blank())\na\n\n\n\nNow, I add the year we are referring to in a new geom_text layer.\n\n\na <- a + geom_text(aes(0.24, 0.9, label = as.factor(year)), size = 8.5, color = \"gray\")\na\n\n\n\nData\nWe are ready to add the data. In order to show the situation of each country in each year, I will generate a scatter plot with using geom_jitter, in which the aesthetics are set as follows:\n- Human Development Index value for the given year mapped to position Y\n- HDI Gender Gap mapped to position X\n- HDI female for the given year mapped to size\n- Development region mapped to color (hue)\n\n\na <- a + geom_jitter(aes(y = value, x = f_m_diff, color = Region, size = hdi_f), alpha = 0.6)\na\n\n\n\nSince I want to adjust the color palette and the elements of the legends, I add scale_color_brewer for the color, and scale_size_area for the bubbles’ size.\nIn them, I set the legends options with guide_legend and make bigger color points and title adjustments.\n\n\na <- a +\n  scale_color_brewer(\n    palette = \"Set1\",\n    guide = guide_legend(\n      title = \"Region\",\n      override.aes = list(size = 5),\n      direction = \"vertical\",\n      title.vjust = 1,\n      title.hjust = 0,\n      title.position = \"top\",\n      order = 2,\n      label.theme = element_text(size = 7))) +\n  scale_size_area(\n    breaks = c(0.2, 0.5, 0.7, 0.8, 1),\n    guide = guide_legend(\n      title = \"HDI female\",\n      title.vjust = 1,\n      title.hjust = 0.5,\n      title.position = \"top\",\n      direction = \"vertical\",\n      label.position = \"right\",\n      order = 1))\n\na\n\n\n\nAdding title, subtitle and caption\n\n\na <- a + labs(\n  title = \"Human Development Index and Gender gaps\",\n  subtitle = \"Gender gap =  HDI male - HDI female\",\n  caption = \"Source: United Nations\")\na\n\n\n\nFinal static result\nTweaking legend and titles’ details to fix their sizes and background\n\n\na <- a + theme(\n  plot.title = element_text(face = \"bold\", size = 10),\n  plot.caption = element_text(size = 7.5, hjust = 0, color = \"grey50\"),\n  plot.subtitle = element_text(face = \"italic\", size = 9),\n  plot.title.position = \"plot\",\n  plot.caption.position = \"plot\",\n  legend.key = element_blank(),\n  legend.direction = \"v\",\n  legend.title = element_text(size = 8))\na\n\n\n\nFinally, it is worth annotating the countries which are outliers or have interesting positions in the plot. To do so, I select a bunch of countries and save them in a vector. Them, I filter the dataset to get this names along with its data in 1990. Finally, I add a new geom_text\n\n\ncountries <- c(\"Spain\", \"Afghanistan\", \"China\", \"Yemen\", \"India\", \"Niger\", \"Uruguay\")\n\nlabels1990 <- hditotal %>% filter(country %in% countries, year == 1990)\n\na_lab <- a + geom_text(\n  data = labels1990, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3) \n\na_lab\n\n\n\nMoving the wrong direction? 1990 VS 2021\nHaving the chart for 1990 ready, we can reproduce it for different years using %+% to use the whole data set and filtering the desired year. I create the static chart for 2021 like this\n\n\nd <- a %+% (hditotal %>% filter(year == 2021))\n\nlabels2021 <- hditotal %>% filter(country %in% countries, year == 2021)\n\nd_lab <- d + geom_text(\n  data = labels2021, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3)\n\nd_lab\n\n\n\nPlacing both years together, we can see the changes produced in 30 years of evolution:\nMuch more countries in the “Very High” HDI area\nLess Y dispersion: concentrated in the top par, implying higher HDI in general\nLess X dispersion: most countries between 0 an 0.1 HDI gender gap, with some outliers\nMany more countries at the left side of 0, implying better liver standards for women than for men\nLess very small bubbles: in general, HDI female has risen worldwide\nGreat movement up of the two most populated countries (China, India)\nLow HDI area: Sub-Saharan countries + those with highest gender gap in 2021\n\n\na_lab + (d_lab +plot_layout(guides=\"keep\")) + plot_layout(guides=\"collect\")\n\n\n\nAdding motion\nThe main goal of this visualization is to show historical evolution taking advantage of the time series availability in UNDP data.\nTo achieve that, I use plotly to add the variable year as a frame aesthetic used to add animation.\nIn order to have the labels for all years, I do the same than for 1990 but without filtering for 1990. Then, I add the geom_text as before and save it with a new name (b). Additionally, I set scale_x_continuous(limits = c(-0.08, 0.28)) which replaces the previous one, in which expand was fixed to 0. Now, since plotly does not keep much of the formatting, I allow for more space to keep visible all the elements.\n\n\nall_labels <- hditotal %>% filter(country %in% countries)\n\nb <- a + geom_text(\n  data = all_labels, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3\n) + scale_x_continuous(limits = c(-0.08, 0.28))  \n\n\nBy using %+% hditotal we switch to use the whole data set\n\n\nggplotly(b %+% hditotal + aes(frame = year),\n  width = 750, height = 550,\n  dynamicTicks = FALSE) \n\n\n\nAnd finally… a GIF\nThe package gganimate also allows us add a different kind of motion. It keeps all formatting much better than ggplotly, showing clearly how regions have evolved over the past 30 years, converging towards higher levels of human development (moving up) and reducing the HDI gender gap (moving to the left).\nAs before, we have to use the whole data set. I create a new object for that (c). We also have to add two more lines specific of this package in which we specify the transition time and the way in which it moves.\n\n\nc <-  b %+% hditotal\n\nc <- c +\n  transition_time(as.integer(year)) +\n  ease_aes(\"linear\")\n\n\nNow we just use animate\n\n\n# sizes fit better with this option in the gif\nshowtext::showtext_opts(dpi=96)\nanimate(c, height = 400, width = 600)\n\n\n\n\n\n\n",
    "preview": "projects/2022/100392586/100392586_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100470958/",
    "title": "Satellite images defy economic data of authoritarian regimes",
    "description": "Highly customized dumbbell chart that compares official GDP against\nsatellite-based estimation of GDP, across 103 countries.",
    "author": [
      {
        "name": "Freddy Andrés Camargo",
        "url": {}
      }
    ],
    "date": "2023-02-02",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData collection\nVisualization assembly\nThe grid\nData layer\nScales\nAppereance\nLegend\nAnnotations\n\nAlternative\n\nSatellite images of the brightness of the earth, also called nighttime lights data (NTL, from the US Air Force’s Defense Meteorological Satellite Program), have been used as a proxy for economic activity. Luis R. Martínez, professor at the Harris School of Public Policy at the University of Chicago, not only developed a model to calculate the GDP of every country based in the NTL data set, but he also found that countries with less political rights and civil liberties report overestimated GDP. The goal of this article is to rebuild a chart designed by The Economist to show the magnitude of this finding.\nThe Economist’s chartData collection\nThe data includes different records per country: the GDP from World Bank, the GDP estimated based on NTL, and the yearly growth of each one between 2002 and 2021. In addition, it includes the status in the Freedom in the World Index 2021, published by Freedom House, which classifies each country in three categories (Free, Partly Free, and Not Free). Finally, the population is incorporated, because for visualization purposes the chart only shows countries with more than 5 million population. Mr. Martínez provided me the projections of the NTL model, after contacting him by email.\n\n\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\nLet’s see how the data looks like:\n\n\nDF <- read.csv(\"economist.csv\")\n\n\n\nCountry.Name\nYear\nGDP. growth.LCU.R\nGDP.in. 2015.USD.R\nGDP.growth. LCU.adjExag.NTL\n1\nLibya\n2021\n31\n60910775962\n20\n2\nYemen, Rep.\n2021\n-2\n33429671860\n-2\n3\nZimbabwe\n2021\n6\n20562359266\n4\n4\nGreece\n2021\n8\n200827546085\n8\n5\nLebanon\n2021\n-11\n30979755568\n-11\n\n\n\n\n\n\n\nGDP.in. 2015.USD.NTL\nGDP.var.R\nGDP.var.NTL\nFIW.Status\nPopu.2021\n\n36634943488\n8.73\n-34.61\nNF\n6958538\n\n29289246720\n-25.33\n-34.58\nNF\n30490639\n\n15954965504\n10.36\n-14.36\nNF\n15092171\n\n197563367424\n-7.88\n-9.38\nF\n10664568\n\n26433470464\n11.82\n-4.59\nPF\n6769151\nVisualization assembly\nThe grid\nThe chart emphasizes the importance of the Y-axis, which shows percentage change in GDP. The X-axis doesn’t include a new variable. We just order the countries from lowest to highest GDP growth. We add 3 facets that correspond to the categories in the Freedom in the World Index, assigning a color to each one.\n\n\nc <- ggplot(DF, aes(x = order, y = GDP.var.NTL, xend = order, \n                    yend = GDP.var.R, color = FIW.Status)) +\n  facet_wrap(~ factor(FIW.Status, levels = c(\"F\", \"PF\", \"NF\")))\n\nc\n\n\n\nData layer\nWe want to draw a vertical dumbbell chart. As a consequence, we specify two sets of coordinates in the Y-axis, one for the GDP-NTL growth, and the other for the GDP-official growth. In order to connect both points, we add a segment that evidences how big is the distance between them. Then, we create a dumbbell per country.\nWe scale the size of each point to show the size of the economy, according to the respective methodology. In the beginning, we create a horizontal reference line where Y is equal to 0, below the data points.\n\n\nc <- c + \n  geom_hline(yintercept = 0, linewidth = 0.25) +\n  geom_segment() +\n  geom_point(aes(xend = order, y = GDP.var.R, size = GDP.in.2015.USD.R/1e+12), \n             shape = 21, fill = \"#C7C5BD\", color = \"white\") +\n  geom_point(aes(size = GDP.in.2015.USD.NTL / 1e+12, fill = FIW.Status), \n             shape = 21, color = \"white\") \n\nc\n\n\n\nScales\nWe adjust manually the bubbles colors, according to the freedom categories. However, as we defined a point shape that allows us to specify a border color (# 21), we see that each point has a border color ‘white’ to facilitate the distinction between countries.\nWe adapt the size, to highlight largest economies, but keeping visible the smallest with the help of the range argument. In addition, we define the breaks for the size scale.\nThe Y-axis has breaks for every 50 percentage points in a range between -50 and 450. Note that this axis is placed on the right. Furthermore, the X-axis needs an extra space for annotations.\n\n\nc <- c + scale_color_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_fill_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_size(range = c(1, 12), breaks = c(0.1, 2, 10), \"GDP in 2021, $trn†\") + \n  scale_y_continuous(\n    position = \"right\",\n    limits = c(-50, 450),\n    n.breaks = 10,\n    expand = expansion(0)\n  ) +\n  lims(x = c(0.5, 46)) \n\nc\n\n\n\nAppereance\nThe Economist’s chart has a minimalist and clean design. We use the correspondent theme provided by the “ggthemes” library, as a base. It is required to include many theme adjustments to conclude the design. As an important piece of the visual aspect, we incorporate the “PT Sans” font type to make the chart more light and stylized.\n\n\nsysfonts::font_add_google(\"PT Sans\")\nshowtext::showtext_auto()\n\n\nWe assign a white background, and remove the divisions between facets, as well as its titles, to integrate the canvas. Observe that we reduce the grid linewidth and change its color, to highlight the dumbbells. Now, the bottom line is not a frame of the chart.\n\n\nc <- c + \n  theme_economist_white() + \n  theme(\n    plot.background = element_rect(fill = \"white\"),\n    panel.spacing.x = unit(0, \"cm\"),\n    strip.background = element_rect(fill = \"white\"), \n    strip.text = element_text(color = \"white\"), \n    panel.grid = element_line(color = \"ligthgray\", linewidth = 0.10), \n    axis.line.x.bottom = element_line(color = \"gray\", linewidth = 0.10),\n  )\n\nc\n\n\n\nWe remove the titles from both axis. Besides, we withdraw texts and ticks from X-axis. On the other hand, we move the legends to the top right position, saving a space for the dumbbell legend. Also we change their color to harmonize the chart. Perceive that now the Y-Axis texts are aligned with the horizontal gridlines.\n\n\nc <- c + theme(\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank(), \n  axis.text.y = element_text(vjust = -0.5, color = \"#2C2E2E\"), \n  axis.text.x = element_blank(),\n  axis.ticks.x = element_blank(),\n  legend.background = element_rect(fill = \"white\"),\n  legend.position = c(0,0.85),\n  legend.direction = \"horizontal\",\n  legend.justification = c(0, 1),\n  legend.key = element_rect(fill = \"transparent\"),\n  plot.caption = element_text(hjust = 0, vjust = -1, \n                              color = \"#454545\", size = 8)\n)\n\nc\n\n\n\nLegend\nWe take out the fill and size legends. But most importantly, we adjust the position of the legend title of the size. What’s more, we create an additional chart to represent the dumbbell legend. Later, we add it to the main chart as an inset.\n\n\nc <- c + guides(color = FALSE, fill = FALSE, \n                size = guide_legend(title.position = \"top\"))\n\nz <- data.frame(\n  name = c(\"Satelite-based\\n estimate\"),\n  x = c(3), y = c(5)\n)\n\nv <- data.frame(\n  name = c(\"Reported\"),\n  x = c(3), y = c(7)\n)\n\npinset <- ggplot(z, aes(x, y)) +\n  geom_segment(aes(x=3, xend=3, y=5, yend=7), linewidth=0.5) +\n  geom_point(size=2)+\n  geom_point(data=v,size=2, color=\"grey\")+\n  geom_text(aes(label=name), hjust= -0.1, size=4, lineheight = .5) +\n  geom_text(data=v,aes(label=name), hjust= -0.2, size=4) + \n  lims(x = c(2.9, 4), y = c(4.6, 7.3)) +\n  ggtitle(\"Change in GDP, 2002-21, %*\", ) +\n  theme_void() + \n  theme(\n    panel.background = element_rect(fill = \"white\", color=\"white\"),\n    plot.background = element_rect(fill = \"white\", color=\"white\"),\n    panel.border = element_rect(colour = \"white\", fill=NA),\n    plot.title = element_text(face = \"bold\", hjust = 0.3, size= 12, vjust = 3)\n  )\n\npinset\n\n\n\nAnnotations\nThe chart has 4 annotations types:\nText labels for a group of countries per category, including largest economies.\nCategories titles inside of each facet.\nThe average values per category.\nA brief summary of the average values for autocratic countries.\nThe caption that includes some clarifications about the chart.\nWe add the labels bringing geom_text() into play, and filtering the data set to keep those countries that we need. Note that we separate the 4 largest economies, because we place them with independent coordinates taking into account its bubble size. In addition, we include category titles.\n\n\ntitles <- data.frame(\n  labels = c(\"Free countries\", \"Partly free\", \"Not free\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = 20,\n  GDP.var.NTL = c(175, 225, 275),\n  GDP.var.R = c(170, 220, 270)\n)\n\ncountriestxt <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\", \"Australia\", \n             \"Ireland\", \"India\", \"Russia\", \"Mexico\", \"Peru\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\", \"F\", \"F\", \"PF\", \"NF\", \"PF\", \"F\"),\n  order = c(5, 11, 21, 34, 27, 35, 41, 10, 5, 34),\n  GDP.var.NTL = c(-6, 11, 25, 175, 56, 144, 159, 27, 17, 112),\n  GDP.var.R = c(-6, 11, 25, 175, 56, 144, 159, 27, 17, 112)\n  )\n\nc <- c +\n   geom_text(data = DF%>% filter(label == 1 & \n          !(Country.Name %in% c(\"Japan\", \"Britain\",\"United States\", \"China\",\n            \"Australia\", \"Ireland\", \"India\", \"Russia\", \"Mexico\", \"Peru\"))), \n            aes(label = Country.Name), color = \"#454545\",\n            vjust = 1.5, hjust = -0.1, check_overlap = T) +\n  geom_text(data= countriestxt, aes(label = labels), color=\"#454545\", hjust=0)+\n  geom_text(data = titles, aes(label = labels), fontface = \"bold\", size=4.5)\n\nc\n\n\n\nTo point out the averages, we draw a set of 3 dumbbells with a black border, and we include a label for them. Observe that we should create independent data frames, for annotations that require a specific location inside the chart. Then, we map these data frames with ggplot components.\n\n\nav_data <- DF %>% \n  group_by(FIW.Status)  %>%\n  summarise(\n    av.GDP.var.R = mean(GDP.var.R),\n    av.GDP.var.NTL = mean(GDP.var.NTL),\n    av.GDP.usd.R = mean(GDP.in.2015.USD.NTL)/1000000000000,\n    av.GDP.usd.NTL = mean(GDP.in.2015.USD.NTL)/1000000000000\n  )\n\nav_data <- av_data[c(1,3,2),]\n\naverage <- data.frame(\n  Country.Name = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  GDP.in.2015.USD.NTL = as.vector(av_data$av.GDP.usd.NTL),\n  GDP.in.2015.USD.R = as.vector(av_data$av.GDP.usd.R),\n  GDP.var.R = as.vector(av_data$av.GDP.var.R),\n  GDP.var.NTL = as.vector(av_data$av.GDP.var.NTL),\n  order= c(22,19,17),\n  colorT = c(\"grey\", \"grey\", \"grey\"),\n  colorB = c(\"#FFC259\", \"#F6423C\",\"#FFA9A6\"),\n  fill = c(\"black\", \"black\", \"black\")\n)\n\navTitles <- data.frame(\n  labels = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = c(20, 16, 14),\n  GDP.var.NTL = c(85, 138, 165),\n  GDP.var.R = c(80, 133, 160)\n  )\n\nc <- c +\n  geom_segment(data = average, aes(x=order, xend=order, y=GDP.var.NTL, \n                                   yend=GDP.var.R), color=\"black\") +\n  geom_point(data = average,aes(x=order, y=GDP.var.NTL, \n             size=GDP.in.2015.USD.NTL, fill=FIW.Status), \n             shape=21, color=\"black\") + \n  geom_point(data = average, aes(x=order, y=GDP.var.R, size=GDP.in.2015.USD.R), \n             shape=21, color=\"black\", fill=\"gray\") +\n  geom_text(data= avTitles, aes(label= labels), fontface = \"bold\", \n            size= 3.5, color = \"black\") \n\nc\n\n\n\nThe autocratic category summary and the caption are added. We highlight that the summary is incorporated just to one facet. It means that we should specify the level of the factor that we want to use. To conclude, we combine the inset with the “Patchwork” library, specifying the desired position.\n\n\nsumQuote <- data.frame(\n  text = \"↓ Autocratic countries reported\\nGDP growth of 147% on average.\nSatellite imagery suggests the\\ntrue figure is 76%\",\n  FIW.Status = factor(\"NF\", levels = c(\"F\", \"PF\", \"NF\")),\n  order = 0.5,\n  GDP.var.NTL = 420,\n  GDP.var.R = 420\n)\n\ncaptiontx <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate\", sep=\" \"\n            )\n\nc <- c +\n  geom_label(data = sumQuote, aes(label = text), color = \"black\", \n             size = 3, hjust = 0, vjust = 1, lineheight = .8, fill = \"white\", \n             label.size = NA, label.padding = unit(0, \"cm\")) +\n  labs(caption = captiontx) + \n  inset_element(pinset, left=0, bottom=0.83, right=0.3, top=1, align_to=\"full\")\n\nc\n\n\n\nAlternative\nAnalyzing the original chart, we can see that it has some advantages. For instance, it allows us to identify each of the 103 countries, or it separates clearly the Freedom categories. Nevertheless, we realize that the X-axis is used to create an order among dumbbells, but it doesn’t add more information. Therefore, we propose an alternative visualization that uses this axis to compare GDP values.\nIn our chart, the Y-axis shows the officialy reported GDP growth, while the X-axis illustrates the NTL-based estimate of GDP. As a result, we should expect that each country will be located in the intersection line where Y is equal to X. However, the autocratic countries are far away from this line, as their value of the officialy reported GDP.\n\n\nlineAnnotations <- data.frame(\n  labels = c(\"Countries close to this line have official GDP = NTL GDP \", \n             \"+50 pp Inflation\", \"+100 pp Inflation\", \"+200 pp Inflation\"),\n  GDP.var.R = c(340, 445,445,445),\n  GDP.var.NTL = c(353, 387, 337, 237),\n  FIW.Status = c(\"PF\", \"PF\", \"PF\", \"PF\")\n  )\n\nEcountrieslbl <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\",\"Russia\", \n             \"Turkey\", \"Mexico\", \"Philippines\", \"India\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\",\"NF\", \"NF\", \"PF\", \"PF\", \"PF\"),\n  GDP.var.R = c(-5, 10, 30, 390, 83, 179, 50, 135, 228),\n  GDP.var.NTL = c(18, 31, 58, 149, 16, 92, 4, 110, 173)\n  )\n\ncaptiontxt <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate.\",\n            \"'PP' means Percentage Points.\",\n            sep=\" \"\n            )\n\nDF$FIW.Status <- factor(DF$FIW.Status, levels=c(\"F\", \"PF\", \"NF\"))\n\n\n\n\nggplot(DF, aes(GDP.var.NTL, GDP.var.R, fill= FIW.Status)) + \n  geom_abline(slope = 1, intercept = 0, linetype=\"dashed\") +\n  geom_abline(slope = 1, intercept = 50, linetype=2, linewidth=0.1) +\n  geom_abline(slope = 1, intercept = 100, linetype=2, linewidth=0.1) +\n  geom_abline(slope = 1, intercept = 200, linetype=2, linewidth=0.1) +\n  geom_point(aes(size=GDP.in.2015.USD.NTL/1e+12), shape=21, alpha=0.8) + \n  geom_text(data = DF%>% filter(label == 1 & (Country.Name %in% \n            c(\"Greece\", \"Australia\", \"South Korea\", \"Ghana\",\"Poland\", \n              \"Ireland\", \"Yemen, Rep.\", \"Libya\", \"Rwanda\"))), \n    aes(label = Country.Name), check_overlap = T, hjust = -0.15, vjust=1.3) +\n  geom_text(data = Ecountrieslbl, aes(label=labels), hjust=0) + \n  geom_text(data = lineAnnotations[1,], aes(label = labels), angle = 25.8, \n            fontface=\"bold\", color=\"#44B4C1\") +\n  geom_text(data = lineAnnotations[2:4,], aes(label = labels), \n            angle = 26, fontface=\"bold\", size = 4) +\n  lims(x= c(-50,450)) + \n  scale_size(range = c(1,12), breaks= c(0.1,2,10), \"GDP in 2021, $trn†\") +\n  scale_fill_manual(values=c(\"#FEC427\",\"#255D91\", \"#B41D11\"), \n    name= \"Freedom Status\", labels=c(\"Free\", \"Partly Free\", \"Not Free\")) + \n  scale_x_continuous(limits=c(-50, 450), n.breaks=10, expand=expansion(0)) +\n  scale_y_continuous(limits = c(-50, 450), n.breaks = 10) +\n  labs(x= \"NTL-estimated GDP\", y=\"Official GDP\") + \n  ggtitle(\"GDP growth, 2002-21, %*\", ) +\n  labs(caption = captiontxt) +\n  theme_minimal()+\n  theme(\n    panel.background = element_rect(fill= \"#F3F0EA\"),\n    plot.background = element_rect(fill= \"#F3F0EA\"),\n    panel.grid = element_line(linetype = 2),\n    panel.grid.major = element_line(size = 0.5, colour = \"grey\"),\n    panel.border = element_rect(color = \"#F3F0EA\", fill=NA),\n    axis.title.y =  element_text(color = \"black\"), \n    axis.text.y = element_text(color = \"black\"),\n    legend.position=c(1, 0.01),\n    legend.justification=c(1, 0),\n    legend.background = element_rect(fill=\"#F3F0EA\", color=\"#F3F0EA\"),\n    axis.line.x.bottom = element_line(color = \"#F3F0EA\"),\n    axis.line.y.left  = element_line(color = \"#F3F0EA\"),\n    plot.title = element_text(face = \"bold\", hjust = 0, size= 15, vjust = 3),\n    plot.caption = element_text(hjust = 0, color =\"#454545\", size = 8),\n    plot.margin = unit(c(10,5.5,5.5,5.5), 'pt')\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2022/100470958/100470958_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100462872/",
    "title": "Use of Social Media Platforms in 2021 (U.S.) by Demographic Group",
    "description": "Replication and alternative version of a heatmap from 'Social Media Use in\n2021' (Pew Research Center).",
    "author": [
      {
        "name": "Marina Sánchez Moreno",
        "url": {}
      }
    ],
    "date": "2023-01-24",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nCollection and data processing\nCollection of data\nCleaning and processing data\nStoring the new dataframe\n\nReplication: heatmap\nChanging the name and ordering X axis labels\nY axis labels order, padding and pre-faceting\nBuilding the plot: geom_tile()\nFacetting\nX axis and legend scale\nTitle, subtitle, caption and tag\nFonts and Theme\nAnnotation\n\nAlternative version: parallel coordinates\nBuilding the plots: ggparcoord()\nColor scales and theme\nPatchwork and general theme\n\nConclusions\n\nIntroduction\nThis project is based on a graph from the article “Social Media Use in 2021”,\npublished by Brooke Auxier and Monica Anderson in April, 2021. In this article,\nthe authors focus on the differences in the use of social media platforms\nthrough time (from 2012 to 2021), as well as on the differences in use in each\nplatform within different demographic groups in 2021 in the U.S.\nThe platforms under study are: YouTube, Facebook, Instagram, Pinterest,\nLinkedIn, Snapchat, Twitter, Whatsapp, TikTok, Reddit and Nextdoor. Regarding\nthe demographic groups and divided at the same time in subgroups, we find:\ngender (Men and Women), race/ethnicity (Black, White and Hispanic), age\n(18-19 y/o, 30-49 y/o, 50-64 y/o and 65+ y/o), income (<$30K, $30K-$49,999,\n$50K-$74,999 and $75K+), education (High School or less, Some College,\nCollege+) and place (Urban, Suburban and Rural), as well as the total (that\nfrom now on, we will be considering when talking about this categories).\nThe results are obtained from a survey conducted on 1502 participants.\nI found this publication worth reading since it gives some numbers to analyse\nthe real tendencies in the use of Social Media and, in some cases, disarm some\nunfounded general beliefs regarding this topic (although the scope is obviously\nlimited to one country).\nBut, let’s get visual. The plot I chose from this article is a heatmap that\nrepresents the percentage of people from several socioeconomic groups that\nactually use each platform. Here you can see the original plot:\nOriginal plotI found this plot interesting to work with since this kind of matrix\ndistribution of the elements was slightly different from the graphs we are use to\nplot and since it had many aspects to practice: the text annotation of values\ninside the matrix had different aesthetics (white and bold and black and plain),\nthe facets could be challenging and the font use seemed elaborated.\n\n\n# Load needed libraries\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(ggtext)\n\n\nCollection and data processing\nCollection of data\nFirst, we need to download the raw data file from the original article page (we\nneed to log-in to the PEW RESEARCH CENTER website first to access the dataset\nand the documentation of the methodology). We can find the data .csv file in\nthe documentation in the GitHub folder of this project. Once we have it in our\ndirectory, we can read it and store it in “data”:\n\n\n# Collect and store raw data\ndata <- read.csv(\"./documentation/Jan 25-Feb 8, 2021 - Core Trends Survey - CSV.csv\")\n\n\nCleaning and processing data\nWhen we take a look at the data, we find a total of 89 columns and 1502 rows,\nwhere each observation represents the answers of one participant). The high\namount of columns (apart from being in wide format) is due to the fact that the\ndataset is also shared by other article (‘Mobile Technology and Home Broadband\n2021’).\nTo clean this dataframe, we need to:\nFirst, think what table we need (final output, original plot): Platforms,\ndemographic groups and percentages. Since the percentages are not in the dataset,\nwe need to compute them by using the values of the platforms and the weights\n(explained in the methodology section of the article).\nSelect the variables we need according to our previous conclusions. To\nunderstand which variables are the ones we are looking for and which values\nrepresent what, it is essential that we read carefully the documentation\n(Jan 25-Feb 8, 2021 - Core Trends Survey - Questionnaire.docx):\nSocioeconomic categories: gender, racecmb, hisp, age, educ2, usr, income\nweight: weight\nPlatforms = web1a (Twitter), web1b (Instagram), web1c (Facebook), web1d\n(Snapchat), web1e (YouTube), web1f (Whatsapp), web1g (Pinterest), web1h\n(LinkedIn), web1i (Reddit)\n\nRename platforms columns, pivot longer the platforms and create dummy\nvariables of subgroups when needed.\n\n\nclean_data <- data %>% \n  # Keeping the above mentioned columns of interest:\n  select(contains(\"racec\") | starts_with(\"hisp\") | contains(\"gender\") |\n           contains(\"educ2\") | contains(\"usr\") | contains(\"income\") |\n           contains(\"weight\") | contains(\"web\") | contains(\"age\")) %>% \n  # Rename the columns of each platform with the actual platform name:\n  dplyr::rename(Twitter = web1a, Instagram = web1b, Facebook = web1c, \n                Snapchat = web1d, YouTube = web1e, Whatsapp = web1f,\n                Pinterest = web1g, LinkedIn = web1h, Reddit = web1i,\n                TikTok = web1j, Nextdoor = web1k) %>% \n  # Select these platform columns and pivot them into two columns:\n  pivot_longer(matches(\"^[A-Z]\", ignore.case = FALSE),\n               names_to = \"Platform\", # One column for the name of the platform \n               values_to = \"YesNo\" ) %>% # Another for the values (1=Yes, 0=No)\n  transform(YesNo = as.numeric(YesNo)) %>% \n  # PLACE: Create 3 columns, one for each of the Urban/Suburban/Rural values\n  # of the usr column\n  mutate(Urban = case_when(usr == \"U\" ~ \"1\", usr != \"U\" ~ \"0\"),\n         Suburban = case_when(usr == \"S\" ~ \"1\", usr != \"S\" ~ \"0\"),\n         Rural = case_when(usr == \"R\" ~ \"1\", usr != \"R\" ~ \"0\"),\n         USR_nas = case_when(usr == \" \" ~ \"1\", usr != \" \" ~ \"0\")\n  ) %>% \n  # AGE: Create 4 columns, one for each of the age ranges of the graph\n  # (from age column)\n  mutate(X18_29 = case_when(age <= 29 ~ 1),\n         X30_49 = case_when(age <= 49 & age >= 30 ~ 1),\n         X50_64 = case_when(age >= 50 & age <= 64 ~ 1),\n         X65. = case_when(age >= 65 & age <= 97 ~ 1)) %>% \n  # EDUCATION: Create 3 columns, one for each of the education ranges of the graph\n  # (from educ2 column)\n  mutate(HS_or_less = case_when(educ2 == 1 ~ 1 ,educ2 == 2 ~ 1, educ2 == 3 ~ 1),\n         Some_College = case_when(educ2 == 4 ~1, educ2 == 5 ~1),\n         College = case_when(educ2 == 6 ~1, educ2 == 7 ~1, educ2 == 8 ~1 )) %>% \n  transform(Urban = as.numeric(Urban), Suburban = as.numeric(Suburban),\n            Rural = as.numeric(Rural), USR_nas = as.numeric(USR_nas)) \n\n\nCompute the percentage of each demographic subgroup by:\n\n\n# Calculating the percentages displayed in the graph\n\n# Function to generate the percentage per category (including weights)\nperc <- function(weight, ind_yesno, ind_var) {\n  round(sum(ind_yesno * ind_var * weight) / sum(ind_var * weight) * 100)\n}\n\nclean_data <- clean_data %>%\n  group_by(Platform) %>%\n  summarise(\n    # TOTAL: Percentage of people in the sample that uses sometimes each platform \n    Total    = perc(weight, YesNo==1, rep(1, n())),\n    # GENDER: Create 2 columns, one for each of the gender categories of the graph\n    # (from gender column)\n    Men      = perc(weight, YesNo==1, gender==1),\n    Women    = perc(weight, YesNo==1, gender==2),\n    # RACE: Create 3 columns, one for each of the race groups of the graph\n    # (from racecmb and hisp columns)\n    White    = perc(weight, YesNo==1, racecmb==1 & hisp!=1),\n    Black    = perc(weight, YesNo==1, racecmb==2 & hisp!=1),\n    Hispanic = perc(weight, YesNo==1, hisp==1),\n    # AGE\n    X18_29   = perc(weight, YesNo==1, !is.na(X18_29)),\n    X30_49   = perc(weight, YesNo==1, !is.na(X30_49)),\n    X50_64   = perc(weight, YesNo==1, !is.na(X50_64)),\n    X65.     = perc(weight, YesNo==1, !is.na(X65.)),\n    # INCOME: Create 4 columns, one for each of the income ranges of the graph\n    # (from income column)\n    `Income_30K`        = perc(weight, YesNo==1, income <= 3),\n    `Income_30K_49.999` = perc(weight, YesNo==1, (income <= 5 & income > 3)),     \n    `Income_50K_74.999` = perc(weight, YesNo==1, income == 6),\n    `Income_75K`        = perc(weight, YesNo==1, (income > 6 & income <= 9)),\n    # EDUCATION\n    HS_or_less          = perc(weight, YesNo==1, !is.na(HS_or_less)),\n    Some_College        = perc(weight, YesNo==1, !is.na(Some_College)),\n    College             = perc(weight, YesNo==1, !is.na(College)),\n    # PLACE\n    Urban    = perc(weight, YesNo==1, Urban==1),\n    Suburban = perc(weight, YesNo==1, Suburban==1),\n    Rural    = perc(weight, YesNo==1, Rural==1) \n  )\n\n\nStoring the new dataframe\nFor future work, it may be convenient to save the new clean and organised\ndataframe: write_csv(clean_data, \"clean_data.csv\").\nReplication: heatmap\nChanging the name and ordering X axis labels\nBefore creating the heatmap, we need to fix some aspects like the names of the\ncolumns. In some cases R has changed the names for dealing with white spaces\nand numbers at the beginning (“X18_19”, “HS_or_less”…). Also, we can order\nnow the name of the platforms according to their value for variable “total”\n(descending order):\n\n\n# Change the names of the columns according to the original plot:\ncolnames(clean_data) <- c(\"Platform\", \"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                      \"Hispanic\", \"Ages 18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                      \"$30K-$49,999\", \"$50K-$74,999\", \"$75K+\", \"HS or less\",\n                      \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n# We arrange platforms' names by their \"total\" values (descending order)\nclean_data <-clean_data %>%\n  arrange(desc(Total)) %>%\n  column_to_rownames(var=\"Platform\") #Column \"platform\" to row names\n\n\nY axis labels order, padding and pre-faceting\nNow let’s work the Y axis labels. We need to:\nCreate a reference vector. We will create and use a reference vector\nwith the desired order of the labels and with the same padding we will applied\nfor the y labels to order them. Regarding padding, we have to set the width of\neach of the elements in the outcome vector. In this case, since the longest y\naxis label has 12 characters, that will be our width.\nPadding the real y axis labels. Now we have to apply the same padding\nused before so both the reference vector and the y labels are equivalent. This\npadding will avoid the horizontal left justification to be applied only\nindividually by facet instead of in all the facets together.\nOrder the y labels. Using the reference vector to order the levels.\nCreating a column for group faceting\n\n\n# REFERENCE VECTOR:\n# Creating a y axis labels reference vector that will be used for ordering within facets\naxisLabels.y <- c(\"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                  \"Hispanic\", \"Ages 18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                  \"$30K-$49,999\", \"$50K-$74,999\", \"$75K+\", \"HS or less\",\n                  \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n# Padding  the vector (as we will do with key/groups)\naxisLabels.y <- str_pad(axisLabels.y, side =\"right\",\n                        width = 12, pad = \" \")\n\n\n# LABELS ORDER AND PADDING:\nrep <- clean_data %>%\n  # Turning the row names to a column \"Platform\"\n  tibble::rownames_to_column(\"Platform\") %>%\n  \n  # Collecting columns (demographic subgroups, excluding platform column)\n  # as one column called \"key\"\n  # Collecting the previous columns' values as one column called \"value\"\n  gather(\"key\", \"value\", -Platform) %>%\n  \n  # PADDING Y-axis labels\n  mutate(key = str_pad(key, side =\"right\", width = 12,\n                       pad = \" \")) %>%\n  \n  # ORDER Y-axis labels using the reference vector to order the levels\n  mutate(key = fct_relevel(key, rev(axisLabels.y))) %>%\n  \n  # CREATING A COLUMN FOR LATTER GROUP FACETTING (total, gender, age, income...)\n  mutate(group = case_when(\n    grepl(\"Total\", key) ~ \"total\",\n    grepl(\"Men|Women\", key) ~ \"gender\",\n    grepl(\"White|Black|Hispanic\", key) ~ \"race\",\n    grepl(\"Ages|30-49|50-64|65\", key) ~ \"age\",\n    grepl(\"30K|50K|75K\", key) ~ \"income\",\n    grepl(\"HS|ollege\", key) ~ \"education\",\n    grepl(\"rban|Rural\", key) ~ \"place\",\n  )\n  )\n\n\nBuilding the plot: geom_tile()\nAmong all the options available to generate a heatmap, I chose geom_tile().\n\n\nrepl <- ggplot(rep, aes(reorder(Platform, value, decreasing=TRUE), key,\n                        fill = value, label = value)) +\n  geom_tile(color = \"white\",\n            lwd = 0.2,\n            linetype = 1)\nrepl\n\n\n\nFacetting\nWe will use column “group” to establish the facets. For this, we create another\nreference vector (as we did for y axis labels) to order the items in column\n“group”. This vector “categories” will act as the levels (and order) of the\ngroup column.\n\n\n# Another reference vector for ordering \"group\"\ncategories <- c('total', 'gender', 'race', 'age', 'income', 'education', 'place')\n\n\nrepli <- repl +\n  # Faceting\n  facet_grid(factor(repl$data$group,\n                    levels= categories) ~ .,\n             scales=\"free\", space=\"free\") \nrepli\n\n\n\nX axis and legend scale\nFor the legend I used scale_fill_stepsn() for selecting individual colors for\neach discrete ranges of values (percentages). In order to add the % symbol to\nthe 0 value only we can create a function called “labeller” that will take the\nbreaks specified in “breaks” argument and will paste the % symbol after the\nvalue when it is equal to 0.\nRegarding the scale color, to select each color code I used the website\nImageColorPicker.com, where you can upload an\nimage (in this case, the original plot) and select the colors to get the color\ncodes.\n\n\n# This function adds a \"%\" to the break label when it is equal to 0\nlabeller <- function(breaks) {\n  if (breaks[1] == 0)\n    breaks[1] <- paste0(breaks[1], \"%\")\n  breaks\n}\nrepli <- repli+\n  scale_fill_stepsn(breaks=seq(20, 80, 20), limits=c(0, 100), # Percentages \n                    labels=labeller, # Applies the above function\n                    space= \"Lab\",\n                    colors=c(\"#c7d9ee\", \"#8ab4df\", \"#5e91cb\", \"#286c9c\", \"#314565\"),\n                    guide=guide_colorsteps(show.limits=TRUE, # 0% and 100 visible\n                                           # We can see the ticks:\n                                           ticks = TRUE, \n                                           direction= \"horizontal\",\n                                           ticks.linewidth= unit(2, 'pt'),\n                                           ticks.colour = \"white\",\n                                           # 1 line legend\n                                           nrow = 1, \n                                           label= TRUE,\n                                           # On top of color values\n                                           label.position = \"top\")\n  )+\n  # Put X axis on top\n  scale_x_discrete(position = \"top\")\n\nrepli\n\n\n\nTitle, subtitle, caption and tag\nIntroducing the title, subtitle, caption and tag with labs(), adding \\n for\nnewlines and \\for special characters (like ““)\n\n\nrepli <- repli+\n  labs(\n    title = \"Use of online platforms, apps varies — sometimes widely — by demographic group\",\n    subtitle = \"\\n% of U.S. adults in each demographic group who say they ever use...\",\n    caption = paste0(\n      'Note: White and Black adults include those who report being only one ',\n      'race and are not Hispanic. Hispanics are of any race. Not all numerical',\n      '\\ndifferences between groups shown are statistically significant (e.g.,',\n      ' there are no statistically significant differences between the shares ',\n      'of\\nWhite, Black or Hispanic Americans who say the use Facebook). ',\n      'Respondents who did not give an answer are not shown.\\nSource: Survey ',\n      'of U.S. adults conducted Jan. 25-Feb. 8, 2021.\\n\\\"Social Media Use in 2021\\\"\\n'),\n    tag = \"PEW RESEARCH CENTER\",\n    # No x or y axis title\n    x=NULL, y = NULL)\nrepli\n\n\n\nFonts and Theme\nRegarding the fonts, initially I used similar fonts by analyzing the typography\nwith whatfontis.com. However, for license\nreasons, I then selected similar Google fonts. In both cases, I had to use a\nmonospace font version (Noto Sans Mono) for a perfect left justification of\nthe y axis text.\nDownload the .ttf files of the correspondent font type, load import it from the\ncorrect path and load them. Then add each font to each label, determining the\n.ttf file path for each face of the font. Finally, render the fonts with\nshowtext_auto().\n\n\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\n\n## Add the font with the corresponding font faces:\n\n#Title font\nfont_add(\"Libre Franklin Black\",\n         regular = \"./fonts/LibreFranklin-Black.ttf\",\n         bold = \"./fonts/LibreFranklin-Black.ttf\")\n\n# Subtitle font\nfont_add(\"Libre Franklin Medium\",\n         regular = \"./fonts/LibreFranklin-MediumItalic.ttf\",\n         italic = \"./fonts/LibreFranklin-MediumItalic.ttf\")\n\n# Y axis text  (monospaced Google font for left justification between facets)\nsysfonts::font_add_google(\"Noto Sans Mono\")\nfont_add(\"Noto Sans Mono\",\n         regular = \"./fonts/NotoSansMono-Regular.ttf\")\n\n# Geom_text font (values inside matrix), Caption text and and X axis labels\nfont_add(\"Libre Franklin\",\n         regular = \"./fonts/LibreFranklin-Regular.ttf\", # caption and X text\n         bold = \"./fonts/LibreFranklin-SemiBold.ttf\")\n\n# Tag text\nfont_add(\"Libre Franklin Bold\",\n         regular = \"./fonts/LibreFranklin-Bold.ttf\")\n\n## Automatically use showtext to render plots\nshowtext::showtext_auto()\n\n\nAdd the settings of the theme relative to facets, x/y axis, plot, labs and\nlegend:\n\n\nrepli <- repli+\n  theme(\n    # Labels of the facets (no visible)\n    strip.text=element_blank(),\n    # x and y axis\n    axis.ticks.x= element_blank(),\n    axis.ticks.y= element_blank(),\n    axis.text.x.top = element_text(size = 14, color = \"black\",\n                                   margin = margin(10, 10, 10, 10),\n                                   family = \"Libre Franklin\"),\n    axis.text.y = element_text(size = 15, color = \"black\",\n                               hjust= 0, margin = margin(0,-5,0,0),\n                               family = \"Noto Sans Mono\"),\n    # Plot margins\n    plot.margin = margin(17,4,22,4),\n    #Plot labs\n    plot.title = element_text(color = \"black\", size = 22.5,\n                              family = \"Libre Franklin Black\", face = \"bold\"),\n    plot.subtitle = element_text(color = \"grey40\", size = 17, lineheight = 0.2,\n                                 family = \"Libre Franklin Medium\",\n                                 face = \"italic\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(color = \"grey30\", size= 14, face=\"bold\",\n                                lineheight = 0.8,\n                                family = \"Libre Franklin\",\n                                hjust = 0, vjust = 0, margin = margin(13,0,0,0)),\n    plot.tag.position = c(0, -0.01),\n    plot.tag = element_text(size = 15, family = \"Libre Franklin Bold\", face = \"bold\",\n                            hjust = 0, vjust = 0, lineheight = 10),\n    # Legend \n    legend.position = \"top\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey40\", size = 18)\n    \n  )\nrepli\n\n\n\nAlso, set the theme settings for the background, the grid and the legend (more\ngeneral aesthetics):\n\n\nrepli <- repli+\n  theme(\n    # Panel and plot (spacing and grid)\n    panel.spacing=unit(10, \"pt\"),\n    #transparent panel and plot bg\n    panel.background = element_rect(fill='transparent', color=\"white\"), \n    plot.background = element_rect(fill='transparent', color=\"white\"),\n    panel.grid.major = element_blank(), #remove major gridlines\n    panel.grid.minor = element_blank(), #remove minor gridlines\n    # Legend\n    legend.background = element_rect(color=\"white\"), # white legend bg\n    legend.box.background = element_rect(color=\"white\"),#no legend panel\n    legend.key.width = unit(48, 'pt'),\n    legend.key.height = unit(12, 'pt'),\n    legend.margin = margin(5, 0, 0, 0)\n  )\nrepli\n\n\n\nAnnotation\nThe annotation of the values inside the matrix is applied using geom_text().\nWhen the values are above or equal to 40(%) the font is in white and in bold,\nwhen they are below, they are in black and in plain text. Color selection is\ncreated with an individual scale. Bold/plain font is applied by an ifelse\ncondition.\n\n\nrepli <- repli+\n  # Face, size, family and justification of text\n  geom_text(aes(color = value >= 40), family= \"Libre Franklin\",\n            fontface= ifelse(repl$data$value < 40, \"plain\", \"bold\"),\n            size = 6, vjust = \"center\", hjust = \"center\",\n  )+\n  # Color of the text\n  scale_color_manual(guide = \"none\", values = c(\"grey20\", \"white\"))\n\n# Final version:\nrepli\n\n\n\nAnd this is the version with no Google Fonts (fonts more similar to the\noriginal plot, except for x and y axis text that has to be in a monospaced\nfont):\nReplication 2 with no Google fontsAlternative version: parallel coordinates\nThinking about an alternative version of the original plot, we can say that, in\ngeneral terms, the graph is good. Some minor details could be implemented: some\ncolors of the color scale (legend) could have more extreme values to distinguish\nthem better. Also, the labels for the demographic main groups (age, gender,\nincome…) could be added. Optionally, the logos of the platforms could be\ndisplayed above their names since we tend to recognize even faster the social\nmedia app logos than their names.\nApart from this, the main disadvantage of the plot is the difficulty in visually\ndistinguishing the difference in the tendencies within demographic groups. To\nsolve that, we can use a parallel coordinates plot.\nOnce we have read the clean_data.csv file we generated in the replication plot,\nwe create, as before, new column names (these are slightly different from the\nother plot in the case of age, for space reasons). Also, we adjust the\ndata frame for our parallel coordinate plot’s structure: we order according to\ndescending Total values, we create a column “key” from the demographic group\ncolumn names and another column “value” with their values, we filter the\ndata frame and we create a column for “group” (as before). Then, we pivot wider\nthe Platform column into individual columns.\n\n\ndataK <- read.csv(\"clean_data.csv\")\ncolnames(dataK) <- c(\"Platform\", \"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                      \"Hispanic\", \"18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                      \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\", \"HS or less\",\n                      \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n\ndataK <- dataK %>% \n  # Order by descending values of \"Total\"\n  arrange(desc(Total)) %>% \n  # Create two columns: key (demo. subgroups) and value (percentages)\n  gather(\"key\", \"value\", -Platform) %>%\n  # Filter\n  filter(key %in% c(\"Total\", \"Men\", \"Women\", \"White\", \"Black\", \"Hispanic\",\n                    \"18-29\", \"30-49\", \"50-64\", \"65+\",\"<$30K\",\n                    \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\", \"HS or less\",\n                    \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n         ) %>%\n  # Create a \"group\" column\n  mutate(group = case_when(\n    key == \"Total\" ~ \"total\",\n    key %in% c(\"Men\", \"Women\") ~ \"gender\",\n    key %in% c(\"White\", \"Black\", \"Hispanic\") ~ \"race\",\n    key %in% c(\"18-29\", \"30-49\", \"50-64\", \"65+\") ~ \"age\",\n    key %in% c(\"<$30K\",\"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\") ~\"income\",\n    key %in% c(\"HS or less\", \"Some college\", \"College+\") ~ \"education\",\n    key %in% c(\"Urban\", \"Suburban\", \"Rural\") ~ \"place\"\n  )) %>% \n  # Pivot wider\n  pivot_wider(names_from = \"Platform\",\n              values_from = \"value\"\n              ) \n\n\nBuilding the plots: ggparcoord()\nThe idea is to create individual parallel coordinate plots for each of the\ndemographic groups, using an individual color scale for each one (color-hue\nscales). We will use ggparcoord() for this purpose.\nWe will need to discard the percentage values (geom_text()). Otherwise, we\nwouldn’t be able to properly read them.\nWe will repeat almost the same process: filter data frame by the group,\nbuilding the ggplot (x axis the platforms, y axis the percentages) and\nsetting the line size. In some cases, we will need a reference vector to\norder the variables in the legend.\n\n\nlibrary(ggrepel)\nlibrary(GGally)\n\n\nTotal\n\n\ntotal <- dataK%>%\n  # Filter by group\n  filter(group == \"total\") %>% \n  # Generating the plot\n  ggparcoord(dataK,\n             columns= c(3:13), # Platforms\n             groupColumn = \"key\", # Demographic subgroups\n             showPoints = TRUE,\n             order= c(2:21),\n             scale= \"globalminmax\",\n             title= \"Total\"\n  )+\n  # Line thickness\n  geom_line(size= 1.2)\ntotal\n\n\n\nGender\n\n\ngender <- dataK%>%\n  # Filter by group\n  filter(group == \"gender\") %>% \n  # Generating the plot\n  ggparcoord(dataK,\n             columns= c(3:13), # Platforms\n             groupColumn = \"key\", # Demographic subgroups\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Gender\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7\n  )+\n  # Line thickness\n  geom_line(size= 1.2)\ngender\n\n\n\nRace/Ethnicity\n\n\nrace <- dataK%>%\n  filter(group == \"race\") %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Race\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\nrace\n\n\n\nAge\n\n\nage <- dataK%>%\n  filter(group == \"age\") %>% # Filtering by age\n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Age\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7\n  )+\n  geom_line(size=1)\nage\n\n\n\nIncome\n\n\norder_inc <- c(\"<$30K\", \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\")\nincome <- dataK%>%\n  filter(group == \"income\") %>% # Filtering by income category\n  mutate(key = fct_relevel (key, levels = order_inc)) # Ordering income subgroups\n\nincome <- dataK%>%\n  filter(group == \"income\") %>% \n  mutate(key = fct_relevel (key, levels = order_inc)) %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Income\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\n\nincome\n\n\n\nEducation\n\n\norder_educ <- c(\"HS or less\", \"Some college\", \"College+\") # Ordered levels vector\neducation <- dataK%>%\n  filter(group == \"education\") %>% # Filtering education categories \n  mutate(key = fct_relevel (key, levels = order_educ))  \n  \neducation <- education %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Education\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\neducation\n\n\n\nPlace\n\n\nplace <- dataK%>%\n  filter(group == \"place\") %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Place\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\nplace\n\n\n\nColor scales and theme\nAt the beginning I tried to use mostly hue-colors palettes with\nscale_color_discrete_sequential(). However, in some cases I had to use\nscale_color_manual() to select the colors and correct the low color value\n(too bright).\nIn relation to the theme, initially, I tried to give more emphasis to the 40%\nvalue (as in the original plot). However, as pointed by the teacher,\nintroducing a horizontal line could give the feeling of a timeline. Therefore,\nI tried to keep the horizontal lines as subtle as possible (but still visible\nfor the easily reader to read the percentages) while giving emphasis to the\nvertical lines (grid).\nTotal\n\n\n# Grid annotations (horizontal, x axis)\ntotal <- total+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\ntotal <- total +\n  # Scales\n  scale_colour_manual(values = c(\"Total\"= \"grey30\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  #Theme\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    # Emphasis to the vertical lines\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    # X and Y axis\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    # legend\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \ntotal\n\n\n\nGender\n\n\ngender <- gender+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\ngender <- gender +\n  scale_colour_manual(values = c(\"Women\"= \"#8ab4df\", \"Men\"= \"#286c9c\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \ngender\n\n\n\nThe rest of demographic groups\nApply the same theme and color scale style to the rest of socioeconomic\ncategories:\n\n\nlibrary(colorspace)\n\n\n\n\n#RACE\n\nrace <- race+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\nrace <- race +\n  scale_color_manual(values = c(\"Black\"= \"#a2d0a8\", \"Hispanic\" = \"#62a086\",\n                                \"White\"= \"#294e5e\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n# AGE\n\nage <- age+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\nage <- age +\n  scale_color_discrete_sequential(palette= \"Red-Blue\")+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n# INCOME\n\n\nincome <- income +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\nincome <- income +\n  scale_color_discrete_sequential(palette= \"Burg\")+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    legend.spacing.x = unit(3, \"pt\"),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\n# EDUCATION\n\neducation <- education +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\neducation <- education +\n  scale_colour_manual(values = c(\"HS or less\"= \"#fdbb84\",\n                                 \"Some college\"= \"#f16914\",\n                                 \"College+\" = \"#a63603\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\n# PLACE\n\nplace <- place +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\nplace <- place +\n  scale_color_manual(values = c(\"Urban\" = \"#213e4b\",\n                                \"Suburban\" = \"#3b809a\", \"Rural\" = \"#99cfd1\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\nPatchwork and general theme\nWe need to paste all the individual plots together with {Patchwork}, add the\ntitle, subtitle and caption with plot_annotation() and add the aesthetics with\ntheme(). We should keep some coherence in the aesthetics so we will recycle\nsome elements from the theme of the replication (the plot is expected to be in\nthe article and should match the rest of the plots).\n\n\nlibrary(patchwork)\n\n# Pasting the plots together\nglobal <-gender+race+age+income+\n  education+place+total+\n  # Distribution in 3 lines\n  plot_layout(ncol = 3)+\n  # Labs annotation:\n  plot_annotation(\n    title = \"Use of online platforms, apps varies — sometimes widely — by demographic group\",\n    subtitle = \"% of U.S. adults in each demographic group who say the ever use...\",\n    caption = paste0(\n      'Note: White and Black adults include those who report being only one ',\n      'race and are not Hispanic. Hispanics are of any race. Not all numerical',\n      '\\ndifferences between groups shown are statistically significant (e.g.,',\n      ' there are no statistically significant differences between the shares ',\n      'of\\nWhite, Black or Hispanic Americans who say the use Facebook). ',\n      'Respondents who did not give an answer are not shown.\\nSource: Survey ',\n      'of U.S. adults conducted Jan. 25-Feb. 8, 2021.\\n\\\"Social Media Use in 2021\\\"',\n      '\\n\\nPEW RESEARCH CENTER'),\n    theme= theme(plot.margin = margin(17,4,22,4),\n                 plot.title = element_text(color = \"black\", size = 28,\n                                           family = \"Libre Franklin Black\",\n                                           face = \"bold\"),\n                 plot.subtitle = element_text(color = \"grey40\", size = 21,\n                                              lineheight = 0.2,\n                                              family = \"Libre Franklin Medium\",\n                                              face = \"italic\"),\n                 plot.title.position = \"plot\",\n                 plot.caption.position = \"plot\",\n                 plot.caption = element_text(color = \"grey30\", size= 14, face=\"plain\",\n                                             lineheight = 0.8,\n                                             family = \"Libre Franklin\",\n                                             hjust = 0, vjust = 0)\n                 )\n    )\n\n# Final result of the replication\nglobal\n\n\n\nConclusions\nApart from the put-in-practice opportunity of what was seen during the course of\nData Visualization, I would like to highlight some findings and messages for my\nfuture self:\nIt has been such a great exercise to face a real-world example of dataset and\ndocumentation and learn from mistakes. Always read carefully all the\ndocuments in the documentation, it’s all there and it shows (or it should do)\nthe reasoning behind the author’s choices. The time invested in reading the\ndocumentation will save you tons of time.\nUse RMarkdown from the beginning, especially if you intend to share your\nproject. Comments in .R are ok (if you remember to add them), but adding\ntext and separate your scripts in chunks gives you a more visually organised\nresult. Plus, using chunks allows you to section your work progress in stages\nand it’s easier to control bugs.\nThere must be always an ending, specially when replicating.\nLeave the fonts and the export size for the last stage (even if it’s hard to\nwatch). Otherwise, you may invest too much time in doing this process\niteratively. And don’t forget to render them before trying the next font of the\nlist.\n\n\n\n",
    "preview": "projects/2022/100462872/100462872_files/figure-html5/final-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 2496,
    "preview_height": 2496
  },
  {
    "path": "projects/2022/100488462/",
    "title": "Steph Curry's 3-Point Record in Context: Off the Charts",
    "description": "In this project, I will explain how to replicate a graph of the three-point\nfield goals made over the course of a season for every player in a range of\ntime. The graph shows a relevant difference in cumulative sums between \nthe current seasons and the previous ones.\nFirst, I will clean the dataset according to the variables that I need.\nSecond, I will present step by step how to reproduce the graph using\nggplot2 package.",
    "author": [
      {
        "name": "Nicola Ricciardi",
        "url": {}
      }
    ],
    "date": "2023-01-24",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nReplicating the chart\nImprove the Graph\n\nGetting the data\nRun the below commands to load the libraries we use. We also increase the vroom connection size to accomodate for the large file we read.\n\n\nlibrary(nbastatR)\nlibrary(tidyverse)\n\nSys.setenv(\"VROOM_CONNECTION_SIZE\" = 131072 * 2)\n\n\nSelect the Seasons useful for the graph.\n\n\nselectedSeasons <- c(1978:2017)\n\n\nExtract data from the function game_logs. I used selectedSeason to indicate the range of time, NBA to select the league, player and the type of season as Regular Season.\n\n\nP_gamelog_reg <- suppressWarnings(game_logs(seasons = selectedSeasons,\n                                            league = \"NBA\",\n                                            result_types = \"player\",\n                                            season_types = \"Regular Season\"))\n\n\n\n\naa <- P_gamelog_reg%>%\n  filter(slugSeason>= (\"1979-80\") & slugSeason <= (\"2015-16\"))%>%\n  select(yearSeason,slugSeason, namePlayer, dateGame, slugMatchup, fg3m, fg3a)%>%\n  arrange(slugSeason, namePlayer, dateGame)\n\n\nIt results that Eddie Johnson played in two teams at the same time, for this reason I select only the games when he played in Cleveland.\n\n\nEddie_ATL <- ifelse(aa$namePlayer==\"Eddie Johnson\"& !grepl(\"ATL|CLE\", aa$slugMatchup)==F, 1,0)\n\nEd <- cbind(aa,Eddie_ATL)\n\nEdd <- Ed%>%\n  filter(Eddie_ATL==0)%>%\n  select(-c(Eddie_ATL))\n\n\nI Create a column in which I compute the cumulative sum of the number of three point shoots made.\n\n\nEdd <- Edd%>%\n  group_by(namePlayer, slugSeason)%>%\n  mutate(P3M=sum(fg3m), P3A=sum(fg3a), \"cum_sum\"=cumsum(fg3m))%>%\n  ungroup()%>%\n  group_by(slugSeason)%>%\n  arrange(desc(P3M), .by_group = T)%>%\n  ungroup()\n\n\nI create two new columns, one for ID players and one for the first 20 players in the ID column.\n\n\nplayer_id2 <- Edd%>%\n  select(namePlayer)%>%\n  distinct()%>%\n  mutate(Id_player=row_number())\n\ntop_20_2 <- Edd%>%\n  select(c(slugSeason, namePlayer,P3M))%>%\n  arrange(slugSeason, desc(P3M))%>% \n  distinct()%>%\n  group_by(slugSeason)%>%\n  mutate(top_20=row_number())%>%\n  filter(top_20<=20)%>%\n  select(-c(P3M))%>%\n  ungroup()\n\ntop_20_x <- top_20_2%>%\n  mutate(ID=row_number())\n\n\nI merge three datasets in order to obtain Id_player and top_20 columns\n\n\nmerge.player1 = merge(x=Edd,player_id2,by=\"namePlayer\",all.Edd=TRUE)\nmerge.201 <-  merge(merge.player1, top_20_x, all=TRUE)\n\n\nI select the variables of interest and then I order by slugSeason, top_20 and dategame. I compute the cumulative sum of three points field goals made.\n\n\nmerge.df11 <- merge.201%>%\n  select(yearSeason,slugSeason, namePlayer, dateGame, slugMatchup, P3M, fg3m,\n         Id_player, top_20, ID)%>%\n  arrange(slugSeason, top_20, dateGame,ID)%>%\n  group_by(namePlayer,slugSeason)%>%\n  mutate(P3M=sum(fg3m), \"cum_sum\"=cumsum(fg3m))%>%\n  distinct()%>%\n  filter(!is.na(top_20))%>%\n  filter(top_20<=20)\n\n\nI create the final dataset adding a new column for the number of games (#82 in a season).\n\n\nff <- merge.df11%>%\n  group_by(slugSeason,namePlayer)%>%\n  mutate(\"N_games\"= row_number())\n\n\nThis is the final dataset with another column to annotate the name of the players in the right part of the graph.\n\n\nff1 <- ff%>%\n  mutate(aa = substring(slugSeason, 3, 7))%>%\n  mutate(aa1 = namePlayer)\n\nff <- unite(ff1, col='n-d-3', c('aa1', 'aa'), sep=\" '\")\n\nff <- ff%>%\n  rename(pp = 'n-d-3')\n\n\nSaving dataset:\n\n\nwrite.csv(ff, file = \"ff2.csv\", \n          sep = \"\\t\", \n          row.names = F)\n\n\nReplicating the chart\nIt is a graph from the Sunday Sports cover celebrating 3-point records of Stephen Curry during the last years.\nThe graph has 740 lines, one for each player who was in the top 20 in 3-point shoot made starting from 1980. The best record is established by Stephen Curry with 402 3 pointers.\nThe colors scale highlights a a clear difference in cumulative sum during the range of time.\nFor the regular season 2015 - 2016 Stephen Curry is an outlier compare with the other records.\n\n\nlibrary(tidyverse)\nlibrary(ggrepel)\n\nff <- read.delim(\"ff.csv.gz\", sep =\",\", header=TRUE)\n\n\nHere, I create a function to expand the scale color I select in my favourite colours. In cvi_palettes I select n = 37 according to the range time of the graph. I need to set type as “continuous”.\n\n\ncvi_colours = list(\n  cvi_purples = c(\"#381532\", \"#4b1b42\", \"#5d2252\", \"#702963\",\n                  \"#833074\", \"#953784\", \"#a83e95\"),\n  my_favourite_colours = c(\"#CD9B9B\", \"#EECFA1\",  \"#7CCD7C\", \"#00688B\")\n)\n\ncvi_palettes = function(name, n, all_palettes = cvi_colours, type = c(\"discrete\", \"continuous\")) {\n  palette = all_palettes[[name]]\n  if (missing(n)) {\n    n = length(palette)\n  }\n  type = match.arg(type)\n  out = switch(type,\n               continuous = grDevices::colorRampPalette(palette)(n),\n               discrete = palette[1:n]\n  )\n  structure(out, name = name, class = \"palette\")\n}\n\ncol <- cvi_palettes(\"my_favourite_colours\", type = \"continuous\", n = 37)\n\n\nAt this point, I tried to replicate the graph without the original colors and axis labels, but I encountered some problems related with annotations. In fact, when I plot the names for each player at the top 1 in every season, I have several overlaps. Using the parameter check_overlap = T in the function geom_text I lose a lot of players, for this reason I decided to improve the graph using the function geom_text_repel that plot the labels with rows to avoid overlaps.\n\n\nn1 <- ggplot(ff, xlim=c(0, 97), ylim=c(0, 420)) + \n  \n  geom_segment(\n    aes(\n      x=0, xend=0,\n      y=0, yend=0\n    )\n  ) + geom_segment(\n    aes(\n      x=0, xend=97,\n      y=50, yend=50\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=10, xend=97,\n      y=100, yend=100\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=27, xend=97,\n      y=150, yend=150\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=37, xend=97,\n      y=200, yend=200\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=46, xend=97,\n      y=250, yend=250\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=55, xend=97,\n      y=300, yend=300\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=65, xend=97,\n      y=350, yend=350\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=75, xend=97,\n      y=400, yend=400\n    ), color = \"grey90\"\n  )\n\n\nn1 <- n1 + geom_step(aes(x = ff$N_games, y = cum_sum, group = ID, color = yearSeason),\n                   linetype = \"solid\", alpha = 1, size = 1.08)\n\nn1 <-  n1 + geom_segment(aes(x=0, xend=83, y=0, yend=0), size=1) \n\nn1<-  n1 + coord_fixed(ratio=1/3)\n\nn1 <- n1 + ggtitle(\"Stephen Curry's 3-Point Record in Context: Off the Charts\")\n\nn1 <- n1 +  geom_text(data = ff%>%\n              select(yearSeason,slugSeason, namePlayer, P3M, top_20, N_games, cum_sum, pp)%>%\n              filter(top_20 == 1)%>%\n              group_by(yearSeason, slugSeason, pp,namePlayer, P3M)%>%\n              summarise(\n                P3M1 = sum(cum_sum)\n              )%>%\n              select(-P3M1),\n            aes(x = 82, y = P3M, colour = yearSeason, label=pp), \n            family = \"Palatino\",\n            fontface = \"plain\",\n            size = 2,\n            direction = \"y\",\n            hjust = \"left\",\n            nudge_x = 0\n            )\n\nn1 <- n1 +  guides(colour = guide_colourbar(title = substitute(paste(bold(\"Cumulative \nthree-point field \ngoals made over \nthe course of a \nseason\"))), barwidth = 0.8, barheight = 7))\n\nn1 <- n1 + theme(\n     plot.title = element_text(size = 15, family = \"serif\", face = \"plain\", hjust = 0.8),\n     plot.background = element_rect(fill = \"white\", colour = NA),\n        panel.background = element_rect(fill = \"white\", colour = NA),\n   panel.grid.major.x = element_blank(),\n legend.position=\"left\",\n\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank(),\n  axis.ticks.length.x = unit(-.2, \"cm\"),\n  axis.ticks.y = element_blank(),\n  axis.text.y = element_text(vjust = -1)) \nn1\n\n\n\nImprove the Graph\nHere, I set the coordinates of my graph according to x - axis that represent the number of games in a regular season, and y - axis that marks how many three point shoots made by a player.\n\n\nn <- ggplot(ff, xlim=c(0, 83), ylim=c(0, 420)) + \n  \n  geom_segment(\n    aes(\n      x=0, xend=0,\n      y=0, yend=0\n    )\n  ) + geom_segment(\n    aes(\n      x=0, xend=83,\n      y=50, yend=50\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=10, xend=83,\n      y=100, yend=100\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=27, xend=83,\n      y=150, yend=150\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=37, xend=83,\n      y=200, yend=200\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=46, xend=83,\n      y=250, yend=250\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=55, xend=83,\n      y=300, yend=300\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=65, xend=83,\n      y=350, yend=350\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=75, xend=83,\n      y=400, yend=400\n    ), color = \"grey90\"\n  )\nn\n\n\n\nI visualize the cumulative sum of three points shoot through geom_step, where for the x - axis there is the number of games, in the y - axis there is the cumulative sum, the group and the colour change according to ID and yearSeason.\n\n\nn <- n + geom_step(aes(x = ff$N_games, y = cum_sum, group = ID, color = yearSeason),\n                   linetype = \"solid\", alpha = 1, size = 1.08)\nn\n\n\n\nHere, I visualize the x - axis representing the number of games in a season.\n\n\nn <-  n + geom_segment(aes(x=0, xend=83, y=0, yend=0), size=1) \nn\n\n\n\nA fixed coordinate system forces a specified ratio between the physical representation of data units on the axes. The ratio is equal to 1/3, it means that one unit on the x - axis is 1/3 of one unit on the y - axis.\n\n\nn <-  n + coord_fixed(ratio=1/3)\nn\n\n\n\nHere, I visualize the title according to the original graph.\n\n\nn <- n + ggtitle(\"Stephen Curry's 3-Point Record in Context: Off the Charts\")\nn\n\n\n\nI use geom_text_repel to annotate the name of the first player for every. This is a good option to increase the visualization of the graph, in fact it is possible to highlight different players with different colours and plot arrows to increase clarity and avoid overlaps.\n\n\nn <- n + geom_text_repel(data = ff%>%\n              select(yearSeason,slugSeason, namePlayer, P3M, top_20, N_games, cum_sum, pp)%>%\n              filter(top_20 == 1)%>%\n              group_by(yearSeason, slugSeason, pp,namePlayer, P3M)%>%\n              summarise(\n                P3M1 = sum(cum_sum)\n              )%>%\n              select(-P3M1),\n            aes(x = 82, y = P3M, colour = yearSeason, label=pp), \n            family = \"Palatino\",\n            fontface = \"plain\",\n            size = 3,\n            direction = \"y\",\n            hjust = \"left\",\n            nudge_x = 9\n            )\nn\n\n\n\nHere I define the color scale I created previously. I have 37 seasons for 37 different shades. According to the visualization, it is possible observe that the cumulative sum increases over the years. The exception is Stephen Curry who is off the charts with more than 400 three points shoots made over the season.\n\n\nn <- n + scale_colour_gradientn(colours = col, breaks = c(1980, 2016), labels =c(\"1979-80\", \"2015-16\"))\nn\n\n\n\nI define the labels for the x - axis and the y - axis. The first axis has a label every 10 games, while y - axis has a label every 50 three - point field goals.\n\n\nn <-  n + scale_x_continuous(expand = c(0,0), \n                     breaks =c(1:82), limits = c(0,110), \n                     labels = c(\"1st game\",\"\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"10th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"20th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"30th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"40th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"50th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"60th\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"70th\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"80th\",\"\",\"\")\n                     ) + \n  scale_y_continuous(expand = c(0,4),\n                     breaks = c(0,50, 100, 150, 200, 250, 300, 350, 400),\n                     labels = c(\"\", \"50\", \"100\", \"150\", \"200\", \"250\", \"300\", \"350\", \"400\"),\n                     limits = c(0,420))\nn\n\n\n\nIn this part I define the legend title for the plot, customizing the legend’s size.\n\n\nn <- n +  guides(colour = guide_colourbar(title = substitute(paste(bold(\"Cumulative \nthree-point field \ngoals made over \nthe course of a \nseason\"))), barwidth = 0.8, barheight = 7))\nn\n\n\n\nIn this part I use some functions to modify the title, customize the background or set the position of the legend.\nAccording to the original graph I remove the axis title and the ticks from the y - axis.\n\n\nn <- n + theme(\n  plot.title = element_text(size = 15, family = \"serif\", face = \"plain\", hjust = 0.8),\n  plot.background = element_rect(fill = \"white\", colour = NA),\n  panel.background = element_rect(fill = \"white\", colour = NA),\n  panel.grid.major.x = element_blank(),\n  legend.position=\"left\",\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank(),\n  axis.ticks.length.x = unit(-.2, \"cm\"),\n  axis.ticks.y = element_blank(),\n  axis.text.y = element_text(vjust = -1)) \nn\n\n\n\n\n\n\n",
    "preview": "projects/2022/100488462/100488462_files/figure-html5/unnamed-chunk-25-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1728
  },
  {
    "path": "projects/2022/100446823/",
    "title": "Views on Financial Well-Being of Future Generations",
    "description": "In this post I recreate a Pew Research graph and propose an alternative\nvisualization of the data.",
    "author": [
      {
        "name": "Eliseo Garilleti",
        "url": {}
      }
    ],
    "date": "2023-01-23",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData reading\nGraph replication\nThe same graph made more beautiful\nAlternative visualization of the data\n\nData reading\nI load the data, transform it into long format and create a new column that assigns a number to each country to group them into different categories as a preliminary step to the alternative visualisation I will carry out.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\ndataviz <- readxl::read_xlsx(\"data.xlsx\")\n\ndataviz_long <- dataviz %>% \n  pivot_longer(cols = c(2,3),\n               names_to = \"Eco_perception\",\n               values_to = \"Proportion\")  %>% \n  mutate(zone = case_when(Country == \"Poland\" ~ 1,\n                          Country == \"Hungary\" ~ 1,\n                          Country == \"Germany\" ~ 2,\n                          Country == \"Greece\" ~ 3,\n                          Country == \"Italy\" ~ 3,\n                          Country == \"France\" ~ 2,\n                          Country == \"Netherlands\" ~ 2,\n                          Country == \"Sweden\" ~ 2,\n                          Country == \"Spain\" ~ 3,\n                          Country == \"Belgium\" ~ 2,\n                          Country == \"UK\" ~ 4,\n                          Country == \"U.S.\" ~ 4,\n                          Country == \"Canada\" ~ 4,\n                          Country == \"Australia\" ~ 4,\n                          Country == \"Malaysia\" ~ 5,\n                          Country == \"South Korea\" ~ 5,\n                          Country == \"Singapore\" ~ 5,\n                          Country == \"Japan\" ~ 5),\n         Eco_perception = case_when(Eco_perception == \"Eco_good\" ~ \"Good\",\n                                    Eco_perception == \"Eco_bad\" ~ \"Bad\")) \n\ncountry_order <- c(\"Japan\", \"Belgium\", \"Spain\", \"Sweden\", \"Netherlands\", \"Israel\", \n                   \"UK\", \"Australia\", \"France\", \"Canada\", \"Italy\", \"Singapore\", \"Greece\", \n                   \"U.S.\", \"South Korea\", \"Germany\", \"Malaysia\", \"Hungary\", \"Poland\")\n\n\nGraph replication\nHere I replicate, as close as possible, a graph by Pew Research in their 2022 article Large shares in many countries are pessimistic about the next generation’s financial future.\n\n\n\nFigure 1: The original graph by Pew Research\n\n\n\nThrough the graph above, they show the differences between two groups, those who have positive or negative views of the current state of the domestic economy, in different countries, in relation to the economic future that awaits their children. Specifically, it shows how, systematically, the % of individuals who think that their children will have a worse economic situation than their parents is higher among those who think that the economic situation in their country is bad.\nThis graph, while not overly complicated to replicate, presents some difficulty stemming from the fact that it is actually two graphs in one. The main graph was relatively easy to carry out, except for the legend, which presented a challenge to some degree. To carry out the accompanying one (the table showing the difference between the groups) I had to think a bit out the box. The process of putting them together was the most time-consuming part, mainly because I had no prior knowledge of the library patchwork and not much practice in joining graphs. In any case, I consider that the final result has been satisfactory.\nIn my view, they have chosen an almost perfect graph to tell the story they want to tell, one about differences between groups. Representing each group as a dot and showing their differences in terms of percentage points through horizontal distances (by adding a grey line connecting the dots) makes it easy to observe the degree of these differences within the countries. The order in which the countries are shown (according to the differences between groups, in descending order), helps to visualize the differences between countries. It also uses color to make it easier for the reader to distinguish between the two groups, although the choice of colors is not ideal from my point of view, an idea I will develop later.\nThe graph incorporates a table that allows the differences to be consulted numerically. The appropriateness of this table is debatable, is the information it provides really necessary? The main graph already makes it possible to clearly see the differences within and between countries. In any case, I think that the presentation of this table could be improved, which I will also discuss later.\n\n\np1 <- dataviz_long %>% \n  ggplot(aes(x = Country, y = Proportion, fill = Eco_perception,\n             color = Eco_perception, group = Country, label = Proportion)) +\n  geom_line(color = \"gray45\", size = 1.5, alpha = .2) + \n  geom_point(shape = 21, size = 2.7) +\n  geom_text(vjust = 2.5, nudge_x = 0.15, size = 2.9) +\n  coord_flip() +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, color = \"#657032\") +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"situation is good\",\n           size = 2.9, vjust = -1.7, color = \"#657032\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, hjust = .3, color = \"#326296\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"situation is bad\",\n           size = 2.9, vjust = -1.7, hjust = .25,color = \"#326296\") +\n  expand_limits(y = c(0,100),\n                x = c(-.1, 20.5)) +\n  scale_y_continuous(breaks = c(0,100)) +\n  scale_x_discrete(limits = country_order) +\n  scale_fill_manual(values = c(\"#8cb3e6\", \"#d5ddad\")) +\n  scale_color_manual(values = c(\"#326296\", \"#657032\")) +\n  labs(x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray45\", size = .2),\n        panel.grid.minor = element_line(color = \"gray45\", size = .2),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        axis.text = element_text(family = \"Helvetica\", size = 9, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray55\", size = 7.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -3),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7.5,\n                                face = \"bold\", hjust = .4, vjust = 1),\n        plot.margin = unit(c(.7, .25, 1, .5), \"cm\"))\n\np1 \n\n\n\n\n\np2 <- dataviz %>% \n  ggplot(aes(fct_reorder(Country, Diff), Diff, label = Diff)) +\n  geom_point(alpha = 0) +\n  coord_flip() + \n  annotate(\"rect\", xmin = 0.5, xmax = 20.5, ymin = 15.5, ymax = 20, fill = \"#efefe2\") +\n  geom_text(label = paste(\"+\",dataviz$Diff), y=17.5, fontface = \"bold.italic\",\n            size = 3, color = \"gray30\") +\n  ylim (15.5,20) +\n  expand_limits(x = c(-.1, 20.5)) +\n  annotate(\"text\", x = \"Poland\", y = 17.5, label = \"Diff\", size = 3,\n           vjust = -2.5, fontface = \"bold.italic\", color = \"gray30\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\",\n        plot.margin = unit(c(.7, 0.25, 1, 0), \"cm\"))\n\np2 \n\n\n\n\n\np1 + p2 + \n  plot_layout(widths = c(1.7, .3)) +\n  plot_annotation(title = \"People who see economy negatively are \\nmore likely to see a worse financial \\nfuture for the next generation\",\n                  subtitle = \"% who say that when children today in (survey country) \\ngrow up, they will be worse off financially than their \\nparents, among those who say their country's...\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 12.5,\n                                              face = \"bold\", vjust = -3.5),  \n                    plot.subtitle = element_text(family = \"Times\", size = 10.5,\n                                                 color = \"gray25\", face = \"italic\",\n                                                 vjust = -5))) \n\n\n\nThe same graph made more beautiful\nThere were a couple of elements related to the presentation and aesthetics of the graph that did not quite convince me: the colors and the background of the table presenting the differences.\nI think red is a more appropriate color to represent groups that have a negative view on something, so I have replaced blue with this color. I have also replaced the green with a brighter green, because the red stood out too much. I have also removed the background of the column that presents the differences and I have chosen to divide this column from the graph using a vertical line, which contributes to a cleaner presentation.\n\n\np1a <- dataviz_long %>% \n  ggplot(aes(x = Country, y = Proportion, fill = Eco_perception,\n             color = Eco_perception, group = Country, label = Proportion)) +\n  geom_line(color = \"gray45\", size = 1.5, alpha = .2) + \n  geom_point(shape = 21, size = 2.7) +\n  geom_text(vjust = 2.5, nudge_x = 0.15, size = 2.9) +\n  coord_flip() +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, color = \"#025902\") +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"situation is good\",\n           size = 2.9, vjust = -1.7, color = \"#025902\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, hjust = .3, color = \"#AB0202\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"situation is bad\",\n           size = 2.9, vjust = -1.7, hjust = .25, color = \"#AB0202\") +\n  expand_limits(y = c(0,100),\n                x = c(-.1, 20.5)) +\n  scale_y_continuous(breaks = c(0,100)) +\n  scale_x_discrete(limits = country_order) +\n  scale_fill_manual(values = c(\"#FA8080\", \"#A7F3A7\")) +\n  scale_color_manual(values = c(\"#AB0202\", \"#025902\")) +\n  labs(x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray45\", size = .2),\n        panel.grid.minor = element_line(color = \"gray45\", size = .2),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.title = element_text(family = \"Helvetica\", size = 11.5,\n                                  face = \"bold\", vjust = 3),  \n        plot.subtitle = element_text(family = \"Times\", size = 10,\n                                     color = \"gray25\", face = \"italic\", vjust = 3),\n        axis.text = element_text(family = \"Helvetica\", size = 9,\n                                 color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.title.position = \"plot\",\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray55\", size = 7.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -3),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7.5,\n                                face = \"bold\", hjust = .43, vjust = 1),\n        plot.margin = unit(c(.7, .25, 1, .5), \"cm\"))\n\n\n\n\np2r <- dataviz %>% \n  ggplot(aes(fct_reorder(Country, Diff), Diff, label = Diff)) +\n  geom_point(alpha = 0) +\n  coord_flip() + \n  geom_text(label = paste(\"+\",dataviz$Diff), y=17.5, fontface = \"bold.italic\",\n            size = 3, color = \"gray30\") +\n  ylim (13,20) +\n  expand_limits(x = c(-.1, 20.5)) +\n  geom_hline(yintercept = 13.5, size = .3, color = \"gray65\") +\n  annotate(\"text\", x = \"Poland\", y = 17.5, label = \"Diff\", size = 3,\n           vjust = -2.5, fontface = \"bold.italic\", color = \"gray30\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title.x = element_blank(),\n        axis.title.y =  element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\",\n        plot.margin = unit(c(.7, 0.25, 1, 0), \"cm\"))\n\n\n\n\ngraphr <- p1a + p2r + \n  plot_layout(widths = c(1.7, .3)) +\n  plot_annotation(title = \"People who see economy negatively are \\nmore likely to see a worse financial \\nfuture for the next generation\",\n                  subtitle = \"% who say that when children today in (survey country) \\ngrow up, they will be worse off financially than their \\nparents, among those who say their country's...\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 12.5,\n                                              face = \"bold\", vjust = -3.5),  \n                    plot.subtitle = element_text(family = \"Times\", size = 10.5,\n                                                 color = \"gray25\", face = \"italic\",\n                                                 vjust = -5))) \n\ngraphr\n\n\n\nAlternative visualization of the data\nThe type of graphic Pew Research uses to tell its story is probably the most appropriate. Below I show a proposal that tells a similar story, using a different type of visualization.\nIn terms of the story, I thought it relevant to group the countries into different graphs. The criteria I have followed to carry out this grouping is geographic and cultural. I have grouped different European countries according to the region in which they are located; I have also grouped Anglo-Saxon countries and Asian countries. As for the way of visualizing the data, I have chosen to show the differences through the slope of the line.\n\n\nalt1 <- dataviz_long %>% \n  filter(zone == 1) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 72.5, label = \"HU\", size = 5.8,  color = \"#1d42ff\") +\n  annotate(\"text\", x = \"Bad\", y = 65.5, label = \"PL\", size = 5.8,  color = \"#ed009c\") +\n  scale_fill_manual(values = c(\"#1d42ff\", \"#ed009c\")) +\n  scale_color_manual(values = c(\"#1d42ff\", \"#ed009c\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"Hungary and Poland\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 9,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        #plot.title.position = \"plot\",\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 7,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7,\n                                face = \"bold\", hjust = .37, vjust = 2),\n        plot.margin = unit(c(1.5, .5, 1.5, 1), \"cm\"))\n\nalt1\n\n\nalt2 <- dataviz_long %>% \n  filter(zone == 2) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 90.5, label = \"FR\", size = 5.8, color = \"#0079b1\") +\n  annotate(\"text\", x = \"Bad\", y = 84, label = \"BE\", size = 5.8, color = \"#8a76cb\") +\n  annotate(\"text\", x = \"Bad\", y = 78.3, label = \"NL\", size = 5.8, color = \"#e966b0\") +\n  annotate(\"text\", x = \"Bad\", y = 72.5, label = \"DE\", size = 5.8, color = \"#ff706a\") +\n  annotate(\"text\", x = \"Bad\", y = 65.5, label = \"SW\", size = 5.8, color = \"#ffa600\") +\n  scale_fill_manual(values = c(\"#8a76cb\", \"#0079b1\", \"#ff706a\", \"#e966b0\", \"#ffa600\")) +\n  scale_color_manual(values = c(\"#8a76cb\", \"#0079b1\", \"#ff706a\", \"#e966b0\", \"#ffa600\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"France, Belgium, Netherlands, \\nGermany and Sweden\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20,\n                                 color = \"gray30\"),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 9,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 9,\n                                face = \"bold\", hjust = .67, vjust = 1),\n        plot.margin = unit(c(1.5, .5, 1.5, .5), \"cm\"))\n\nalt2\n\n\nalt3 <- dataviz_long %>% \n  filter(zone == 3) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 85.5, label = \"IT\", size = 5.8, color = \"#eaa200\") +\n  annotate(\"text\", x = \"Bad\", y = 79.5, label = \"ES\", size = 5.8, color = \"#ff5441\") +\n  annotate(\"text\", x = \"Bad\", y = 73.5, label = \"GR\", size = 5.8, color = \"#73b600\") +\n  scale_fill_manual(values = c(\"#73b600\", \"#eaa200\", \"#ff5441\")) +\n  scale_color_manual(values = c(\"#73b600\", \"#eaa200\", \"#ff5441\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"Italy, Spain and Greece\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 9,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 9,\n                                face = \"bold\", hjust = .67, vjust = 1),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt3\n\n\nalt4 <- dataviz_long %>% \n  filter(zone == 4) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 89.5, label = \"CAN\", size = 5.8, color = \"#003f5c\") +\n  annotate(\"text\", x = \"Bad\", y = 86.5, label = \"AUS\", size = 5.8, color = \"#775193\") +\n  annotate(\"text\", x = \"Bad\", y = 83.5, label = \"UK\", size = 5.8, color = \"#ea5476\") +\n  annotate(\"text\", x = \"Bad\", y = 79.5, label = \"US\", size = 5.8, color = \"#ff9f0f\") +\n  scale_fill_manual(values = c(\"#775193\", \"#003f5c\", \"#ff9f0f\", \"#ea5476\")) +\n  scale_color_manual(values = c(\"#775193\", \"#003f5c\", \"#ff9f0f\", \"#ea5476\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(49, 90), breaks = seq(50, 90, by = 10)) +\n  labs(subtitle = \"Canada, Australia, UK and US\",\n       x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 17.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -6),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 16.5,\n                                face = \"bold\", hjust = .33, vjust = 2.5),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt4\n\n\nalt5 <- dataviz_long %>% \n  filter(zone == 5) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 87, label = \"JPN\", size = 5.8, color = \"#3e015c\") +\n  annotate(\"text\", x = \"Bad\", y = 77, label = \"MYS\", size = 5.8, color = \"#be004e\") +\n  annotate(\"text\", x = \"Bad\", y = 72, label = \"KOR\", size = 5.8, color = \"#f18000\") +\n  annotate(\"text\", x = \"Bad\", y = 67, label = \"SGP\", size = 5.8, color = \"#98c114\") +\n  scale_fill_manual(values = c(\"#3e015c\", \"#be004e\", \"#98c114\", \"#f18000\")) +\n  scale_color_manual(values = c(\"#3e015c\", \"#be004e\", \"#98c114\", \"#f18000\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(33, 88), breaks = seq(35, 85, by = 10)) +\n  labs(subtitle = \"Japan, Malaysia, South Korea and \\nSingapore\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt5\n\n\n\n\n\ngraph_alt <- alt1 + alt2 + alt3 + alt4 + alt5 +\n  plot_annotation(title = \"People who see economy negatively are more likely to see a worse financial future for the \\nnext generation\",\n                  subtitle = \"% who say that when children today in (survey country) grow up, they will be worse off financially than their parents,  \\namong those who say their country's economic situation is good or bad\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 28.5,\n                                              face = \"bold\", vjust = 2, color = \"gray20\"),  \n                    plot.subtitle = element_text(family = \"Helvetica\", size = 23.5,\n                                                 color = \"gray20\", face = \"italic\",\n                                                 vjust = 0))) \n\ngraph_alt\n\n\n\n\n\n\n",
    "preview": "projects/2022/100446823/100446823_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 739,
    "preview_height": 1536
  },
  {
    "path": "projects/2022/100486421/",
    "title": "Worldwide Top 10 Listened Songs in Spotify",
    "description": "This project is about a visualization of the ten most listened songs between\nJune and August 2022 in Spotify.",
    "author": [
      {
        "name": "Jorge Pascual Segovia",
        "url": {}
      }
    ],
    "date": "2023-01-23",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData cleaning\nReplicating the plot\nAlternative plot\n\nFor this project, I decided to select Spotify worldwide data about the most listened songs between June and August from Newtral’s webpage.\nAt first, we can find the codes for the data cleaning, the replication plot and the alternative plot. Then I will go step by step explaining each of the decisions I took during the replication plot and the alternative plot.\n\n\n#### Libraries\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(gganimate)\n\n\nData cleaning\n\n\n#### Read the Dataset\nspoti<-read_csv(\"spotify-data.csv\", skip = 2,\n                col_names = c(\"Date\",\n                              \"As It Was\",\n                              \"Despechá\",\n                              \"Me Porto Bonito\",\n                              \"Pink Venom\",\n                              \"Quevedo: Bzrp Music Sessions, Vol. 52\",\n                              \"Tití Me Preguntó\"))\n\n\nHere, I noticed that I needed to create the columns of my variable by pivoting the dataframe so I obtain columns for the date, the ranking position and the name of the song:\n\n\n#Pivot long the Song\nspoti <- spoti %>% \n  tidyr::pivot_longer(-Date,\n               names_to = \"Song\",\n               values_to = \"Ranking\")\nspoti\n\n# A tibble: 294 × 3\n   Date   Song                                  Ranking\n   <chr>  <chr>                                   <dbl>\n 1 06-jul As It Was                                   2\n 2 06-jul Despechá                                   NA\n 3 06-jul Me Porto Bonito                             4\n 4 06-jul Pink Venom                                 NA\n 5 06-jul Quevedo: Bzrp Music Sessions, Vol. 52      NA\n 6 06-jul Tití Me Preguntó                            5\n 7 07-jul As It Was                                   2\n 8 07-jul Despechá                                   NA\n 9 07-jul Me Porto Bonito                             4\n10 07-jul Pink Venom                                 NA\n# … with 284 more rows\n\nThen, I wanted the Date column to be date type so it’s easier to handle.\n\n\n#Transform Date column into \"date type\" \nspoti$Date <- paste(spoti$Date, \"2022\",sep=\"-\")\nspoti$Date<-  gsub(\"jul\",07,spoti$Date)\nspoti$Date<-  gsub(\"ago\",08,spoti$Date)\nspoti$Date <- dmy(spoti$Date)\nspoti\n\n# A tibble: 294 × 3\n   Date       Song                                  Ranking\n   <date>     <chr>                                   <dbl>\n 1 2022-07-06 As It Was                                   2\n 2 2022-07-06 Despechá                                   NA\n 3 2022-07-06 Me Porto Bonito                             4\n 4 2022-07-06 Pink Venom                                 NA\n 5 2022-07-06 Quevedo: Bzrp Music Sessions, Vol. 52      NA\n 6 2022-07-06 Tití Me Preguntó                            5\n 7 2022-07-07 As It Was                                   2\n 8 2022-07-07 Despechá                                   NA\n 9 2022-07-07 Me Porto Bonito                             4\n10 2022-07-07 Pink Venom                                 NA\n# … with 284 more rows\n\nAlso, I realized that the font was Roboto, which is in the Google’s font package, so I loaded it as we learnt in the course.\n\n\n#### First theme settings\ntheme_set(theme_minimal()) #Set the minimal theme\nsysfonts::font_add_google(\"Roboto\") #Adding a google font type\n\n\nReplicating the plot\n\n\np <- ggplot(spoti) +\n  aes(Date, Ranking) + #set x and y axis\n  geom_line(aes(color=Song), size = 1) + #set the visualization mark\n  theme(text = element_text(family=\"Roboto\")) #set the font\np\n\n\n\nTo follow with, I realized that the plot is upside down so I needed to adjust the axis’ scales:\n\n\np <- p +\n  #set the order of y axis guides\n  scale_y_continuous(trans = \"reverse\", n.breaks = 10) +               \n  scale_x_date(\n    #set the date format of the y tickmarks\n    date_labels = \"%d-%b\",                                               \n    breaks = seq(as.Date(\"2022-07-11\"), as.Date(\"2022-08-25\"), by = 6))\np\n\n\n\nThen I introduced the title and subtitle and set the format for them. To get the code of the specific color, I used this very useful webpage: https://imagecolorpicker.com/. The size was guessed by playing with the code until I got the same format.\n\n\n  p <- p +\n  labs(\n    title=\"Evolución diaria del ránking en Spotify\", \n    subtitle = \"Posición de las seis canciones más escuchadas en la plataforma a nivel mundial\") +\n  theme(plot.title = element_text(face = \"bold\", size = 16.5)) + # Format of titles\n  labs(x = NULL, y = NULL, color = NULL) # Remove the labels from the axis\np\n\n\n\nHere is the tricky part, the theme settings to make this graph look identically as the original one, step by step. I didn’t write the code at once. I added things while I was advancing with the plot and realizing of needed theme features.\n\n\np <- p +\n  # size and color of the axis components\n  theme(axis.text.y = element_text(colour = \"#a8a8a8\", size = 10), \n        axis.line.y = element_line(size = 0, color = \"#eeeeee\"),\n        axis.text.x = element_text(colour = \"#a8a8a8\", size = 10),\n        panel.grid.minor.y = element_blank(), # remove some grid lines\n        panel.grid.major.y = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position=\"none\") #remove the legend\np\n\n\n\nAs I removed the legend, I needed to add information to know which song is represented by each visualization mark. I started trying it with annotations but then figured out that ‘geom_text’ was more simple and easy. Once I got the labels, I only needed to adjust the limits so it fitted:\n\n\n#for the location of the legend annotations\ndf.labs <- spoti %>% \n  filter(Date == \"2022-08-23\") \n\np <- p +\n  geom_text(aes(\n    label=Song, colour = Song), df.labs, hjust=0, nudge_x=0.7) + #Annotations for legend\n  expand_limits(x= as.Date(\"2022-9-1\")) + #Create space for the annotations\n  expand_limits(y= 9) \np\n\n\n\nFinally, I only needed to fit the colors of the original plot.\n\n\np <- p +\n  scale_color_manual(values=c( \n  \"#8dc7ad\", \"#5cb689\", \"#267d59\", \"#54b182\", \"#c71e1d\", \"#4ea07c\"))  \np\n\n\n\nAlternative plot\nAt first, I considered that I could add more information as the color visualization mark was almost not giving information apart of which song is the spanish one. As I didn’t have the resources to get more data from Spotify.\n\n\nspotig <- spoti %>% \n  mutate(\"Genre\" = case_when(\n    endsWith(Song, \"52\") ~ \"Pop\",\n    endsWith(Song, \"As It Was\") ~ \"Pop\",\n    endsWith(Song, \"Pink Venom\") ~ \"K-Pop\",\n    endsWith(Song, \"Me Porto Bonito\") ~ \"Reggaeton/Latino\",\n    endsWith(Song, \"Tití Me Preguntó\") ~ \"Reggaeton/Latino\",\n    endsWith(Song, \"Despechá\") ~ \"Reggaeton/Latino\"\n  ))\nspotig\n\n# A tibble: 294 × 4\n   Date       Song                                  Ranking Genre     \n   <date>     <chr>                                   <dbl> <chr>     \n 1 2022-07-06 As It Was                                   2 Pop       \n 2 2022-07-06 Despechá                                   NA Reggaeton…\n 3 2022-07-06 Me Porto Bonito                             4 Reggaeton…\n 4 2022-07-06 Pink Venom                                 NA K-Pop     \n 5 2022-07-06 Quevedo: Bzrp Music Sessions, Vol. 52      NA Pop       \n 6 2022-07-06 Tití Me Preguntó                            5 Reggaeton…\n 7 2022-07-07 As It Was                                   2 Pop       \n 8 2022-07-07 Despechá                                   NA Reggaeton…\n 9 2022-07-07 Me Porto Bonito                             4 Reggaeton…\n10 2022-07-07 Pink Venom                                 NA K-Pop     \n# … with 284 more rows\n\nCreating an alternative plot that wasn’t like the replication was tough as the best way to visualize a timeline is with a line and the time on the x axis. I decided to use an animation as I realized that the second most common type of timelines were animation with bubbles. Bubbles were okay but I thought that the best visualization mark for the names had to be done with ‘geom_text’ with the name of the song. The time would be represented by each frame of the animation and the Genre by color.\nThe toughest thing to find was how to label the date of each frame until I found the argument ‘frame_time’ between brackets.\nFinally, I wanted the theme to be similar as the last one, so I chose many similar options. Here is the result:\n\n\npa <- ggplot(spotig) +\n  aes(Song, Ranking) +\n  geom_text(aes(color = Genre, label = Song)) + # Assign Genre as the color of the text\n  scale_y_continuous(trans = \"reverse\", n.breaks = 9) +\n  expand_limits(x=c(0, 7)) +\n  labs(\n    title=\"Evolución diaria del ránking en Spotify\", \n    subtitle = \"Evolución de las 6 canciones más escuchadas mundialmente en verano de 2022\",\n    tag = \"Date: \n    {frame_time}\", # To tag the Date variable written\n    x = NULL, y = NULL\n  ) +\n  transition_time(Date) + # Date as the variable represented by the animation \n  ease_aes('linear') + # Make the animation smoother\n  theme(\n    plot.title = element_text(face = \"bold\", size = 16.5),\n    plot.subtitle = element_text(size = 10.5, colour = \"#6f6f6f\"),\n    plot.tag.position = c(0.836,0.65),\n    plot.tag = element_text(face = \"bold\", size = 12, hjust = 0),\n    legend.title = element_text(face = \"bold\", size = 12, hjust = 0),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"light grey\"),\n    axis.text.x = element_blank()\n  ) \n\npa\n\n\n\n\n\n\n",
    "preview": "projects/2022/100486421/100486421_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100490068/",
    "title": "Military Spending",
    "description": "In this article I have a walkthrough on how to create a graph as closely as\npossible that was published by the New York Times with ggplot2, but is it\ngraph or a map paste(graph,map); it is both. It shows the country military\nspending in respect to the geolocation of the country.",
    "author": [
      {
        "name": "Yassin Abdelhady",
        "url": {}
      }
    ],
    "date": "2023-01-19",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nNeeded Libraries\nCreating the main data frame\nInitial Trial\n\nProcessing the data\nAttracting all the countries to the center of their continent\nAttracting all the countries to the center of the map\nFinal adjustment to the plot\n\nCreating the legend\nFinal Results\n\nPasting the map with the legend\n\nThe New York Times was posting couple of articles for people/student to be able to analyze the graph with some session being held to discuss them By The Learning Network and this graphs was one of them with a title of What’s Going On in This Graph? it was posted on Feb. 7, 2019 which i found it really interesting to replicate because the graph was a representation of each country but on a map showing their military spending with their bubble size.\nOriginal plot by NYTGetting the data\nNeeded Libraries\n\n\nlibrary(tidyverse)\nlibrary(ggpubr)\nlibrary(plotly)\nlibrary(bubbles) # jcheng5/bubbles\nlibrary(geosphere)\nlibrary(gganimate)\n\n\nThe 3 files will be used are:\nThe main file where it has all the countries with their spending in 2022 and its poplulation\ncountry_file: which has the latitude and the longitude of each country to be able to plot it on the map\ncountry_cont: has each country and which continent it belongs to for grouping\nadding each csv file to a data frame.\n\n\n# country with spending and population 2022\ncountry_main_file<- data.frame(read_csv(file = \"csvData.csv\"))\n#country telemetaries\ncountry_file<- data.frame(read_csv(file = \"Countries.csv\"))\n#country continant\ncountry_cont<- data.frame(read_csv(file = \"country_continent.csv\"))\n\n\nCreating the main data frame\n\n\n#to change spending from numeric to Billions\nto_billion <- 1000000000\n#choosing the desired columns from the lat and lng data file for each country\n#and joining it to the continent\ncountry_file <-  country_file %>%\n  transmute(country = Country, lat = Latitude,lng = Longitude)%>%\n  left_join(.,country_cont,by = \"country\")\n\n#main data frame\ncountry_main <- country_main_file%>% \n  #changing rhe spending to billions for the text view\n  mutate(spending_text = paste(spending/to_billion,\"Billion\"))%>%\n  mutate(text = paste(\"Country: \", country, \"\\nMilitary Sepnding: \", spending_text, sep=\"\"))%>%\n  #removing the population column\n  select(-c(pop2022))%>%\n  #joining the data frame with lat and lng and continent\n  left_join(.,country_file,by=\"country\")%>%\n  #arrangaing the data set into descending order in respect of military spending \n  arrange(desc(spending))%>%\n  #creating a variable \"graph group\" to be able to differentiate between\n  #the first country then the next 7 and the rest\n  #creating a variable \"color graph\" to assign each group a color\n  #creating a variable \"country_id\" to give a numeric ID to each country\n  #in respect of the military spending\n  mutate(\n    graph_group = ifelse(\n      row_number()==1, paste(country,spending_text,sep=\" \"),\n      ifelse(\n        row_number()>=2 & row_number()<=8, \"Next 7 countries\",\"Rest of The World\")),\n    color_graph = ifelse(\n      row_number()==1, \"#225600\",\n      ifelse(\n        row_number()>=2 & row_number()<=8, \"#7c997c\", \"#bebebe\")),\n    country_id=row_number()\n  ) %>% \n  #changing the military spending for the rest of the world to divide it by 4\n  #to decrease their size in the graph \"spending_extra\"\n  mutate(spending_extra = ifelse(country_id>9,spending/4,spending))%>%\n  #dropping NAs\n  drop_na()%>%\n  #\n  mutate(\n    graph_text = ifelse(\n      country_id == 1, paste(country,\"\\n\",\"$\",spending_text,sep=\"\"),\n      ifelse(\n        country_id>1 & country_id<9, paste(country,\"\\n\",spending/to_billion,sep=\"\"), \"\")), \n    #creating a variable to be able to create the legend\n    legend_group=ifelse(row_number()>=2 & row_number()<=8,country,graph_group),\n    #creating a ratio for the bubble size so the highest spending would be 10\n    #\"the max\" and the rest ratio from the country that spends the most\n    bubble_size = (spending - min(country_main_file$spending)) /\n      (max(country_main_file$spending) - min(country_main_file$spending)),\n    #making north america and south america near the rest of the map\n    lng = ifelse(continent==\"North America\" | continent==\"South America\",lng+35,lng )\n  )%>%\n  #Removing Oceania to make it easier\n  filter(continent!=\"Oceania\")\n\n\nInitial Trial\nPlotting all the point on a graph just to see the output and adding this graph to ggplotly to make it interactive\n\n\np <- ggplot(country_main) + \n  aes( x =lng ,y=lat,color=graph_group , size = spending,text=text,label = country)+\n  geom_point(alpha=1.3)+\n  theme_void()+\n  ggtitle(\"Military Spending by Country 22\") +\n  theme(plot.title = element_text(hjust = 0.5),legend.position=\"none\")\n\np\n\n\n\n\n\nggplotly(p, tooltip=\"text\")\n\n\n\nProcessing the data\nAttracting all the countries to the center of their continent\nThe problem is getting all the points together without making them to over lap.. since there is no package that take into consideration that it is lat and lng of country they do a great job at repelling the point from each other but not the same way we need it, so by getting the center of each continent and drawing a line from each country to the center of its continent then dividing this number into 2 to get\nVariables will use later in equations\n\n\ndivide_num <- 2\nmultiplier <- 10\n\n\n\n\n# To get the continent center by adding the max of the cords with the min\n# and then dividing by 2 \ncontinent_center <- country_main%>%\n  group_by(continent)%>%\n  summarise(top_lat=(max(lat)+min(lat))/2,top_lng=(max(lng)+min(lng))/2)\n# to make all the points go to the center of the continent\nto_continent<-country_main%>% \n  #selecting the desired columns\n  select(country,lat,lng,spending,color_graph,graph_text,continent,\n         bubble_size,graph_group)%>%\n  #joing each country the center of its continent\n  left_join(.,continent_center, by =\"continent\")%>%\n  #calculating the slope between each country and the center of its continent\n  mutate(slope = (lat-top_lat)/(lng-top_lng))%>%\n  #getting the intercept of each country and the center of continent line\n  mutate(intercept = (slope*lng)*-1 + lat)%>%\n  #creating a new Y value \"lat\" and dividing by \"divide_num\" to move the old\n  #value on the same line to the center of the continent \n   mutate(new_lat = (slope*( \n    ifelse(top_lng<0 & lng>top_lng,(abs(top_lng-lng)/divide_num)+top_lng,\n           ifelse(top_lng<0 & lng<top_lng,top_lng-(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           ifelse(top_lng>0 & lng>top_lng,top_lng+(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           ifelse(top_lng>0 & lng<top_lng,top_lng-(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           top_lng))))  ) )+intercept)%>%\n  #generating a new X value \"lng\" \n  mutate(new_lng = (new_lat+(intercept*-1))/slope)%>%\n  mutate(new_lat=ifelse(is.na(new_lat),lat,new_lat),\n         new_lng =ifelse(is.na(new_lng),lng,new_lng) )%>%\n  #selecting only the columns that we need and adding the calculations that\n  #we have made to lat and lng\n  transmute(country,lat=new_lat,lng=new_lng,spending,color_graph,graph_text,\n            continent,bubble_size,graph_group)\n\n# to visualize what happened in the previous part \n to_continent_graph <-country_main%>%\n   #selecting the desired columns from the main data frame and adding a new\n   #column to be able to animate \n   transmute(lat,lng,continent,country,frame_num=1)%>%\n   #appending to_continent dataframe to the normal country data and adding a\n   #column frame_num=2 to indicate to the animation its the second part\n   union(.,to_continent%>%transmute(lat,lng,continent,country,frame_num=2))%>%\n   #plotting the data and coloring each contient to be able to see the transformation\n   ggplot(.,aes(x=lng,y=lat,color=continent))+\n   #decreasing the opacity of the point\n    geom_point(alpha=0.4)+\n   #plotting thr center of each continent to be able to see the movement direction\n   geom_point(data= continent_center,mapping = aes(top_lng,top_lat),color=\"black\")+\n   #applying a void theme \n   theme_void()+\n   #adding a title for the graph\n   ggtitle(\"To the center of the continent\")+\n   #making the plot title centered and removing the legend\n   theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\")+\n   #for the animation the column we have created earlier\n   transition_time(frame_num)\n\nto_continent_graph\n\n\n\nAttracting all the countries to the center of the map\n\n\n# To get the map center by adding the max of the cords with the min\n# and then dividing by 2 \ncenter_map <- to_continent%>%\n  select(lat,lng)%>%\n  summarise(lat=(max(lat)+min(lat))/2,lng=(max(lng)+min(lng))/2)\n\n#creating a data frame to move the countires towards the center of the map\nto_center <- to_continent%>%\n  #adding the lat and lng of the center of the map\n  mutate(top_lat =as.numeric(center_map[1]), top_lng =as.numeric(center_map[2]))%>%\n  #calculating the slope between each country and the center of the map\n  mutate(slope = (lat-top_lat)/(lng-top_lng))%>%\n  #getting the intercept of each country and the center of the map line\n  mutate(intercept = (slope*lng)*-1 + lat)%>%\n  #creating a new Y value \"lat\" and dividing by \"divide_num\"*2 to move the\n  #old value on the same line to the center of the map \n  mutate(new_lat = (slope*( \n    ifelse(top_lng<0 & lng>top_lng,(abs(top_lng-lng)/(divide_num*2))+top_lng,\n           ifelse(top_lng<0 & lng<top_lng,top_lng-(abs(top_lng-lng)/(divide_num*2)),\n           ifelse(top_lng>0 & lng>top_lng,top_lng+(abs(top_lng-lng)/(divide_num*2)),\n           ifelse(top_lng>0 & lng<top_lng,top_lng-(abs(top_lng-lng)/(divide_num*2)),\n           top_lng))))  ) )+intercept)%>%\n  #generating a new X value \"lng\" \n  mutate(new_lng = (new_lat+(intercept*-1))/slope)%>%\n  #error handling\n  mutate(new_lat=ifelse(is.na(new_lat),lat,new_lat),\n         new_lng =ifelse(is.na(new_lng),lng,new_lng) )%>%\n  #selecting only the columns that we need and adding the calculations that we\n  #have made to lat and lng\n  transmute(country,lat=new_lat,lng=new_lng,spending,color_graph,graph_text,\n            continent,bubble_size,new_lat,new_lng,graph_group)\n\n\n# to visualize what happened in the previous part \n to_center_graph <-to_continent%>%\n   #selecting the desired columns from  to_continent data frame and adding\n   #a new column to be able to animate \n   transmute(lat,lng,continent,country,frame_num=1)%>%\n   #appending to_center dataframe to to_continent dataframe and adding\n   #a column frame_num=2 to indicate to the animation its the second part\n   union(.,to_center%>%transmute(lat,lng,continent,country,frame_num=2))%>%\n   #plotting the data and coloring each contient to be able to see the transformation\n   ggplot(.,aes(x=lng,y=lat,color=continent))+\n   #decreasing the opacity of the point\n   geom_point(alpha=0.4)+\n   #plotting the center of the map point to see the movement towards it \n   geom_point(data= center_map ,mapping = aes(lng,lat),color=\"black\")+\n   #applying theme void\n   theme_void()+\n   #adding title to the graph\n   ggtitle(\"To the center of the map\")+\n   #aligning the title to the center of the graph and removing the legend\n   theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\")+\n   #for the animation the column we have created earlier\n   transition_time(frame_num)\n \nto_center_graph\n\n\n\nFinal adjustment to the plot\nManually adjusting just to ensure no overlapping bubbles\n\n\nfinal_country_adj <- to_center%>%\n  #move all north america up and left \n  mutate(\n    top_lat =ifelse(continent==\"North America\",\n                    ((to_center[to_center$country==\"Finland\",2]-lat)/1.1)+lat,lat),\n    top_lng =ifelse(continent==\"North America\",lng+10,lng))%>%\n  # Moving Africa up towards spain\n  mutate(\n    top_lat =ifelse(continent==\"Africa\",\n                    (((to_center[to_center$country==\"Spain\",2]-lat)/1.05)+lat)+2.25,\n                    top_lat))%>%\n  #Moving South America up toward Panama and right manual \n  mutate(\n    top_lat =ifelse(continent==\"South America\",\n                    ((to_center[to_center$country==\"Panama\",2]-lat)/1.1)+lat+8.85,top_lat),\n    top_lng =ifelse(continent==\"South America\",lng+4.7,top_lng))%>%\n  #decreasing the distance between the highest lat and Europe\n  mutate(\n    top_lat =ifelse(continent==\"Europe\",\n                    ((to_center[to_center$country==\"Finland\",2]-lat)/1.5)+lat,top_lat))%>%\n  mutate(\n    #Moving Asia towards Finland and left manual\n    top_lat =ifelse(continent==\"Asia\",\n                    (((to_center[to_center$country==\"Finland\",2]-lat)/1.1)+lat)+0.2,top_lat),\n    top_lng =ifelse(continent==\"Asia\",\n                    ((max(to_center[to_center$continent==\"Europe\",3])-\n                        min(to_center[to_center$continent==\"Asia\",3]))+lng)-2,top_lng))%>%\n  transmute(country,lat=top_lat,lng=top_lng,spending,color_graph,graph_text,continent,\n            bubble_size= ifelse(country!=\"United States\",\n                                bubble_size*3,bubble_size*1.2),graph_group)\n\n\n\n\nfinal_plot<- ggplot(final_country_adj,aes(x=lng,y=lat,text=country))+\n  ggforce::geom_mark_ellipse(\n    aes(filter = country == \"United States\", \n        description = \"Proposed Increase\\n +$54 billion\"),\n    con.linetype = 4,con.size=0.3,label.fontsize = 6,\n    label.fill = \"transparent\",con.cap = 0)+\n  ggforce::geom_mark_ellipse(\n    aes(filter = graph_group == \"Next 7 countries\" , description = graph_text),\n    con.linetype = 4,con.size=0.3,label.fontsize = 6,label.fill = \"transparent\",\n    con.cap = 0,expand = unit(1, \"mm\"))+\n  geom_point(data = final_country_adj%>%\n               filter(country==\"United States\") ,\n             aes(x = lng,y=lat, size = bubble_size*multiplier*2 ,\n                 stroke = bubble_size*multiplier*1.7),color=\"black\")+\n  geom_point(data=final_country_adj ,\n             aes(size = bubble_size*multiplier*2 ,\n                 stroke = bubble_size*multiplier*1.6,color=color_graph))+\n  scale_color_identity()+\n  annotate(\"text\", x=final_country_adj[final_country_adj$country==\"United States\",'lng'],\n           y=final_country_adj[final_country_adj$country==\"United States\",'lat'],\n           label=final_country_adj[final_country_adj$country==\"United States\",'graph_text'],\n           hjust=0.5, color=\"white\",size=3)+\n  ggtitle(\"Military Spending by Country 22\") +\n  theme_void()+\n  theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank(),\n        panel.border = element_blank())\nfinal_plot\n\n\n\nCreating the legend\n\n\n#creating a Dataframe from the main Dataframe to make the legend\nlegend_df <- country_main%>%\n  mutate(graph_group = ifelse(country_id==1,country,graph_group))%>%\n  group_by(legend_group,graph_group)%>%\n  summarise(spending=sum(spending),nr = max(country_id))%>%\n  arrange(nr)%>%mutate(text_color = ifelse(nr<9,\"#FFFFFF\", \"#000000\"))\n\n#Legend column color\nlegend_colors <-country_main%>%\n  arrange(desc(spending))%>%\n  group_by(legend_group)%>%\n  summarise(bar_color = max(color_graph))%>%select(bar_color)\n# in column text\nlegend_ann <-legend_df%>%\n  group_by(graph_group)%>%\n  summarise(spending = sum(spending),rn = max(nr))%>%\n  arrange(rn)%>%\n  mutate(spending_ann =ifelse(\n    rn==1,paste(\"$\",spending/to_billion,\" billion\",sep=\"\"),\n    round(spending/to_billion)) )\n\n\n#Legend plot\nlegend_plot <- ggplot(\n  legend_df%>%\n    left_join(.,y=legend_ann%>%\n                select(graph_group,spending_ann),by=\"graph_group\"))+\n  aes(x = spending,y=reorder(graph_group,-nr), fill = legend_group )+ \n  geom_bar(stat = \"identity\",color =\"#FFFFFF\",\n           position = position_stack(reverse = TRUE),width = 0.9)+\n  scale_fill_manual(values =  legend_colors[['bar_color']]  )+\n  theme(legend.position = \"none\")+\n  geom_text(aes(x=15000000000,label=spending_ann,hjust=0),\n            color = legend_df[['text_color']] )+\n  theme_void()+\n    theme(legend.position = \"none\",\n          axis.text.x=element_blank(),\n          axis.text.y=element_text(hjust=0,size=12)\n  )\n\nlegend_plot\n\n\n\nFinal Results\nIn summary, so far we have\nBuild steps:\nInitial plot to visualize the map;\nMoving all the countries to the center of the continent;\nMoving all the continents to the center of the map;\nPlotting the final map;\nCreating the legend.\nPasting the map with the legend\n\n\nggarrange(\n  final_plot,\n  ggarrange(\n    ggplot()+theme_void(),\n    legend_plot\n    ,ggplot()+theme_void()\n    ,hjust=10,ncol = 3, nrow = 1,widths = c(0.3,1,0.3) \n    ),\n  hjust=10,\n  ncol = 1, \n  nrow = 2, \n  widths = c(1,0.5),\n  heights = c(5,1)\n)\n\n\n\n\n\n\n",
    "preview": "projects/2022/100490068/original_graph.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 3372,
    "preview_height": 1740
  },
  {
    "path": "projects/2022/100385545/",
    "title": "Searches of common jobs: women tends to appear lower than men",
    "description": "A replication of the graph made by Pew Research Center about the topic and another proposal.",
    "author": [
      {
        "name": "Mario Yanes",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGender equality on online search of jobs?\nLet’s start with the replication\nAdding tiles\nPlot again\nRearrange y-axis\nAesthetic and themes\nProblems\nSolving the x-axis\n\n\nAlternative visualization or improvements\nFinal alternative visualization\n\n\nGender equality on online search of jobs?\nA research conducted by the Pew Research Center on December 2018 showed that inequalities also exist on online search. They represented the obtained data in several graphs, such as the underrepresentation or overrepresentation of women depending on the profession, with a several gap between the results of the search and the actual proportion of women in each occupation.\nBut the graph we are going to replicate on this project is the one that shows the average position obtained by the first male or female depending on the profession. Such graph is the following:\n\n\n\nFigure 1: Original graph from Pew Research Center\n\n\n\nLet’s start with the replication\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\nsysfonts::font_add_google(\"Poppins\", family=\"poppins\")\nsysfonts::font_add_google(\"Tinos\", family=\"tinos\")\nsysfonts::font_add_google(\"Arimo\", family=\"arimo\")\nshowtext::showtext_auto()\n\n\nAfter importing (and installing, if necessary) the libraries needed for this project, the next step is to import the data of the plot. Besides the Pew Research Center didn’t publish the dataset they used to the article alongside it, it’s pretty simple to generate ourselves a dataframe, as they are integers numbers (the position on a search results page) and 20 professions.\n\n\ndf <- data.frame(\n  Profession = c(\"CEO\", \"Professor\", \"Electrical engineer\", \"Security guard\",\n                 \"Banker\", \"Clergy\", \"Industrial engineer\", \"Bartender\", \"Musician\",\n                 \"Chef\", \"Movie director\", \"Police\", \"Athlete\", \"Medical scientist\",\n                 \"Physician\", \"Pharmacist\", \"Nurse\", \"Clerk\", \"Customer service rep.\",\n                 \"Housekeeper\"),\n  Male = c(2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 4, 4, 4, 6),\n  Female = c(16, 13, 10, 8, 9, 8, 7, 7, 6, 6, 6, 5, 5, 4, 3, 3, 4, 3, 2, 2)\n)\n\n\nAs for now, we have the data we want to plot. Let’s focus on generating the plot. Following the original graph, the position of the first male/female that appears on a web search of a certain job is plotted as a tile. The tile is #eb9f2e if it’s a male, #83669f if it’s a female.\n\n\np <- ggplot(df, aes(y=Profession)) + \n  geom_tile(aes(x=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.35, height = 0.7) + \n  geom_tile(aes(x=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.35, height =0.7)\n\np\n\n\n\nAt this time, we have one major issue: we only plotted the female/male tiles, but the original graph has another 14 white tiles (or 15, on Pharmacist and Nurse, where both gender have the same value), as they represent all the possible values.\nAdding tiles\nThe way of adding the blank tiles that represent all the possible values was tricky. First of all, my intention was trying to generate them automatically with a given R function, but I was not capable of. Instead, I added to the dataset 16 new variables, one per column, that would fit on the x-axis and be the “empty” tiles. In order from 1 to 16, I added the positions that were left. So the entire and final dataframe resulted on the following:\n\n\ndf <- df %>%\n  mutate(\n    position = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),\n    position2 = c(3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 4, 2, 2, 2, 3, 3),\n    position3 = c(4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 3, 5, 5, 4),\n    position4 = c(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 5, 5, 6, 6, 5),\n    position5 = c(6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7),\n    position6 = c(7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8),\n    position7 = c(8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9),\n    position8 = c(9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 10, 10, 10),\n    position9 = c(10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 11, 11, 11),\n    position10 = c(11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 12, 12, 12),\n    position11 = c(12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 13, 13, 13),\n    position12 = c(13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 14, 14, 14),\n    position13 = c(14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 15, 15, 15),\n    position14 = c(15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 16),\n    position15 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 16, 16, NA, NA, NA)\n)\n\n\nPlot again\nDone that, the plot should have now all the needed tiles, both of the gender variable and all the possible positions. So we add to the first code we plotted the geom_tile() for each new variable we added to the dataset, as the following:\n\n\np <- ggplot(df, aes(y=Profession)) + \n  geom_tile(aes(x=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.35, height = 0.7) + \n  geom_tile(aes(x=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.35, height =0.7) +\n  geom_tile(aes(x=position), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position2), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position3), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position4), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position5), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position6), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position7), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position8), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position9), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position10), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position11), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position12), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position13), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position14), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position15), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) \n\np\n\n\n\nRearrange y-axis\nThis graph has the essential parts of the original one. Nonetheless, the order of the y-axis is not the same, besides we created the dataframe following, from top to bottom, the graph of the Pew Research Center. To fix that, we can use the function scale_y_discrete(limits = rev(df$Profession). We also use the scale_y_discrete() function to add some space at the top of the grid, as we will needed it for the title and the subtitle:\n\n\np <- p + scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_y_discrete(limits = rev(df$Profession), expand = expansion(mult = c(0, 0.1))) \n\np\n\n\n\nAesthetic and themes\nNow we have a graph that follows the original one in its factor form, but we have to modify the appearance to achieve a replica.\nFirst of all, they removed the axis title of both y and x-axis. Also, the title and the subtitle and the attribution of the plot, and one important thing: the legend. The legend is added to the graph in a particularly way: Male and Female are not together in a traditional box or something like that, as they are on top of the corresponding first tile. So, instead of using labs or another related function, we insert “Male” and “Female” as an annotation. With the extra space we gave to the top of the grid, the words are not cut by the space of the subtitle.\n\n\np <- p + labs(\n    x = \"\",\n    y = \"\",\n    title = \"Women appear lower in image\\nsearch results for common jobs\\nacross countries\",\n    subtitle = \"\\nAverage position of the first man or woman\\nin image search results for ...\\n \"\n  ) +\n  annotate(\"text\", x = 2, y = 21, label = \"Male\", size = 3, color = \"#eb9f2e\",\n           fontface = 2, family = \"arimo\") +\n  annotate(\"text\", x = 16, y = 21, label = \"Female\", size = 3, color = \"#83669f\",\n           fontface = 2, family = \"arimo\") \n\np\n\n\n\nThe trickiest thing we tended to solve is the tiles of Pharmacist and Nurse, the only ones where Male and Female have the same value. The closest approach was generating an annotation with a rectangle (instead of a triangle, as it was impossible to achieve):\n\n\np <- p +\n  annotate(\"rect\", xmin = 3.05, xmax = 3.2, ymin = 4.725, ymax = 5.3, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"rect\", xmin = 4.05, xmax = 4.2, ymin = 3.725, ymax = 4.3, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") \n\np\n\n\n\nFinally, we adjust the things related to the themes. The grid has to be completely white and without borders, the axis ticks and line disappear and we try to have the same font family as the original one, as well of adjusting on the horizontal axis the title and the subtitle. This results in the final graph.\n\n\np <- p + theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  panel.border = element_blank(),\n  axis.text = element_text(family = \"tinos\"),\n  axis.text.x = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"arimo\", hjust = 0),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"tinos\",\n                               hjust = 0, vjust = 4),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np\n\n\n\nProblems\nIf we compare the original graph and the replica one, we see three main differences. The first difference is the width of the plot and the distance between the columns of tiles. Through different manners we tried to narrow the grid, but these actions tended to deform the tiles and the graph.\nThe second difference is located at the tiles of Pharmacist and Nurse, where the original one plotted the tiles half #eb9f2e and half #83669f with each color in a triangle. The closest approach was generating an annotation with geom_rect(), as geom_polygon() couldn’t be printed in a annotation, besides several tries.\nThe third difference is the x-axis. While seemed to be an easy way to modify the breaks of the axis in order to show 1, 4, 8, 12 and 16, at the moment we introduced to the code the scale_x_discrete(breaks = c(1, 4, 8, 12, 16)) or scale_x_discrete(limits = c(1,16), breaks = c(1, 4, 8, 12, 16)), the x-axis disappears and also some data is not plotted correctly.\nSolving the x-axis\nThe solution I found to solve the problem with the breaks of the x-axis was to expand the bottom of the graph and introducing the labels as regular text with anotate.\n\n\np <- p + expand_limits(y = -1.5) +\n  annotate(\"text\", x = 1, y = -.9, label = \"1st\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 4, y = -.9, label = \"4th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 8, y = -.9, label = \"8th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 12, y = -.9, label = \"12th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 16, y = -.9, label = \"16th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 1, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 4, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 8, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 12, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 16, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\")\np\n\n\n\nAlternative visualization or improvements\nWhen thinking about another ways of plotting the same data while maintaining the essence and the meaning of the graph, the first thing that came to my mind was to plot the searches individually and in a vertically way. The goal is to keep a familiar look and feel to an actual web search engine. The spirit is the same, but instead of tiles, rectangles figures that tend to be similar to the boxes that Google, DuckDuckGo and other search engines use to organize the results.\nThe first step was to recreate the dataset inverting the position of the tiles, as 1 being 16, 2 being 15 and so on, as we want to plot the first positions on top, instead from bottom to top. We also introduced two empty professions, “Blank”, that will help us later in order to clean the view and insert the legend.\n\n\na_df <- data.frame(\n  Profession = c(\"CEO\", \"Professor\", \"Electrical engineer\", \"Security guard\",\n                 \"Banker\", \"Blank\", \"Clergy\", \"Industrial engineer\", \"Bartender\",\n                 \"Musician\", \"Chef\", \"Movie director\", \"Police\", \"Athlete\",\n                 \"Medical scientist\", \"Physician\", \"Blank\", \"Pharmacist\", \"Nurse\",\n                 \"Clerk\", \"Customer service rep.\", \"Housekeeper\"),\n  Male = c(15, 15, 14, 15, 14, NA, 15, 15, 15, 15, 15, 15, 15, 14, 14, 15, NA, 14, 13, 13, 13, 11),\n  Female = c(1, 4, 8, 9, 7, NA,  9, 10, 10, 11, 11, 11, 12, 12, 13, 14, NA, 14, 13, 14, 15, 15),\n  position = c(16, 16, 16, 16, 16, NA, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, NA, 16, 16, 16, 16, 16),\n  position2 = c(14, 14, 15, 14, 15, NA, 14, 14, 14, 14, 14, 14, 14, 15, 15, 13, NA, 15, 15, 15, 14, 14),\n  position3 = c(13, 13, 13, 13, 13, NA, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, NA, 13, 14, 12, 12, 13),\n  position4 = c(12, 12, 12, 12, 12, NA, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, NA, 12, 12, 11, 11, 12),\n  position5 = c(12, 12, 12, 12, 12, NA, 12, 12, 12, 10, 10, 11, 11, 11, 11, 11, NA, 12, 12, 11, 11, 11),\n  position6 = c(11, 11, 11, 11, 11, NA, 11, 9, 9, 9, 9, 9, 9, 9, 9, 9, NA, 11, 11, 9, 9, 9),\n  position7 = c(9, 9, 9, 8, 9, NA, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, NA, 9, 9, 8, 8, 8),\n  position8 = c(8, 8, 7, 7, 8, NA, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, NA, 8, 8, 7, 7, 7),\n  position9 = c(7, 7, 6, 6, 6, NA, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, NA, 7, 7, 6, 6, 6),\n  position10 = c(6, 6, 5, 5, 5, NA, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, NA, 6, 6, 5, 5, 5),\n  position11 = c(5, 5, 4, 4, 4, NA, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, NA, 5, 5, 4, 4, 4),\n  position12 = c(4, 3, 3, 3, 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, NA, 4, 4, 3, 3, 3),\n  position13 = c(3, 2, 2, 2, 2, NA, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, NA, 3, 3, 2, 2, 2),\n  position14 = c(2, 1, 1, 1, 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, 2, 2, 1, 1, 1),\n  position15 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 1, 1, NA, NA, NA)\n) \n\n\nThe next step is to create dataframes for every graph we want to plot (and join at the last steps). As there are 22 positions (twenty professions and two empty columns), we divide them in 2 different dataframes. We use the entire dataframe we’ve just created and divide it maintaining the positions and adding another column to fix the empty tiles.\n\n\nf_df <- a_df %>% slice(1:(n()-11)) %>% \n  mutate(position15 = c(10, 10, 10, 10, 10, NA, 10, 11, 11, 10, 10))\n\nfo_df <- a_df %>% slice(12:n()) %>% \n  mutate(position15 = c(10, 10, 10, 10, 10, NA, 10, 10, 10, 10, 10)) %>% \n  mutate(position5 = c(NA, NA, NA, NA, NA, NA, 12, 12, 11, 11, NA)) %>% \n  mutate(position16 = c(1, 1, NA, NA, NA, NA, 1, 1, NA, NA, NA))\n\n\nWith the two dataframes, we set the variable Profession as a factor and we indicate the order in we want it to be plotted with the levels option.\n\n\nf_df$Profession <- factor(f_df$Profession, levels = c(\n  \"Professor\", \"CEO\", \"Electrical engineer\", \"Banker\", \"Security guard\", \"Blank\", \n  \"Clergy\", \"Industrial engineer\", \"Bartender\", \"Musician\", \"Chef\" ))\n\np1 <- ggplot(f_df, aes(x = Profession)) + \n  geom_tile(aes(y=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.7, height = 0.8, size = 1) + \n  geom_tile(aes(y=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.7, height = 0.8, size = 1) +\n  geom_tile(aes(y=position), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position2), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position3), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position4), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position5), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position6), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position7), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position8), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position9), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position10), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position11), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position12), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position13), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position14), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position15), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_x_discrete(position = \"top\", guide = guide_axis(n.dodge=2)) +\n  annotate(\"text\", x = 6, y = 15, label = \"Male\", size = 3.5, color = \"#eb9f2e\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 6, y = 9.05, label = \"Female\", size = 3.5, color = \"#83669f\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 16, label = \"1st\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 13, label = \"4th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 9, label = \"8th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 5, label = \"12th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 1, label = \"16th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 16, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 13, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 9, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 5, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 1, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 1, y = 17.2, label = \"Professor\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 2, y = 18.2, label = \"CEO\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 3, y = 17.2, label = \"Electrical eng.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 4, y = 18.2, label = \"Banker\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 5, y = 17.2, label = \"Security guard\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 7, y = 17.2, label = \"Clergy\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 8, y = 18.2, label = \"Industrial eng.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 9, y = 17.2, label = \"Bartender\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 10, y = 18.2, label = \"Musician\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 11, y = 17.2, label = \"Chef\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  expand_limits(x = c(-.5, 12.5), y = c(0, 18)) +\nlabs(\n    title = \"Women appear lower in image search results\\nfor common jobs across countries\\n\",\n    subtitle = \"Average position of the first man or woman in image search results for ... \"\n  ) +\n  theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  axis.text = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"poppins\", hjust = 0.5),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"poppins\",\n                               hjust = .5, vjust = 4),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np1\n\n\n\nIn this case, we also rename the profession “Customer service rep.” to “Cust. serv. rep.” in order to make the name shorter and avoid overlapping.\n\n\nfo_df[fo_df$Profession == \"Customer service rep.\", \"Profession\"] <- \"Cust. serv. rep.\"\n\nfo_df$Profession <- factor(fo_df$Profession, levels = c(\n  \"Movie director\", \"Police\", \"Athlete\", \"Medical scientist\", \"Physician\",\n  \"Blank\", \"Pharmacist\", \"Nurse\", \"Clerk\", \"Cust. serv. rep.\", \"Housekeeper\"))\n\n\np2 <- ggplot(fo_df, aes(x = Profession)) + \n  geom_tile(aes(y=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.7, height = 0.8, size = 1) + \n  geom_tile(aes(y=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.7, height = 0.8, size = 1) +\n  geom_tile(aes(y=position), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position2), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position3), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position4), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position5), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position6), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position7), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position8), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position9), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position10), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position11), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position12), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position13), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position14), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position15), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position16), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_x_discrete(position = \"top\", guide = guide_axis(n.dodge=2)) +\n  annotate(\"rect\", xmin = 7, xmax = 7.35, ymin = 13.6, ymax = 14.4, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"rect\", xmin = 8, xmax = 8.35, ymin = 12.6, ymax = 13.4, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"text\", x = 6, y = 15, label = \"Male\", size = 3.5, color = \"#eb9f2e\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 6, y = 14.05, label = \"Female\", size = 3.5, color = \"#83669f\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 16, label = \"1st\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 13, label = \"4th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 9, label = \"8th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 5, label = \"12th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 1, label = \"16th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 16, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 13, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 9, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 5, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 1, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 1, y = 17.2, label = \"Movie director\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 2, y = 18.2, label = \"Police\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 3, y = 17.2, label = \"Athlete\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 4, y = 18.2, label = \"Medical scientist\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 5, y = 17.2, label = \"Physician\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 7, y = 17.2, label = \"Pharmacist\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 8, y = 18.2, label = \"Nurse\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 9, y = 17.2, label = \"Clerk\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 10, y = 18.2, label = \"Cust. serv. rep.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 11, y = 17.2, label = \"Housekeeper\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  expand_limits(x = c(-.5, 12.5), y = c(-.5, 18)) +\n  theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  axis.text = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"poppins\", hjust = 0.5),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"poppins\",\n                               hjust = .5, vjust = 2),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np2\n\n\n\nFinal alternative visualization\nAnd finally, here we have our alternative visualization, composed by the two previous plots:\n\n\np1 / p2\n\n\n\n\n\n\n",
    "preview": "projects/2022/100385545/100385545_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100385586/",
    "title": "Restrictions on religion among the most populated countries across time",
    "description": "A replication of a graph from Pew Research Center on the \nrestrictions on religion among the 25 most populous countries.",
    "author": [
      {
        "name": "Alejandro Aísa",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original graph\nSet up and libraries\nPrerequisites for the graph\nAdapting the database\nElements and labels\n\nGraph construction\nTechnical features of the graph\n\nThe Graph(s)\nVisual features and information transmitted\nUnachieved features\nInteractive options with plotly\nProposed enhacements\nSecond alternative\n\n\nThe original graph\nThe graph to replicate was originally created by the Pew Research Center.\nIt is an interactive graph depicting the evolution in time of two measures related to religious conflicts: Goverment Restrictions Index (GRI) and Social Hostilities Index (SHI). The 25 most populous countries are included in the graph. Our goal: to replicate it as closely as possible.\nSet up and libraries\nAs with any other project, we have to load some the libraries that will be needed to complete the graph.\n\n\nlibrary(tidyverse)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(ggtext)\nlibrary(RColorBrewer)\nlibrary(showtext)\n\n\nPrerequisites for the graph\nAdapting the database\nFirst, we have to load the data. In this case, it has been directly compiled from the Pew Research Center.\nSome columns are going to be renamed and/or modified to make easier the coding. Also, a new variable is created to give later the colour to the bubbles (geom_point()) via the case_when() function.\n\n\nreligion.df <- read_delim(\"rel.csv\", show_col_types = FALSE)\n\nreligion <- religion.df %>% transmute(\n  year = as.integer(`Year `), \n  GRI = GRI, \n  SHI = SHI,\n  Country = Country, \n  Pop = `Population Size `) %>% \n  mutate(\n# The position is numerically defined according to the score in the variables\n  pos = case_when( \n    (GRI < 2.3 & SHI < 1.4) ~ 1, \n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 1.4) ~ 2, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 1.4) ~ 3, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 1.4) ~ 4,\n    ((GRI >= 0 & GRI < 2.3)   & SHI < 3.6) ~ 2,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 3.6) ~ 3, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 3.6) ~ 4, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 3.6) ~ 5, \n    ((GRI >= 0 & GRI < 2.3)   & SHI < 7.2) ~ 3,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 7.2) ~ 4, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 7.2) ~ 5, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 7.2) ~ 6,\n    ((GRI >= 0 & GRI < 2.3)   & SHI <= 10) ~ 4,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI <= 10) ~ 5, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI <= 10) ~ 6, \n    ((GRI >= 6.6 & GRI < 10)  & SHI <= 10) ~ 7)) %>% \n  mutate(\n    pos = as.factor(pos), \n    Country = as.factor(Country))\n\n\nElements and labels\nAt this preliminary stage, some elements of the graph, such as the breaks, titles and subtitles are defined for the same purpose of making the code easier and more understandable.\nText elements\n\n\ntitle <- paste (\"Restrictions on religion among the 25 most populous countries,\",  \n                \"2007-2020\", sep = \"\\n\")\n\nsubtitle  <- paste ( \n\"Among the 25 most populous countries, India, Egypt, Pakistan, Indonesia and Nigeria had the highest levels of overall restrictions on\", \n\"religion in 2020, while Japan, the United States, Italy, the Democratic Republic of the Congo and Tanzania had the fewest restrictions.\", \n\"Click play to see how restrictions have changed in each country since 2007. Read the full report.\", \n\"Year: {closest_state}\", \nsep = \"\\n\") # The phrases have to be written independently and separated with the \\n function. \n\n\nX <- \"Government Restrictions Index (GRI)\"\nY <- \"Social Hostilities Index (SHI)\"\n\ncaption <- paste(\n\"Note, Population data comes from United Nations 2020 population estimates.\", \n\"Source of the original graph: Pew Research Center, 2022\", \nsep = \"\\n\")\n\n\nBreaks and aesthetics\n\n\nbreaks_x <- c(0.1, 1.1, 3.35, 5.55, 8.3, 10)\nbreaks_y <- c(0.1, 1.35, 4.1, 6, 9.9, 10)\n\nlabels_x <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\nlabels_y <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\n\n\npal <-c(\"#f7f3d7\",\"#f6e9c8\",\"#f4dbbd\",\"#f5c6ac\",\"#f2b0a2\",\"#e89389\",\"#d48379\")\n\nsysfonts::font_add_google(\"Playfair Display\", family = \"playfair display\")\nshowtext::showtext_auto()  \n\n\nGraph construction\nTechnical features of the graph\nFirst, we include the main aesthetics of the graph; the two variables of the X (GRI) and Y (SHI) axis. The main visual representation is the geom_point(), labelled by country. Sizes depending on population and colour depending on position are also included.\nAt this stage, all the points, regardless of the year are included in the graph.\n\n\np <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 20)+\n  geom_text(aes(label=Country), size = 1.6)\np\n\n\n\nLet’s include the scales!\nWith respect to the colour, we have already defined the palette of colour at the beginning of the construction. Then, we only have to mention it in the scale_colour_manual().\nThe graph is also limited between 0 and 10 in both axis, under a continuous scale (scale_x_continuous). We take advantage of using this function by already including the breaks and labels that would define the levels of religious conflicts.\n\n\np <- p + scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y, \n    labels = labels_y)\n\np  \n\n\n\nIn the next step we add the text elements that will be included in the graph, from the title to the caption. As they were defined before, we only have to specify them in the labs() function.\n\n\np <- p + labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) \np\n\n\n\nNow that we have all the elements that should be included, we have to customize them and bring some order. With a theme_classic() we can have the axis removed. Only some custom horizontal and vertical lines will be needed. The particular features of each element_text() are specified also at this stage.\n\n\np <- p + theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 21),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 11),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())\n\np \n\n\n\nThe final step in constructing the static graph involves the removal of the the guides providing the legend for different aesthetics. Finally, we include the custom lines (geom_vline() and geom_hline()).\nNow we have the fixed graph built, but we have to include a last aesthetic. The one that will be needed to create the animation: the frame. (one per year).\n\n\np <- p + guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\") + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year) \n\np \n\n\n\nThe Graph(s)\nVisual features and information transmitted\nThe graph consist in a basic scatter plot accounting for the relationship between two variables: GRI and SHI. However, more information is included on it.\nOn the one hand, the size of the geom_points is going to be determined by the population of each country. On the other hand, the colour of the bubble is given by the position in the graph. Each quadrant has its own colour. These combination of factors makes possible that, visually, the amount of religious constraints for each country is rapidly comprehend. The darker the point, the more conflicts related to religion. Technically speaking, it was achieved with the case_when() function at the beginning.\nLastly, we have to include the most important characteristics of the graph. While the interactive part had to be forfeited due to logistical and time constraints, it possesses the animation depicting the evolution in time.\nThis evolutionary feature is provided by GGanimated. Notice how each country change the colour depending on the position within the graph.\n\n\np <- p + transition_states(year) \n\np\n\n\n\nUnachieved features\nApart from the interactivity, there are some issues that could not not be fully replicated:\nThe fonts for the titles are not exactly the same as the original.\nThe spacing between lines is smaller than the original.\nThe orientation of the 0 and the 10 of the Y axis is not the correct. The “very high” label is also wrongly positioned.\nIt was not possible to include the link in the last part of the subtitle.\nInteractive options with plotly\nThe library that may be used to provide interactivity to the graph is Plotly via ggplotly(p). However, some technical issues arise when we include this option:\nFirst, dimensions of the chart can not be properly modelled. Fig.height() and fig.weight do not work the same way. As a consequence, the title and subtitle disappear from the graph, some labels move along the axis, etc.\nMore importantly, when the time animation is included, some geom_points get lost, moving along the chart without sense. Thus, as plotly was not the scope of the work, and due the time that would have to be invested to solve these problems, it was decided to forfeit this version of the graph.\n\n\nfig <- ggplotly(p) %>% \nconfig(displayModeBar = FALSE) %>% \nanimation_slider(currentvalue = {\"year\"}) \nfig\n\n\n\nProposed enhacements\nThe first alternative of the graph involve re-scaling the graph. As the two main variables are measured in the same scale, it would be suitable to have both axis on the same scale.\nTo do that, we only have to do small changes, such as changing the position of the breaks in the Y axis and the sizes of the fonts.\n\n\nbreaks_y1 <- c(0.1, 1.3, 3.7, 6, 9.9, 10)\n\nThe_graph2 <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 16)+\n  geom_text(aes(label=Country), size = 1.6)+\n  scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y1, \n    labels = labels_y)+\n  labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) +\n  theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 12),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 6),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())+\n  guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\", \n   ) + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year)\n\n\nFinally, in the chunk options we specify that the height of the graph is the same as the width, to maintain equal proportions.\n\n\nThe_graph2 <- The_graph2 + \n  transition_states(year) \nThe_graph2\n\n\n\nSecond alternative\nAn additional option involves discarding the animated part, and faceting the display in four different graphs. For each facet we would be showing a particular year (2007-2012-2012-2016).\nThe main objective of this alternative is about focusing on the evolution in time of the linear relationship between these variables. Then, we add the regression line via geom_smooth() along with other minor changes in breaks and labels.\n\n\nyears <- c(2007, 2012, 2016, 2020)\n\nreligion_2 <- religion %>% filter(year %in% years)\n\nbreaks_y2 <- c(0.1, 1.35, 5, 6, 9.9, 10)\n\nThe_graph3 <- ggplot(religion_2) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 8)+\n  geom_text(aes(label=Country), size = 1)+\n  scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y2, \n    labels = labels_y)+\n  labs(\n    title = title,  \n    subtitle = \"Years: 07', 12', 16' and 20'\",\n    caption = caption, \n    x = X, \n    y = Y) +\n  theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 15),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 12),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 7), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())+\n  guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\", \n   ) + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+ \n  facet_wrap(~year)+\n  geom_smooth(method = lm, se = FALSE, col = \"burlywood\", \n              alpha  = .3, linetype = \"dotted\")\n\n\n\n\nThe_graph3\n\n\n\n\n\n\n",
    "preview": "projects/2022/100385586/100385586_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100386498/",
    "title": "The World Bank's Richer Countries Tend to Have Higher National Poverty Lines Chart",
    "description": "The aim of this project is to recreate and improve a chart from the first Atlas of Sustainable Development Goals.",
    "author": [
      {
        "name": "Isabela Zeberio",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nSustainable Development Goals\nGetting the data\nLibraries\nCountry groups\n\nBuilding the chart\nData\nScale transformation\nAxes and panel grid\nColor of dots\nCountry labels\nText\nLegend\nBackground\n\nFinal chart\nInteractive chart\n\n\nDiagram listing the 17 Sustainable Development Goals. Figure from un.orgThe Atlas of Sustainable Development Goals is a compilation of statistics from over 200 economies about global development and the quality of people’s lives. The Atlas is a visual guide to the trends, challenges and measurement issues related to each of the 17 Sustainable Development Goals (SDGs). The SDGs are an urgent call for action by all countries in a global partnership. The Atlas was first created in 2017 and since then two more editions have been published, 2018 and 2020. From 2017 to 2020 there has been a big change in the visualization of the data.. Therefore, for this project I have decided to focus on recreating a chart from the first Atlas and improve some elements to better represent the idea that richer countries tend to have higher national poverty lines.\nSustainable Development Goals\n\n1. No poverty\n2. Zero hunger\nEnd poverty in all its forms everywhere\nEnd hunger, achieve food security and improved nutrition, and promote sustainable agriculture\n3. Good health and well-being\n4. Quality education\nEnsure healthy lives and promote well-being for all at all ages\nEnsure inclusive and equitable quality education and promote lifelong learning opportunities for all\n5. Gender equality\n6. Clean water and sanitation\nAchieve gender equality and empower all women and girls\nEnsure availability and sustainable management of water and sanitation for all\n7. Affordable and clean energy\n8. Decent work and economic growth\nEnsure access to affordable, reliable, sustainable, and modern energy for all\nPromote sustained, inclusive, and sustainable economic growth, full and productive employment, and decent work for all\n9. Industry, innovation, and infrastructure\n10. Reduced inequalities\nBuild resilient infrastructure, promote inclusive and sustainable industrialization, and foster innovation\nReduce inequality within and among countries\n11. Sustainable cities and communities\n12. Responsible consumption and production\nMake cities and human settlements inclusive, safe, resilient, and sustainable\nEnsure sustainable consumption and production patterns\n13. Climate action\n14. Life below water\nTake urgent action to combat climate change and its impacts by regulating emissions and promoting developments in renewable energy\nConserve and sustainably use the oceans, seas and marine resources for sustainable development\n15. Life on land\n16. Peace, justice and strong institutions\nProtect, restore and promote sustainable use of terrestrial ecosystems, sustainably manage forests, combat desertification, and halt and reverse land degradation and halt biodiversity loss\nPromote peaceful and inclusive societies for sustainable development, provide access to justice for all and build effective, accountable and inclusive institutions at all levels\n17. Partnership for the goals\n\nStrengthen the means of implementation and revitalize the global partnership for sustainable development\n\n\nThe chart I have chosen is from the first SDGs: No poverty. In the section on Reducing poverty in all its dimensions according to national definitions, the figure 1c is introduced to represent how richer countries tend to have higher national poverty lines than poorer ones, and in some cases a richer country may even have a higher national poverty rate than a poorer country.\nThe World Bank’s Chart. Figure from worldbank.orgGetting the data\nThe data consist on country observations of national poverty lines and household final consumption expenditure (HFCE). I retrieved the data from the Jolliffe & Beer Prydz (2016) paper on Estimating International Poverty Lines from Comparable National Thresholds. In the Appendix 2: Poverty lines and economic variables, used in main specifications, there is a table with the data required to replicate the chart.\nLibraries\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(janitor)\nlibrary(showtext)\nlibrary(ggtext) \n\n\nI created the csv file coping the data from the Appendix 2 table. The variables needed to recreate the chart are the following:\n\n\nworld_bank <- read_delim(\n  \"povertyline.csv\", delim = \";\", escape_double = FALSE,\n  col_types = cols(`National poverty line 2011 PPPs` = col_number(),\n                   `Household survey mean 2011 PPPs` = col_number(),\n                   `HFCE (2011 PPPs)` = col_number(),\n                   `GNI (2011 USD, Atlas)` = col_number()),\n  trim_ws = TRUE, skip = 1)\n\n\nworld_bank <-  world_bank %>% \n  janitor::clean_names() %>% \n  select(-c(source_of_national_poverty_rate)) %>% \n  rename(\"country\" = country_territory,\n         \"national_povt_line\" = national_poverty_line_2011_pp_ps,\n         \"household_survey\" = household_survey_mean_2011_pp_ps,\n         \"HFCE\" = hfce_2011_pp_ps,\n         \"GNI\" = gni_2011_usd_atlas) \n\n\n\n\nglimpse(world_bank)\n\nRows: 126\nColumns: 6\n$ country            <chr> \"Zambia\", \"West Bank and Gaza\", \"Vietnam\"…\n$ year               <dbl> 2007, 2009, 2012, 2006, 2011, 2010, 2011,…\n$ national_povt_line <dbl> 1.83, 6.06, 3.35, 6.28, 6.92, 21.70, 21.2…\n$ household_survey   <dbl> 2.66, 10.76, 8.07, 11.63, 23.09, 62.38, 4…\n$ HFCE               <dbl> NA, 9.72, 7.83, 20.99, 30.49, 92.57, 59.1…\n$ GNI                <dbl> 2.62, 5.91, 4.23, 18.59, 32.90, 136.28, 1…\n\n\n\nsummary(world_bank)\n\n   country               year      national_povt_line\n Length:126         Min.   :2001   Min.   : 1.270    \n Class :character   1st Qu.:2009   1st Qu.: 2.203    \n Mode  :character   Median :2011   Median : 4.585    \n                    Mean   :2010   Mean   : 7.872    \n                    3rd Qu.:2011   3rd Qu.: 8.290    \n                    Max.   :2012   Max.   :35.120    \n                                                     \n household_survey       HFCE             GNI        \n Min.   :  1.450   Min.   : 1.220   Min.   :  0.43  \n 1st Qu.:  3.865   1st Qu.: 5.635   1st Qu.:  2.77  \n Median :  9.335   Median :15.880   Median : 11.04  \n Mean   : 22.403   Mean   :22.083   Mean   : 33.57  \n 3rd Qu.: 20.523   3rd Qu.:30.915   3rd Qu.: 35.51  \n Max.   :800.000   Max.   :92.570   Max.   :247.32  \n                   NA's   :11       NA's   :2       \n\nCountry groups\nThe World Bank has an income classification by which it separates countries into four categories based on per capita gross national income (GNI): low-income, lower-middle, upper-middle, and high-income countries. To create the categories, I first calculated the GNI per capita quartile:\n\n\nquantile(world_bank$GNI, na.rm=TRUE)\n\n     0%     25%     50%     75%    100% \n  0.430   2.770  11.040  35.505 247.320 \n\nAfter calculating GNI per capita quartile, I create a new column to group each country in its corresponding category:\n\n\nqntile <-  world_bank %>% \n  mutate(GNI = replace_na(GNI, 0)) %>% \n  mutate(country_class = \n           case_when(GNI <= 2.770  ~ \"Low income\",\n                     GNI > 2.770  & GNI <= 11.040 ~ \"Lower middle income\",\n                     GNI > 11.040 & GNI <= 35.505   ~ \"Upper middle income\",\n                     GNI > 35.505 ~ \"High income\")) \n\n\nqntile %>% group_by(country_class) %>% \n    summarise(country = n_distinct(country)) %>% \n    arrange(desc(country))\n\n# A tibble: 4 × 2\n  country_class       country\n  <chr>                 <int>\n1 Low income               33\n2 High income              31\n3 Lower middle income      31\n4 Upper middle income      31\n\nDespite grouping the countries following the indications from the article by Jolliffe & Beer Prydz (2016), I obtained a slightly different classification. These differences mean that in my final chart some countries (dots) are colored differently than in the original chart.\nTable 2: International Poverty Lines: Median and mean national lines, by group. Figure from Jolliffe & Beer Prydz (2016)In order to maintain the order in which the categories are shown in the legend I used the function factor:\n\n\nqntile$country_class <- factor(\n  qntile$country_class,levels = c(\"Low income\",\"Lower middle income\",\n                                  \"Upper middle income\", \"High income\"))\n\n\nBuilding the chart\nData\nThe World Bank’s chart is a scatterplot in which each dot represents a country, they are colored by income group. The idea is to create a scatterplot with points that have different colors and fills depending on the value of the country_class variable.\nThe variable country_class will be used to determine the color and fill of the plotted points by using these arguments through aes().\nThe y axis has a blank space as label because in the original it is displayed under the title.\nShape 21 of geom_point allows us to use the outline and fill arguments for the dots, which will be important later on.\nstroke enables us to change the line’s width. I will recreate the dots from the original chart by setting a thick outline and filling the dots in white.\n\n\np<-ggplot(qntile) +\n  aes(x=HFCE, y=national_povt_line, \n      color=country_class,\n      fill=country_class) + \n  ylab(\"\") + \n  xlab(\n    \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\"\n    ) +\n  geom_point(size=3, shape=21, stroke=3) \np\n\n\n\nScale transformation\nIn the original chart what is plotted is the log of HFCE and the log of the national poverty line. The limit of the x axis is 100 and the limit of the y axis is 40, and the origin is 1. The breaks of both axes are really specific, thus I specified all of them.\n\n\np <- p + scale_y_log10(\n  limits=c(1, 40),\n  expand=expansion(0),\n  breaks=c(1,1.5,2,3,4,5,7,10,15,20,30,40),\n  labels=c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\"30\",\"40\"))+\n  scale_x_log10(\n    limits = c(1, 100),\n    expand = expansion(0),\n    breaks= c(1,1.5,2,3,4,5,7,10,15,20,30,40,50,70,100),\n    labels = c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\n               \"30\",\"40\",\"50\",\"70\",\"100\"))\np\n\n\n\nThe other major difference with respect to the distribution and classification of the data is that in my chart the relationship between the national poverty line and HFCE starts lower than in the original. I have not been able to figure out why this happens or how to fix it.\nAxes and panel grid\nAs the theme of the original graph is quite peculiar and very different from R’s aesthetics, I will be changing every element to make it as similar as the original instead of using a complete theme.\nI used the theme function to customize the panel and the axes. After specifying the colors of the panel background and lines, and also removing the lines in between the numbers with element_blank, I specified the style of the axes’ numbers and removed the its ticks.\n\n\np <- p + theme(panel.background = element_rect(fill=\"#f8f8f8\"), \n        panel.grid.major = element_line(\n          color = \"#dbddde\",size = 0.5,linetype = 1),\n        panel.border = element_rect(\n          fill = \"transparent\",color = \"#d5d7d8\",size = 0.5), \n        panel.grid.minor = element_blank(),\n        axis.text = element_text(face=\"bold\",\n                                 color=\"#58595b\",size=12),\n        axis.ticks = element_blank())\np\n\n\n\nColor of dots\nThe color of the dots are what made this graph more difficult to recreate. By combining stroke aesthetic with scale_manual, I created a unique scale to specify the World Bank’s aesthetic values. I filled the dots from the Low income and Lower middle income categories in white and those from Upper middle income and High income with its respective color to create the impression that they are solid.\n\n\np <- p +\n  scale_fill_manual(values=c(\"Low income\" =\"white\",\n                             \"Lower middle income\" =\"white\",\n                             \"Upper middle income\" =\"#e28e8e\", \n                             \"High income\" = \"#cd1349\")) +\n  scale_colour_manual(values=c(\"Low income\" =\"#58595b\",\n                               \"Lower middle income\" =\"#939598\",\n                               \"Upper middle income\" =\"#e28e8e\", \n                               \"High income\" = \"#cd1349\")) \np\n\n\n\nCountry labels\nWith the function annotate we can add geoms to the plot passed as vectors which is very useful to display the countries’ labels.\nIn the original chart some dots have a label which indicates the country and the reference year in which data was collected. It is not stated why these countries should be highlighted over the others. In addition, in some cases it is not very clear to which dot the label refers to as some are really close to each other. I specified the position of each label with hjust and vjust which control the alignment of the labels.\nHorizontal(hjust) and vertical(vjust) justification have the same parameterisation, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1. Although it is recommended not to use number outside the range (0, 1), in order to recreate the country labeling of the original chart, I used numbers outside the range.\nTop = 1, middle = 0.5, bottom = 0\nLeft = 0, center = 0.5, right = 1\n\n\np <- p + annotate(\"text\",\n  x=c(1.44, 1.9, 1.58, 2.72, 2.76, 5.96, 5.31, 4.4, 3.79, 5.2, 6.48, 9.28,\n        9.47, 13.9,7.96, 13.36, 12.52, 17.91, 29.61, 22.88,16.46,15.88,\n        28.99, 26.12, 31.85, 35.4, 33.95, 29.28, 27.98, 35.52,35.9,46.8,\n        39.98, 49.03, 63.41),\n  y=c(1.27, 1.45, 1.86, 2.1, 2.53, 1.76, 2.75, 3.7, 3.89, 4.46, 5.19,6.43,\n        7.63, 6.32,2.97, 2.14, 2.60, 3.08, 2.82, 3.38, 3.8, 3.87,5.24, 6.06,\n        7.17, 8.01, 9.16, 9.62,11.07, 12.98, 15.69, 18.63,19.37, 20.33, \n        35.12), \n  label=c(\"Malawi (2010)\",\"Mozambique (2009)\",\"Niger (2011)\",\"Togo (2011)\",\n          \"Guinea (2012)\",\"Lesotho (2010)\",\"Cong, Rep. (2011)\",\n          \"Mauritania (2008)\",\"Comoros (2004)\",  \"Tajikistan (2009)\",\n          \"Azerbaijan (2001)\",\"Honduras (2011)\",\"Bolivia (2011)\",\"Paraguay (2011)\",\n          \"Bhutan (2012)\",\"Namibia (2010)\",\"Sri Lanka (2010)\",\"Swaziland (2010)\",\n          \"Turkey (2011)\",\"Malaysia (2009)\",\"Albania (2012)\",\"Armenia (2011)\",\n          \"Romania (2011)\",\"Montenegro (2011)\",\"Chile (2011)\",\"Poland (2011)\",\n          \"Lithuania (2011)\",\"Croatia (2011)\",\"Estonia (2011)\",\"Czech Rep (2011)\",\n          \"Slovak Rep. (2011)\",\"Spain (2011)\",\"Slovenia (2011)\",\"Ireland (2011)\", \n          \"Norway(2011)\"),\n  hjust = c(0.5, 0.15, 0.5, 1.2, 1.2, 0.65, 1.2, 0.5, 1.25, 1.25, 1.2,1.25,\n            -0.2, 0.5, -0.25, -0.2, -0.15, 0.5,0.3, -0.15, 0.65, -0.2, -0.2,\n            -0.1, -0.15, -0.15, -0.1, 1.15, -0.15, 1.15,-0.15, -0.15, 1.15, \n            0.95, 1.15),\n  vjust = c(2, 2, 2, 0.45, 0.45, 2.5, -1.5, 2.5, 0.35, 0.5, 0.15, 0.1,0,-1.5,\n            0.15, 0.2, 1.15, 3, 3, 0.25, 2, -1.6,0.55, 0, 0.5,0.25, 0.3, \n            0.25, 0.35, 0.5, 0.35, 2.5,0.45, -2, 0.25),\n  size= 3.5,\n  color = \"#58595b\") \np\n\n\n\nText\nIn this segment I add to the chart the title, the subtitle, and the caption. I used a <span> element to set the two colors of the title.\n\n\np <- p +\n  labs(title = \"<span style='color: #cd1449;'>1c<span><span style=\n  'color: #444444;'> Richer countriestend to have higher national poverty lines<span>\",\n       subtitle = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n       x = \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\",\n       y = \"\",\n       caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, \n       Estimating International Poverty Lines from Comparable National Thresholds,\n       Policy Research Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  theme(text = element_text(size = 12),\n        plot.title = element_markdown(face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(hjust=0),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1))\np\n\n\n\nLegend\nThe legend of the original chart is located on the upper left corner of the panel, to move it out there I used the argument of legend.position. Because the legend does not have a title or a key I used element_blank to remove them.\n\n\np <- p + theme(legend.text=element_text(size=10),\n        legend.position = c(0.095,0.91), \n        legend.title = element_blank(),  \n        legend.key = element_blank())\np\n\n\n\nBackground\nThe last touch to replicate the original chart is to color the background in light grey with plot.background. To do this, I first use plot.margin to control the margins around the plot. This code sets top margin to 1 cm, the right margin to 4 cm, the bottom margin to 1 cm, and the left margin to 4 cm. Despite setting the caption to the left of the plot, I could not figure put how to align it with the title and the subtitle.\n\n\np <- p + theme(plot.margin = unit(c(1,4,1,4),\"cm\"),\n          plot.background = element_rect(fill=\"#f8f8f8\"),\n          plot.title = element_markdown (hjust =-0.35),\n          plot.subtitle = element_markdown(hjust=-0.25),\n          plot.caption.position = \"plot\",\n          plot.caption = element_markdown(hjust= -0.25))   \np\n\n\n\nFinal chart\nThe World Bank’s chart is trying to represent the relationship between the HFCE and the national poverty line to showcase how richer countries have higher national poverty lines. The visual channels I will focus on to build an alternative chart are the xy position and the hue.\nTo represent this relationship it is important that the dots of the scatterplot inform us about the values of each country and the global pattern. One possible way to deal with overplotting faceting: the same plot is repeated, each time highlighting another group. A nice way to keep the global and the between groups comparisons is to plot the non-group dots in the background and in light grey (general context data).\nMoreover, I have decided to keep the logarithmic transformation because it helps the visualization of the data. It also helps to the representation of the information that the axes are not shown in logarithmic scale, and are rather displayed in the original scale.\nAs in the original graph it was a bit confusing to know precisely which dot the label was referring to, by now having four facets, there is more space to specify each country. To do this I used library(ggrepel).\nIn addition, to enhance the colors of the dots I used the color scheme by Carto to make more visible the different groups.\n\n\nsapply(qntile, function(x) sum(is.na(x)))\n\n           country               year national_povt_line \n                 0                  0                  0 \n  household_survey               HFCE                GNI \n                 0                 11                  0 \n     country_class \n                 0 \n\nqntile <- qntile %>% filter(!is.na(HFCE))\n\n\n\n\np1 <- ggplot(qntile, \n             aes(HFCE, national_povt_line, color=country_class, label=country)) + \n  geom_jitter(data = transform(qntile,\n     country_class = NULL), colour = \"grey80\") + \n  geom_point(alpha=0.7) +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\"))+\n  facet_grid(~country_class, scales = \"free\") + \n  theme_bw() + \n  labs(title = \"<span style='color: #CC503E;'>1c<span><span style='color: #000000;'> \n  Richer countries tend to have higher national poverty lines<span>\",\n  subtitle=\"Class country\",\n  x = \"Household final consumption expenditure per capita per day, 2000-12 \n  (2011 PPP $)\",\n  y = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n  caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, Estimating \n  International PovertyLines from Comparable National Thresholds, Policy Research \n  Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  scale_x_log10()+\n  scale_y_log10()+\n  theme(text = element_text(size = 8),\n        legend.position = \"none\",\n        plot.title = element_markdown (face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(face = \"bold\",hjust = 0.5),\n        axis.title.x  = element_markdown(),\n        axis.title.y = element_markdown(),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1)) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\n\np1 <- p1 + ggrepel::geom_text_repel(size=2, box.padding = 0.1, max.overlaps = 6)\n\np1\n\n\n\nInteractive chart\nAnother alternative visualization is to plot an interactive scatterplot by using ploytly. This way more information is added to every dot without increasing data density:\nCountry\nYear\nNational poverty line\nHousehold final consumption\nGNI\n\n\nlibrary(plotly)\n\np2 <- qntile %>%\n   mutate(text = paste(\"Country: \", country, \"\\nYear: \", \n                       year, \"\\nNational poverty live: \", national_povt_line,\n                       \"\\nHousehold final consumption: \", \n                       HFCE, \"\\nGNI: \", GNI,sep=\"\")) %>% \n  ggplot(aes(x=HFCE, y=national_povt_line, color = country_class, text=text)) +\n  geom_point(alpha=0.7) +\n  scale_size(range = c(1.4, 19), name=\"Dollars ($)\") +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\")) +\n  theme(legend.position=\"none\") +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_minimal() \n\np2\n\n\n\n\n\np_int <- plotly::ggplotly(p2, tooltip=\"text\", type='scatter', mode='markers')\n\np_int <- p_int %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_int <- p_int %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_int\n\n\n\nThis new visualization of the data allow us to see that Low income and Lower middle income countries follow a different trend than Upper middle income and High income countries. In order to better see these patterns I use the function geom_smooth().\nSubgroups:\n\n\nlow_income <- qntile %>% filter(country_class == \"Low income\" | country_class == \"Lower middle income\")\nhigh_income <- qntile %>% filter(country_class == \"Upper middle income\" | country_class == \"High income\")\n\n\nTrend line of each group:\n\n\np3 <- qntile %>%\n  # text is not a standard aesthetic for this geom_smooth()\n  ggplot(aes(x=HFCE, y=national_povt_line, color = country_class, label=country)) + \n  geom_point(alpha=0.7) +\n  scale_size(range = c(1.4, 19), name=\"Dollars ($)\") +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\")) +\n  theme(legend.position=\"none\") +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_minimal() \n\np_group <-  p3 + geom_smooth(method = \"lm\", se = FALSE, size=0.5) \n\np_group <- plotly::ggplotly(p_group)\n\np_group <- p_group %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_group <- p_group %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_group\n\n\n\nTrend line of the two subgroups, Low income (Low income & Lower middle income) and High income (Upper middle income & high income):\n\n\np_subgroup <- p3 + geom_smooth(data=low_income, method=\"lm\",se=FALSE, color = 'red')\np_subgroup <- p_subgroup + geom_smooth(data=high_income, method=\"lm\",se=FALSE, color = \"blue\")\n\np_subgroup <- plotly::ggplotly(p_subgroup)\n\np_subgroup <- p_subgroup %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_subgroup <- p_subgroup %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_subgroup\n\n\n\n\n\n\n",
    "preview": "projects/2022/100386498/100386498_files/figure-html5/unnamed-chunk-17-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 748
  },
  {
    "path": "projects/2022/100482798/",
    "title": "Social Dissent in China by ‘The Economist’: How Frequent are Protests in the Country?",
    "description": "An explanation of my layer-by-layer construction of a chart representing\nsocial dissent in China geospatially and by issue. This article consists in\nthe replication of a plot made by The Economist's, continuing with an\nalternative representation using similar data. The critique of the strengths\nand weaknesses of the original chart and the successive transformations of\nthe chart are fundamented in data visualization theory.",
    "author": [
      {
        "name": "Gabriel Rodríguez Molina",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nStep One: Replication of the chart\nData collection and processing\nBuilding the plot\nCriticsms to the plot\n\nStep Two: New visualization of the chart\nManaging data\nMaking an alternative representation: First attempt\nManaging data II\nMaking an alternative representation: Second attempt\n\n\nThe current social and political environment in China is complex and dynamic. The Land of the Dragon is usually misunderstood by the Western countries whose vision is usually biased or distorted due to all the contradictory narratives hiding international political dynamics of power. Differently to what many people think, protests are very usual in the People’s Republic. However, due to the lack of transparency it’s not such an easy thing to measure. This is a subject that is worth exploring for those who are interested in gaining a deeper understanding about the controversial economic giant. Studying the trends of the protests in China and the motivations behind them, it is possible to acquire insight about the current state of affairs in the country. Additionally, understanding the role that China’s government plays in responding to and facilitating protests can provide further knowledge about the country’s current political and social environment.\nI will work on the next chart extracted from the article “How common are protests in China?” by The Economist, which aims to represent the different demonstrations of discontent in the country. It is made of two charts which assess popular manifestations geographically and depending on the issue. Scores are calculated using the data supplied by the China Dissent Monitor, a webpage owned by the neo-liberal think thank Freedom House. The data lists one by one all the monitored cases of dissent and different variables including dates, provinces, issues, descriptions, number of participants…\n\n\nStep One: Replication of the chart\nData collection and processing\n\n\n# Load libraries\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(ggtext)\nlibrary(patchwork)\n\n\nAs it was explained, the data has been obtained from the China Dissent monitor, made by the Freedom House. The second data set is a .shp document that allow us to geospatially reproduce the whole map of china, including cities and provinces.\n\n\n# Read data\n\nchinacsv <- read_delim(\"dissent.csv\", delim=\",\", skip=0)\nchina_map <- st_read(\"province.shp\", quiet=TRUE)\n\n\nTo represent the data it’s necessary to first merge both data sets. In order to accomplish that it is necessary to create a similar ID code for each of the provinces.\n\n\nchinacsv <- chinacsv %>%\n  rename(code = province)\n\nchina_map <- china_map %>%\n  mutate(code = sub(\" Sheng\", \"\", NAME_PINGY)) %>%\n  mutate(code = sub(\"Guangxizhuangzu Zizhiqu\", \"Guangxi\", code)) %>%\n  mutate(code = sub(\"Neimenggu Zizhiqu\", \"Inner Mongolia\", code)) %>%\n  mutate(code = sub(\"Xizang Zizhiqu\", \"Tibet\", code)) %>%\n  mutate(code = sub(\"Xinjiangweiwu'erzu Zizhiqu\", \"Xinjiang\", code)) %>%\n  mutate(code = sub(\"Ningxiahuizu Zizhiqu\", \"Ningxia\", code)) %>%\n  filter(NAME_PINGY != \"Taiwan Sheng\")\n\n\nBefore combining both data frames, a few transformations have to be done. First, the “code” column is changed to numeric value and then the “count” function is used to score and group the cases of dissent by province. As a result we have only two columns left related to each object: the province with an ID code assigned to it and the number of cases in each province.\n\n\nchina_dissent <- chinacsv %>%\n  select(code) %>% \n  count(code) \nchina_dissent\n\n# A tibble: 28 × 2\n   code             n\n   <chr>        <int>\n 1 Anhui            9\n 2 Fujian          21\n 3 Gansu            8\n 4 Guangdong       83\n 5 Guangxi         31\n 6 Guizhou          8\n 7 Hainan           8\n 8 Hebei           91\n 9 Heilongjiang    14\n10 Henan           99\n# … with 18 more rows\n\nIt’s time to join both data frames using left_join function. We only keep the code representing the provinces and the geospatial information about each of these provinces.\n\n\njoin_map_data <- china_map %>% \n  left_join(china_dissent, by=\"code\") %>% \n  select(n, geometry)\n\n\nIt is also necessary to modify the data for the second chart. As there are many different variations of each of the issues introduced in the data set we have to group them in wider categories. For example, to represent the variable “Fraud,” we are using “fraud, building quality”, “fraud corruption”…etc.\n\n\nx <- c(\"Others\", \"Corruption\", \"State violence\", \"Fund withdrawal freeze\",\n       \"Land rights\", \"School disputes\", \"Building disputes\", \"Fraud\",\n       \"COVID-19 pandemic policies\", \"Pay and benefits\", \"Delayed housing project\")\n\nchina_data <- chinacsv %>%\n  transmute(\n    Date = `beginning date`,\n    Issue = issue,\n    reason_dissent = case_when(\n      grepl(\"^fraud\", issue) ~ \"Fraud\",\n      grepl(\"^delayed\", issue) ~ \"Delayed housing project\",\n      grepl(\"^pay\", issue) ~ \"Pay and benefits\",\n      grepl(\"^COVID-19\", issue) ~ \"COVID-19 pandemic policies\",\n      grepl(\"^school\", issue) ~ \"School disputes\",\n      grepl(\"^building\", issue) ~ \"Building disputes\",\n      grepl(\"^fund\", issue) ~ \"Fund withdrawal freeze\",\n      grepl(\"^land\", issue) ~ \"Land rights\",\n      grepl(\"^state\", issue) ~ \"State violence\",\n      grepl(\"^corruption\", issue) ~ \"Corruption\",\n      TRUE ~ \"Others\"\n    )\n  )\n\n\nSubsequent changes include creating a new column counting the number of cases for each case of dissent. The column “reason_dissent” is changed into a factor so labels can be ordered when building the plot. It wouldn’t be necessary to use factors if the data had just to be ordered alphabetically or in a descendant/ascendant order. However, the original plot locates the “Others” label in last place even though it’s not the least frequent variable.\n\n\nchina_data_n <- china_data %>% \n  group_by(reason_dissent) %>%\n  count() %>%  \n  transmute(\n      reason_dissent = factor (reason_dissent, levels = x),\n      n_cases= n) %>% \n  drop_na()\nchina_data_n\n\n# A tibble: 11 × 2\n# Groups:   reason_dissent [11]\n   reason_dissent             n_cases\n   <fct>                        <int>\n 1 Building disputes               47\n 2 Corruption                      10\n 3 COVID-19 pandemic policies     162\n 4 Delayed housing project        272\n 5 Fraud                          105\n 6 Fund withdrawal freeze          21\n 7 Land rights                     26\n 8 Others                         144\n 9 Pay and benefits               163\n10 School disputes                 49\n11 State violence                  14\n\nBuilding the plot\nWe start by filling our geom_sf using the values in n, which provides data about the amount of protests by province. We locate the map in the center reducing the background using the “ylim” and “xlim” functions. Borders are changed to white and its thickness can be controlled with “lwd” function.\n\n\nfinal_map <- join_map_data %>% \n  ggplot() +\n    geom_sf(aes(fill=n), color=\"white\",lwd=0.2, )  + \n    coord_sf(ylim=c(-1.7e+06, 2e+06), xlim=(c(-3.3e+06, 2e+06)))\nfinal_map\n\n\n\nThe title and a subtitle are included in this part. We use the R Markdown language to generate two lines in the subtitle. It is a very useful tool in the case it’s necessary to change the color, size or type of letter, however in this case that is not required. To use it correctly we must include element markdown in the theme.\n\n\nfinal_map <- final_map +\n  labs(\n    fill=quote(bold(\"By province\")),\n    title = quote(bold(\"Do you hear the people sing?\")),\n    subtitle =(\"<span style='font-size: 10pt; font-family:Helvetica;'>China, number of protests<\/font><br>\n                <span style='font-size: 9pt; font-family:Helvetica;'> September 1st to December 31th, 2022<\/font>\")\n  ) + \n  theme(\n    plot.title = element_text(size = 12, family=\"Calibri\", hjust=-0.015),\n    plot.subtitle = element_markdown(lineheight=1.5, hjust=-0.01),\n  )\nfinal_map\n\n\n\nOur variable and the scale to represent it is not discrete nor continuous but binned. “Scale_fill_binned” also allow us to change colors and establish breaks for the legend.\n\n\nfinal_map <- final_map +\n    scale_fill_binned(\n        breaks = c(20, 40, 60, 80),\n        low = \"#C7E6FD\", high = \"#004776\", \n        limits=c(0, 100)\n    )\nfinal_map\n\n\n\nThe plot is very minimalist so in both charts we are removing the background, the grids and the ticks and text of the axis. Many different features are modified here to change sizes and type of letters, the position of the legend and the title and spacing between different objects. In this case we are not adding the NAs in the legend because we don’t have any.\n\n\nfinal_map <- final_map + \n  theme(\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size=9, family=\"Helvetica\"),\n    legend.key.height = unit(0.18, 'cm'),\n    legend.key.size = unit(0.6, 'cm'),\n    legend.position = c(0.125,0.89),\n    legend.title = element_text(size=9, family=\"Helvetica\"),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    legend.spacing.x = unit(8.0, 'cm')\n  ) +\n  guides(fill = guide_colorbar(title.position = \"top\"))\nfinal_map\n\n\n\nThe second plot is an horizontal bar chart which can be build using “geom_col”. The x axis represents the number of issues and the y axis each of those issues.\n\n\nfinal_plot <- china_data_n %>% \n  ggplot() +\n    aes(n_cases, reason_dissent) +\n    geom_col(fill=\"#195B87\", width = 0.45)\nfinal_plot\n\n\n\nIn this step title and caption are added and the labels for the y axis are explicitly named to put “COVID-19 pandemic policies” in bold.\n\n\nfinal_plot <- final_plot +\n  labs(\n    x=NULL,\n    y=NULL,\n    title=quote(bold(\"By reason for dissent\")),\n    caption = (\"Source: Freedom's House China Dissent Monitor\")\n    ) +\n  scale_y_discrete(labels = c(\"Others\",\n                              \"State violence\",\n                              \"Corruption\",\n                              \"Fund withdrawal freeze\",\n                              \"Land rights\",\n                              \"School disputes\",\n                              \"Building disputes\",\n                              expression(bold(\"COVID-19 pandemic policies\")),\n                              \"Fraud\",\n                              \"Pay and benefits\",\n                              \"Delayed housing project\"))\nfinal_plot\n\n\n\nFollowing the minimalist aesthetic, the background and the axis ticks are eliminated; word’s size, type and colour is modified; and the x axis is placed on top. The “aspect.ratio” function allows us to make the plot longer and fit the previous one. The breaks for the x axis are also made explicit with “scale_x_continuous”.\n\n\nfinal_plot <- final_plot +\n  theme(\n    plot.title = element_text(size = 9, family=\"Helvetica\"),\n    panel.background = element_blank(),\n    panel.grid.major.x = element_line(color= \"grey\"),\n    plot.title.position = \"plot\",\n    axis.ticks= element_blank(),\n    axis.text.y = element_text(hjust=0, size=8, family=\"Helvetica\", color=\"black\"),\n    axis.text.x = element_text(size=8, family=\"Helvetica\", color=\"black\"),\n    aspect.ratio = 2.2,\n    plot.caption = element_text(hjust = 1.3, size=9, color=\"grey\")\n    ) +\n  scale_x_continuous(breaks = c(0,50,100,150,200,250), position = \"top\")\nfinal_plot\n\n\n\nIf we compare this plot with the original one made by The Economist we can realize the data doesn’t match accurately. This is because Freedom House eventually updates the data for the graph. It has been attempted to filter earlier dates or reduce the case ID but none of them are giving us the exact same pattern than the one presented. What’s more, filtering until November 22nd gives a much more different output in relation to the original chart than in the present case. Doing a general filtering in the data set does not allow us to replicate the chart, it would be necessary to exclude some cases one by one. However, even though the values are not the exact same, the essential aspects of its visual representation are not really affected and the message is the same. In our case NAs label was not added because all provinces have more than 0 cases.\nIn order to plot the charts together patchworks deformed too much the final result. In our case we are just placing one chart over the next one and adjusting all parameters correctly make them match. This is the final replication:\n\n\n\n\n\n\nCriticsms to the plot\nI think the main message these two charts plotted together are sending is that China’s regime is not as robust as we usually think. Western imaginary tends to conceive the pros and cons of their political system taking into account two sides of the same coin: On the one had, their lack of political and individual rights in an autocratic environment is negative, while the absence of popular grievances, open public debates and other democratic procedures allows the country to be more efficient and united in order to achieve common goals and an exponential economic growth. However, this plot tell us that political claims and cases of dissent are much more frequent than we think, and these popular demonstrations are widespread all over the country concerning many different issues. I think this charts perfectly accomplish this purpose.\nThe original chart, which has been presented at the beginning, was published by The Economist on November 28th. It is an update of a previous plot which contained less data and was exactly the same visually. Besides this, the only change which was made is putting “Covid-19 pandemic policies” in bold, a change that makes sense taking into account the whole article in which this plot is included, where they explain the undergoing situation in the country. Nevertheless, I think the graph is not informative in this context. Visual representation aims to communicate a message by itself regardless of the information beyond the plot. The Economist wanted to express how numerous anti-lockdown protests were being due to the general questioning of zero-Covid strategy, which has resulted to be an absolute failure. Using a barplot does not seem to be useful to show this huge exponential increase of covid-19 protests, and someone who hasn’t been aware of this political dynamics would not understand why that concrete label is in bold being the 4th issue in the ranking.\nI will propose a modification taking into account this argumentary.\nStep Two: New visualization of the chart\nManaging data\nMy first approach consisted on exploring the best way of showing the difference in cases of Covid-19 between the two plots made by The Economist. Filtering the data I could manage to represent the previous plot (the one which was launched by The Economist but is no longer uploaded) and the current update.\n\n\nchina_data_filter <- chinacsv %>%\n  filter(`Case ID`<669) %>% \n  transmute(\n    Issue = issue,\n    reason_dissent = case_when(\n      grepl(\"^fraud\", issue) ~ \"Fraud\",\n      grepl(\"^delayed\", issue) ~ \"Delayed housing project\",\n      grepl(\"^pay\", issue) ~ \"Pay and benefits\",\n      grepl(\"^COVID-19\", issue) ~ \"COVID-19 pandemic policies\",\n      grepl(\"^school\", issue) ~ \"School disputes\",\n      grepl(\"^building\", issue) ~ \"Building disputes\",\n      grepl(\"^fund\", issue) ~ \"Fund withdrawal freeze\",\n      grepl(\"^land\", issue) ~ \"Land rights\",\n      grepl(\"^state\", issue) ~ \"State violence\",\n      grepl(\"^corruption\", issue) ~ \"Corruption\",\n      TRUE ~ \"Others\" \n    )\n  ) %>% \n  group_by(reason_dissent) %>%\n  count() %>%  \n  transmute(\n        reason_dissent = factor (reason_dissent, levels = x),\n        n_cases= n) %>%\n  arrange(reason_dissent) %>% \n  drop_na()\n\n\nIn this context, the filtered data set and the full one can be merged, each one containing a different amount of cases per issue to be represented.\n\n\ndiff_data <- china_data_n %>% \n  full_join (china_data_filter, by = \"reason_dissent\") %>% \n  transmute(\n    reason_dissent,\n    before = n_cases.y,\n    after = n_cases.x\n  )\ndiff_data\n\n# A tibble: 11 × 3\n# Groups:   reason_dissent [11]\n   reason_dissent             before after\n   <fct>                       <int> <int>\n 1 Building disputes              30    47\n 2 Corruption                      8    10\n 3 COVID-19 pandemic policies     37   162\n 4 Delayed housing project       214   272\n 5 Fraud                          85   105\n 6 Fund withdrawal freeze         21    21\n 7 Land rights                    18    26\n 8 Others                         95   144\n 9 Pay and benefits              109   163\n10 School disputes                38    49\n11 State violence                 13    14\n\nMaking an alternative representation: First attempt\nLollipops seem to be a good way to show the differences between both data sets representing at the same time the absolute values as the previous chart did. In this case, I repeated all geoms twice filtering it the second time to give covid-19 protest a different colour.\n\n\nfinal_plot <- diff_data %>% ggplot() +\n  aes(after, reorder(reason_dissent, after, sum)) +\n  geom_segment(\n              aes(\n                xend=before, yend=reason_dissent), \n                color=\"#195B87\", \n                size=0.7) +\n  geom_segment(\n    aes(xend=before, yend=reason_dissent), \n        color=\"#B10000\", size=1, data = diff_data %>% \n        filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  geom_point(size=2, color=\"#195B87\") +\n  geom_point(aes(before), size=0.7, color=\"#195B87\") +\n  geom_point(\n    aes(before, reason_dissent), size=1, \n    color=\"#B10000\", data = diff_data %>% \n    filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  geom_point(\n    aes(after, reason_dissent), size=2.3, \n        color=\"#B10000\", data = diff_data %>% \n        filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  labs(\n    y=NULL,\n    x=NULL,\n    title=quote(bold(\"By reason for dissent\")),\n    caption = (\"Source: Freedom's House China Dissent Monitor\")\n    ) +\n  scale_x_continuous(position = \"top\", breaks = c(0,50,100,150,200,250)) +\n  theme(plot.title = element_text(size = 11, family=\"Helvetica\"),\n        panel.background = element_blank(),\n        panel.grid.major.x = element_line(color= \"grey\"),\n        plot.title.position = \"plot\",\n        axis.ticks= element_blank(),\n        axis.text.y = element_text(hjust=0, size=9, family=\"Helvetica\", color=\"black\"),\n        axis.text.x = element_text(size=9, family=\"Helvetica\", color=\"black\"),\n        aspect.ratio = 2.5,\n        plot.caption = element_text(hjust = 2, size=7, color=\"grey\")\n        )+\n  expand_limits(x=0)\nfinal_plot\n\n\n\nThe result of the two charts merged together look like this:\n\n\n\n\n\n\nThe main problem of this chart is that dates are not shown, but even if they were added it would be quite arbitrary to just represent two dates corresponding to two different releases of The Economist. Also the map above is problematic as the lollipops are representing two absolute values and its difference, but a map can not show all these features and the interpretation can be misleading. What should be added to the map? Only the data concerning the difference? The absolute value of the second date?\nThis is why a second attempt was made, representing this time how the cases for each issue change through time and showing at the same time the exponential covid-19 rise of dissent.\nManaging data II\nIn this case we calculated the cumulative of the protests depending on the dates and the reason for dissent, so we can represent what’s the number of protest each day depending on the issue. As we want to incise in the high number of anti-lock down covid-19 protests we are filtering information after September. Taking a very long time lapse hides this change, so both charts are being filtered.\n\n\nx <- c(\"COVID-19 pandemic policies\", \"Delayed housing project\", \"State violence\",\n       \"Fund withdrawal\", \"Pay and benefits\", \"Building disputes\",\n       \"School disputes\", \"Land rights\", \"Corruption\", \"Fraud\", \"Others\")\n\nchina_data_n <- china_data %>% \n      group_by(reason_dissent,Date) %>%\n      count() %>%\n      filter(Date >=\"2022-09-01\") %>% \n      group_by(reason_dissent) %>% \n      mutate(cumulative_n = cumsum(n)) %>% \n      transmute(\n          reason_dissent = factor (reason_dissent, levels = x),\n          cumulative_n,\n          Date)\nchina_data_n\n\n# A tibble: 214 × 3\n# Groups:   reason_dissent [10]\n   reason_dissent    cumulative_n Date      \n   <fct>                    <int> <date>    \n 1 Building disputes            1 2022-09-03\n 2 Building disputes            3 2022-09-05\n 3 Building disputes            4 2022-09-17\n 4 Building disputes            7 2022-09-18\n 5 Building disputes            8 2022-09-24\n 6 Building disputes            9 2022-09-28\n 7 Building disputes           10 2022-10-02\n 8 Building disputes           12 2022-10-09\n 9 Building disputes           13 2022-10-12\n10 Building disputes           14 2022-10-26\n# … with 204 more rows\n\nMaking an alternative representation: Second attempt\nIn this case it was possible to represent this data using a linear chart, but using a stream in a proportional way seemed to be an even better option to show the rise in covid-19 protests. In this context, “geom_stream” from ggstream package was used.\n\n\nfinal_plot <- ggplot(china_data_n) +\n  aes(Date,cumulative_n) +\n  ggstream::geom_stream(\n      aes(fill=reason_dissent),\n      type=\"proportional\")\nfinal_plot\n\n\n\nIn this part we use titles not just in a descriptive way but trying to help interpretation in terms of the centrality we want covid-19 to have. The map chart is very long, so having the legend at the right is not an option if we want both charts to fit well together. Besides, colours seem to be very confusing.\n\n\nfinal_plot <- final_plot + labs(\n      title=quote(bold(\"Anti-lockdown protests boost due to zero-Covid strategy\")),\n      fill=quote(bold(\"By Issue\")),\n      caption = (\"Source: Freedom's House China Dissent Monitor\"),\n      y = quote(bold(\"Percentage of protests\")))\nfinal_plot\n\n\n\nAs always, the theme is used to adjust many different things. The most challenging aspect here was to adjust all parameters to make both charts fit, as this one looked better horizontally but has to substitute a vertical one.\n\n\ncols <- c(\"#146c9b\", \"#eacbab\", \"#d49c4c\", \"#acdbdb\" , \"#040404\",\"#9c947c\",\n          \"#ce9f5d\", \"#498caa\", \"#546466\", \"#729499\")\n\nfinal_plot <- final_plot +  theme(\n      plot.title = element_text(size = 12, family=\"Calibri\", \n                                margin=margin(0,0,5,0)),\n      panel.background = element_blank(),\n      plot.margin=unit(c(0,0,0,0),\"cm\"),\n      plot.title.position = \"plot\",\n      axis.text.y = element_text(hjust=0, size=11, family=\"Helvetica\", color=\"black\"),\n      axis.text.x = element_text(size=11, \n                                 family=\"Helvetica\", color=\"black\"),\n      axis.title.x = element_blank(),\n      aspect.ratio = 0.68,\n      plot.caption = element_text(hjust = -1.25, size=10, color=\"grey\"),\n      legend.text = element_text(size=9, family=\"Helvetica\"),\n      legend.key.height = unit(0.27, 'cm'),\n      legend.key.width  = unit(0.27, 'cm'),\n      legend.key.size = unit(0.9, 'cm'),\n      legend.position = \"bottom\",\n      legend.title = element_text(size=9, family=\"Helvetica\"))+\n  scale_x_date(date_breaks = \"months\", date_labels = \"%m-%Y\", expand = c(0.01, 0))+\n  scale_y_continuous(labels= c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\"), expand = c(0.10, 0))+\n  guides(fill = guide_legend(title.position = \"top\"))+\n  scale_fill_manual(values = cols)\nfinal_plot\n\n\n\nAs we can observe, the map also suffered many modifications to fit well the second chart. I think the final result allows a better comprehension of the data as we have included the dimension of transformation of the data over time. This way it’s not just about the different issues and their total frequency but about how the social demands are proportionally changing depending on the matter. In this context, understanding the recent rise of covid-19 protests is also easier to analyze.\n\n\n\n\n\n\n\n\n\n",
    "preview": "projects/2022/100482798/100482798_files/figure-html5/final_map-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100485232/",
    "title": "Percentage of elders feeling lonely",
    "description": "Visualizing and comparing loneliness percentage among elders between \ndifferent countries, through barplots and maps.",
    "author": [
      {
        "name": "Raquel Sánchez-Hermosilla García",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nChosen graph\nInitial graph replicated\nInitial graph enhanced\nAlternative visualization of the graph\nChoropleth map\nInteractive map\n\n\n\n\nlibrary(tidyverse)\nlibrary(corrplot)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(rnaturalearth)\n\nsysfonts::font_add_google(\"Playfair Display\", family = \"Playfair Display\")\nsysfonts::font_add_google(\"Arimo\", family = \"arimo\")\nshowtext::showtext_auto()\n\n\nChosen graph\nSource: Our World in DataThe graph I have chosen is a bar plot that shows the percentage of loneliness\namong elders in different countries, from Our World in Data, and it is part of\nan article that tries to prove and explain the importance that social\nconnections and personal relationships have in our health.\nRegarding the data gathering process to improve, enhance and do alternative\nvisualizations, I had to download the CSV file that is available\non the “Download” bottom tab of the above graph.\nInitial graph replicated\n\n\n#Open data set\nworldsadness <- read_csv(\"self-reported-loneliness-older-adults.csv\", \n                          show_col_types = FALSE)  %>% dplyr::select(-Code)  %>% \n                          dplyr::rename( Country = Entity)\n                    \nworldsadness$Country <- factor(worldsadness$Country, \n                               levels=c(\"Denmark\",\"Switzerland\", \"Sweden\",\n                                        \"United States\", \"England\",\n                                        \"Netherlands\",\"Germany\", \"Finland\",\n                                        \"Spain\", \"Belgium\",\"France\", \"Austria\",\n                                    \"Italy\",\"Israel\", \"Greece\"))\n\n#Graph\nggplot(worldsadness)+\n  #establecer los ejes\n  aes(x=Country, y= Sadness, fill=Country )+\n  #quitar las etiquetas del eje x\n  scale_x_discrete(NULL) + \n  #specify a color for each bar\n  geom_col( width = 0.75,#width of bars in relation to the x-axis\n            fill = c(\"#4982C5\",#Austria\n                     \"#C69F73\",#Belgium\n                     \"#719461\",#Denmark\n                     \"#E98473\",#England\n                     \"#CA6B7D\",#Finland\n                     \"#9A5057\",#France\n                     \"#3B6334\",#Germany\n                     \"#835CA2\",#Greece\n                     \"#CA723A\",#Israel\n                     \"#72B99E\",#Italy\n                     \"#A96C4A\",#Netherlands\n                     \"#274A74\",#Spain\n                     \"#B06FAB\",#Sweden\n                     \"#56B7C5\",#Switzerland\n                     \"#B06FAB\"#USA\n                     ))+\n  coord_flip()+\n  theme_minimal()+\n  #now texts content \n  labs(y= NULL,\n       title= \"Self-reported loneliness among older adults\",\n        subtitle = \"Share of survey respondents who report feeling lonely at least some of the time. For all countries estimates \\n correspond to population ages 65+, except in the following cases: US (ages 72+); UK (ages 65-74); and \\n Finland (ages 75+).\",\n       caption = \"Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\\nNote: Estimates correspond to people who report feeling lonely \\\"some of the time\\\", \\\"most of the time\\\", or \\\"almost all the\\n time\\\". This is in contrast to those that report feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\", or \\\"never\\\".\\nCC BY\")+\n  #now texts characteristics\n  theme(\n    plot.title = element_text(size=32, family = \"Playfair Display\",\n                              color = \"#555555\"),\n    plot.subtitle = element_text(size=18, family = \"arimo\", color = \"#555555\",\n                                 lineheight = 0.8, margin= margin(0,0,20,0)),\n    plot.caption = element_text(size = 15, family = \"arimo\", color = \"#555555\",\n                                lineheight = 0.7,  margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 0))+\n  theme(plot.caption =  element_text(hjust = 0))+\n  theme(plot.caption.position = \"plot\")+\n  #add label at the end of the bar\n  geom_text(aes(label = paste(Sadness, Year, sep= \"% in \")), vjust = 0.7,\n            hjust=-0.1, colour = \"#555555\", size= 6, family= \"arimo\")+\n  #change the grid\n  theme(panel.grid.major.x = element_line(color = \"lightgrey\",\n                                          size = 0.4, linetype = 2))+\n  theme(panel.grid.minor.x = element_blank())+\n  theme(panel.grid.major.y = element_blank())+\n  #ticks del eje y bien puestos\n  scale_y_continuous(limits = c(0,70), \n                     labels = c(\"0%\",\"10%\",\"20%\",\"30%\",\"40%\",\"50%\",\"60%\"),\n                     breaks = c(0,10,20,30,40,50,60))+\n                    \n   #both axis text characteristics modified\n  theme(axis.text.x = element_text(size = 20, family = \"arimo\",\n                                   color = \"#555555\"))+\n  theme(axis.text.y = element_text( size = 17, family = \"arimo\", \n                                    face = \"bold\", color = \"#555555\", \n                                    hjust=1, vjust= 0.5))\n\n\n\nOn one hand, this visualization has two main weaknesses, the first and most\nobvious one is the use of colors inside bars, because it seems randomly chosen\nand it is non-informative. And at the same time, the visualization has too many\ntext explaining information displayed on the graph, like the difference among\ncountries regarding year of data collection and respondents age.\nOn the other hand, as a strength, the hierarchical bars position is truly\ninformative, because we can easily see that Greece is the country with the\nhighest percentage of loneliness among elders, while Denmark has the lowest,\nand the rest of the countries are positioned following that hierarchy.\nInitial graph enhanced\n\n\n#above code chunk to extend graph height, and make it longer\n\n#Open data set\nworldsadness2 <- read_csv(\"remake2-self-reported-loneliness-older-adults.csv\",\n                          show_col_types = FALSE)  %>% select(-Code)  %>%\n                          rename( Country = Entity)\n\nworldsadness2$Country <- factor(worldsadness2$Country, \n                               levels=c(\"Denmark\",\"Switzerland\", \"Sweden\",\n                                        \"United States\", \"England\",\n                                        \"Netherlands\",\"Germany\", \"Finland\",\n                                        \"Spain\", \"Belgium\",\"France\", \"Austria\",\n                                        \"Italy\",\"Israel\", \"Greece\"))\nworldsadness2$Age <- factor(worldsadness2$Age, \n                               levels=c(\"65+\", \"65-74\", \"72+\", \"75+\"))\n#Graph\nggplot(worldsadness2)+\n  #establecer los ejes\n  aes(x=Country, y= Sadness, fill= Age)+\n  geom_col(width = 0.75)+#width of bars in relation to the x-axis\n  coord_flip()+\n  #the legend characteristics\n  scale_fill_manual(name = \"Respondents age and \\n data collection year\",\n                      labels = c(\"65+ & 2005\",\n                                 \"65-74 & 2018\",\n                                 \"72+ & 2018\", \n                                 \"75+ & 2002\"),\n                      values = c(\"#BEBEBE\",#Austria and all\n                                \"#4169E1\",#England\n                                \"#A020F0\",#USA\n                                \"#2E8B57\"))+#Finland\n  theme(legend.position = c (.8,.4))+\n  theme(legend.title =  element_text(size = 8, family = \"Playfair Display\",\n                                     hjust=0.4))+\n  theme(legend.text =  element_text(size = 7, family = \"Arimo\"))+\n  #quitar las etiquetas del eje x\n  scale_x_discrete(NULL)+\n  #remove the grid\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),\n  panel.background = element_blank())+\n\n  #now texts content\n  labs(y= NULL,\n       title= \"Self-reported loneliness among older adults\",\n       subtitle = \"Percentage of respondents who reported feeling lonely \\\"some of the time\\\",\\\"most of the time\\\", or \\\"almost \\nall the time\\\", contrary to those who reported feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\" or\\\"never\\\".\",\n       caption = \"Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\")+\n  #now texts characteristics\n  theme(\n    plot.title = element_text(size=17, family = \"Playfair Display\",\n                              color = \"black\"),\n    plot.subtitle = element_text(size=9, family = \"Arimo\", color = \"#555555\",\n                                 lineheight = 0.9, margin= margin(0,0,10,0)),\n    plot.caption = element_text(size = 7, family = \"Arimo\", color = \"#555555\",\n                                lineheight = 0.5, margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 0))+\n  theme(plot.caption =  element_text(hjust = 0))+\n  theme(plot.caption.position = \"plot\")+\n  #add label at the end of the bar\n  geom_text(aes(label = paste(Sadness, \"%\", sep = \"\")), vjust = 0.7, hjust=-0.1,\n            colour = \"#555555\", size= 3, family= \"Arimo\")+\n    #ticks del eje y bien puestos\n  scale_y_continuous(limits = c(0,70), labels = c(\"\",\"\",\"\",\"\",\"\", \"\",\"\"),\n                     breaks = c(0,10,20,30,40,50,60))+  \n   theme(axis.ticks.y = element_blank())+\n  theme(axis.ticks.x =  element_blank())+\n  #both axis text characteristics modified\n  theme(axis.text.x = element_text(size = 10, family = \"Arimo\",\n                                   color = \"#555555\"))+\n  theme(axis.text.y = element_text(size = 9, family = \"Arimo\", face = \"bold\",\n                                   color = \"#555555\", hjust=1, vjust= 0))\n\n\n\nIn order to enhance the chosen graph I worked on the weakness and took advantage\nof its strength.\nAs color was the main problem, I changed the color of the bars to make color\ninformative about the differences between countries in relation to respondents\nage and data collection year. To do so, I used grey as baseline, and three\ndifferent colors: green, purple and blue, to show that most of the countries had\nthe same year of data gathering and respondents age, but there are three\ncountries that differ from the rest. That is why I used four different colors,\nto remark that difference, even though using a color hue would have been more\naesthetically pleasing.\nTherefore, this bars color difference and the legend that explains them,\nallowed me to remove text from the graph subtitle and caption. I have\njust kept information about how the data gathering process took place, and moved\nit from the caption to the subtitle, besides, I have kept the graph reference in\nthe caption. Furthermore, the color legend also allowed me to remove the\ndata gathering year from the end of the bars next to the loneliness proportion.\nThus, the enhanced graph has just the concrete percentage of loneliness next\nto the bar, in order to make it clearer and easier to spot and compere that data.\nMoreover, the x axes percentages have been removed because as I have mentioned,\nthe hierarchical position of bars is already informative about how the\nloneliness percentage varies among the different countries. And at the same time,\nthe percentage labels at the end of the bars provide the concrete differences,\ntherefore, there is no need for percentages from 0% to 60% to appear in the x\naxis, because it is repeating information that is already in the graph.\nAlternative visualization of the graph\nThe graph shows a ranking categorical variable, thus, alternative visualizations\nsuch as lollipop chart, a radar chart or a wordcloud where considered, but they\ndid not have any advantage compared to the bar plot.\nHence, as the categorical variables are country names, and 13 out of 15 are\nEurope countries, I decided to plot the Europe map and add the information about\nIsrael and United States as a reference.\nHowever, one of those countries is England and I really struggled to find a\nEurope map data that included England as a country, until I reread the\ndocumentation of the graph and realized they were talking about data gathered in\nUnited Kingdom, besides the fact that the label on the chosen graph to represent\nthis data, was England. Therefore, from now on the territory represented is\nUnited Kingdom and not England.\nChoropleth map\n\n\n#The data\nworldsadness3 <- read_csv(\"map-self-reported-loneliness-older-adults.csv\", \n                          show_col_types = FALSE)  %>% select(-Code)  %>% \n                          rename( Country = Entity)\n#The map\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nEurope <- world[which(world$continent == \"Europe\"),]\n#To join the data frames, map and data\nmapdata<- Europe %>% left_join(worldsadness3, by = c(\"admin\" = \"Country\"))\n#data as map\nmapdata <- st_as_sf(mapdata)\n# Project the map data into a different coordinate system\nmapdata <- st_transform(mapdata, crs = \"+proj=longlat +datum=WGS84\")\n#The graph\n ggplot(mapdata) +\n  geom_sf(aes(fill= Sadness),color = \"white\",\n          linetype = 1,\n          lwd = 0.25) +\n  coord_sf(xlim = c(-15,50), ylim = c(35,73), expand = FALSE)+\n#Without grid\n  theme_void()+\n#scale color and legend\n   scale_fill_gradient(low=\"yellow\", high =\"red\", limits = c(20,70), name=NULL,\n                      labels = c(\"30%\",\"40%\", \"50%\",\"60%\"),\n                      breaks = c(30,40,50,60),\n                      guide = guide_colourbar(reverse = TRUE))+\n#now texts content\nlabs(\n     title= \"Percentage of elders \\n feeling sad\",\n     subtitle= \"Other countries: \\n USA 30% \\n Israel 48%\",\n     caption = \"Displayed respondents reported feeling lonely \\\"some of the time\\\",\\n \\\"most of the time\\\", or \\\"almost all the time\\\", contrary to those who \\n reported feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\" or \\\"never\\\"\\n \\n Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\")+\n#now texts characteristics\n  theme(\n    plot.title = element_text(size=19, family = \"Playfair Display\",\n                              color = \"black\", lineheight = 0.9),\n    plot.subtitle = element_text(size = 9, family = \"public sans\",\n                                 color = \"#555555\",\n                                 lineheight = 0.8, margin= margin(10,0,0,0)),\n    plot.caption = element_text(size = 8, family = \"public sans\",\n                                color = \"#555555\", \n                                lineheight = 0.8, margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.title = element_text(hjust = 0.5))+\n  theme(plot.caption =  element_text(hjust = 0.5))+\n  theme(plot.caption.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 1))\n\n\n\nA choropleth map is an eye catching visualization that allows to get a general\nidea about the information displayed with just one look.\nThat is due to the fact that size and position inform about the country, and the\nheat map color gradient chosen represent the increasing percentage of sadness\namong countries being yellow the lowest, orange the middle one and red the\nhighest.\nNevertheless, if we compare this map to the enhanced graph, a lot of information\nhas been dropped: the concrete percentage of loneliness for each country, the\ndata collection year and the age of the respondents.\nAs a consequence, I decided to do an interactive map, which will keep all the\nchoropleth map advantages, and at the same time, will display information\nabout the country name, the concrete percentage, the data collection year and\nthe age of the respondents, when moving the pointer over the map.\nInteractive map\n\n\n#The data\nworldsadness4 <- read_csv(\"map-self-reported-loneliness-older-adults.csv\",\n                          show_col_types = FALSE)%>%\n                          select(-Code)  %>%\n                          rename( Country = Entity)\n#The map\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nEurope <- world[which(world$continent == \"Europe\"),]\n#To join the data frames, map and data\nmapdata<- Europe %>% left_join(worldsadness4, by = c(\"admin\" = \"Country\"))\n#data as map\nmapdata <- st_as_sf(mapdata)\n# Project the map data into a different coordinate system\nmapdata <- st_transform(mapdata, crs = \"+proj=longlat +datum=WGS84\")\n#ANIMATED GRAPH\n#Color gradient another function, \ncolor_gradient2 <- colorNumeric(c(\"white\", \"yellow\",\n\"red\", \"darkred\"), 1:65)\nmy_colors3 <- color_gradient2(mapdata$Sadness)\n#labels content\nmylabels <- paste(ifelse(is.na(mapdata$name), \"\", mapdata$name), \"<br/>\",\n                  ifelse(is.na(mapdata$Sadness), \"\", paste(mapdata$Sadness,\"%\")),\n                  \"<br/>\",ifelse(is.na( mapdata$Year), \"\",\n                  paste(\"Data collection:\", mapdata$Year)), \"<br/>\",\n                  ifelse(is.na(mapdata$Age), \"\", \n                         paste(\"Respondents age:\", mapdata$Age)))%>%\n  lapply(htmltools::HTML)\n#title and reference\nhtmltitle <- \"<h5> <b> Percentage of elders feeling sad <b> <\/h5>\"\nEEUU <- \"<h5> USA 30%  <br /> Data collection: 2018 <br /> Respondents age: 72+\n<\/h5>\"\nIsrael <- \"<h5> Israel 48% <br /> Data collection: 2005 <br /> Respondents age: \n65+ <\/h5>\"\n\n#THE GRAPH\nleaflet(mapdata) %>%\n  setView( lat=55, lng=20 , zoom=3)%>%\n  addPolygons(\n    fillColor = my_colors3,\n    stroke = TRUE,\n    color = 'White', \n    weight = 1.5,\n    label = mylabels,\n    labelOptions = labelOptions( \n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"13px\", \n      direction = \"auto\")) %>%\n  \n  addLegend(\n            position = \"bottomright\", \n            pal= color_gradient2, \n            values = ~mapdata$Sadness,\n            na.label = \"No data\",\n            opacity = 0.4,\n            labFormat = labelFormat(suffix=\"%\"),\n            title = \"\") %>%\n  addControl(html=Israel, position = \"topright\") %>%\n  addControl(html=EEUU, position = \"bottomright\") %>%\n  addControl(html=htmltitle, position = \"topleft\")\n\n\n\n\n\n\n",
    "preview": "projects/2022/100485232/100485232_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100348375/",
    "title": "New York Times market share graph",
    "description": "In this article I explain how I replicated a New York Times chart in R and the \nprocess of creating a different chart with ggplot2 with the same data. I'll \nalso explain the limitations of replication and alternative visualization, and\ndiscuss the strengths and weaknesses of both charts, based on data \nvisualization theory.",
    "author": [
      {
        "name": "Isabel Molero Lopez",
        "url": {}
      }
    ],
    "date": "2023-01-13",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nFirst step: replicate the graph\nOriginal graphic source: New York Times\n1. Read and prepare the data\n2. Create the first part of the plot\n3. Create the second part of the plot\n4. Arranging plots\nLimitations of the replication of the graph\n\nChart evaluation based on data visualization theory\nSecond step: create a new visualization with the same data\nPrepare the data\nCreate the static graph\nAdd interactivity with the package ggiraph\n\n\nFirst step: replicate the graph\nOriginal graphic source: New York Times\nThe American newspaper “The New York Times” published in November 2018 an\nopinion article written by columnist David Leonhardt. This journalist explained\nhow in recent years monopolies have increased in the United States despite the\nreluctance of many Americans who consider them a threat to market competition\nand individual freedom. This article is accompanied by a graph showing how the\ncombined market share has changed for the top two companies in many industries.\nThe Monopolization of America\n\n\n\nFigure 1: Source: New York Times\n\n\n\nIn this tutorial I will show how to replicate this data visualization step by\nstep with R and the package ggplot2.\nFirst we have to load the two basic libraries that we will use throughout the\ntutorial: tidyverse and ggplot2\n\n\n# Load libraries:\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n\n1. Read and prepare the data\nSince the chart’s data source was not directly accessible, I created a csv file\nwith the data. This file contains data for three different variables: the type\nof industry, the market share in the year 2000, and the current market share.\nAlso, since in the original graph the positive and negative increases over time\nin the market share are differentiated, I create a new variable (increase)\nwith this information.\n\n\ndata <- read.csv(\"data_graph.csv\", sep = \";\") %>% \n  mutate(increase = market_share_now - market_share_2000,\n         increase2 = case_when(increase > 0 ~ \"positive\",\n                              T ~ \"negative\")) %>%\n  group_by(increase2) %>% \n  arrange(desc(increase))\n\n\nLet’s see how the data is!\n\n\nglimpse(data)\n\nRows: 26\nColumns: 5\nGroups: increase2 [2]\n$ industry          <chr> \"Hardware stores\", \"Shipbuilding\", \"Privat…\n$ market_share_2000 <int> 42, 24, 19, 51, 30, 35, 39, 79, 22, 35, 34…\n$ market_share_now  <int> 84, 62, 55, 82, 61, 61, 60, 99, 41, 52, 49…\n$ increase          <int> 42, 38, 36, 31, 31, 26, 21, 20, 19, 17, 15…\n$ increase2         <chr> \"positive\", \"positive\", \"positive\", \"posit…\n\n\n\nsummary(data)\n\n   industry         market_share_2000 market_share_now\n Length:26          Min.   :19.00     Min.   :23.00   \n Class :character   1st Qu.:31.00     1st Qu.:42.00   \n Mode  :character   Median :38.50     Median :56.50   \n                    Mean   :42.73     Mean   :55.88   \n                    3rd Qu.:51.75     3rd Qu.:62.75   \n                    Max.   :79.00     Max.   :99.00   \n    increase       increase2        \n Min.   :-25.00   Length:26         \n 1st Qu.:  5.50   Class :character  \n Median : 11.50   Mode  :character  \n Mean   : 13.15                     \n 3rd Qu.: 20.75                     \n Max.   : 42.00                     \n\n2. Create the first part of the plot\nThe chosen graph has two distinct parts. The first one shows the evolution of\nthe market share since the early 2000s (2002 to 2007 depending on data\navailability) and the second since 2012. For this reason, I will do the upper\nplot first and then the lower one.\nThe first step, therefore, is to filter the data to use only those that\ncorrespond to the industries included in the first graph. Also, I need to create\na new variable that allows me to order the categorical variable industry from\nthe highest to lowest increase in market share over time (industry_order)\n\n\nupper_plot <- data %>%\n  filter(industry != \"Smartphones\" & industry != \"Social networks\" \n         & industry != \"Cellphone service\") %>% \n  mutate(industry_order = fct_reorder(industry, increase)) \n\n\nCoordinates and axes\nThe graph has Cartesian coordinates, where x is the market share (continuous\nvariable ranging from 0 to 100) and y is the type of industry (categorical\nvariable with 25 different categories). However, in this graph for each y (for\neach industry) we have to plot two points on the x-axis: the market share in the\nearly 2000s and now. But we will see this after in the “Data” section.\n\n\nupper_plot <- upper_plot %>%\n  ggplot() +\n  (aes(x = market_share_2000, \n       y = industry_order))\n\nupper_plot\n\n\n\nAlso, we want the x scale to go from 10% to 100% in steps of 10 and to be at the\ntop of the graph. We achieve all this with the arguments of the\n“scale_x_continuous” function. In the case of the y-axis, we only need to expand\nit slightly at the top to accommodate the labels that need to be entered on the\nchart later.\n\n\nupper_plot <- upper_plot +\n  scale_x_continuous(position = \"top\", \n                     breaks = c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(10, 100),\n                     labels = c(\"10%\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \n                                \"80\", \"90\", \"100\"),\n                     name = NULL,\n                     expand = c(0,0)) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.4, 1.5)))\n\nupper_plot\n\n\n\nLabels\nThe next step is to put the labels we need: the chart title, the subtitle and\nthe tag. For this I use the “labs” function. Later, within the “theme” function,\nI will be able to adjust its characteristics: font size and type, position…\n\n\nupper_plot <- upper_plot +\n    labs(title = \"Dominance of Corporate Behemoths\",\n       subtitle = paste0(\"The combined market share of the two largest companies\",\n       \" in many industries has grown\\n\",\n       \"in recent years, often because of mergers.\"),\n       tag = \"MARKET SHARE:\")\n\nupper_plot\n\n\n\nTheme\nLabel settings\nSince the original graphic uses the “Noto Serif” font, the first thing I do is\ndownload it from Google Fonts\nand install it on my computer. Then I use the function “font_add_google” from\nthe R package “sysfonts” to be able to use it in the graph. Also, in the R\nmarkdown chunk you have to put the following: “fig.showtext= TRUE”.\nNow with the “theme” function I establish the characteristics of the labels that\nI have created before (font size and color, font family, font face…). With the\n“margin” argument I can set the margins (top, bottom, left and right) of each\nlabel. For example, I have added a bottom margin to both the title and the subtitle.\nEven though the “market share” tag now looks like it’s not positioned correctly,\nsince it overlaps the x-axis text, later when I add the margins it will look\nfine.\nOn the other hand, the argument “plot.title.position =”plot” allows both the\ntitle and the subtitle to start at the top corner of the entire plot and not at\nthe beginning of the plot pane.\n\n\nsysfonts::font_add_google(\"Noto Serif\")\n\nupper_plot <- upper_plot +\n    theme(legend.position = \"none\",\n          plot.title = element_text(size = 12, \n                                  face = \"bold\", \n                                  family = \"Noto Serif\", \n                                  margin = margin(0, 0, 5, 0)),\n          plot.subtitle = element_text(size = 9.5, \n                                     colour = \"#636363\", \n                                     family = \"Noto Serif\", \n                                     margin = margin(0, 0, 20, 0)),\n          plot.title.position = \"plot\",\n          plot.tag.position = c(0.12, 0.878),\n          plot.tag = element_text(size = 8.7, family = \"sans\", \n                                colour = \"#a7a7a7\"))\n  \nupper_plot\n\n\n\nPanel grid and panel background\nThe next step is to configure the grid and the background panel, also with\narguments inside the “theme” function. I change the type of line and the color of\nthe line with “element_line” function and I set the background of the chart to\nwhite with “element_rect”.\n\n\nupper_plot <- upper_plot +\n    theme(panel.grid.major.y = element_line(linetype = \"dotted\", \n                                            colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        panel.background = element_rect(fill = \"white\"))\n        \nupper_plot\n\n\n\nAxis text, axis ticks and margins\nThe last step before finishing the theme of the chart is to adjust the ticks of\neach axis (x and y), the titles of the axes and the margins of the chart.\nIn order to bold the “50” on the x-axis I create a vector inside the function\n“element_line”, with the argument “linewidth”. This type of function is not\nofficially supported, so a “warning” appears. However, it works and it’s the\nonly way I’ve found to do it.\n\n\nupper_plot <- upper_plot +\n    theme(axis.ticks.y = element_blank(),\n        axis.ticks.x = element_line(colour = \"#c9c9c9\", \n                                    linewidth = c(0.3, 0.5, 0.5, 0.5, 0.8,\n                                                  0.5, 0.5, 0.5, 0.5, 0.4)),\n        axis.ticks.length.x = unit(0.2, \"cm\"),\n        axis.text.y = element_text(size = 10, family = \"sans\", \n                                   hjust = 0, vjust = 0.5),\n        axis.text.x = element_text(size = 9, family = \"sans\", \n                                   colour = \"#a7a7a7\",\n                                   face = c('plain', 'plain', 'plain', \n                                            'plain', 'bold', 'plain', \n                                            'plain', 'plain', 'plain', 'plain')),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\"))\n  \nupper_plot\n\n\n\nData\nNow is the time to put the data on the chart. To plot the arrows from the 2000’s\nmarket share data to now I use “geom_segment”. In this type of geom you have to\ngive it 4 aesthetics (x, xend, y, y-end). In addition, you can configure the type\nof line (an arrow in this case) and the color, which in this graph depends on\nwhether the increase is positive or negative (variable increase2 created\npreviously). Then, with the “scale_color_manual” function, the colors associated\nwith each category of this variable are set.\nLastly, I’ve also added a thicker vertical line highlighting the 50, using the\n“geom_vline” function.\n\n\nupper_plot <- upper_plot +\n  geom_vline(xintercept = 50, color = \"gray\", linewidth = 0.8) + \n  geom_segment(aes(x = market_share_2000, \n                   xend = market_share_now, \n                   y = industry_order, \n                   yend = industry_order, \n                   color = increase2), \n               arrow = arrow(length = unit(0.15, \"cm\"), \n                             type = \"closed\"), linewidth = 1) +\n  scale_color_manual(values = c(\"#575757\", \"#DB3B27\"))\n\nupper_plot\n\n\n\nAnnotations\nFinally, to finish the first graph, we must add the two annotations. To do this,\nI have used the “annotate” function, using the x and y arguments to get the\nproper final position within the plot area.\n\n\nupper_plot <- upper_plot +\n  annotate(\"text\", x = 34.8, y = 23.9, label = \"Early 2000s\", \n           size = 3, fontface = \"bold\") +\n  annotate(\"text\", x = 86.2, y = 23.9, label = \"Now\", \n           size = 3, fontface = \"bold\") +\n  annotate(\"text\", x = 42, y = 23.4, label = \"|\", \n           size = 3.2, fontface = \"bold\") +\n  annotate(\"text\", x = 84, y = 23.4, label = \"|\", \n           size = 3.2, fontface = \"bold\")\n\nupper_plot\n\n\n\n3. Create the second part of the plot\nTo make the second part of the graphic I have used a very similar code. I have\nfiltered the data to keep only the three industries starting in 2012.\nIn addition, I have removed the title, put a different subtitle and added a\ncaption with the argument “caption” inside the “theme” function.\n\n\nlibrary(grid)\n\nbottom_plot <- data %>%\n  filter(industry == \"Smartphones\" | industry == \"Social networks\" | \n           industry == \"Cellphone service\") %>% \n  mutate(industry = case_when(industry %in% c(\"Cellphone service\") ~ \n                                \"Cellphone service  \",\n                              T ~ industry),\n         industry_order = fct_reorder(industry, increase)) %>% \n  ggplot() +\n  geom_vline(xintercept = 50, color = \"gray\", size = 0.8) +\n  geom_segment(aes(x = market_share_2000, \n                   xend = market_share_now, \n                   y = industry_order, yend = industry_order, \n                   color = increase2), \n               arrow = arrow(length = unit(0.15, \"cm\"), \n                             type = \"closed\"), size = 1) +\n  scale_color_manual(values = c(\"#DB3B27\")) +\n  scale_x_continuous(position = \"bottom\", \n                     breaks = c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(10, 100),\n                     labels = c(\"10%\", \"20\", \"30\", \"40\", \"50\", \n                                \"60\", \"70\", \"80\", \"90\", \"100\"),\n                     name = NULL,\n                     expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 0.8))) +\n  labs(subtitle = \"Technology companies since 2012\",\n       caption = paste0('By The New York Times | Source: IbisWorld and Open',\n       'Markets Institute; \"Early 2000s\" ranges\\n', 'from 2002 to 2007',\n       'depending on data availability')) +\n  theme(legend.position = \"none\",\n        plot.title.position = \"plot\",\n        plot.subtitle = element_text(size = 9.5, family = \"Noto Serif\", \n                                     face = \"bold\", margin = margin(0, 0, 0, 0)),\n        plot.caption = element_text(size = 9, colour = \"#636363\", \n                                    family = \"Noto Serif\", \n                                    hjust = 0, margin = margin(20, 0, 0, 0)),\n        plot.caption.position = \"plot\",\n        panel.grid.major.y = element_line(linetype = \"dotted\", \n                                          colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.ticks.x = element_line(colour = \"#c9c9c9\", \n                                    size = c(0.3, 0.5, 0.5, 0.5, 0.8, \n                                             0.5, 0.5, 0.5, 0.5, 0.3)),\n        axis.ticks.length.x = unit(0.2, \"cm\"),\n        axis.text.y = element_text(size = 10, family = \"sans\", \n                                   hjust = 0, vjust = 0.5),\n        axis.text.x = element_text(size = 9, family = \"sans\", \n                                   colour = \"#a7a7a7\",\n                                   face = c('plain', 'plain', 'plain', \n                                            'plain', 'bold',\n                                            'plain', 'plain', 'plain', \n                                            'plain', 'plain')),\n        panel.background = element_rect(fill = \"white\"),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\")) +\n  annotation_custom(grob = textGrob(label = \"Now\", \n                                    gp = gpar(fontsize = 8.5, fontface = \"bold\", \n                                              fontfamily = \"sans\")),\n                    ymin = 3, xmin = 94.3) +\n  annotation_custom(grob = textGrob(label = \"2012\", \n                                    gp = gpar(fontsize = 8.5, fontface = \"bold\", \n                                              fontfamily = \"sans\")),\n                    ymin = 3, xmin = 52) \n\nbottom_plot\n\n\n\n4. Arranging plots\nNow I am going to show the two plots created previously to see the replication\nof the graph from the New York Times. To join the two graphics I have used the\npatchwork library, specifying that I want them in a single column, with a space\nbetween both graphics and with different heights. All this is configured with\nthe “plot_layout” function.\n\n\nlibrary(patchwork)\n\nupper_plot + plot_spacer() + bottom_plot +\n  plot_layout(ncol = 1,\n              heights = c(11.5, 0.35, 1.5))\n\n\n\nLimitations of the replication of the graph\nThe replication of the plot, created with the R package ggplot2, is very close\nto the original plot. There is a detail that I have not been able to replicate\nexactly. In the lower chart annotations (“2012” and “Now”) I had to expand the\ny-axis to fit them, as they were above the last industry category. Expanding\nthis axis with the “expand” argument of the “scale_y_discrete” function also\nexpanded the grid major x lines. In the original chart, however, these lines do\nnot go as far as the x-axis ticks, but intersect at the first category of the\nindustry variable. For that reason I have also put them closer to the arrow\nthan in the original graph and I have not had to put a line joining the arrow\nwith the annotation (with the geom_segment function).\nChart evaluation based on data visualization theory\nGiven the data the graph represents and the content of the New York Times\narticle it is a good graph. This is a chart called a “lollipop chart” which\nconsists, in short, of a bar chart in which the bar is a line and the end of the\nline is a point (a triangle in this case since they are arrows). Unlike typical\nbar charts, in this chart the bars (or lines) do not start at the same point on\nthe x-axis.\nAt first glance, the colors and size of the arrows already make clear the\nincrease in market share in the vast majority of industries. Positioning on a\ncommon scale is the most effective visual communication channel together with\nthe length, so the choice of this type of representation is a wise one and they\nhave used this highest ranked channels for the most relevant information of the\nplot (the change of the market share and the comparison between industries).\nIn addition, adding the shape of an arrow makes it possible to identify whether\nit is an increase or a decrease in market share. The choice of two colors to\nrepresent the positive and negative values in the difference between years is\nalso very useful as the hue color is a very effective identification channel. It\nis true that it is striking that the positive values are represented in red,\nsocially related to the negative values. However, this may be related to the\ncontent of the article, which seeks to highlight this growth in market share (as\nopposed to the gray assigned to the negative values) and which, in a way, sees\nthis growth as something negative for society.\nAnother positive element to highlight is the order of the industries on the\ny-axis, placed from highest to lowest market share growth. The authors of the\ngraph have also decided to highlight the line on the x-axis that marks 50% of\nthe market share, allowing the observer to identify more quickly which\nindustries have reached a market share above this figure.\nAs for the titles of the axes, the authors have decided to eliminate the y-axis\ntitle since it is easy to know from the labels of each industry which variable\nis represented. The x-axis title is also correctly represented, since it is\nplaced before the first tick, to which they add the “%” symbol so that the\nreader knows what the scale on which it is measured looks like. As soon as you\nlook down at the subtitle, you know that the x-axis measures the market share,\nwhich starts at 10 and is measured as a percentage.\nFinally, the chart has a brief but clear title, which lets the reader know what\nhe or she will find in the chart. The subtitle is also very useful because it\nexpands on the information given in the title, explaining that the graph\nrepresents the market share of two large companies. It also gives a brief\nanalysis to the reader, saying that this share has grown and that it may be a\nconsequence of the mergers. It also adds a second title to help the reader\nunderstand what the second part of the graph is about and a brief, explanatory\ncaption.\nSecond step: create a new visualization with the same data\nIn this section I will explain the process of creating an alternative\nvisualization of the New York Times chart with the same data.\nSince the data to be represented contains one categorical variable (with a large\nnumber of categories) and two continuous variables (ranging from 0 to 100) a bar\nchart is a good idea to represent them. However, as I have explained in the\nprevious section, the original graph is, de facto, a bar chart (with slight\nmodifications of the traditional ones).\nAt first I thought of making a bar chart in which to represent only the\ndifference between the market share of each industry in the early 2000s and now.\nHowever, I think that relevant information would be lost (where was the market\nshare before and now). I also thought about the possibility of making a grouped\nbar chart like these from R Graph Gallery,\nrepresenting on the x or y axis each industry, and on the other axis a bar for\nthe market share in the 2000’s and another for the current market share (each\nwith a different color). However, since the data consists of 25 different\nindustries (50 bars in total) I thought it would be unattractive and difficult\nto understand.\nI finally decided on the option of making a graph of parallel coordinates.\nNormally, in this type of graphs, time series are not represented, but a set of\nvariables are placed on the x-axis and a y-axis (a vertical line) is graphed for\neach variable. According to graphic perception theory, this type of graphic\nwould be slightly less visually effective than the one created by the New York\nTimes. This is because angles are less effective in conveying visual information\nthan position on a common scale (as in the original graphic) and length. However,\nI think it’s also a good way to represent this data in a different way.\nIn this case I have represented the variable industry on the y axis and on\nthe x axis I have made two parallel lines with the data related to the market\nshare of the 2000s and today. Subsequently, I have joined the points between the\ntwo lines of the x axis with a line. Also, I have set two colors in the\naesthetics of the segments: green when the increment is positive and red when it\nis negative. In the case of the green ones, I have put a slightly higher alpha\nin those increases that exceed 40% (value in which the average of the increases\nis), in order to highlight them in the graph. I have decided to put these colors\nbecause we socially associate green with positive or increase and red with\nnegative or decrease.\nOn the other hand, I have labeled the type of industries that exceed that 40%,\nsince labeling all of them was impossible due to overlapping problems. For those\nreaders who want to expand the information, I have added interactivity in such a\nway that if you put the mouse over the lines you can see what type of industry\nit is and the percentage of increase.\nInstead of making two graphs to represent the technology industries starting in\n2012, I have decided to include them by highlighting them with a yellow dot and\na label explaining the difference with the rest of the lines. I thought it\nconvenient to do so in order to be able to compare at a glance the percentage of\ncurrent market share of these industries with that of the rest of the industries.\nFinally, I have kept the same original title, which I think is concise and\nexplicit, and slightly changed the subtitle to highlight information about\nthose industries that have grown proportionally the most.\nNow I will show the code and the steps to follow to create this new\nvisualization!\nPrepare the data\nThe first step is to prepare the data. For this I have created two different\ndata frames. In the first, taking the original dataset, I have created four new\nvariables:\nperc_increase, which is the percentage increase in market share between the\ntwo years.\nperc_increase_label, to add a “+” to the previous variable in case the\nvalue is positive.\nincrease2, with three categories to differentiate positive increases below\n40%, positive increases above 40% and negative.\nindustry_labels, keeps the industry label only in case the percentage\nincrease is greater than 40%.\nThe second data frame contains the market share data for the three technology\nindustries starting in 2012 and an additional column with a 1. This data frame\nwill serve to draw the three dots that indicate that these data are slightly\ndifferent from the rest.\n\n\n# First data frame:\n\nalternative_plot_data <- data %>%\n  ungroup() %>% \n  mutate(perc_increase = round(increase/market_share_2000*100, 1),\n         perc_increase_label = case_when(perc_increase > 0 ~ \n                                           paste0(\"+\", perc_increase),\n                       T ~ as.character(perc_increase)),\n         increase2 = case_when(perc_increase > mean(perc_increase) ~ \n                                 \"high_increase\",\n                               T ~ increase2),\n         industry_labels = case_when(increase2 != \"high_increase\" ~ \"\",\n                              T ~ industry),\n         \"Early 2000s\" = 1,\n         Now = 2) %>% \n  arrange(desc(increase2))\n\nhead(alternative_plot_data)\n\n# A tibble: 6 × 10\n  industry     marke…¹ marke…² incre…³ incre…⁴ perc_…⁵ perc_…⁶ indus…⁷\n  <chr>          <int>   <int>   <int> <chr>     <dbl> <chr>   <chr>  \n1 Smartphones       79      99      20 positi…    25.3 +25.3   \"\"     \n2 Sanitary pa…      53      63      10 positi…    18.9 +18.9   \"\"     \n3 Truck and b…      52      62      10 positi…    19.2 +19.2   \"\"     \n4 Railroads         49      58       9 positi…    18.4 +18.4   \"\"     \n5 Amusement p…      60      69       9 positi…    15   +15     \"\"     \n6 Credit cards      26      35       9 positi…    34.6 +34.6   \"\"     \n# … with 2 more variables: `Early 2000s` <dbl>, Now <dbl>, and\n#   abbreviated variable names ¹​market_share_2000, ²​market_share_now,\n#   ³​increase, ⁴​increase2, ⁵​perc_increase, ⁶​perc_increase_label,\n#   ⁷​industry_labels\n\n\n\n# Second data frame:\n\ndata.frame.points <- data %>%\n  ungroup() %>% \n  filter(industry == \"Smartphones\" | industry == \"Social networks\" \n         | industry == \"Cellphone service\") %>% \n  select(market_share_2000, industry) %>% \n  mutate(x = 1)\n\nhead(data.frame.points)\n\n# A tibble: 3 × 3\n  market_share_2000 industry              x\n              <int> <chr>             <dbl>\n1                79 Smartphones           1\n2                75 Social networks       1\n3                65 Cellphone service     1\n\nCreate the static graph\nData, coordinates and axes\nParallel coordinate plots can be easily created with the ggplot2 extension\n“ggally”, as explained here.\nHowever, in this case I have had to do it with a combination of geom_segment and\n“geom_vline” because the ggally functions don’t support interactivity with either\nggplotly or ggiraph. The function used from the ggiraph package is called\n“geom_segment_interactive”.\nWith “geom_vline” I have created the two vertical and parallel lines where the\nvalues of the market share in 2012 and currently are represented.\nSubsequently, with the geom_segment function I have created the lines that join\nthe values between one date and another.\nIn the geom_segment aesthetic I have specified that I want the color and alpha\nto be associated with the previously created variable increase2 that\ndifferentiates between positive, negative and positive values above 40%\nincrement. To set the values of both aesthetics I have used the\n“scale_color_manual” and “scale_alpha_manual” functions.\n\n\nlibrary(ggiraph)\nlibrary(grid)\nlibrary(ggrepel)\nsysfonts::font_add_google(\"Catamaran\", family = \"catamaran\")\n\nalternative_plot <- alternative_plot_data %>% \n  ggplot() + \n  geom_segment_interactive(aes(x = `Early 2000s`, xend = Now, \n                               y = market_share_2000, yend = market_share_now, \n                               col = increase2,\n                               alpha = increase2,\n                               tooltip = paste0(industry, \" \", \n                                                perc_increase_label, \"%\"),\n                               data_id = industry), \n               size = 0.71, show.legend = F) +\n  geom_vline(xintercept = 1, size = 0.5, color = \"gray\") + \n  geom_vline(xintercept = 2, size = 0.5, color = \"gray\") +\n  scale_color_manual(values = c(\"#006400\", \"#d3101e\", \"#006400\")) +\n  scale_alpha_manual(values = c(0.9, 0.6, 0.5)) +\n  scale_y_continuous(breaks = c(20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(15, 100),\n                     labels = c(\"20\", \"30\", \"40\", \"50\", \n                                \"60\", \"70\", \"80\", \"90\", \"100%\"),\n                     name = \"Market share\",\n                     expand = c(0,0)) +\n  scale_x_discrete(name = \"Now\", position = \"top\", \n                   expand = expansion(add = c(0.02, 0.32))) \n\nalternative_plot\n\n\n\nTheme and labels\nWith the “labs” function I have created the title, the subtitle, the tag, and\nthe caption. I used the “tag” argument to create the “Early 2000s” tag because\nunlike the “annotation” function it allowed me to place it outside the chart\narea without expanding the grid lines. In order to create the parallel label\n“Now” that names the second vertical line, I have used the title of the x axis\nitself.\nWith the “theme” function I have configured all these labs and I have\nestablished a very minimalist theme, with dotted grid lines of the y-axis and a\nwhite background. I also wanted to highlight the “50” of the “y” scale by\nputting it in bold.\nTo put the industry type labels at the end of each line I have used the\n“geom_label_repel” function, thus making sure that they do not overlap each\nother. With the “direction” argument I have specified that in case of\noverlapping I wanted them to move in the y axis, never in the x axis, in such a\nway that they would be aligned.\n\n\nalternative_plot <- alternative_plot +\n  labs(title = \"Dominance of Corporate Behemoths\",\n       subtitle = paste0('The combined market share of the two largest ', \n                         'companies in many industries\\n','has grown in recent', \n                         ' years, often more than 40%.'),\n       tag = c(\"Early 2000s\", \"Now\"),\n       caption = paste0('By Isabel Molero López | Source: New York Times; \"Early 2000s \"',\n       'ranges from 2002 to 2007.\\n', 'Lines that begin with a yellow dot ', \n       'correspond to the data of technology companies since 2012.')) +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = 13.5, face = \"bold\", family = \"catamaran\", \n                                  margin = margin(0, 0, 5, 0)),\n        plot.subtitle = element_text(size = 11.5, colour = \"#636363\", \n                                     family = \"catamaran\", \n                                     margin = margin(0, 0, 30, 0)),\n        plot.title.position = \"plot\",\n        plot.tag.position = c(0.11, 0.88),\n        plot.tag = element_text(size = 11.5, family = \"catamaran\", \n                                colour = \"#636363\", face = \"bold\"),\n        plot.caption = element_text(size = 9.5, colour = \"#636363\", \n                                    family = \"catamaran\", \n                                    margin = margin(15, 0, 0, 0),\n                                    hjust = 0),\n        plot.caption.position = \"plot\",\n        panel.grid.major.y = element_line(linetype = \"dotted\", \n                                          colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.text.y = element_text(size = 10, family = \"catamaran\", \n                                   hjust = 0.7, vjust = 0.5, \n                                   face = c('plain', 'plain', 'plain', \n                                            'bold', 'plain','plain', \n                                            'plain', 'plain', 'plain')),\n        axis.title.x = element_text(hjust = 0.78, margin = margin(0, 0, 20, 0), \n                                    size = 11.5, family = \"catamaran\", \n                                    colour = \"#636363\",\n                                   face = \"bold\"),\n        axis.title.y = element_text(size = 11, family = \"catamaran\", \n                                    colour = \"#636363\", margin = margin(r = 7)),\n        axis.title.x.top = element_text(vjust = 7.6),\n        panel.background = element_rect(fill = \"white\"),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\")) +\n     geom_label_repel(aes(x = 2, y = market_share_now, label = industry_labels,\n                         segment.alpha = 0),\n                    inherit.aes = FALSE, \n                    color = c(\"#505050\"), \n                    alpha = 2, hjust = 1,\n                    size = 3.2,\n                    force = 0.0016,\n                    force_pull = 10,\n                    direction = \"y\",\n                    xlim = c(2, NA),\n                    label.size = NA,\n                    box.padding = 0.002,\n                    family = \"catamaran\")\n\nalternative_plot\n\n\n\nAnnotations and other aditional settings\nFinally, I have added with the “annotate_interactive” function a label that\nindicates the lines that correspond to the technological industries. Also, I’ve\nused the “geom_point” function to put a point at the beginning of these lines so\nthat the reader can quickly identify them. With the “geom_segment” function I\nhave joined the point with the annotation by means of a line. Finally, the\n“geom_hline” function has allowed me to overlay a thicker, black line at 50%,\nthus highlighting industries that have a market share above this value.\n\n\nalternative_plot <- alternative_plot +\n  geom_hline(yintercept = 50, size = 0.7, color = \"black\", linetype = \"dotted\") +\n  geom_segment_interactive(aes(x = 1.01, xend = 1.07,\n                   y = 80, yend = 83.5,\n                   tooltip = \"\",\n                   data_id = 1),\n               size = 0.17,\n               color = \"#E6B400\") +\n  geom_point_interactive(data = data.frame.points, \n                         aes(x, market_share_2000,\n                             tooltip = paste0(industry, \", since 2012\"),\n                             data_id = 1),\n             colour = \"#E6B400\") +\n  annotate_interactive(\"text\", x = 1.09, y = 84.7, label = \"2012\", \n                       size = 3.4, color = \"#E6B400\", \n                       fontface = \"bold\", family = \"catamaran\",\n                       tooltip = \"\", data_id = 1) +\n  annotate_interactive(\"text\", x = 1.11, y = 88, label = \"Technology\", \n                       size = 3.1, color = \"#E6B400\", \n                       fontface = \"bold\", family = \"catamaran\", \n                       tooltip = \"\", data_id = 1) +\n  annotate_interactive(\"text\", x = 1.11, y = 86.5, label = \"companies\", \n                       size = 3.1, color = \"#E6B400\",\n                       fontface = \"bold\", family = \"catamaran\",\n                       tooltip = \"\", data_id = 1)\n\nalternative_plot\n\n\n\nAdd interactivity with the package ggiraph\nInteractivity can be added to the graph previously created to expand information.\nIn this case I have decided that when placing the mouse over each line the rest\nlower their alpha, in such a way that it stands out. In addition, a label\nappears with the name of the industry that corresponds to that line along with\nthe percentage increase or decrease in market share between the different years.\nTo add interactivity I have used the R package “ggiraph”. When making the graph\nitself I have used the geoms from this library (for example,\n“geom_segment_interactive”). Finally, with the “girafe” function the\ninteractivity is added to the created graph and with “girafe_options” the\noptions are set. For example, I have selected the color and background of the\nlabels that appear and the font with “opts_tooltip”. With “opts_hover_inv” I\nhave set the opacity of the rest of the lines when I pass the mouse over one in\nparticular.\nBelow you can see the final result!\n\n\nalternative_plot_interactive <- girafe(ggobj = alternative_plot, width_svg = 6, \n                                       height_svg = 7)\nalternative_plot_interactive <- girafe_options(x = alternative_plot_interactive,\n                    opts_tooltip(\"background-color:gray;color:white;\n                                 font-style:italic;padding:6px;\n                                 border-radius:7px;\"),\n                    opts_hover_inv(css = \"opacity:0.1;\"),\n                    opts_hover(css = \"opacity:1;\"),\n                    opts_sizing(rescale = TRUE, width = 0.75))\n\nalternative_plot_interactive\n\n\n\n\n\n\n",
    "preview": "projects/2022/100348375/100348375_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1209,
    "preview_height": 1728
  },
  {
    "path": "projects/2022/100483851/",
    "title": "Car fleet by antiquity in Spain",
    "description": "Car accident rate is directly related to the antigüity of the vehicle.\nThe graph represents car fleet and its age along 10 years.\nI will replicate it as closely as possible, as weel as providing a \nvisualization alternative.",
    "author": [
      {
        "name": "Maria del Mar Escalas Martorell",
        "url": {}
      }
    ],
    "date": "2023-01-13",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nLoading libraries and letter type\nGetting the data\nBuilding the chart\nCoordinates and axes\nLabels and theme\n\nFinal step: creating an interaction\nAlternative graph\n\nLoading libraries and letter type\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggiraph)\nlibrary(showtext)\nlibrary(ggfittext)\nlibrary(dplyr)\nlibrary(patchwork)\n\nfont_add_google(\"Encode Sans\", family = \"encodesans\")\nfont_add_google(\"Chivo\", family = \"chivo mono\")\nshowtext_auto()\n\n\nThis graph is from an online newspaper article from “El Motor” (El País).\nThe author talks about the higher mortality rate when older cars are involved in\nthe accident.\nOriginal plot by El Motor / El País.Getting the data\nThe data is not openly available, we should have a look at the source mentioned\nin the plot: Traffic General Direction. In this case, data needs to be\ntransformed into percentages and organized in a dataframe manually.\n\n\ndata <- data.frame(Año = c(2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019,\n                           2020),\n                   \"0-4 años\" = c(\"22%\", \"18%\", \"16%\", \"15%\", \"15%\", \"16%\", \n                                  \"18%\", \"20%\", \"21%\", \"20%\"),\n                   \"5-9 años\" = c(\"31%\", \"32%\", \"31%\", \"28%\", \"25%\", \"21%\", \n                                  \"16%\", \"14%\", \"14%\", \"14%\"),\n                   \"10-14 años\" = c(\"24%\", \"26%\", \"27%\", \"27%\", \"27%\", \"28%\", \n                                    \"28%\", \"27%\", \"24%\", \"22%\"),\n                   \"Más de 15 años\" = c(\"23%\", \"25%\", \"26%\", \"29%\", \"33%\", \n                                        \"36%\", \"37%\", \"39%\", \"41%\", \"44%\"),\n                   check.names = FALSE)\n\nmygraph <- data %>% pivot_longer(-\"Año\", \n                                 names_to = \"Antigüedad\",\n                                 values_to = \"Valor\") \n\nmygraph <- mygraph %>%  mutate(Año = as.factor(Año),\n                               Antigüedad = as.factor(Antigüedad),\n                               Valor = as.numeric(str_sub(mygraph$Valor, 1, 2)))\n\nmygraph <- mygraph %>% mutate(Año = fct_reorder(Año, desc(Año)),\n                              Antigüedad = fct_relevel(Antigüedad, \n                                                       \"Más de 15 años\", \n                                                       \"10-14 años\", \"5-9 años\", \n                                                       \"0-4 años\"))\n\n\nBuilding the chart\nCoordinates and axes\nHere we set x and y variables. We introduce “Antigüedad” to differentiate\nsegments in the bar according to age of the vehicles.\n\n\np <- mygraph %>% ggplot(aes(x=Año, y=Valor, fill=Antigüedad)) +\n        geom_bar(stat=\"identity\")\n\np\n\n\n\nAssigning colour to each level of “Antigüedad” and flip coordinates.\n\n\np <- p + scale_fill_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                                    rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) + \n         coord_flip()\n\np\n\n\n\nLabels and theme\nNow, we label the plot, remove both axis labels and background, and organize the\nlegend.\n\n\np <- p + labs(title = \"El parque automovilístico por antigüedad\",\n              caption = \"Fuente: Dirección General de Tráfico. EL MOTOR\") +\n         theme(plot.title = element_text(family = \"encodesans\", face = \"bold\",\n                                         size = 22),\n               plot.title.position = \"plot\",\n               plot.caption = element_text(family = \"encodesans\", \n                                           color = \"gray\", hjust = 1, \n                                           size = 14,\n                                           margin = margin(20,0,0,0)),\n               axis.title.x = element_blank(),\n               axis.text.x = element_blank(),\n               axis.ticks.x = element_blank(),\n               axis.title.y = element_blank(),\n               axis.text.y = element_text(family = \"chivo mono\", size = 20),\n               axis.ticks.y = element_blank(),\n               legend.position = \"top\",\n               legend.title = element_blank(),\n               legend.justification = c(-0.36,1),\n               legend.text = element_text(family = \"encodesans\", size = 18),\n               legend.key.size = unit(0.7, \"cm\"), \n               panel.grid.major = element_blank(),\n               panel.grid.minor = element_blank(),\n               panel.background = element_blank()\n         ) +\n         scale_x_discrete(expand = c(0,0)) + \n         scale_y_discrete(expand = c(0,0)) + \n         guides(fill = guide_legend(reverse=TRUE))\n\np\n\n\n\nOnce we have the basic structure of the plot, it is time to introduce labels\ninside each segment of the bars. This is the most tricky part, as we have to\nbear in mind several aspects:\nTo put labels inside each segment of the bars we should use geom_bar_text().\nIt is similar to geom_text() and it is contained in library(ggfittext).\nAt the time when presenting this work (January 2023) ggfittext package is in\n“maturing” lifecycle, this means that some functions are in an experimental\nphase and may suffer changes and updates.\nIn this particular case, there was not specific documentation for dealing\nwith independent label color changes inside bars. So, I assigned default colors\nfor “Antigüedad” and then changed them manually relating “Values” with the\ndifferent levels of “Antigüedad”.\ngeom_bar_text has a contrast option (TRUE or FALSE) which gives black or\nwhite color to the label based on its background. The problem that I had was\nthat R assigned white labels only for the two darker blues in our plot, leaving\n“10-14 años” with black number labels.\n\n\np <- p + geom_bar_text(aes(label = paste0(`Valor`, \"%\"), colour = Antigüedad),\n                           position = \"stack\", \n                           reflow = TRUE, \n                           place = \"left\",\n                           family = \"chivo mono\",\n                           size = 20) + \n         scale_colour_manual(values = c(`0-4 años` = \"White\", \n                                        `5-9 años` = \"White\", \n                                        `10-14 años` = \"White\", \n                                        `Más de 15 años` = \"Black\"), \n                             guide = \"none\")\n\np\n\n\n\nFinal step: creating an interaction\nTo make the graph interactive I have used the package ggiraph(). Because it is\nvery recent and there is not much documentation and users’ feedback, it has some\nfunctions that are difficult to use or are not extended a lot.\nThe idea that ggiraph proposes is to redefine ggplot functions with the suffix\n_interactive. At the same time, key data has to be provided inside each function\nin order to ggiraph make the interaction. With this mechanism, ggiraph\nidentifies which parts of the plot have to interact and adds this movement to\nthe plot.\nParticularly for this graph, I find the presence f interactivity very important.\nThe way that information inside bars is plotted does not allow to see clearly\nincreases or decreases of percentages all along years (in the case of the two\ncentral columns: “5-9 años” and “10 -14 años”). Interactivity allows the reader\nto select individually these segments and makes them more easy to read.\n\n\ninteractive <- ggplot(mygraph, aes(Año, Valor, fill = Antigüedad, \n                                   data_id = Antigüedad)) +\n  geom_bar_interactive(stat = \"identity\", aes(`data-id`= Antigüedad), \n                       extra_interactive_params = \"data-id\") +\n  scale_fill_manual_interactive(extra_interactive_params = \"data-id\",\n                                 `data-id`= unique(mygraph$Antigüedad),\n                                 values=c(rgb(0.43, 0.89, 0.99), \n                                          rgb(0, 0.66, 0.91), \n                                          rgb(0.02, 0.4, 0.67), \n                                          rgb(0, 0.2, 0.53)),\n                                 guide = guide_legend_interactive(reverse=TRUE),\n                                 data_id = function(breaks) as.character(breaks)) +\n  coord_flip() + \n  labs(title = \"El parque automovilístico por antigüedad\",\n       caption = \"Fuente: Dirección General de Tráfico. EL MOTOR\") +\n  theme(plot.title = element_text(family = \"encodesans\", \n        face = \"bold\", \n        size = 22),\n        plot.title.position = \"plot\",\n        plot.caption = element_text(family = \"encodesans\", \n          color = \"darkgray\",\n          face = \"bold\",\n          size = 14,\n          hjust = 1,\n          margin = margin(20,0,0,0)), \n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.y = element_text(family = \"chivo mono\", size = 20), \n        axis.ticks.y = element_blank(),\n        legend.position = \"top\",\n        legend.title = element_blank(),\n        legend.justification = c(-0.36,1),\n        legend.text = element_text(family = \"encodesans\", size = 18), \n        legend.key.size = unit(0.7, \"cm\"), \n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.background = element_blank()) +\n  scale_x_discrete(expand = c(0,0)) + \n  scale_y_discrete(expand = c(0,0)) +\n  guides(guide_legend_interactive(reverse=TRUE)) +\n  geom_bar_text(aes(label = paste0(`Valor`, \"%\"),\n                    colour = Antigüedad),\n                    position = \"stack\", \n                    reflow = TRUE, \n                    place = \"left\",\n                    family = \"chivo mono\",\n                    size = 20) + # cambiar tipo de letra\n  scale_colour_manual(values = c(`0-4 años` = \"White\", `5-9 años` = \"White\", \n                                 `10-14 años` = \"White\", \n                                 `Más de 15 años` = \"Black\"), guide = \"none\")\n\nfinal <- girafe(ggobj = interactive,\n                width_svg = 10, \n                height_svg = 6,\n                options = list(\n            opts_hover(css = girafe_css(\"stroke-width: 1; opacity: 1;\")),\n            opts_hover_key(css = girafe_css(\"stroke-width: 1; opacity: 0.6;\")),\n            opts_hover_inv(css = girafe_css(\"stroke-width: 1; opacity: 0.1;\"))\n               ))\n\nfinal\n\n\n\nAlternative graph\nThe original graph has some aspects to improve that can be solved with another\ntype of graph. Especially, I am trying to improve readability of data and\ninformation organisation.\nThe original graph has some problems that need to be solved. First, and most\nimportant, is the data itself used. As it can be visually appreciated, there are\nseveral bars which are longer, and others fall short. This is due to a fail in\nthe rounding of data: 2012 and 2016 account for 101%, and 2014 and 2017 only\nreach 99%.\nSo, first step is to recalculate data, adjusting roundings properly. I have also\ntaken the opportunity to translate it into English.\n\n\nalternative <- data.frame(Year = \n               as.factor(c(\"2011\", \"2011\", \"2011\", \"2011\", \"2012\", \"2012\", \n                    \"2012\", \"2012\", \"2013\", \"2013\", \"2013\", \"2013\", \"2014\", \n                    \"2014\", \"2014\", \"2014\", \"2015\", \"2015\", \"2015\", \"2015\", \n                    \"2016\", \"2016\", \"2016\", \"2016\", \"2017\", \"2017\", \"2017\", \n                    \"2017\", \"2018\", \"2018\", \"2018\", \"2018\", \"2019\", \"2019\", \n                    \"2019\", \"2019\", \"2020\", \"2020\", \"2020\", \"2020\")), \n                          Antiquity = \n               as.factor(c(\"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\")),\n                           Value = c(22, 31, 24, 23, 18, 32, 26, 24, 16, 31, 27, \n                                     26, 15, 28, 27, 30, 15, 25, 27, 33, 16, 20,\n                                     28, 36, 19, 16, 28, 37, 20, 14, 27, 39, 21, \n                                     14, 24, 41, 20, 14, 22, 44))\n\n\nThen, I decided to make an alternative that allowed the reader to see the\nchanges all along years, which was one of the objectives that were expressed in\nthe news from where the original graph was taken. For this reason, firstly, I\ndecided to make a simple line graph. I changed axis, so that years are shown in\nthe x axis and the reader can see clearly the tendency that all age groups are\nfollowing. In addition, I assigned darker colors to older age groups, instead of\nwhat the original graph shows (going from dark to bright).\n\n\nfullgraph <- alternative %>% mutate(Antiquity = fct_relevel(Antiquity, \n                                                      \"0-4 years\", \n                                                      \"5-9 years\", \n                                                      \"10-14 years\", \n                                                      \"More than 15 years\")) %>% \n  ggplot(aes(x = Year, y = Value, group = Antiquity, color = Antiquity)) +\n  geom_line(linewidth= 1.2) + \n  labs(title = \"Car park by age in Spain\") +\n  theme_minimal() +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\"),\n    legend.position = c(0.25, 0.87),\n    legend.title = element_blank(),\n    legend.margin = margin(c(0,8,5,5), \"pt\"), \n    axis.title.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.text.x = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"), \n    axis.ticks.y = element_blank(),\n    legend.background = element_rect(fill = \"white\")) +\n  scale_y_continuous(labels = function(x) paste0(x, \"%\"), limits = c(0, 50)) +\n  scale_color_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                              rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) +\n  scale_x_discrete(expand = c(0.01, 0.05)) +\n  guides(color=guide_legend(nrow=2, byrow=TRUE))\n\nfullgraph\n\n\n\nI also created facets to plot individually each group of age, in order for\nthe reader to have an individual view of each of the age segments.\n\n\nalternative2 <- alternative %>% mutate(Antiquity2 = Antiquity)\n\nfacetsalternative <- alternative %>% ggplot(aes(x = Year, \n                                                y = Value, \n                                                group = 1)) +\n  geom_line(data = alternative2 %>% select(-Antiquity), aes(group = Antiquity2), \n            color = rgb(1, 0.65, 0.31), size = 0.7, alpha = 0.3) +\n  ylim(0,50) +\n  geom_line(aes(color = Antiquity),  size = 1.2) +\n  theme(\n    axis.title.x = element_blank(),\n    axis.text.x = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"),\n    axis.ticks = element_blank(),\n    panel.background = element_blank(),\n    panel.grid.major = element_line(color = rgb(0.97, 0.97, 0.97)),\n    panel.grid.minor = element_line(color = rgb(0.97, 0.97, 0.97)),\n    legend.position = \"none\"\n  ) +\n  scale_y_continuous(labels = function(x) paste0(x, \"%\"), limits = c(0, 50)) +\n  scale_x_discrete(expand = c(0.04, 0.04)) +\n  scale_color_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                              rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) +\n  facet_wrap(~factor(Antiquity, levels = c(\"0-4 years\", \"5-9 years\", \n                                          \"10-14 years\", \"More than 15 years\")))\n\nfacetsalternative\n\n\n\nWith patchwork it is easy to join both graphs together.\n\n\ndefinitive_alternative <- fullgraph / facetsalternative\n\ndefinitive_alternative\n\n\n\n\n\n\n",
    "preview": "projects/2022/100483851/100483851_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100376720/",
    "title": "Education Attainment Graph",
    "description": "This project consists in the replicaion and alternative representation of a\ngraph from a New York Times article called \"Where Education Drives Mobility\".",
    "author": [
      {
        "name": "Edgar Chicurel",
        "url": {}
      }
    ],
    "date": "2023-01-12",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nGraph to replicate (two graphs in one)\nLoad libraries and read the database\nAdjusting the data\nFirst graph\nAdjusting the data for second graph\nSecond graph\nMerge both graphs into one\nAlternative Representations\nGraph 1:\nGraph 2\nMerge them together\n\nConclusion\n\nIntroduction\nThe graph for this project was inspired by a New York Times article about education mobility and gender differences in education. The first part of the article talks about how young students’ highest level of education compares to their parents’ highest level of education. Students who achieved a higher level than their parents are considered upwardly mobile, those who achieved the same level are considered to have experienced status quo mobility, and those who achieved a lower level are considered downward mobile. The second part of the article examines gender differences in education at a specific level. You can find the full article here.\nGraph to replicate (two graphs in one)\nThe graph that needs to be replicated is actually two graphs in one. The first graph (on the left) shows the differences in education mobility among OECD countries for students aged 25-34. The graph uses a dark purple color for students who achieved a higher education level than their parents, a light grey color for students who achieved the same level, and a yellow color for students who achieved a lower level. The second graph (on the right) shows the difference for the same countries, except for Russia and Japan (for which data is not available), but by country and gender for students who achieved a highest education level higher than high school. The first graph is a stacked percentage bar graph, and the second graph consists of dotted lines and points. Both graphs have annotations to label the categories. At first glance, the graphs do not appear to be complicated. Here is a link to the original graph:\nGraph to replicateLoad libraries and read the database\nThe first step was to load the libraries, in this case I only used two: tidyverse and patchworks. The second step was to read the database which was on a csv file.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\ndf <- read_csv(\"Data_on_intergenerational_mobility.csv\")\n\n\nAdjusting the data\nIn this part, the data for the first graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Mobility_type” column. After this I created 3 different databases, each one of them containing only one category, this was done in order to arrange the graph in descending order of a specific category inside the “Mobility_type” column.\n\n\neduc <- df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\"\n  ) %>%\n  pivot_longer(cols = ends_with(\"ility\"), \n               names_to = \"Mobility_type\", \n               values_to = \"Mobility_perc\") \n\ndf_order <- educ[educ$Mobility_type == \"Upward_mobility\", ]\ndf_order2 <- educ[educ$Mobility_type == \"Status_quo_Mobility\",]\ndf_order3 <- educ[educ$Mobility_type == \"Downward_Mobility\",]\n\n\nFirst graph\nThe code for this visual representation can be divided into six parts:\nPlotting the data as vertical columns (“stack”) and arranging it in descending order based on the Upward_mobility category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adding a percent symbol or adding extra space).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) + \n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        plot.background = element_rect(fill = \"white\", colour = NA), \n        panel.background = element_rect(fill = \"white\", colour = NA),\n        legend.background = element_rect(fill = \"white\", colour = NA),\n        legend.key = element_rect(fill = \"white\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x))+\n geom_text(data = df_order, \n            aes(x=12, label = ifelse(\n              Country == \"South Korea\", paste0(Mobility_perc, \"%\"), \n              ifelse(\n              Country != \"South Korea\", paste0(Mobility_perc, \"    \"), \n              Mobility_perc))), \n           size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=150, label = ifelse(\n              Country != \"South Korea\", \n              paste0(Mobility_perc, \"       \"), Mobility_perc)), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, \n            aes(x=200, label = Mobility_perc), size=3, \n            position = position_stack(vjust = 0.485)) +\n  labs(\n  subtitle = \"\\nPercentage of people who got more, the same or\\nless education than their parents, as of 2012.\") +\n  theme(\n        plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\", \n                                  margin=margin(0,0,-20,0)),\n        plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                                     margin=margin(0,0,70,0)),\n axis.text.y = element_text(margin=margin(0,-15,0,0))) +\n  annotate(\"text\", x=7.5, y=28, label=\"MORE\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=8, y=26.7, label=\"  (upwardly\\nmobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=3, xend=3, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=60, y=28, label=\"SAME\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=60,  y=26.7, label=\"(status\\n   quo)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=66, xend=66, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=97, y=28, yend = 32, label=\"         LESS\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=97,  y=26.7, label=\"(downardly\\n       mobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=99.9, xend=99.9, y = 23.6, yend = 25.2, \n           color=\"grey30\",alpha = 0.5) +\n  coord_cartesian(xlim = c(0, 200), ylim = c(0, 22), clip = \"off\")\n\n\nAdjusting the data for second graph\nIn this part, the data for the second graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Beyond_Sex” column. After this I created 1 different database, containing only one category, this was done in order to arrange the graph in descending order of that specific category inside the “Beyond_Sex” column, in this case by female.\n\n\nbeyond =  df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\" &\n         Country != \"Russia\" &\n         Country != \"Japan\"\n  ) %>%\n  pivot_longer(\n    cols= starts_with(\"Beyond\"),\n    names_to = \"Beyond_Sex\",\n    values_to = \"Beyond_perc\"\n  ) \n\n\n  bey_ordered = beyond %>% \n    filter(Beyond_Sex == \"Beyond_highscool_2014_F\") %>%\n    arrange(desc(Beyond_perc))\n\n\nSecond graph\nThe code for this visual representation can be divided into seven parts:\nPlotting the data points using “geom_point” and arranging them in descending order based on the Female category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adjusting the position of the first numbers to the left and the position of the second numbers to the right).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nChanging the panel.grid composition to include horizontal dotted lines and solid vertical lines with the correct measures and positions.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np2 = beyond %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_point(size=3, color = \"#5e4c5f\", aes(\n    color = Beyond_Sex), data = bey_ordered) + \n  geom_point(size=3, color = \"#b8bdd0\", aes(color = Beyond_Sex), \n             data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",\n                           ]) +\n  labs(y=NULL) +\n  theme(plot.background = element_rect(fill = \"white\",colour = NA), \n        panel.background = element_rect(fill = \"white\",colour = NA),\n        legend.background = element_rect(fill = \"white\",colour = NA),\n        legend.key = element_rect(fill = \"white\"),\n        legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_text(size = 8.5),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0, \n                                   margin=margin(0,-10,0,0))) +\n  geom_text(data = subset(bey_ordered, \n                          Country %in% c(\n                            \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = 2, nudge_y = 0.1, size=3) +\n  geom_text(\n    data = subset( beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n                           Country %in% c(\n                             \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = -2, nudge_y = 0.1, size= 3) +\nlabs(\n  subtitle = \"Percentage of people who attained\\neducation beyond high scool, as of 2014.\",\n     caption = \"Gender data for Russia and Japan not available.\") +\ntheme(\n  plot.caption = element_text(hjust = 0, size = 7.5, color = \"grey30\", \n                              margin = margin(20,0,0,0)),\n  plot.caption.position = \"plot\",\n  panel.grid.major = element_line(color = '#80808066', linetype = 'dotted'),\n  panel.grid.major.x = element_line(color = '#80808066', linetype = 'solid'),\n  plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                               margin = margin(-30,0,0,0)),\n  plot.title = element_text(colour = \"grey30\"),\n  plot.title.position = \"plot\",\n) +\ncoord_cartesian(xlim = c(3.3, 71.2),ylim = c(1.3, 22), clip = 'off') +\nscale_x_continuous(breaks = c(0, 25, 50), \n                   position = \"top\", \n                   labels = c(\"0\", expression(paste(\"25\",\"%\", \"\")),\"50\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n  annotate(\"text\", x=72, y=25, label=\"WOMEN\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=64, y=23.5, label=\"MEN\",\n            fontface = \"bold\",size=3) +\n  annotate(\"segment\", x=64, xend=64, y = 21.3, yend = 22.9, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"segment\", x=72, xend=72, y = 21.3, yend = 24.4, \n           color=\"grey30\", alpha = 0.5)\n\n\nMerge both graphs into one\nIn the final part, I had to merge both graphs into one.This part was the most tricky for me because the dimensions of the plot were different and a lot of editing of the margins, plot_layout had to be done so they merged correctly. I also added a common title as a plot_annotation and a line in the middle just as the original graph.\n\n\np + p2 + plot_layout(ncol=2,widths=c(6,5)) + \n  annotate(\"segment\", x = -25, xend = -25, y = -15, \n           yend = 30, color = \"grey30\", alpha = 0.3) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nAlternative Representations\nI thought of creating different visual representations to display data. I first tried a tree map, but the values were difficult to read. I then considered using a multi-level circular packing, but this made it difficult to see the relative magnitudes of the values, and there were too many categories because each country was treated as a separate category. As a result, I chose to use the facet_wrap option and split the plot into categories based on the type of mobility for the first plot and sex for the second, with the same y-axis for all categories. I created two separate plots and combined them.\nGraph 1:\nTo create the first graph of the alternative representation, I followed these steps:\nI created a labeller argument to change the titles of each facet.\nI used geom(col) to add the data and arrange it in descending order of Upward_mobility value.\nI used facet_wrap to separate the data by type of mobility.\nIn the theme function, I removed some elements and adjusted others to achieve the desired aesthetics.\nI finally added numbers to the graph by using geom_text and adjusting their size.\n\n\neduc_names <- list(\n  'Downward_Mobility'=\"Downward mobile\",\n  'Upward_mobility'=\"Upward mobile \",\n  'Status_quo_Mobility'=\" Status quo mobile\"\n)\n\n\neduc_labeller <- function(variable,value){\n  return(educ_names[value])\n}\n\na1 = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) +\n    facet_wrap(~Mobility_type, labeller = educ_labeller )+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = df_order, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), \n        Mobility_perc))), size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", \n         paste0(Mobility_perc, \"  \"), Mobility_perc))), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, aes(x=7, \n                                  label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), Mobility_perc))), \n  size=3, position = position_stack(vjust = 0.485)) +\n  labs(\n    subtitle = \"Percentage of people who got more, the same or less education than their parents, as of 2012.\") +\n  theme(\n        plot.subtitle = element_text(colour = \"grey30\", size = 11, \n                                     margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5), plot.title.position = \"plot\")\n\na1\n\n\n\nGraph 2\nThe Second graph of the alternative representation followed similar steps as the alternative graph 1 with the only difference being that now there are two categories that the facet wrap is done by: Female and Male.\n\n\neduc_names2 <- list(\n  \"Beyond_highscool_2014_M\"=\"Beyond higschool males\",\n  'Beyond_highscool_2014_F'=\"Beyond higschool females\"\n)\n\n\neduc_labeller2 <- function(variable,value){\n  return(educ_names2[value])\n}\n\na2 = beyond %>%\n  group_by(Country, Beyond_perc) %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_col(data = bey_ordered, position = \"stack\") +\n  scale_fill_manual(values = c(\"#5e4c5f\", \"#b8bdd0\")) + \n  geom_col(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\", ], \n    position = \"stack\") +\n  geom_col(aes(fill = Beyond_Sex)) +\n    facet_wrap(~Beyond_Sex, labeller = educ_labeller2)+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\", expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = bey_ordered, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n        Beyond_perc))), size=3,\n            position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n         Beyond_perc))), size=3,position = position_stack(vjust = 0.44)) +\n  labs(\n    subtitle = \"Percentage of people who attained education beyond high scool, as of 2014.\") +\n  theme(\n        plot.subtitle = element_text(\n          colour = \"grey30\", size = 11, \n          margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60,80), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\",\"80%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5),\n      plot.title.position = \"plot\")\n\na2\n\n\n\nMerge them together\nIn this part the two alternative graphs are merged together specifying the correct width and height so they look nice and adding a general title for both.\n\n\na2 + a1 + plot_layout(ncol=1) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nConclusion\nReplicating these graphs involved some challenges, such as arranging the data in the desired order of the category and adding specific elements to only a few values like axis titles or geom texts. While the rest of the process was relatively straightforward, the most difficult part for me was merging the two graphs together. Determining the correct dimensions, aspect ratios, plot layout, coordinate limits, etc. was challenging. The final result may not have the exact desired dimensions, but it is similar to the original. I chose the facet_wrap option for the alternative representation because, in my opinion, it was a clear and tidy way to view the data, although it may not have been the most complex method I am satified with the end result.\n\n\n\n",
    "preview": "projects/2022/100376720/original.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 832,
    "preview_height": 871
  },
  {
    "path": "projects/2022/100483841/",
    "title": "Population Perspectives",
    "description": "A graph about population in 2017 and 2100 will be replicated and an\nalternative way of visualizing this graph will be presented.",
    "author": [
      {
        "name": "Victoria Costas Salamanca",
        "url": {}
      }
    ],
    "date": "2023-01-12",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGraph to replicate\nDataframe\nGraph outline\nPlotting the graph: annotations, text and labels\nAlternative graph: plotting the graph\n\nFirst of all, the libraries required for plotting the graph need to be loaded, or if necessary install the packages.\n\n\n#Libraries needed\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggalluvial)\nlibrary(showtext)\nlibrary(ggtext)\n\n\nGraph to replicate\nThis is the original graph.This graph was made by Vollset SE, Goren E, Yuan W. in Fertility, mortality, migration, and population scenarios for 195 countries and territories from 2017 to 2100: a forecasting analysis for the Global Burden of Disease Study. The Lancet 2020. Published online July 14.It shows the ranking by population of the countries in two years 2017 and 2100. Besides it gives some brief insights of the three main populous countries in 2100. It is remarkable that the ranking is from 1 to 10, but 4 other countries are added (the ones which are expected to have huge growth in 20100).\nDataframe\nAs the source of the graph doesn´t provide us with the dataframe we need to create it, since all the data are in the graph is easy to do it, as it follows:\n\n\n#Create my database:\ndf <- read.csv(\"database.csv\")\n\ngroup_colors <- c(China = \"#009ee5\", India = \"#0973cb\", U.S = \"#384aae\",\n                Indonesia = \"#603c9c\", Pakistan = \"#893e9b\", Brazil =\"#be388f\", \n                Nigeria = \"#e75c93\", Bangladesh = \"#e53e48\", Russia = \"#f96439\",\n                Japan = \"#f78c24\", VIRTUAL = \"#FFFFFF\", Ethiopia = \"#f5b314\",\n                Egypt = \"#98b245\", DRC =\"#40b87b\", Tanzania = \"#25a99b\")\n\n\nGraph outline\nWe prepare the outline of the graph, removing the axes, legend and everything that is not the lines. The lines are matched to the population, that is the reason why their width is variable. We match also the lines to the specific color of each country. We code that first line in order to use Constantia font. One of the most important facts of these lines is that the y limits are really big since they match the population, so we need to take this into account.\n\n\n#Needed to use \"Constantia\" Font\n#windowsFonts(\"Constantia\" = windowsFont(\"Constantia\"))\nfont_add(family = \"Constantia\", regular = \"constan.ttf\")\nshowtext_auto()\n\n#Schema of the graph, data and geoms\np <- ggplot(df) +\n  aes(x, y, alluvium=group, fill=group) +\n  geom_alluvium(decreasing=FALSE, alpha=1, width=30, show.legend = FALSE) +\n  scale_fill_manual(values = group_colors) +\n  theme(legend.position = \"none\")+\n  xlim(min(df$x) - 43, max(df$x) + 43) + \n  ylim(min(df$y) - 0.1e9, max(df$y) + 3.7e9) +\n  theme_void()\np\n\n\n\nPlotting the graph: annotations, text and labels\nThe legend in this plot is substituted by side annotations in the right and the left with the value of the population and the ranking, a part from the country. We manually set their position, using horizontal and vertical adjustments (notice that the y axis is really big and we need to use very large numbers). As only one part of the text is modified (with bold, color or size) we use html annotation to do this.\n\n\n#Plotting completely the graph\np +\n  geom_curve(x = 2003, y = 0.40e9, xend = 2114, yend = 0.5e9, linetype=\"dashed\",\n             color = \"black\", size = 0.5, angle = 20, curvature = 0) +\n  #adding labels and text\n  labs(title = \"Here's how IHME projects the most populous \\n countries will change by 2100.\",\n       subtitle = \"Top 10 Countries \\n by Population\") +\n  theme(text = element_text(family = \"Constantia\"),\n        plot.subtitle = element_text(hjust = 0.5, size = 35, face = \"bold\"),  # Center subtitle\n        plot.title = element_text(hjust = 0.5, size = 16)) +\n  annotate(\"text\", x=2025, y = max(df$y) + 3.65e9, label = \"2017\", size = 4) +\n  annotate(\"text\", x=2090, y = max(df$y) + 3.65e9, label = \"2100\", size = 4) +\n  annotate(\"richtext\", x=1988, y = 4.10e9, label = paste0(\n    \"<span style='color: #009ee5; '>#1<\/span> China \",\n    \"<span style='font-size: 20px '><b>1.4B<\/b><\/span>\"),\n    fill = NA, label.color = NA)+\n  annotate(\"richtext\", x=1988, y = 2.75e9, label = paste0(\n    \"<span style='color: #0973cb; '>#2<\/span> India \",\n    \"<span style='font-size: 20px '><b>1.38B<\/b><\/span>\"), \n    fill = NA, label.color = NA)+\n  annotate(\"richtext\", x=1992, y = 1.90e9, label = paste0(\n    \"<span style='color: #384aae;font-size: 10px '>#3<\/span> \",\n    \"<span style='font-size: 10px '> U.S.<b>325M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 1.65e9, label = paste0(\n    \"<span style='color: #603c9c;font-size: 10px '>#4<\/span> \",\n    \"<span style='font-size: 10px '> Indonesia <b>258M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 1.40e9, label = paste0(\n    \"<span style='color: #893e9b;font-size: 10px '>#5<\/span> \",\n    \"<span style='font-size: 10px '> Pakistan <b>214M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 1.20e9, label = paste0(\n    \"<span style='color: #be388f;font-size: 10px '>#6<\/span> \",\n    \"<span style='font-size: 10px '> Brazil <b>212M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 1e9, label = paste0(\n    \"<span style='color: #e75c93;font-size: 10px '>#7<\/span> \",\n    \"<span style='font-size: 10px '> Nigeria <b>206M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1988, y = 0.80e9, label = paste0(\n    \"<span style='color: #e53e48;font-size: 10px '>#8<\/span> \",\n    \"<span style='font-size: 10px '> Bangladesh <b>157M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1990, y = 0.65e9, label = paste0(\n    \"<span style='color: #f96439;font-size: 10px '>#9<\/span> \",\n    \"<span style='font-size: 10px '> Russia <b>146M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0.50e9, label = paste0(\n    \"<span style='color: #f78c24;font-size: 10px '>#10<\/span> \",\n    \"<span style='font-size: 10px '> Japan <b>128M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0.30e9, label = paste0(\n    \"<span style='color: #f5b314;font-size: 10px '>#13<\/span> \",\n    \"<span style='font-size: 10px '> Ethiopia <b>103M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 0.20e9, label = paste0(\n    \"<span style='color: #98b245;font-size: 10px '>#14<\/span> \",\n    \"<span style='font-size: 10px '> Egypt <b>96M<\/b> <\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 0.10e9, label = paste0(\n    \"<span style='color: #40b87b;font-size: 10px '>#18<\/span> \",\n    \"<span style='font-size: 10px '> DRC <b>81M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0, label = paste0(\n    \"<span style='color: #25a99b;font-size: 10px '>#24<\/span> \",\n    \"<span style='font-size: 10px '> Tanzania <b>54M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2122, y = 45e8,\n           label = \"<span style='font-size: 14px'><b>1.09B<\/b><\/span>\",\n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2133, y = 42e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #009ee5;'>#1 <\/span><b>India<\/b> \",\n    \"emerges at the top<br>of the leaderboard, despite<br>\",\n    \"an overall decline in numbers.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2121, y = 36.5e8,\n           label = \"<span style='font-size: 14px'><b>791M<\/b><\/span>\", \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2133.5, y = 33e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #e75c93;'>#2 <\/span><b>Nigeria<\/b> \",\n    \"leads Sub-Saharan<br>Africa as the only region that<br>\",\n    \"will continue to see population<br>growth in 2100.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2121, y = 28e8,\n           label = \"<span style='font-size: 14px'><b>732M<\/b><\/span>\", \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2132, y = 25e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #384aae;'>#3 <\/span><b>China's<\/b> \",\n    \"total population<br>will contract by almost<br>half by 2100.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124.5, y = 20.7e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>336M<\/b><\/span> \",\n    \"U.S. <span style='color: #384aae;'>#4<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127, y = 18.2e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>248M<\/b><\/span> \",\n    \"Pakistan <span style='color: #893e9b;'>#5<\/span><\/span>\"), \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124, y = 15.7e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>246M<\/b><\/span> \",\n    \"DRC <span style='color: #40b87b;'>#6<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127, y = 13.2e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>229M<\/b><\/span> \",\n    \"Indonesia <span style='color: #603c9c;'>#7<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2126.5, y = 11e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>223M<\/b><\/span> \",\n    \"Ethiopia <span style='color: #f5b314;'>#8<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2125, y = 8.8e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>199M<\/b><\/span> \",\n    \"Egypt <span style='color: #98b245;'>#9<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127.5, y = 6.8e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>186M<\/b><\/span> \",\n    \"Tanzania <span style='color: #25a99b;'>#10<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2125.5, y = 3.6e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>165M<\/b><\/span> \",\n    \"Brazil <span style='color: #be388f;'>#13<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2126, y = 2.28e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>106M<\/b><\/span> \",\n    \"Russia <span style='color: #f96439;'>#19<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2128, y = 10e7, label = paste0(\n    \"<span style='font-size: 10px '><span><b>81M<\/b><\/span> \",\n    \"Bangladesh <span style='color: #e53e48;'>#25<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124.5, y = 5e4, label = paste0(\n    \"<span style='font-size: 10px '><span><b>60M<\/b><\/span> \",\n    \"Japan <span style='color: #f78c24;'>#38<\/span><\/span>\"), \n    fill = NA, label.color = NA)\n\n\n\nAlternative graph: plotting the graph\nThe alternative graph is a diverging lollipop chart showing the percentage change in the population of the countries shown between 2017 and 2100. It clearly shows the difference in population from one year to the next and, moreover, how the general trend is one of population decline.\nThis alternative visualisation is based on the fact that the main idea of the graph is not to show the ranking of countries in terms of population, but rather to visualise the evolution of the population between these years (2017 and 2100). About the data we are going to use (created in the dataframe section) we must say that these are values formed from those of the previous graph, with the amount of population of 2100 and 2017 the percentage variation is calculated and from there the graph begins.\n\n\n#Create the dataset\ndf <- read.csv(\"database_alternative.csv\")\n\n# Reorder the rows of the data frame based on the variation values and establish categories\ndf <- df[order(df$variation), ]\ndf$pos_neg <- ifelse(df$variation < 0, \"negative\", \"positive\")\n\n\n\n\n#Create the plot\n\nggplot(df, aes(x = country1, y = variation, color = group_colors)) + #basic plot\n  geom_hline(yintercept = 0, color = \"red\", linetype = \"solid\", size = 2) + #to remark the 0\n  geom_segment(aes(x = country1, xend = country1, y = 0, yend = variation, color = pos_neg), size = 1) + \n  geom_point(size = 8.25, shape = 21, aes(fill = pos_neg, color = pos_neg)) +\n  geom_text(aes(label = variation), color = \"black\", hjust = 0.5, vjust = 0.5,\n            size= 2, fontface = \"bold.italic\")+\n  coord_flip() + #to change axis position\n  theme(legend.position = \"none\",\n        plot.background = element_blank(),\n        panel.background = element_blank()) +\n  #Adding labels and text\n  labs(x= \"Country\") +\n  labs(y = \"Variation (%)\") +\n  labs(title = \"Percentage Change in Population between 2017 and 2100\", size = 20) +\n  labs(subtitle = \"Top 10 Countries by Population in 2017 and 2100 respectively.\", size = 10) +\n  annotate(\"text\", x = 9, y = 246,\n           label = \"Ranking 2017 vs. 2100\", fontface = \"bold.italic\") +\n  annotate(\"text\", x = 8, y = 246,\n           label = \"1. China 1.4B       1. India 1.09B\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 7.25, y = 246,\n           label = \"2. India 1.38B       2. Nigeria 791M\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 6.5, y = 250,\n           label = \"3. U.S. 325M        3. China 732M \",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 6.15, y = 250,\n           label = \"- - - - - - - - - - - - - - -\") +\n  annotate(\"text\", x = 5.7, y = 250,\n           label = \"8. Bangladesh 157M         8. Ethiopia 223M\",\n           size = 3, fontface = \"italic\") +\n  annotate(\"text\", x = 4.95, y = 248,\n           label = \"9. Russia 146M            9. Egypt 199M\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 4.20, y = 250,\n           label = \"10. Japan 128M         10. Tanzania 186M\",\n           size = 3, fontface =\"italic\")\n\n\n\n\n\n\n",
    "preview": "projects/2022/100483841/100483841_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1536,
    "preview_height": 2150
  },
  {
    "path": "projects/2022/100385774/",
    "title": "Social Media Use in 2021",
    "description": "Social Media Use evolution in the USA for 11 major platforms: step-by-step replication of the graph, possible enhancements and alternative visualization.",
    "author": [
      {
        "name": "Álvaro Sanz",
        "url": {}
      }
    ],
    "date": "2023-01-11",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nAbout the graph\nPlot construction\nInitial settings, getting the data\nFont preparation and color setting\nCoordinates, axes and scales\nAdding the data\nTheme settings\nAdding side annotations and last values\n\nEnhancements and alternative visualizations\nPossible changes in the plot\nAlternative visualizations\n\n\nAbout the graph\nBrooke Auxier and Monica Anderson published an article in the Pew Research Center in which they analyzed Social Media Use in 2021 for the Northamerican context, through data collected by the same organization and depicted by them in several graphs. One of them, the objective of this project, visually presents the evolution of use of eleven Social Networks since 2012 (although only 5 of them have available data for the whole time series).\nOriginal graph. Source: Auxier and Anderson, 2021.With it, their objective was to show how despite all controversies and negative feelings towards them, a majority of Northamericans still use at least one, and how their usage has increased through the last years. The goal of this project is to replicate the plot as closely as possible and to offer feasible enhancements and alternative visualizations.\nPlot construction\nInitial settings, getting the data\nFirst of all, we should load into R the necessary libraries to develop our work. In our case, we need the following three:\n\n\nlibrary(tidyverse) #To use the pipe operator and filter data\nlibrary(ggplot2) #To produce the graph\nlibrary(showtext) #To include alternative fonts\n\n\nOnce we prepared our environment, it’s time for us to work with the data. In this case, the Pew Research Center uploaded a PDF file with the specific questions and answers used for the report, from which we created a CSV file. We anticipated our future needs and introduced the different variables in a long format, as we would later need it to develop the plot.\n\n\nread_delim(\"Data/database.csv\")\n\n# A tibble: 53 × 3\n    Year `Social media`   Use\n   <dbl> <chr>          <dbl>\n 1  2012 Twitter           13\n 2  2013 Twitter           14\n 3  2014 Twitter           19\n 4  2015 Twitter           20\n 5  2016 Twitter           21\n 6  2018 Twitter           24\n 7  2019 Twitter           22\n 8  2021 Twitter           23\n 9  2012 Instagram          9\n10  2013 Instagram         14\n# … with 43 more rows\n\nSo, we store our CSV file as a dataframe, also renaming the ‘Social media’ variable into just ‘Social’ for simplicity purposes. Additionally, we filter the first and last data values for each Social Network into another dataframe, as we later will need it to display the points in each side of the lines.\n\n\ndata <- read_delim(\"Data/database.csv\")\n\ndata <- data %>% rename(\n  \"Social\" = `Social media`\n)\n\nfiltered <- data %>% \n  group_by(Social) %>% \n  filter(Year==min(Year)|Year==max(Year))\n\n\nFont preparation and color setting\nIn this step, we start by adding into our document the fonts used by the authors. Note that we included the same font two times, the regular and the bold version; this is because we had some issues while trying to compute the bold aspect manually (with double asterisk at each side of the text).\n\n\nfont_add(family = \"Franklin Gothic\", regular = \"FRAMD.ttf\")\nfont_add(family = \"Franklin Gothic Demi\", regular = \"FRADM.ttf\")\nfont_add(family = \"Georgia\", regular = \"GEORGIAI.ttf\")\nshowtext_auto()\n\n\nThen, we create a vector assigning each possible Social Network to its displayed color in the graph, to then apply it to the lines setting.\n\n\ncolors <- c(\"Youtube\" = \"#bf4538\", \"Facebook\" = \"#23689a\", \n            \"Instagram\" = \"#6c9acf\", \"Pinterest\" = \"#747a46\",\n            \"Linkedin\" = \"#c2c88e\", \"Snapchat\" = \"#746a7c\", \n            \"Twitter\" = \"#d1aa42\", \"Whatsapp\" = \"#253a5c\",\n            \"TikTok\" = \"#e9a03f\", \"Reddit\" = \"#92885a\", \n            \"Nextdoor\" = \"#e28377\" )\n\n\nCoordinates, axes and scales\nOur panel base depends on two axis, years and usage rate (%).\n\n\np <- data %>% ggplot() +\n  aes(Year, Use)\n\np\n\n\n\nPrevious to mapping the data inside the plot, we need to set properly the labels, axes and scales.\n\n\np <- p +\n  scale_x_continuous(\n    name = NULL,\n    limits=c(2012, 2021.9),\n    n.breaks = 10,\n    labels = function(x) paste0(\"'\", substr(x, 3, 4)),\n    expand=c(0,0)\n  ) +\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 100),\n    breaks = c(20, 40, 60, 80),\n    labels = c(\"20\" = \"20\", \"40\" = \"40\", \"60\" = \"60\", \"80\" = \"80\"),\n    expand = c(0,0)\n  ) \n\np\n\n\n\nNow, the first year is ‘12, just as the original plot, and we’ve set the y limits to 100%. We didn’t add the last vertical label, “100%”: this is because it’s placed slightly to the right, as the top grid is shorter than the rest, so we’ll later set it as an individual annotation. We can also check how the x axis doesn’t ’strictly’ end in ’21: this is because we’ve left some space to connect the last values to their labels through segments.\nOne characteristic aspect of this graphic is that it requires a lot of annotations in order to display its elements correctly. As our first one, we’ll set the grid lines (although we’ll not see them properly until applying the theme). The reason behind this is to avoid them extending 2021 when we leave space to connect the last points of data with the labels.\n\n\np <- p +\n  annotate(\"segment\", x=2012, xend = 2021, y=10, yend=10, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=20, yend=20, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=30, yend=30, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=40, yend=40, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=50, yend=50, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=60, yend=60, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=70, yend=70, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=80, yend=80, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=90, yend=90, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012.25, xend = 2021, y=100, yend=100, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=0, yend=0, \n           color = \"grey\", alpha = 0.4) \n\np\n\n\n\nAdding the data\nNow that we’ve prepared the plot’s ‘skeleton’, it’s time for us to add the data. It’s important to do it after adding the grid annotations: if not, they would overlap the geom_line().\n\n\np <- p +  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  scale_color_manual(values = colors) \n\np\n\n\n\nTheme settings\nWe’ll now prepare the theme for previous and further changes. As seen in the original image, the background and plot margins are all white, vertical grid lines are not displayed, there are some margins we need to adjust at the right (to leave space for the labels and values) and at the bottom (to leave space for the last caption, “PEW RESEARCH CENTER”) and there are no axis ticks but for the years. Another important aspect is that the default legend is not included: we will create it manually as a kind of secondary axis, with side annotations.\n\n\np <- p +\n  theme(\n    axis.ticks.x.bottom = element_line(color = \"lightgrey\"),\n    panel.grid.major.y = element_line(colour = \"transparent\"),\n    panel.grid.minor.y = element_line(colour = \"transparent\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    legend.position = \"none\",\n    axis.text.x.bottom = element_text(color=\"grey64\", \n                                    family = \"Franklin Gothic\"),\n    axis.text.y.left = element_text(color=\"grey64\", \n                                    family = \"Franklin Gothic\", hjust=-0.5, size=10),\n    axis.line.x.bottom = element_line(color=\"transparent\"),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    plot.caption = element_text(family = \"Franklin Gothic\", \n                                color = \"grey64\", hjust = 0),\n    plot.caption.position = \"plot\",\n    aspect.ratio = 1.1,\n    plot.subtitle = element_text(family = \"Georgia\", \n                                 color = \"grey64\", hjust = 0.02, size=11),\n    plot.title = element_text(family = \"Franklin Gothic Demi\", hjust = 0, size=14.4),\n    plot.title.position = \"plot\",\n    plot.margin = margin(t=0,\n                         r=17,\n                         b=18,\n                         l=0)\n  ) +\n  annotate(\"text\", label=\"100%\", x=2012, y=100, color = \"grey64\", \n           family=\"Franklin Gothic\", size=3.5, hjust=1) +\n  coord_fixed(xlim=c(2012,2021), clip = 'off') \n\np\n\n\n\nWe also delete the previous grids and set the correct text settings, along with the “100% annotation” (it will display correctly after adding the title and subtitle) and a fixed coordinate system ending in 2021 (with clip = ‘off’ to allow us to annotate outside the plot limits).\nOur next step is to set the title, subtitle, caption and bottom annotation (this last one acting as a tag, but avoiding some placement problems). Note that now the plot space is complete and the “100%” mark does not appear as cut in half.\n\n\np <- p +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of U.S. adults who say they ever use ...\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown. Pre-2018 telephone poll\",\n       \"data is not available for Youtube, Snapchat and Whatsapp; pre-2019 telephone poll data is\",\n       \"not available for Reddit. Pre-2021 telephone poll data is not available for TikTok. Trend\",\n       \"data is not available for Nextdoor.\",\n       \"Source: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\"Social media use in 2021\"',  sep=\"\\n\")) +\n  annotate(\"text\", label= \"PEW RESEARCH CENTER\", x=2012, y=0, vjust=16.5, \n           hjust=0.15, family = \"Franklin Gothic\", size=2.8)\n\npbase <- p\n\np\n\n\n\nAdding side annotations and last values\nAs we previously mentioned, the legend in this plot is substituted by side annotations with the last value for each series. We manually set their position, using horizontal and vertical adjustments.\n\n\np <- p +\n  annotate(\"text\", label=\"YouTube\", y=81, x=2021, hjust=-0.8, size=3.5, \n           family = \"Franklin Gothic\", color = \"#bf4538\") +\n  annotate(\"text\", label=\"Facebook\", y=69, x=2021, hjust=-0.73, size=3.5, \n           family = \"Franklin Gothic\", color = \"#23689a\") +\n  annotate(\"text\", label=\"Instagram\", y=46, x=2021, hjust=-0.68, size=3.5, \n           family = \"Franklin Gothic\", color = \"#6c9acf\") +\n  annotate(\"text\", label=\"Pinterest\", y=40, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#747a46\") +\n  annotate(\"text\", label=\"LinkedIn\", y=34.5, x=2021, hjust=-0.82, size=3.5, \n           family = \"Franklin Gothic\", color = \"#c2c88e\") +\n  annotate(\"text\", label=\"Snapchat\", y=29, x=2021, hjust=-0.72, size=3.5, \n           family = \"Franklin Gothic\", color = \"#746a7c\") +\n  annotate(\"text\", label=\"Twitter\", y=24.5, x=2021, hjust=-0.96, size=3.5, \n           family = \"Franklin Gothic\", color = \"#d1aa42\") +\n  annotate(\"text\", label=\"WhatsApp\", y=19, x=2021, hjust=-0.65, size=3.5, \n           family = \"Franklin Gothic\", color = \"#253a5c\") +\n  annotate(\"text\", label=\"TikTok\", y=15, x=2021, hjust=-1.03, size=3.5, \n           family = \"Franklin Gothic\", color = \"#e9a03f\") +\n  annotate(\"text\", label=\"Reddit\", y=11, x=2021, hjust=-1.05, size=3.5, \n           family = \"Franklin Gothic\", color = \"#92885a\") +\n  annotate(\"text\", label=\"Nextdoor\", y=6, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#e28377\") +\n  \n  annotate(\"text\", label=\"81\", y=81, x=2021, hjust=-6.6, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=69, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=46, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=40, x=2021, hjust=-6.5, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=34.5, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=29, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=24.5, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=19, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=15, x=2021, hjust=-6.7, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=11, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=6, x=2021, hjust=-7, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\")\n\np\n\n\n\nAnd finally, we set the lines that join each last point with its Social Network, using the expanded limits we set a few steps ago and also manually adjusting their position via hjust and vjust.\n\n\np <- p +\n    #YouTube\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=81, yend=81, color=\"grey\") +\n  #Facebook\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=69, yend=69, color=\"grey\") +\n  #Instagram\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=40, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=40, yend=46, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=46, yend=46, color=\"grey\") +\n  #Pinterest\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=31, yend=31, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=31, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=40, yend=40, color=\"grey\") +\n  #LinkedIn\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=28, yend=28, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=28, yend=34, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=34, yend=34, color=\"grey\") +\n  #Snapchat\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=25, yend=25, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=25, yend=29, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=29, yend=29, color=\"grey\") +\n  #Twitter\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=24, yend=24, color=\"grey\") +\n  #Whatsapp\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=23, yend=23, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=23, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=18, yend=18, color=\"grey\") +\n  #TikTok\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=21, yend=21, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=21, yend=15, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=15, yend=15, color=\"grey\") +\n  #Reddit\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=18, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=18, yend=10, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=10, yend=10, color=\"grey\") +\n  #Nextdoor\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=13, yend=13, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=13, yend=6, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=6, yend=6, color=\"grey\")\n\np\n\n\n\nEnhancements and alternative visualizations\nPossible changes in the plot\nWhen looking at the graph by Auxier and Anderson, the first thing that can come to our minds is that, although the evolution through the last 9 year appears to be clear, the discriminability could be better. There are categories with the same color as others, and the distribution seems to be only ‘reasonable’ for the top two Social Networks, YouTube and Facebook, as they are depicted with their corporative colors. This is specially problematic if we take a look at the mid-bottom part of the chart, which compiles a lot of values very close to each other, resulting into some potential confusion at identifying each line or point with their respective category.\nAnother way of improving each category’s identification with the lines could be expanding the plot margins a little bit to the bottom, to avoid the excessive proximity between points that also results into very close reference lines, but we didn’t attempt to do it because excessive height for temporal series plots may distort the evolution shown, making it too difficult to visually see.\n\n\np <- pbase +\n  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  \n  annotate(\"text\", label=\"YouTube\", y=81, x=2021, hjust=-0.8, size=3.5, \n           family = \"Franklin Gothic\", color = \"#bf4538\") +\n  annotate(\"text\", label=\"Facebook\", y=69, x=2021, hjust=-0.73, size=3.5, \n           family = \"Franklin Gothic\", color = \"#23689a\") +\n  annotate(\"text\", label=\"Instagram\", y=46, x=2021, hjust=-0.68, size=3.5, \n           family = \"Franklin Gothic\", color = \"#d50167\") +\n  annotate(\"text\", label=\"Pinterest\", y=40, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#911821\") +\n  annotate(\"text\", label=\"LinkedIn\", y=34.5, x=2021, hjust=-0.82, size=3.5, \n           family = \"Franklin Gothic\", color = \"#0a63bc\") +\n  annotate(\"text\", label=\"Snapchat\", y=29, x=2021, hjust=-0.72, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f7ce2c\") +\n  annotate(\"text\", label=\"Twitter\", y=24.5, x=2021, hjust=-0.96, size=3.5, \n           family = \"Franklin Gothic\", color = \"#189ef3\") +\n  annotate(\"text\", label=\"WhatsApp\", y=19, x=2021, hjust=-0.65, size=3.5, \n           family = \"Franklin Gothic\", color = \"#25ca45\") +\n  annotate(\"text\", label=\"TikTok\", y=15, x=2021, hjust=-1.03, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f70079\") +\n  annotate(\"text\", label=\"Reddit\", y=11, x=2021, hjust=-1.05, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f74301\") +\n  annotate(\"text\", label=\"Nextdoor\", y=6, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#8ace00\") +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of U.S. adults who say they ever use ...\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown. Empty values represent\",\n       \"not available data for that Social Network in that specific year.\",\n       \"Source: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\"Social media use in 2021\"',  sep=\"\\n\")) +\n    #YouTube\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=81, yend=81, color=\"grey\") +\n  #Facebook\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=69, yend=69, color=\"grey\") +\n  #Instagram\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=40, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=40, yend=46, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=46, yend=46, color=\"grey\") +\n  #Pinterest\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=31, yend=31, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=31, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=40, yend=40, color=\"grey\") +\n  #LinkedIn\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=28, yend=28, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=28, yend=34, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=34, yend=34, color=\"grey\") +\n  #Snapchat\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=25, yend=25, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=25, yend=29, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=29, yend=29, color=\"grey\") +\n  #Twitter\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=24, yend=24, color=\"grey\") +\n  #Whatsapp\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=23, yend=23, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=23, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=18, yend=18, color=\"grey\") +\n  #TikTok\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=21, yend=21, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=21, yend=15, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=15, yend=15, color=\"grey\") +\n  #Reddit\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=18, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=18, yend=10, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=10, yend=10, color=\"grey\") +\n  #Nextdoor\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=13, yend=13, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=13, yend=6, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=6, yend=6, color=\"grey\") +\n  \n  annotate(\"text\", label=\"81\", y=81, x=2021, hjust=-6.6, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=69, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=46, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=40, x=2021, hjust=-6.5, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=34.5, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=29, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=24.5, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=19, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=15, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=11, x=2021, hjust=-6.8, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=6, x=2021, hjust=-7.05, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\")\n\np\n\n\n\nWe also abbreviated the plot’s note, only mentioning that not shown data is not available and reducing the total amount of text shown in the graph.\nOne of the article’s objectives was to show that although there is a certain degree of negative feelings towards social media, a high percentage of the Northamerican population still uses at least one. If we added some context underneath the evolution lines, that also showed evolution of other types of media (TV, Newspaper, Radio…), the viewer could easily contextualize the information, while making the graph richer. We understand this is a limitation of the used data, but they could use some alternative surveys also indicating in the caption that it comes from a different source.\nLet’s make some fictitious data in our CSV, adding TV usage, in order to see how it would look:\n\n\nread_delim(\"Data/database2.csv\") %>% \n  rename(\n  \"Social\" = `Social media`\n) %>% \n  filter(Social==\"TV\")\n\n# A tibble: 10 × 3\n    Year Social   Use\n   <dbl> <chr>  <dbl>\n 1  2012 TV        54\n 2  2013 TV        52\n 3  2014 TV        53\n 4  2015 TV        50\n 5  2016 TV        45\n 6  2017 TV        43\n 7  2018 TV        42\n 8  2019 TV        37\n 9  2020 TV        35\n10  2021 TV        33\n\nTV <- read_delim(\"Data/database2.csv\") %>% \n  rename(\n  \"Social\" = `Social media`\n) %>% \n  filter(Social==\"TV\")\n\n\n\n\np <- p +\n  geom_col(data = TV, aes(Year, Use), alpha=0.35, width = 0.8) +\n  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  annotate(\"text\", label=\"TV usage\", x=2016.3, y=56,  color=\"grey\", \n           size = 3.5, family = \"Franklin Gothic\") +\n  annotate(\"segment\", x=2015, xend=2015.8, y=50, yend=55, color=\"grey\")\n\np\n\n\n\nAlternative visualizations\nApart from these potential enhancements on the same graph, we could also imagine of new ways of representing the data, maybe more aligned with the objective of the article and the title itself. The way we see it, the importance remains in the current distribution of usage between different Social Media, which tells the reader that there is a high percentage of Northamerican consumers who use them despite bad social perceptions.\nThe evolution since 2012 (temporal mark when the graphic has no data for more than half of the categories) is also important, but can be transformed to make it more adequate, maybe taking 2018 as starting point.\n\n\nnew <- data %>%\nfilter(\n  Year>2017 & Year<2022\n) %>% \n  group_by(Social) %>% \n  filter(Year == max(Year) | Year == min(Year))\n\n\nWe set our last values, create a new column with the evolution since 2018 for each Social Media and leave only the 2021 value, also creating a zero column that will be the starting point.\n\n\nnew <- new %>% group_by(Social) %>% \n  mutate(\n    evo = last(Use) - first(Use),\n    zero = 0\n  ) %>% \n  filter(Year == max(Year))\n\n\nThe idea is to give more importance to the current ranking position (y position) and the latest evolution (x position), using a lollipop graph displaying the last trend.\nWe could also add the logos from each Social Network next to every name, to improve the understanding of the graph for those readers who are not very familiar with Internet.\n\n\nnew %>% ggplot() +\n  aes(zero, reorder(Social, Use)) +\n  geom_segment(aes(xend=evo, yend = Social), color = colors) +\n  scale_x_continuous(limits = c(-10,10), n.breaks = 10) +\n  geom_point(aes(evo), size = 2, shape = 21, fill=colors, stroke = 1, color = colors) +\n  scale_color_manual(values = colors) +\n  theme_light() +\n  theme(\n    panel.grid.major.y = element_line(colour = \"lightgrey\", linetype = \"dotted\"),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"lightgrey\", linetype = \"dotted\"),\n    panel.grid.minor.x = element_line(colour = \"grey\", linetype = \"dotted\"),\n    axis.title.x.bottom = element_text(),\n    plot.subtitle = element_text(family = \"Georgia\", \n                                 color = \"grey64\", hjust = 0.02),\n    plot.title = element_text(family = \"Franklin Gothic Demi\", hjust = 0, size= 17),\n    plot.caption = element_text(family = \"Franklin Gothic\", \n                                color = \"grey64\", hjust = 0),\n    panel.border = element_blank(),\n    axis.text.y.left = element_text(color = \"gray30\", family = \"Franklin Gothic\", size = 10),\n    axis.title.y.left = element_blank(),\n    plot.margin = margin(t=0,\n                         r=0,\n                         b=20,\n                         l=0)\n  ) +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of growth of Social Media Usage for ... ('18-'21)\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown.\",\n       \"Temporal series start in 2018\\nfor all Social Media except for\",\n       \"TikTok and Nextdoor (2021)\",\n       \"\\nSource: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\\n\"Social media use in 2021\"'),\n        x = \"% evolution\") +\n  annotate(\"text\", label = \"PEW RESEARCH CENTER\", family = \"Franklin Gothic\", \n           x=-10, y = 0, vjust = 12.5, hjust=0.16, size = 3.5) +\n  coord_fixed(clip = \"off\") +\n  annotate(\"text\", label=\"81\", y=\"Youtube\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=\"Facebook\", x=10, hjust=-2.2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=\"Instagram\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=\"Pinterest\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=\"LinkedIn\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=\"Snapchat\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=\"Whatsapp\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=\"Twitter\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=\"TikTok\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=\"Reddit\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=\"Nextdoor\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"% in 2021:\", y=\"Youtube\", x=10, hjust=-0.15, vjust=-2, size=4, \n           family = \"Franklin Gothic\", color=\"gray30\")\n\n\n\nSo, with less complexity we’ve displayed the most important information that the article makes reference to, also reducing the used years to the last 4, that are also the most relevant ones, as the title says. We’ve also avoided the excessive dependence on the original graph on annotations and lines, so you can easier identify all values and labels with the segments.\n\n\n\n",
    "preview": "projects/2022/100385774/100385774_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100484017/",
    "title": "Effect of the introduction of the polio vaccine in the US",
    "description": "This project has two purposes: to reproduce the plot published in 2015 in the Wall Street Journal article 'Battling Infectious Diseases in the 20th Century: The Impact of Vaccines', and to propose an improved visualization.",
    "author": [
      {
        "name": "Juan Diego Mendez",
        "url": {}
      }
    ],
    "date": "2023-01-11",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nPolio Vaccine in the US\nOriginal Plot - WSJ\nReproducing de Original Plot\nData Source –> tycho.pitt.edu\nCleaning Data\nColors\nOriginal Plot\n\nImproved plot\n\nPolio Vaccine in the US\nThe polio vaccine is an important tool in the fight against polio, a highly infectious disease that can cause paralysis and death. Polio is caused by a virus that spreads through contaminated food and water and can attack the nervous system, leading to paralysis in some cases.\nThe first polio vaccine was developed in the 1950s by Dr. Jonas Salk. The first mass vaccination campaign against polio was launched in April of 1995 in the US. The oral polio vaccine was introduced in the US in 1961 and became the primary vaccine used for routine polio vaccination in the US in the 1970s.\nSince the introduction of the polio vaccine in the US, the incidence of polio has decreased dramatically. The last case of wild poliovirus was reported in 1979, and the disease has been considered eradicated in the US since 2000. The success of the polio vaccine in the United States and around the world has been one of the greatest public health achievements of the 20th century.\nOriginal Plot - WSJ\nThe original plot was created by Tynan DeBold and Dov Friedman and published in February 2015 in an article in the Wall Street Journal, and is part of a series of graphics showing the effect of vaccines on different diseases such as measles, heaptitis A, mumps, pertussis, rubella, among others.\nOriginal Plot. Source: WSJ.The visualization was so good that it had a great impact on social networks…\nBill Gates’ reaction.Reproducing de Original Plot\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(forcats)\nlibrary(scales)\nlibrary(viridis)\nlibrary(grDevices)\nlibrary(plotly)\nlibrary(systemfonts)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(RColorBrewer)\nlibrary(showtext)\n\n\nData Source –> tycho.pitt.edu\nThe data in the original plot is from tycho.pitt.edu, a research project aimed at improving the standards, machine readability and availability of global health data, which is sponsored by the University of Pittsburgh in the US.\nHowever, when we consulted the historical records of polio cases registered in the USA, we found that there are several polio viruses: Acute nonparalytic poliomyelitis, Acute paralytic poliomyelitis, Acute poliomyelitis.\nThe original plot does not specify which of the three viruses it refers to, so it was decided to use the information of all the viruses that make up the polio disease.\nAcute nonparalytic poliomyelitis\n\n\nPolio  <- read_csv(\"tycho_20221212-145444.csv\",\n                    col_types = cols_only(Admin1Name = col_guess(),\n                                          PeriodStartDate = col_guess(), \n                                        CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nAcute paralytic poliomyelitis\n\n\nPolio1 <- read_csv(\"tycho_20221215-094815.csv\",\n                   col_types = cols_only(Admin1Name = col_guess(),\n                                         PeriodStartDate = col_guess(), \n                                         CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nAcute poliomyelitis\n\n\nPolio2 <- read_csv(\"tycho_20221215-095240.csv\",\n                   col_types = cols_only(Admin1Name = col_guess(),\n                                         PeriodStartDate = col_guess(), \n                                         CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nCleaning Data\nWe now have the three clean data sets with the number of cases by State and by date.\nNext we will merge the three data sets into one and then add up all the cases so that we have a consolidated file.\n\n\nAbb <- read_delim(\"US State Abbreviations.csv\", \n    delim = \";\", escape_double = FALSE, trim_ws = TRUE)\n\nPoliojoint <- full_join(Polio2, Polio1, by = c(\"State\" = \"State\", \"Date\" =\"Date\"))\n\nPoliojoint1 <- full_join(Poliojoint, Polio, by = c(\"State\" = \"State\", \"Date\" =\"Date\"))\n\nPoliojoint2 <- left_join(Poliojoint1, Abb, by = c(\"State\" = \"States\"))\n\nPolio_sum <- Poliojoint2 %>%  mutate_at(c('Cases.x', 'Cases.y', \"Cases\"), as.numeric) %>% \n  mutate(sum_cases = rowSums(across(where(is.numeric)), na.rm=T), .keep = \"unused\") %>% \n  filter(Date >= '1928-01-01') %>% rename(States = Abb) %>% select(-State)\n\n\nColors\nTo copy the colors of the original plot, I used the website “html-color-codes.info” which allows to upload the image and obtain all the codes present in the image.\n\n\ncols <- c(colorRampPalette(c(\"#e7f0fa\", \"#c9e2f6\", \"#95cbee\", \"#0099dc\",\"#BAC843\", \n                            \"#4ab04a\", \"#ffd73e\", \"#eec73a\", \"#e29421\", \"#e29421\", \n                            \"#f05336\",\"#ce472e\"),bias=1)(11))\n\n\nOriginal Plot\nThe original graph is a heat map showing the number of polio cases reported in each U.S. state over time. For that reason, the x-axis will be the US states, and the y-axis will be the years and the plot will be filled by the number of cases.\n\n\np <- Polio_sum %>% ggplot() +\n  aes(x=Date, y=fct_rev(States),fill=sum_cases)\np\n\n\n\nAs this is a heatmap, to add rectangles we will use the geom_tile function. Additionally, the original plot has white spaces between the rectangles, so we are going to specify this inside the function.\n\n\np <- p + geom_tile(colour=\"white\", lwd = 0.2, linetype = 1)\np\n\n\n\nNext we are going to use the scale_fill_gradientn() function to set the fill color of the rectangles in a continuous gradient. The colors argument specifies the colors to use in the gradient, for which we will use the color palette defined above (“cols”). Then we define the minimum and maximum limits, which correspond to the minimum and maximum number of polio cases in a year. We include the breaks at which the gradient should change color, and specify the labels for these values.\nAdditionally, we use the guide argument to control the appearance of the color bar displayed next to the plot. For this purpose we define gradient marks, number of intervals to use for the gradient, and the color bar height and width arguments, respectively.\n\n\n p <- p+theme_minimal()+\n  scale_fill_gradientn(colours=cols,limits=c(0, 300),\n                       breaks=seq(0, 300, by=50),\n                       labels=c(\"0\", \"50\", \"100\", \"150\", \"200\", \"250\", \"300\"),\n                       guide=guide_colourbar(ticks=T, \n                                             nbin=50,\n                                             barheight=.6, \n                                             label=T, \n                                             barwidth=8, \n                                             ticks.colour= \"grey\", \n                                             ticks.linewidth = 0.5))\np\n\n\n\nWe use scale_x_date() function to set the scale of the x-axis to a date format. Then we need to specify the amount of space to add around the data. A value of c(0,0) means no space is added.\nThe breaks argument specifies the positions of the tick marks on the x-axis. In this case, the seq() function is used to generate a sequence of dates at 5-year intervals from 1930 to 1965.The date_labels argument specifies the format to use for the labels of the tick marks. In this case, the format “%Y” is used, which displays the year in four digits.\n\n\np <- p+ scale_x_date(expand=c(0,0), \n                     breaks = (seq(ymd(\"1930-01-01\"), ymd(\"1965-01-01\"), \n                                   by = \"5 years\")), \n                     date_labels = \"%Y\") \np\n\n\n\nTo include the line indicating the time at which the vaccine was introduced, we will use the function geom_segment(). In this case, the line segment will start at the date “1955-01-01” and end at the same date, so it will be a vertical line.\n\n\n p <- p + geom_segment(x=as.Date(\"1955-01-01\"), xend=as.Date(\"1955-01-01\"), \n                       y=0, \n                       yend=52.5, \n                       size=.9)\np\n\n\n\nNow we want to find the right font. For that we use the website “What the Font” which tells us the font used. However, the exact font has a high cost and is not available. Therefore, we searched Google fonts for the closest possible match, and found the Tajawal family font.\nTo use this font we make use of the “showtext” package, then we select the Google font we want using font_add_google(“Tajawal”), and then we call showtext_auto() to indicate that showtext is going to be automatically invoked to draw text whenever the plot is created.\n\n\nfont_add_google(\"Tajawal\")\nshowtext_auto()\n\n\nNow we use different functions to modify the appearance of the chart to make it resemble the original. The labs() function is used to remove the x-axis, y-axis and fill legend labels. The ggtitle() function is used to set the chart title. The theme() function is used to customize various aspects of the chart appearance, for example the aspect ratio, legend position, and axis labels and markings.\n\n\n p <-  p + labs(x=\"\", y=\"\", fill=\"\")+\n  ggtitle(\"Polio\") +\n  theme(    legend.position= \"bottom\",\n        legend.direction=\"horizontal\",\n        legend.text=element_text(colour=\"grey20\"),\n        axis.text.y=element_text(size=8, family=\"Tajawal\", \n                                 hjust=1),\n        axis.text.x=element_text(size=6),\n        axis.ticks.y=element_blank(),\n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5),\n        panel.grid=element_blank(),\n        title=element_text(hjust=-.07, face=\"bold\", vjust=1, \n                           family=\"Tajawal\"),\n        text=element_text(family=\"Tajawal\"))\np\n\n\n\nFinally, we add a label with the text “Vaccine introduced” to the plot at the specified x and y coordinates, using the specified font size and font family. The label will be aligned top left and the aspect ratio of the plot will be set.\n\n\n  p <- p+ annotate(\"text\", x=as.Date(\"1955-01-01\"), y=55, label=\"Vaccine introduced\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\")\np\n\n\n\nAs can be seen, the plots are not identical because the data set used is not the same.\nAn attempt was made to use the same data set to replicate the original plot as closely as possible, but the same dataset was not found. For this reason, it was decided to use the three datasets with the three viruses that make up the polio, resulting in a slightly different plot.\nIn this version, we can see that after the introduction of the vaccine in 1955 there was no drastic decrease in the number of cases, but on the contrary there was a slight increase in 1956. In addition, we can see that the number of cases actually dropped significantly after 1961, which coincides with the date when an improved version of the vaccine was introduced in the US.\nImproved plot\nIt is a great challenge to make an improvement of a plot so well done and with so many recognitions. In fact, I personally consider that the original plot is the best way to visualize the effect of a vaccine in reducing the number of positive cases of contagion.\nTherefore, I am not going to propose a new plot. Instead, I am going to improve the original plot by adding more useful information.\nFirst, as the most important thing is to see the effect of the vaccine, let’s reduce the number of years exposed. To do this we will start in the year 1940 and end in the year 1970. For this purpose we will reduce the dataset.\n\n\nPolio_sum1 <- Polio_sum %>% filter(Date >= \"1940-01-01\" & Date <= \"1966-01-01\")\n\np1 <- Polio_sum1 %>% ggplot() +\n  aes(x=(Date), y=fct_rev(States),fill=sum_cases) + \n  geom_tile(colour=\"white\", lwd = 0.2, linetype = 1)+\n  theme_minimal()+\n  scale_x_date(expand=c(0,0), \n               breaks = (seq(ymd(\"1930-01-01\"), ymd(\"1970-01-01\"), \n                             by = \"5 years\")), date_labels = \"%Y\")+\n  labs(x=\"\", y=\"\", fill=\"\")+\n  theme(aspect.ratio = 6.5/12.5,\n        legend.position= \"bottom\",\n        legend.direction=\"horizontal\",\n        legend.text=element_text(colour=\"grey50\"),\n        axis.text.y=element_text(size=6, family=\"Tajawal\"),\n        axis.text.x=element_text(size=6),\n        axis.ticks.y=element_blank(),\n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5),\n        panel.grid=element_blank(),\n        title=element_text(hjust=-.07, vjust=1, \n                           family=\"Tajawal\"),\n        text=element_text(family=\"Tajawal\"))\n\n\nI want to change the palette color to a color with more visual impact. That is why I want to choose a palette that makes it easier to see the years with the highest polio cases. That’s why I chose the YlGnBu palette from the RColorBrewer package, which gives a very interesting effect.\n\n\np1 <- p1 + scale_fill_gradientn(colours=brewer.pal(n=9, \"YlGnBu\"),limits=c(0, 300))\np1\n\n\n\nI want also to include a new line distinguishing between the two types of vaccines that were introduced in the U.S.: the injected vaccine invented and licensed in 1955 by Jonas Salk, and the improved oral vaccine invented by Albert Sabin that was introduced in 1961, targeting all types of polio.\nThis shows that it was only after the introduction of the second vaccine in 1961 that there was a real decrease in polio cases in the United States.\n\n\np1 <- p1 + geom_segment(x=as.Date(\"1955-01-01\"), xend=as.Date(\"1955-01-01\"), \n               y=0, yend=52.5, size=.9, color=\"grey50\", alpha=0.5)+\n  annotate(\"text\", x=as.Date(\"1952-01-01\"), y=56, label=\"First vaccine\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\", color=\"grey50\")+\n   geom_segment(x=as.Date(\"1961-01-01\"), xend=as.Date(\"1961-01-01\"), \n                y=0, yend=52.5, size=.9, color=\"grey50\", alpha=0.5)+\n  annotate(\"text\", x=as.Date(\"1960-01-01\"), y=56, label=\"Second vaccine\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\", color=\"grey50\")\np1\n\n\n\nNow, we will introduce a more explanatory title and subtitle about the plot.\n\n\np1 <- p1 + labs(title=\"Effect of the introduction of the two polio vaccines in the US\",\n       subtitle=paste(\"The heat map represents a visualization of the positive cases of Polio\",\n                      \"in the USA during the years 1928 and 1971 for the three existing virus\",\n                      \"\\ntypes (Nonparalytic poliomyelitis, Paralytic poliomyelitis, poliomyelitis),\",\n                      \"where the decrease of positive cases due to the introduction of the\",\n                      \"\\ntwo vaccines can be clearly seen.\"))+\n  theme(plot.subtitle=element_text(size=6), plot.title=element_text(size=10))\np1\n\n\n\nNow I want to include to the plot the number of cases presented in each of the states in order to easily visualize which of the states was the most affected by the polio virus.\nIn that sense, we are going to modify the dataset to obtain the cases presented in each state during the years 1928 and 1971.\n\n\nCasesxstate <- Polio_sum %>%  group_by(States) %>% summarise(total_cases = sum(sum_cases))\n\n\nNext, we are going to make a Barplot using the geom_col function, filling the bars with the colors representing the number of cases per state.\n\n\ncasebars <- ggplot(Casesxstate) + \n  aes(x=total_cases, y=fct_rev(States), fill=total_cases)+\n  geom_col(show.legend=FALSE)+\n  theme_minimal()+\n  scale_fill_gradientn(colors = brewer.pal(n=9, \"YlGnBu\"),\n                       limits=c(1000, 6000))+\n  scale_x_continuous()+\n  theme( aspect.ratio = 3/1, panel.grid=element_blank(),\n    axis.title.y=element_blank(),\n    axis.title.x=element_blank(),\n    axis.line.y=element_blank(), \n    axis.text.y=element_blank(),\n        axis.ticks.y=element_blank(), \n    axis.text.x=element_text(size=6, colour=\"grey50\"), \n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5))\ncasebars\n\n\n\nNext, we will use the patchwork package to assemble different plots. In our case, we are going to use the “inset_element” function to assemble the original plot with the new plot so that they are in the same plot. Let’s see.\n\n\np1+ inset_element(casebars, \n                       left=0.95, \n                       bottom=-0.1, \n                       right=1.22, \n                       top=0.965,\n                       align_to=\"panel\", \n                  clip = TRUE)\n\n\n\nWith these improvements to the plot we can more easily see the change of colors in relation to the number of polio cases, we can see the effect of the introduction of the second vaccine in the US and finally we can see the states that suffered the most from Polio during the years recorded.\nIn conclusion, this plot uses everything that a heat map is good for as it provides an initial view of the data and allows us to explore the information in a wide visual range. Additionally, it allows you to easily analyze the data, which allows you to find patterns and trends.\n\n\n\n",
    "preview": "projects/2022/100484017/Polio Vaccine - WSJ.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1056,
    "preview_height": 733
  },
  {
    "path": "projects/2022/100383017/",
    "title": "Country Convergence",
    "description": "This project enables the user to recreate a specific graph in OurWorldinData on GDP per capita layer by layer. It also introduces two alternative representations resorting to the same data.",
    "author": [
      {
        "name": "Nacho Pulido Ruiz",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nOn the topic of Economics and Country Convergence\nGraph enhancement\nAlternative representation 1\nAlternative representation 2\n\nOn the topic of Economics and Country Convergence\nOur aim will be to resort to visual tools in R studio and ggplot to study the topic of country economic growth and convergence. Classical Solow-Swan models of growth predict convergence as a function of the deviation of a country from its stationary state (natural level) such that we should expect convergence between LEDC´S and MEDC´s. Our point of departure will be to launch the libraries we will use and to obtain the data from the Maddison Project Database.\nOriginal plot:\n\n\n\nlibrary(tidyverse)\nlibrary(scales)\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                delim = \";\"))\n\n\nA prior step to develop our plot will be to clean and sort the data to prepare it for our ggplot() operations. We will filter for rows containing data for 1950 and 2016 and reshape the data to have two columns accounting for GDP per capita for each country and for each year. This enables the analyst to depict a different axis for each of the years containing observations on GDP per capita.\n\n\ngdp <- gdp %>% \n  rename(gdp_capita = gdp_per_capita) %>% \n  select(country, year,gdp_capita, ) %>% \n  filter(year %in% c(1950,2016)) %>% \n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>% \n  drop_na(\"1950\", \"2016\") %>% \n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\")\n\n\nIt will be useful for us to categorize our countries in three groups (poor, medium and rich countries) by generating a factor column using the ifelse() command in the following way:\n\n\ngdp <- gdp %>% \n  mutate(type = ifelse(gdp_capita_2016<6000,\n                       \"poor\",\n                       ifelse(gdp_capita_2016<40000,\n                              \"medium\",\n                              \"rich\")))\n\n\nIt will be convenient for later (at the labelling stage) to generate a new column indicating the amount of growth an economy has undergone.\n\n\ngdp <- gdp %>% \nmutate(fold = round(gdp_capita_2016/gdp_capita_1950,1)) %>%\n  mutate(fold = paste(fold,\"-fold\"))\n\n\nSince we will have many observations for each of the countries (especially for those with middle income), we will filter for a subset of the data by selecting a random sample of middle income countries and then binding the resulting dataframe to the original one:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n  slice(sample(1:73,35,replace = FALSE))\ngdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nNow we have everything we need to start depicting our graph! We will call our gdp data and pipe it into the ggplot() function, defining the aesthetics desired. The advantage of having previously pivoted our data is that now we have 2 columns which account for the desired variables to be plotted:\n\n\nplot <- gdp %>% \n  ggplot()+\n  aes(gdp_capita_1950,gdp_capita_2016)\nplot\n\n\n\nNow we will add some geometry to our plot. We will choose shape 21 in order to be able to fill the points with a different color from the one we will use for the contouring of it.\n\n\nplot <- plot +\n  geom_point(shape = 21,color = \"red\", size = 1.5, fill = \"aquamarine3\")\nplot\n\n\n\nOur plot requires a lot of labels inside the graph, both for lines and for points. We will take advantage of geom_text() and add some label to the geometry including a subheading accounting for the amount of growth each economy has undergone. We will later work on our annotations to the diagonal lines.\n\n\nplot <- plot +\ngeom_text(aes(label = country), size = 1, nudge_y = -0.02)+\n    geom_text(aes(label = fold), size = 1, nudge_y = -0.05)\nplot\n\n\n\nIt is time to choose appropriately the scales of our plot. A logarithmic scale will we used for both axis and we will have to introduce the dollar symbol to account for the unit of measurement. The breaks have to be manually provided by the analyst to mimic as much as possible the original plot.\n\n\nplot <- plot +\n   scale_x_log10(label = label_number(prefix = \"$\"), \n                 breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                            7000,10000,15000,20000,30000,40000,50000,70000))+\n   \n  scale_y_log10(label = label_number(prefix = \"$\"),\n                breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                           7000,10000,15000,20000,30000,40000,70000))\nplot\n\n\n\nTo stick with the original plot as much as possible, we will introduce some text in our axis and title (including a subtitle) and use a bold font for the latter.\n\n\nplot <- plot +\n  labs(x=\"GDP per capita in 1950\",\n       y = \"GDP per capita in 2016\",\n       title = \"GDP per capita in 1950 and 2016\",\n       subtitle = paste0(\n         \"GDP per capita is expressed in international -$. \",\n         \"This means that it is adjusted for price changes over \",\n         \"time (inflation) and for price differences between countries.\"))\nplot\n\n\n\nThere are many informative lines in our plot used to depict the growth rate of a country in comparison to 1950.. We will use the geom_abline() to choose the slope and intercept of each one and change the color to stick to the original plot. The RGB technique will be used to determine the color of interest and the fourth argument of this function refers to the transparency (alpha), which we will set for the diagonal lines. The intercepts with the y-axis have to be transformed by the logarithm.\n\n\nplot <- plot +\ngeom_abline(slope = 1,intercept = 0, color = \"darkblue\")+\n    geom_abline(slope=1,\n                intercept=log10(c(0.5, 2, 3,\n                                  4.4, 10, 15, 30)), linetype=\"dotted\",\n                color = rgb(0,0,0.5,0.3))\nplot\n\n\n\nIn this section we will work on the theme (appearance of the plot). Notice that each of the axis has some specific color associated with it (in accordance with the horizontal and vertical grid lines). In this case, the background lines are faded and we will resort to the RGB mixture of colors providing an alpha for each color. These kind of lines will be chosen as linetype “dotted to achieve the desired dashed effect. The aspect.ratio will be set to 1 inside the theme to ensure that the proportions of the final plot obey the ones of the original graph.\n\n\nplot <- plot +\ntheme(axis.text.x = element_text(colour = \"darkorchid3\", size = 2.9),\n      axis.title.x = element_text(colour = \"darkorchid3\", size = 9,family = \"serif\"),\n      axis.text.y = element_text(colour = \"cyan3\", size = 4,family = \"serif\"),\n      axis.title.y = element_text(colour = \"cyan3\", size = 9, family = \"serif\"),\n      plot.subtitle = element_text(size = 5, colour = rgb(0,0,0,0.6),hjust = 0.4,\n                                   vjust = 5,family = \"serif\"),\n      panel.background = element_rect(fill = \"white\"),\n      panel.grid.major.x = element_line(color = rgb(0.6,0.196,0.8,0.4),\n                                        linetype = \"dotted\"),\n      panel.grid.major.y = element_line(color = rgb(0,1,1,0.4), linetype = \"dotted\"),\n      plot.title = element_text(size = 14,hjust = -0.2, vjust = 1, family = \"serif\"),\n      aspect.ratio = 1)\nplot\n\n\n\nCoordinates will be kept ass Cartesian but we will employ the use of some limits to mimic the ones from the original plot.\n\n\nplot <- plot +\ncoord_cartesian(xlim = c(400,70000), ylim = c(400,70000))\nplot\n\n\n\nWe will now work on the annotations accompanying the vertical lines which will indicate the amount of growth that each of the countries have experienced since 1950, thus, conveying the idea of convergence/divergence among them.\n\n\nplot <- plot +\nannotate(\"text\", label = \"Countries above this line had positive growth\",\n         color = \"darkgreen\", x = 22000, y = 25000, angle = 45, size = 2.3,\n         family = \"serif\") +\n    annotate(\"text\", label = \"Countries below this line had negative growth\",\n             color = \"red\", x = 26000, y = 23000, angle = 45, size = 2.3,\n             family = \"serif\")\nplot\n\n\n\nIn addition to these annotations, we will add the final text annotations pertaining to the rest of diagonal lines adding a smaller size and accounting them with a different color. The 45 degree angle will be held constant since all lines hold a slope equal to unity but with different intercepts.\n\n\nplot<- plot+\n  annotate(\"text\", label = \"2x poorer\", color = rgb(0,0,0.6,1), \n           x = 61000, y = 36000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"2x richer\", color = rgb(0,0,0.6,1),\n             x = 30000, y = 65000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"3x richer\", color = rgb(0,0,0.6,1),\n             x = 19000, y = 65000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"Global average \\n growth (4.4x)\",\n             color = rgb(0,0,0.6,1),  x = 11000, y = 63000, angle = 45, \n             size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"10x richer\", color = rgb(0,0,0.6,1),\n             x = 5700, y = 67000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"15x richer\", color = rgb(0,0,0.6,1),\n             x = 4000, y = 68000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"30x richer\", color = rgb(0,0,0.6,1),\n             x = 2000, y = 68000, angle = 45, size = 1.9,family = \"serif\")\nplot\n\n\n\nAs a final note, we will recall all the problems we encounter on this plot and use this to propose an enhancement:\nEven with a subset of countries, there is a lot of geometry text overlapping -> We will improve the labelling\nIt is difficult to account for convergence across countries since all countries are plotted independent of their nature -> We will distinguish between groups of countries\nIn order to enable the reader extract information on both the country and the level of growth rate, we will provide to distinctive plots such that one contains country labels whereas the other one will resort to quantitative (regression analysis) information\nConvergence is difficult to observe due to axis selection -> We will modify the vertical axis to depict growth rate and help the reader check for convergence with ease\nGraph enhancement\nWe will use the same graph to propose some enhancements or changes in the way the data is presented in an attempt to ease reader´s comprehension. We will reload the data to our Rstudio code:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                  delim = \";\"))\n\n\nThe same technique employed before to clean and prepare our data will be recycled. Recall we are just proposing an improvement of the visualization, an alternative graph will be proposed in the last section of the project. Once again, we categorize our countries into rich, medium and poor:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nThe main difference with the first plot is that, this time, we will resort to the inclusion of a new column which will summarize the average annual growth rate that each economy has undergone since 1950.\n\n\ngdp <- gdp %>% \n mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100)%>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nAs we mentioned previously, the plot will be the same but we will just change the way the data is presented, so the random filter to select countries will be preserved:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n    slice(sample(1:73,35,replace = FALSE))\n  gdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nWe can begin with our enhanced graph! The aesthetics provided now will be set to the gdp per capita in 1950 and the annual growth rate we computed before. We will make use of our geom_label() again but we will omit supplying R with geom_point() this time. The color of the text will be set to white in order to generate a comfortable contrast with the “filling” by type of economy we had established in our aesthetics.\n\n\nlibrary(ggrepel)\nplot_1 <-gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)+\n    geom_label_repel(aes(label = country), size = 2,\n                     segment.color = 'transparent', max.overlaps = 40,\n                     force = 1, color = \"white\",\n                     show.legend = FALSE)\n    plot_1\n\n\n\nWe will add some labels to our axis and set the title to convey the idea that we are working with convergence. The word “conditional” here refers to the fact that we are going one step further and categorizing our data between types of economies and we will finally visualize the concept of “conditional convergence” presented in the classical Solow model of growth.\n\n\nplot_1 <- plot_1 +\nlabs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_1\n\n\n\nWe will provide a continuous y scale with the percentage suffix to make it obvious that we are working with growth rates here. We will also begin by applying a minimal theme to our plot which will be modified later with slight changes.\n\n\nplot_1 <-\nplot_1 + theme_minimal()+\n    scale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)\n    plot_1\n\n\n\nWe will work on the themes by providing some font in the type of “serif” and eliminating any background grid which may distract the reader. We will not devote much effort into changing the theme appearance because we are just modifying some changes of the original plot, not changing the graph completely. The aspect ratio will be set again to 1 to keep the original proportions.\n\n\nplot_1 <- plot_1 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid = element_blank(),\n      plot.title = element_blank(),\n      aspect.ratio = 1)\nplot_1\n\n\n\nFinally, let´s change the limits on the plot to make it more readable by modifying the arguments of the coordinate system:\n\n\nplot_1 <- plot_1+\n  coord_cartesian(xlim = c(0,10000), ylim = c(-2,7))\nplot_1\n\n\n\nNow we will generate the second plot required for our enhancement resorting to a similar analyis as the one depicted above but focusing on the quantitative side. We will append next to plot_1 the corresponding representation of each linear regression accounting for our three country groups. As usual, we will have to read again our data to make from scratch the desirable transformations:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nOne again, we will have to split our country in three categories and generate our “Growth” column accounting for the rate of increase of GDP per capita that each economy experiences. Factor levels will be reset to obtain the desired order:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\"))) %>%\n    mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100) %>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nNow we can start depicting the second part of our enhancement graph! The first part will consist of piping our already filtered data into ggplot() and select the appropriate aesthetics in which we will feed our argument “fill” with our country type.\n\n\nplot_2 <-  gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)\nplot_2\n\n\n\nNotice that, different to plot_1 in which we mapped a text geometry into the plot to be able to spot each of the countries, our task now is to account for types of countries regardless of their label. Therefore, we will change the geometry to geom_point() and let the point be filled with the type of country while contouring it with a white color:\n\n\nplot_2 <- plot_2 +\ngeom_point(shape = 21, color = \"white\", size = 3)\nplot_2\n\n\n\nWe will add some labels to the axis (the same that we had for our previous plot):\n\n\nplot_2 <- plot_2 +\n labs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_2\n\n\n\nLet´s change the label of the vertical axis by adding a percentage symbol to indicate that it is a measure of percentage growth rate. This has been computed as the average annual growth rate, which is the growth rate required for a country to portray year by year (constant) to achieve the final level of GDP per capita:\n\n\nplot_2 <- plot_2+\nscale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)+\n  theme_minimal()\nplot_2\n\n\n\nNext, we will change the appearance of our plot by modifying slightly the theme layout. Family “serif” will be chosen for the font in order to mimic the one used in the replication of the original plot and the background will be fill with grey. Panel grid lanes will be removed by setting the corresponding argument into element_blank().\n\n\nplot_2 <- plot_2 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid= element_blank(),\n      legend.position = \"bottom\",\n      legend.background = element_rect(size = 2),\n      aspect.ratio = 1)\nplot_2\n\n\n\nFinally, a linear regression line will be passed through each of the country groups to account for conditional convergence. The negative relationship which can be easily spotted once the line of best fit is included shows that, within groups of similar countries holding similar characteristics (depreciation rates, population growth rates etc.), there is convergence. However, the transition of a country from one group to another one is rarely seen.\n\n\nplot_2 <- plot_2 +\ngeom_smooth(method = \"lm\", size = 1, color = rgb(1,1,1,0.3))\nplot_2\n\n\n\nWe will change some limits of this plot to enable the reader focus on the inside and not get distracted with a hughe portion of unused plot:\n\n\nplot_2 <- plot_2 +\n coord_cartesian(xlim = c(0,15000), ylim = c(-2,7))\nplot_2\n\n\n\n\n\nlibrary(ggpubr)\nenhancement <- ggarrange(plot_1,plot_2,  common.legend = TRUE, legend=\"bottom\")\nannotate_figure(enhancement,\n                top = text_grob(\"Gdp per Capita Conditional Convergence\",\n            color = \"red\", size = 19))\n\n\n\nAlternative representation 1\nNow that we have resorted to an enhancement of the original plot in order to provide a measure of within group convergence, we will propose an alternative graphical analysis to show between group divergence. In other words, we will see, for each year, how the distribution of income holds for each of our country groups to highlight the difficulty of an economy of jumping from one group to another one.\nWe will have to read again the data to start from scratch our alternative plot:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nWe will only keep data from 1950 onwards and we will filter for any NA´s present (missing observations). The difference with our previous plots is that we will now use all of our economies (no filter selection) and we will plot, for each year, how income per capita is distributed among our countries (the evolution of distribution of wealth).\n\n\ngdp <- gdp %>%\n    select(country,year,gdp_per_capita) %>%\n    filter(year>=1950) %>%\n    drop_na(gdp_per_capita)\n\n\nWe will pivot our data into wide format because we desire a column indicating the GDP per capita and the corresponding year in order to enable the analyst to generate the new column assigning the type of economy (factor).\n\n\ngdp <- gdp %>% \npivot_wider(names_from = \"year\",\n                values_from = gdp_per_capita,\n                names_prefix = \"Year\") %>%\n    mutate(type = ifelse(Year2016<6000,\n                         \"Poor\",\n                         ifelse(Year2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nNow we will reshape our data back to long format for the sake of our alternative representation. This is a different route we are taking with respect to the original plots, but it will be useful for operating with all years and not just 2 specific ones (as earlier). We separate the pivoted columns to eliminate the unnecesary ones and keep just a year and a gdp per capita column:\n\n\ngdp <- gdp %>% \npivot_longer(starts_with(\"Year\"),\n                 names_to = \"Year\",\n                 values_to = \"gdp_per_capita\") %>%\n    separate(Year, c(\"Yeard\", \"Year\"), remove = TRUE, sep =4) %>%\n    select(-Yeard) %>%\n    drop_na(everything())\n\n\nFinally, we will reorder the levels of our factor for a more appealing representation of our faceting and we will generate a new dataframe which contains all information that our original dataset contained with the exception of country type. We do this because we will use both dataframes in our plot to work with the faceting.\n\n\ngdp <- gdp %>%\n   mutate(type = factor(type, levels = c(\"Poor\",\n                                         \"Medium\",\n                                         \"Rich\")))\n gdp_2 <-\n  gdp %>%\n  select(-type)\n\n\nWe pipe our gdp dataset into ggplot() and define our desired aesthetics:\n\n\nplot <-\ngdp %>%\n  ggplot()+\n    aes(Year,gdp_per_capita)\nplot\n\n\n\nNow we will add two geometries which correspond, in this case, to lines that account for the distribution of income per capita each year and for each economy. First we do this with the original data frame and then we mimic the code with the filtered dataframe and we add some alpha in order to achieve this effect in which the important segment of the data is being highlighted.\n\n\nplot<-\nplot+\ngeom_line(data = gdp_2, color = rgb(0,1,0,0.3))+\n  geom_line(color= rgb(0,1,0,1))\nplot\n\n\n\nNow we facet by type of economy…\n\n\nplot <- plot+\nfacet_wrap(~factor(type))\nplot\n\n\n\nLet´s add some labels to our plot. We will improve the readings of the axis and set a title to account for the divergence between countries. This is the case because we see that, although we did see within group (conditional) convergence in our enhancement plot, now one observes that, if we treat countries as a whole by groups, there is some divergence taking place.\n\n\nplot <-\n  plot+\nlabs(y = \"GDP per capita\", x = \"Time\",\n       title = \"Between Group Divergence\")\nplot\n\n\n\nOnce again, we work the scaling of our graph and change the label of the vertical axis to dollars. Timing will only display some years to avoid overlapping and improve readability.\n\n\nplot <- plot +\nscale_x_discrete(breaks = c(1950,1960,1970,1980,1990,2000,2010))+\n  scale_y_continuous(labels = label_dollar())\nplot\n\n\n\nThe final theme will be set now. We begin with a general dark theme and then make some final adjustments. Years in the horizontal axis will be given some angle to enable us to fit more information and the title will be set in the center of our plot. This will be our first proposal for an alternative representation.\n\n\nplot <- plot +\ntheme_dark()+\n  theme(axis.text.x = element_text(size = 10, angle = 90),\n        strip.text.x =element_text(face = \"bold\"),\n        plot.title = element_text(hjust = 0.5, size =14))\nplot\n\n\n\nAlternative representation 2\nOur previous plot operated with the distribution of income per capita within groups to be able to compare across our three types of economies (e.g. variance and overal growth). Our second proposal for alternative visualization will focus on the between-group convergence and reinforce the idea of the set of hardships involved in the process of an economy evolving from a lower class to a higher one. We load again our data to start from scratch, as usual:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                delim = \";\"))\n\n\nNext, we will have to perform similar operations we resorted to in previous sections by filtering only those years corresponding to 1950 and 2016 and arranging each country into its corresponding group.\n\n\ngdp <- gdp %>%\n  rename(gdp_capita = gdp_per_capita) %>%\n  select(country, year,gdp_capita, ) %>%\n  filter(year %in% c(1950,2016)) %>%\n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n  drop_na(\"1950\", \"2016\") %>%\n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n  mutate(Class = ifelse(gdp_capita_2016<6000,\n                       \"Poor\",\n                       ifelse(gdp_capita_2016<30000,\n                              \"Medium\",\n                              \"Rich\")))\n\n\nThe difference with previous plots is that we will now use the overall average annual growth rate from 1950 to 2016 which is the average growth an economy has yearly undergone to achieve their gdp per capita level in 2016. We also attach a measure of the mean average growth for each of our classes to enable the reader to spot the first differences:\n\n\ngdp <- gdp %>%\n  mutate(AAGR = ((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950))-1)*100)\ngdp %>%\n  group_by(Class) %>%\n  summarise(av_AAGR = mean(AAGR))\n\n# A tibble: 3 × 2\n  Class  av_AAGR\n  <chr>    <dbl>\n1 Medium   2.79 \n2 Poor     0.917\n3 Rich     3.27 \n\ngdp <- gdp %>%\n  filter(Class != \"Rich\") %>%\n  mutate(AAGR_diff = 3.26 - AAGR)\n\n\nWe can now start building our plot layer by layer. We pipe in our already filtered data into ggplot() and set the aesthetics such that the horizontal axis accounts for each of the economies and the vertical one measures the growth rate difference between each country and the average one for rich countries. Therefore, high figures for the vertical axis correspond to countries that need to inject a considerable amount of per capita growth rate (annually) in order to catch up with rich economies and viceversa. The argument introduced in geom_bar() will be set to identity because the default for a bar plot is to count th enumber of observations in a column, and we want to plot the column corresponding to the growth rate difference. Notice that we have reordered from lowest to highest to achieve a visually more attractive graph.\n\n\nplot <- gdp %>%\n  ggplot()+\n  aes(reorder(country,AAGR_diff), AAGR_diff, fill = Class)+\n  geom_bar(stat = \"identity\")\nplot\n\n\n\nNow we will set a void theme for our plot because we want to eliminate any axis text and clean the general appearance (we will work in the themes at the end) and add some labels for the acknowledge the reader with a better understanding of the plot:\n\n\nplot <- plot +\ntheme_void()+\n  labs(title = \"The Spiral of convergence\",\n       subtitle = paste0(\n         \"Countries contained inside the white circle are already growing \",\n         \"at the rate of a rich economy\"),\n       caption = paste0(\n         \"Countries falling in the dark regions require an additional \\n\",\n         \"annual average growth rate to catch up with leading economies\"))\nplot\n\n\n\nNow its time to work on the appareance of our graph. The panel grid lines will be removed by setting an element_blank() argument and the aspect ratio will be set so that we can observe a wider spiral in the final graph. The colors chosen for the bar plots are green and purple which contrast among then whereas the background layers will be set in black as a final step:\n\n\nplot <- plot +\nscale_fill_discrete(type = c(\"purple\", \"green\"))+\n  theme(legend.background = element_rect(color = \"black\"),\n        plot.title = element_text(hjust = 0.5, vjust = 3, size =16),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_blank(),\n        aspect.ratio = 0.8,\n        plot.subtitle = element_text(size = 9,hjust = 0),\n        plot.caption = element_text(size = 9,hjust = 0),\n        legend.key = element_rect(color = \"white\", size = 2),\n        legend.key.width = unit(2,\"lines\"),\n        legend.title = element_text(hjust = 0.5))\nplot\n\n\n\nWe will have to add some annotations in our plot to point the amount of growth injection each economy needs. These lines and annotations will make more sense once the polar coordinates have been applied. We encourage the reader to come back to these steps after the plot is over to understand how each of our elements gets settled in the final spiral.\n\n\nplot <- plot +\ngeom_abline(slope = 0,\n            intercept = c(-2,-1,0,1,2,3,4),\n            color = rgb(0,0,0,0.3), linetype = \"dotted\")+\n  annotate(geom=\"text\", x=-10,\n           y=c(-2,-1,0,1,2,3,4), label=c(\"-2%\",\"-1%\",\"0%\",\"1%\",\"2%\",\"3%\",\"4%\"),\n           color=\"black\",size =3,angle = 28)\nplot\n\n\n\nFinally, we have to add some rectangular geometries for different segments of the plot which will be given some alpha (transparency) to account for best to worse layers. These layers mimic the level curves of a three dimensional bowl in which each layer projected in the floor corresponds to a circle. We will see this once we apply our polar coordinates.\n\n\nplot <- plot +\nannotate(\"rect\", ymin = -2, ymax = -1,\n         xmin = -10, xmax = 110, fill = \"black\", alpha = 0.1)+\n  annotate(\"rect\", ymin = -1, ymax = 0,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.2)+\n  annotate(\"rect\", ymin = 0, ymax = 1,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.3)+\n  annotate(\"rect\", ymin = 1, ymax = 2,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.4)+\n  annotate(\"rect\", ymin = 2, ymax = 3,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.5)+\n  annotate(\"rect\", ymin = 3, ymax = 4,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.6)\nplot\n\n\n\nWe can now apply our polar coordinates!\n\n\nplot <- plot +\ncoord_polar()\nplot\n\n\n\nThe first alternative representation deals with the evolution of the distribution of GDP per capita whereas the second one conveys this information in terms of differences in average growth rates with respect to rich economies. The results arising from the first section of the paper point at the existence of conditional convergence between similar economies and we highlight the difficulties an economy faces in jumping from one class to another in the outcome stemming from our alternative plots.\n\n\n\n",
    "preview": "projects/2022/100383017/images/original_plot.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 898,
    "preview_height": 897
  },
  {
    "path": "projects/2022/100481925/",
    "title": "Bump chart: How Americans spend their money",
    "description": "Code to replicate the graph in `ggplot2` and some improvements.",
    "author": [
      {
        "name": "Carolina Cornejo Castellano",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nBackground\nWhat is it for? Representing how Americans distributed their spending in 2021\nWhat can be seen here? Encodings, channels and strengths\nReplication in R\n\nHow can it be improved? Enhancements\nDesigning the enhancements proposal\n\nAlternative visualization(s)\nDesigning the bar plot\nDesigning the lollipop plot\nDesigning the treemap\n\n\nIntroduction\nOn September 25, 2022, the Visual Capitalist, a digital media focused on generating data-centric visual content, published the article How Do Americans Spend Their Money, By Generation? The author of the visualization is Preethi Lodha, and the author of the article is Carmen Ang.\nThis report aims to discuss Preethi Lodha’s (Lodha 2022) graphic in the light of data visualization theory. Thus, some questions that will guide this narrative are: What information does it intend to show? Does it achieve it? How and through what encodings and channels? What are its strengths and points of improvement? Likewise, improvements and alternative visualizations are proposed, which are also not without their own room for improvement.\nBackground\nThe article collected data from the 2021 Consumer Expenditure Surveys (CES) from the U.S. Bureau of Labor Statistics. Specifically, the data used for the visualization was that published in PDF format in Table 2602. Generation of reference person: Annual expenditure means, shares, standard errors, and coefficients of variation.\nThe source of the article and the original graphic can be accessed here. This report was written in December 2022.\nWhat is it for? Representing how Americans distributed their spending in 2021\nFirst, the context and intentionality must be understood. The graphics must be understandable by themselves, and also in their context.\nAs for the article on the Visual Capitalist website, it has as newsworthiness —in Spanish journalist jargon we call it “la pepa”— to show the distribution of Americans’ spending in 2021. Although the title of the article does not specify that the information is from the previous year —it was written and published in 2022—, but the information is from 2021- this type of generalization or omissions are common in the titles and/or in the headlines of journalistic articles: they are licenses that journalists give themselves to attract the reader’s attention. The content of the article clearly specifies the source of information—the PDF—and that it refers to 2021. So it’s not a time series, it’s just a picture of that moment.\nScreenshot of the public Tableau dashboard How Americans spend their money, by Preethi Lodha. Published in: https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/As for the graphic, the author used Tableau to build a bump chart that includes interactive elements when hovering over the dots; but for the purposes of this report, those elements will not be taken into account: only what is seen in the screenshot above is considered.\n\nNote that we use the term bump chart because this type of visualization is commonly found with that name on the Internet. However, in the article of the Visual Capitalist they refer to it as a “graph” and in this report we try to call the other visualizations as “graphic,” as proposed by Wilkinson and Wills (2005).\nBump charts are useful for exploring changes in rank over time across different categories. That is, they usually do not show the actual values of the categories —which in this case would be the money spent by each generation for each spending category—, but the positions in the ranking. In this case, the ranking moves of 14 spending categories are shown, based on the birth year range from the Silent generation (the oldest) to Generation Z.\nAt first glance, this and, in general, all bump charts shows three variables in an easy-to-understand way: category, time and position. That’s especially true in cases of graphics where the only important thing is the ranking. For example, this image from The Washington Post from 2015 shows the “favorite” dog breeds, according to the American Kennel Club, where the three important variables are breed of dog, year, and position in the ranking (Bump 2021).\nArticle published by Philip Bump in The Washington Post: https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/However, there is another important piece of information in Preethi Lodha’s graph, which is the dollar amount spent by each generation for each expenditure category. This is presented within each point and is undoubtedly important if one wants to know how spending is distributed; however, that oscillation is not displayed with any other visual mark and can be misleading. This point will be discussed later.\nWhat can be seen here? Encodings, channels and strengths\nThere are 14 spending categories represented on the Y axis and 5 generations or age ranges showed on the X axis, above the graph and below the title and subtitle, from the Silent generation (the oldest) to the Generation Z.\nAccording to Cleveland (1985), graphs encode data in distinct elements, such as symbols, colors, position, etc. When we study a graphic we perform several mental-visual tasks to extract quantitative information. Some of the basic judgements we perform to decode quantitative information are 1) angle, 2) area, 3) color hue, 4) color saturation, 5) density, 6) length, 7) position along a common scale, 8) position along identical, nonaligned scales, 9) slope, and 10) volume (Cleveland 1985).\nIn consideration of this, the information in the bump chart can be extracted by judgements of position along the vertical scale, which represents the spending categories; the color of each line, which represents the categories of expenditure; the position of each point on the X axis, which represents the generation; and the thickness of the lines, which represents the money spent in each category (the thicker the line the more money has been spent). The closeness of the dots stands for the closeness in the ranking positions. The size of the points does not represent anything.\nCleveland also discusses detection, which he qualifies as the most fundamental perception issue, because before executing any graphical perception task, we must be able to detect the graphical element (Cleveland 1985). Lodha’s bump chart does not show overlaps in the dots, which together with color and position is the most important symbol. The jumps in the ranking are well understood. In broad terms, the graphic is very readable, which is not the same as effective.\nReplication in R\nAn almost exact replica was created using ggplot2,\nThe libraries used were as follows:\n\n\n# Import libraries\nlibrary(tidyverse) # for data manipulation\nlibrary(ggplot2) # for data graphics.\nlibrary(ggtext) # provides markdown and HTML text rendering\nlibrary(grid) # for adding the two white lines at the top and bottom\n\n\nThen, the data was imported. As mentioned above, the data is only a PDF, so the values had to be transcribed manually. After that, we made some transformations.\n\n\ndf <- read_csv(\"data.csv\")\nhead(df)\n\n# A tibble: 5 × 15\n  generation  housing healthcare  food trans…¹ cash_…² enter…³ insur…⁴\n  <chr>         <dbl>      <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 silent        16656       7053  5487    5263    4045    2027    1213\n2 boomers       21273       6594  7651    9327    2876    3476    6309\n3 gen_X         26385       5550 10388   13956    2747    4694   11656\n4 millennials   24052       4026  8463   11052    1163    3457    9249\n5 gen_Z         15449       1354  5529    7929     760    1693    3871\n# … with 7 more variables: miscellaneous <dbl>, apparel <dbl>,\n#   personal_care <dbl>, education <dbl>, alcohol <dbl>,\n#   reading <dbl>, smoking <dbl>, and abbreviated variable names\n#   ¹​transportation, ²​cash_contributions, ³​entertainment, ⁴​insurance\n\n\n\n# Pivot longer, add ranks and order chronologically\ndf <- df %>%\n  pivot_longer(-generation, names_to = \"variables\", values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Manually renaming\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \n  \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance and pensions\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n\n\n# Formatting the dollars' column\ndf$dollars <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars <- paste0(\"$\", df$dollars)\n\n\nCharacter vectors were created to 1) sort the generation names chronologically because ggplot2 displayed them in alphabetical order, 2) format them in HTML language that will later be rendered by the ggtext package, and 3) to add as tag the description of the X-axis.\n\n\nx_names_ordered <- c(\"Silent\", \n                     \"Boomers\", \n                     \"Generation X\", \n                     \"Millennials\", \n                     \"Generation Z\")\n\n\n\n\nx_names_full = c(\n  \n  paste(\"<span style='font-size: 9.55pt'>**Silent**<\/span>\",\n        \"1945 or earlier\",\n        \"**$44,683**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\"<span style='font-size: 9.55pt'>**Boomers**<\/span>\",\n        \"1946 to 1964\",\n        \"**$62,203**\",\n        sep = \"<br>\"),\n\n\n  paste(\"<span style='font-size: 9.55pt'>**Generation X**<\/span>\",\n        \"1965 to 1980\",\n        \"**$83,357**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Millennials**<\/span>\",\n    \"1981 to 1996\",\n    \"**$69,061**\",\n    sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Generation Z**<\/span>\",\n    \"1997 or later\",\n    \"**$41,636**\",\n    sep = \"<br>\")\n\n                )\n\n\n\n\nx_lab <- paste(\n  \"<span style='font-size: 10pt'>**Generation**<\/span>\",\n  \"Birth Year Range\",\n  \"**Average Annual Expenditure**\",\n  sep = \"<br>\"\n              )\n\n\nThen the theme was built. We call this theme theme_bump. Before that, we saved as objects the codes of the two main colors: the one of the background and the one of the text.\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nThe textual elements were changed from element_text to element_markdown of the ggtext package. This allows to use markdown or HTML to design text strings.\n\n\ntheme_bump <- function() {\n\n  # Begin construction of the theme\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n}\n\n\nWe then proceeded to build the bump chart. Note that the following chunk must start with {r fig.width = 8.29, fig.height = 6.88} to display the replica in the same proportions as the original.\n\n\nreplica <- ggplot(\n  data = df,\n  aes(x = generation, \n      y = ranking, \n      group = variables)) +\n  # Add the custom theme just designed\n   theme_bump() +\n  # Add the horizontal lines per generation\n     geom_line(aes(color = variables, \n                   alpha = 1, \n                   # Change line thickness accordingly:\n                   linewidth = rev(ranking))) + \n  # Add the points. The white ones are for the border  \n   geom_point(size = 11.85, \n                color = \"white\") +\n     geom_point(aes(color = variables), \n                size = 11.3) +\n     scale_y_reverse(breaks = 1:nrow(df)) +\n  # Order and \n     scale_x_discrete(\n       limits = x_names_ordered,\n       labels = x_names_full,\n       position = \"top\",\n       expand = expansion(mult = c(0.356, 0.1))\n                    ) +\n  # Titles, subtitle, caption and tag \n  labs(\n    title = \"HOW AMERICANS SPEND THEIR MONEY\",\n    subtitle = \"By Age Group | 2021\",\n    caption = \"Author: Preethi Lodha\",\n    tag = x_lab\n  ) +\n  # Add the two horizontal white lines at the top and the bottom\n    coord_cartesian(clip = \"off\") +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(1.11, 1.11), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(-0.05, -0.05), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n  # Add the Y axis text     \n  geom_text(data = df %>% \n                    filter(generation == \"Silent\"), \n                  aes(label = variables, \n                      x = 0.72236), \n                  hjust = \"outward\", \n                  fontface = \"bold\", \n                  color = \"#272727\", \n                  size = 2.4) +\n  # Add the amount money spent.\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.25, \n                fontface = \"bold\") +\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.253, \n                fontface = \"bold\") +\n      geom_text(data = df, aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.257, \n                fontface = \"bold\") +\n  # Add line colors\n      scale_color_manual(values = c(\n        \"#9c6255\",\n        \"#a0d4ee\",\n        \"#9d8379\",\n        \"#8f93b5\",\n        \"#494c4d\",\n        \"#2f634a\",\n        \"#ed444a\",\n        \"#8a8887\",\n        \"#a13b5d\",\n        \"#87a7a0\",\n        \"#af9e2e\",\n        \"#6d1f29\",\n        \"#466f9d\",\n        \"#3896c4\"\n      )) \nreplica\n\n\n\nTo save the plot:\nggsave(\"replica.png\", \nplot = last_plot(), \npath = \"images\", \nwidth = 8.29, \nheight = 6.88, \nunits = \"in\", \ndpi = 120)\nAs can be seen below, only the small icons at the bottom left and the interactive box at the top right were not reproduced. Since these are interactive elements in the original dashboard, we did not consider it necessary.\nOriginal bump chart created by Preethi Lodha.My replica in ggplot2.How can it be improved? Enhancements\nFrom the start, one might question the need to design a graphic to display these data. Tufte (2013) points out that “[t]ables usually outperform graphics in reporting on small data sets of 20 numbers or less” and that “[t]he special power of graphs comes in the display of large data sets.” This case is not a large data set: in fact, the source is a PDF. This peculiarity has pros and cons: on the one hand, to represent expenditure by generation and expenditure category, it is unnecessary to perform many transformations; but on the other hand, it limits the options for alternative graphics.\nIn terms of features, notwithstanding its goodness, it is noted that this bump chart —and indeed, all of them— give readers the feeling that the difference between each category is about the same because the channels used —width of the lines and distance between them— are the same. Although in this case the thickness of the lines has been manipulated to represent each amount of money, its effect in counteracting that feeling is limited.\nUsing labels within the circles to show the money spent per category and per generation could have been a wise move, following the postulates of Tufte (2013), who points that “[c]lear, detailed and thorough labeling should be used to avoid graphic distortion and ambiguity […].” But, in this case, such labels add an extra layer of information and if the bump chart represents jumps in ranking, these were already encoded in the position of the dots and the jumps in the lines. Moreover, there are examples that even though spending in a certain category decreases from one generation to the next, its position in the ranking goes up and vice versa: just look at the jump from Millennials to Generation Z in the category Personal care products and services; and the jump from Boomers to Generation X in the Food category. Tufte himself would call it “a lying graphic” (Tufte 2013).\n\n“A second defense of the lying graphic is that, although the design itself lies, the actual numbers are printed on the graphic for those picky folks who want to know the correct size of the effects displayed. […]” (Tufte 2013)\n\nSo, if the purpose is to represent the spending distribution of Americans, showing rankings can be misleading. For this reason, the main point of improvement would be to represent spending rather than ranking. This implies to change the type of graph to one where the data items are the money spent and the data attributes are the generation and the category of spending. Tufte (2013), in this regard, postulates that “[t]he representation of numbers, as physically measured on the surface of the graph itself, should be directly proportional to the numerical quantities represented” (Tufte 2013). What visual marks would be the most efficient?\nIn order to continue using lines and dots to represent the data, the proposed enhancements are in a line plot:\nA line plot based on Preethi Lodha’s bump chart. This enhancements proposal also has much room for improvement in concept and implementation. Own elaboration.This is not exempt from problems, both in terms of conception and execution. First, the category with the highest expenditure by far is Housing, but the other categories are very close, which caused problems with overlapping labels. That was the driving force behind plotting only the first 6 expenditure categories. Even so, overlapping continued to exist and the ggrepel package, which would help to solve it, did not really avoid them; it only helped to eliminate the labels that were too close at the cost of dislocating others. Another problem is that, according to Healy (2018), lines illustrate “connection and common fate in that the lines joining the shapes tend to be read left-to-right as part of a series” (Healy 2018). He mentions this when explaining Gestalt rules, which are “the strong inferences we make about relationships between visual elements from relatively sparse visual information.” The author emphasizes that line graphs suggest that the underlying variable is continuous and that is not necessarily advantageous for our data, since the X axis contains the generations, but it is not a continuous variable over time.\nThe Gestalt inferences. Extracted from: Data vizualization: a practical introduction, by Kieran Healy. Published by the author in https://socviz.co/One option was to make a Sankey diagram. These visualize flows of quantities through a process and, as an opinion, are more eye-catching. With a Sankey diagram, we would have split the amount spent by each generation in 2021 into 14 categories of data —or fewer, if we also decide to show only the top categories or to group several ones into “Others”—, and each generation would be a breakdown. However, this would give the false sense that the flow of money changes over a period of time and, in stricto sensu, it is not: spending does not change over time: all the data represented is from 2021. What does change is another categorical variable: generation.\nAn example of a Sanky diagram from Wikimedia Commons:\nWikimedia Commons.In addition, in data visualization, clarity should be privileged over the pomposity: Healy (2018) quotes Tufte about graphical excellence, commenting that it “consists of complex ideas communicated with clarity, precision, and efficiency.” Thus, the idea of a Sankey, despite being relatively simple to execute with the ggsankey package, was discarded. A cleaner, clearer and closer option to Lodha’s original graph is the line plot.\nDesigning the enhancements proposal\n\n\n#Libraries, most of them already used in the replica\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel) # To (try to) avoid label overlappings\n\n\nThe following pipes were useful for obtaining a suitable dataframe:\n\n\ndf <- read_csv(\"data.csv\") %>% \n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  #group_by(generation) %>%\n  arrange(desc(dollars))\n\n\nThen, the data was manipulated. Those code chunks will not be showed here as are the same than in the replica (renaming variables using indexing and generating the same character vectors).\nThe theme was a bit edited. This new version is called theme_lines().\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\n\n\ntheme_lines <- function() {\n\n  theme_bw(base_size = 15) +\n\n    # Background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_blank()) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Legend\n    theme(legend.position = \"bottom\") +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_rect(\n      fill = color_background)) +\n    theme(legend.text  = element_markdown(\n      color = color_text, \n      size = 6.5, \n      face = \"bold\")) +\n    theme(legend.title = element_blank()) +\n    theme(legend.direction = \"horizontal\") +\n    theme(legend.spacing.x = unit(0.3, 'cm')) +\n      \n    # Caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_markdown()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n\n}\n\n\nHere, we started the construction of the line plot. Note that each ggplot2 chunk must start with {r fig.width = 8.29, fig.height = 6.88} for it to be displayed with the same proportions of the original bump chart.\n\n\n# Used by the `ggrepel`. Ensures reproducibility of the same labels disposition\nset.seed(78)\n\n#Select only the head categories:\ndf <- \n  subset(df, variables %in% \n           c(head(unique(df$variables)))) \n\nenhan <- df %>% \nggplot() +\n  aes(x = generation, \n      y =dollars, \n      group = variables, \n      color= variables) + \n # Add lines\n   geom_line(\n    alpha = 0.6, \n    linewidth = 1.4) + \n  # Add points and their border:\n  geom_point(size = 4, \n           shape = 20, \n           alpha = 0.6) +\n  geom_point(size = 3, \n             shape = 1, \n             color=\"white\", \n             alpha = 0.7, \n             stroke = 0.7) +\n  # Order the axis x text\n  scale_x_discrete(\n     limits = x_names_ordered,\n     labels = x_names_full,\n     position = \"top\",\n     expand = expansion(mult = c(0.09, 0.1))\n                  ) +\n  scale_y_discrete(\n    expand = expansion(mult = c(0.001, 0.001))\n                  ) +\n  # Title, subtitle and caption. No tag this time.\nlabs(\n  title = \"HOW AMERICANS SPEND THEIR MONEY\",\n  subtitle = \"Top 6 categories by age group | 2021\",\n  caption = \"Author: Preethi Lodha\"\n) +\n\n# Format dollars spent labels\n   geom_text_repel(\n    aes(label = \n          paste0(\"$\", (format(df$dollars, \n                              big.mark=\",\", \n                              trim=TRUE))), \n      segment.square  = TRUE,\n      segment.inflect = TRUE\n    ),\n    # Max labels overlappings allowed:\n    max.overlaps  = 2, \n    size          = 2.5,\n    fontface      = \"bold\",\n    direction     = \"y\"\n    ) +\n  guides(colour = guide_legend(nrow = 1)) +\n  scale_color_manual(values = c(\n                                \"#ab3a6b\",\n                                \"#494c4d\",\n                                \"#3896c4\",\n                                \"#2f634a\", \n                                \"#af9e2e\",\n                                \"#ed444a\")) +\n  # Add the 2 horizontal white lines\n  coord_cartesian(clip = \"off\") +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(1.13, 1.13), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(-0.05, -0.05), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n  # Add the custom theme \n  theme_lines()\n\nenhan\n\n\n\nThere are 9 unlabeled data points, according to the warning message of the ggrepel package. We save the plot with the following code:\n# Save the plot\nggsave(\"enhancements.png\", \n       plot = last_plot(), \n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,\n       units = \"in\", \n       dpi = 120) # Resolution\nAlternative visualization(s)\nAn attempt was made to design an alternative graphic—and an alternative to the alternative. These, although better, still have some flaws.\nThe design of an alternative graph with the same data involved a nonlinear flow. Cleveland explains that data graphing should be an iterative process: “Iteration and experimentation are important for all of data analysis, including graphical data display. Most times when we make a graph it is immediately [sic] clear that some aspect is inadequate and we regraph the data. In many other cases we make a graph, and all is well, but we get an idea for studying the data in a different way with a different graph; one successful graph often suggests another” (Cleveland 1985).\nThe purposes that the new graph should follow were to make the data stand out and eliminate superfluity (Cleveland 1985). Another important point is ease of understanding. Heer and Bostock (2010) replicated previous studies on graphical perception by evaluating charts that encoded data in different ways. Basically, the best way to represent data is with comparison on a common scale —such as grouped bar charts— and the worst is to show it in areas like treemaps do (these performed even worse than pie charts!) (Heer and Bostock 2010). Given this, the theory suggests simplicity, cleanliness and clarity rather than fancy design details and pomposity. In this case, we went for simplicity even in contradiction to Cleveland, who argues that “[t]he important criterion for a graph is not simply how fast we can see a result; rather, it is whether through the use of the graph we can see something that would have been harder to see otherwise […]” (1985). We believe that it is very important that the graphic shows its main idea at first glance, especially in these days when we have so many visual stimuli on the Internet and they all fight for our attention.\nThus, visual cleanliness is a must, but for those intended for publication in websites such as the Visual Capitalist that target a wide and not necessarily expert audience, it is also a challenge. In addition, there are also studies that suggest that visual embellishment has a positive effect on the comprehension and memorability of graphics (Bateman et al. 2010). How to balance aesthetic taste and graphical excellence and integrity? We had to achieve all this without creating a chartjunk, as Tufte would call it, and without losing the purpose of the data, of the original bump chart and its context, and with a data that is only a small table.\nFor these reasons, the safe bet was to develop a grouped bar chart that shows spending categories, generation and amounts in a clear, simple and uncluttered way, but with a custom theme.\nA grouped bar chart, colorblind-friendly. This is the proposed alternative visualization. Own elaboration.The underlying cause why it is flipped is mainly to avoid label overlappings, which were the major problem in all the visualizations we tried with this data. A colorblind-friendly color palette was made. Also, the grid was eliminated according to Tufte: “one of the most sedate graphical elements, the grid, should usually be muted or completely suppressed so that its presence is only implicit—lest it compete with the data […]. Dark grid lines are chartjunk” (Tufte 2013). We do not agree that much with him in that regard, but we must accept that, at least in this case, they are not necessary: that information is already provided by the labels, which Tufte endorses. The choice of font was a personal choice.\nThis graphic has, however, some flaws: we find that the number of bars make it look bloated even though we reduced their number by including several in the “Others” category.\nAlso, the presence of a legend is not bad per sé, but in this case there are still several categories and the audience would have to constantly go back and forth from the legend to the plot to decipher what represents which bar. However, positioning the name of each spending category instead of the name, birth year range and total spent would make it even more bloated.\nAs the display of multiple bars seemed a bit cluttered even if, in our opinion, the plot delivers the correct visualization, a similar visualization was made. We considered that a lollipop plot could be an even better option, and is a close relative of bar plots.\nA grouped lollipop, also colorblind-friendly. Own elaboration.Clarity was the guideline for this lollipop graphic, too. However, some drawbacks arose: the overlapping labels made us decide to remove any geom_text or geom_label from our code and, contravening Tufte, plot a grid as an alternative. Only minor grids are shown and we set a number of grids that we felt was not exaggerated. We also it dashed and used a very subtle color so that it does not overload the plot too much. Still, it exists.\nBoth plots, even if simple, show the expenses per generation more clearly than the bump chart and have visual encodings, according to Heer and Bostock (2010), capable of being better interpreted than stacked bar charts, bubble charts, pie charts and treemaps, the latter being even less effective than pie charts. This last case caught our attention, as treemaps are quite common in all types of publications and are, in our personal opinion, visually appealing. See here an example of a treemap published by Le Monde newspaper.\nSo, we made one, just for comparison (and learning how-to) purposes:\nA treemap just for clarity comparison. Authors argue that it is not a good option due that areas are hard to compare, even more than angles (like the case of pie charts). Own elaboration.As can be seen, the bar plot is simpler and easier to understand than the treemap, as it uses a single visual mark, the bar, to represent the data. That specific visual mark is always of the same width, so the viewer decodes only the height of the bar to interpret the quantity it encodes. For that reason, the proposed bar plot is more effective at conveying the patterns of the data and to compare the values of different categories.\nWhat cannot be denied about the treemap is that it is visually more attractive, at least to our personal taste. Unfortunately, with this one it is more complicated to interpret the differences in the money spent by each generation in a single category. For example, if there were no money spent labels added, it would be difficult to compare Generation X and Generation Z spending on Housing. Besides, it was way more difficult to design. We could have designed one treemap with 5 subgroups —and not 5 invidivual treemaps and then paste them— and the result would have been more or less similar, but without the spaces between each subgroup and with problems to add specific colors for each generation. The code is at the end of this report.\nDesigning the bar plot\n\n\n# Libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel)\nlibrary(ggpubr)\n\n\nWe first computed the rankings just for the selecting the first categories.\n\n\ndf <- \n  read_csv(\"data.csv\") %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Rename categories lower in the ranking as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\n\nThen, the data was manipulated, and variables renamed.\n\n\n# Format the dollar column\n\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nA character vector for ordering the generations:\n\n\ngen_order <- c(\n  \"Generation Z\",\n  \"Millennials\",\n  \"Generation X\",\n  \"Boomers\",\n  \"Silent\"\n      )\n\n\nWe used the same colors:\n\n\n# Theme colours\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nLater, the custom theme was built. This was called theme_bar().\n\n\ntheme_bar <- function() {\n\n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Format the legend\n    theme(legend.position = \"top\") +\n    theme(\n       legend.text = element_markdown(\n        color = color_text,\n        family = \"Consolas\",\n        size = 7.5,\n        face = \"bold\",\n        hjust = 0)) + \n    theme(legend.title = element_blank()) +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_blank()) +\n\n    # Format de caption\n      theme(plot.caption = element_markdown(\n        hjust = 1, \n        family = \"Consolas\",\n        size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5,\n      margin=margin(4,0.2,4,0.2))) +\n    theme(plot.title.position = \"plot\") +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(4,0.2,4,0.2))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.y = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size = 8.5\n    )) +\n    theme(axis.text.x = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    \n    # Plot margins\n      theme(plot.margin = \n              unit(c(0.2, 0.7, 0.2, 0.7), \"cm\")) # top, right, bottom, left\n}\n\n\nThis is the colorblind friendly palette:\n\n\n#Colorblind friendly palette\ncolorblind <- c(\n                \"#5d3686\",\n                \"#c3a939\",\n                \"#6c7ed7\",\n                \"#b95336\",\n                \"#74a344\",\n                \"#a19f9f\",\n                \"#ba496b\",\n                \"#43c9b0\",\n                \"#c26abb\",\n                \"#ae853d\"\n                )\n\n\nThen the bar plot was designed:\n\n\ntag_house <- \"$26,385\"\n\nbar <- ggplot(df, aes(\n                      fill = reorder(variables, \n                                     desc(dollars)), \n                      y    = dollars,\n                      x    = generation)) +\n    geom_bar(position  = \"dodge\", # for groups\n             stat      = \"identity\",\n             linewidth = 0.05,\n             color     = color_background) +\n  # Add dollars' labels\n geom_text(aes(label = dollars2),\n            position      = position_dodge(0.9),\n            color         = color_text,\n            family        = \"Consolas\",\n            #vjust         = 0.5,\n            hjust         = -0.3,\n            size          = 2.5\n            ) +\n  # Order of the x Axis text\n  scale_x_discrete(\n    limits = gen_order,\n    labels = c(\n       \"**Generation Z**<br>1997 or later<br>**$41,636**\",\n       \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n       \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n       \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n      \"**Silent**<br>1945 or earlier<br>**$44,683**\"\n                )\n    ) +\n  # To manipulate the width of the graphic:\n  scale_y_continuous(\n        expand = c(0.005,0), #0.0632\n                    ) +\n  scale_fill_manual(\n    values = colorblind #colorblind-friendly palette\n                    ) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n   # As one of the bars was too large, we added its label manually as a tag\n    tag = tag_house \n       ) +\n  theme_bar() +\n  theme(\n    legend.box.margin = margin(0.2,2,0.2,0.1, unit = \"cm\"),\n    legend.spacing.x = unit(0.4, 'cm'),\n    plot.title.position = \"plot\",\n    plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 7.5,\n      color = color_background),\n    plot.tag.position = c(0.965, 0.332)) + #horizontal, vertical\n  coord_flip() \n  \nbar\n\n\n\nCode for saving the plot:\nggsave(\"alternative_bar.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the lollipop plot\nThe same bar plot theme was used.\n\n\ngen_order <- c(\n        \"Silent\",\n       \"Boomers\",\n       \"Generation X\",\n       \"Millennials\",\n       \"Generation Z\")\n\n\n\n\nlol <-\nggplot(df)+\n    geom_linerange(aes(\n      x = generation,\n      ymin = 0, \n      ymax = dollars, \n      colour = reorder(variables, desc(dollars))), \n      position = position_dodge(0.8))+\n    geom_point(\n      aes(\n        x = generation,\n        y = dollars,\n        colour = reorder(variables, desc(dollars)),\n      ),\n      size = 4,\n      position = position_dodge(0.8)\n    ) +\n    scale_x_discrete(\n    limits = gen_order,\n    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\",\n               \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n               \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n               \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n               \"**Generation Z**<br>1997 or later<br>**$41,636**\")\n               ) +\n  scale_y_continuous(\n        expand = c(0.03,0),\n        n.breaks = 8\n        ) +\n  scale_color_manual(values = colorblind) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\"\n       ) +\n  theme_bar() +\n    theme(\n          legend.box.margin = margin(0.2,1,0.2,0.2, unit = \"cm\"),\n          legend.spacing.x = unit(0.4, 'cm'),\n          axis.text.x = element_markdown(\n                                        color = \"#3b3b3a\", \n                                        family = \"Consolas\", \n                                        size=7.5\n                                      ),\n          plot.title.position = \"plot\",\n          panel.grid.major.y = element_line(color = \"#b0aeae\",\n                                          linewidth = 0.25,\n                                          linetype = \"dashed\"))\nlol\n\n\n\nThe plot was saved with:\nggsave(\"alternative_lol.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the treemap\nFinally, just for learning and comparison purposes, the treemap code is shown below. As said before, authors do not recommend this kind of visualizations because differences in areas are hard to perceive. Besides, when compared with the bar plot or the lollipop, looks way more bloated and less effective.\n\n\n# Import libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(treemapify)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(ggpubr)\n\n\n\n\n# Import data\ndf <- read_csv(\"data.csv\")\n\n# Data wrangling\n\ndf <- df %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products \\n and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n# Categorize observations with a ranking <= 9 as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\n\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\ndf$ranking <- NULL\n\n\n\n\ntheme_tree <- function() {\n  \n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    #theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_markdown(\n      hjust = 1, \n      family = \"Consolas\",\n      size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), \"cm\")) # top, right, bottom, left\n}\n\n\n\n\n# Format the dollars column.\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nDesigning the 5 treemaps:\n\n\nx <- ggplot(df %>% filter(generation==\"Generation X\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#4b4d27\",\n                              \"#a4a671\",\n                              \"#717342\",\n                              \"#717342\"))\n\nmillennials <- ggplot(df %>% filter(generation==\"Millennials\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#805b28\",\n                              \"#e3af6b\",\n                              \"#c49350\",\n                              \"#c49350\"))\n                              \n\nboomers <- ggplot(df %>% filter(generation==\"Boomers\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left        \n    scale_fill_manual(values=c(\"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#96592d\",\n                              \"#e39762\",\n                              \"#be7c4d\",\n                              \"#be7c4d\"))\n                              \n\nsilent <- ggplot(df %>% filter(generation==\"Silent\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n    scale_fill_manual(values=c(\"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#63431d\",\n                              \"#ba9a73\",\n                              \"#9a7447\",\n                              \"#9a7447\"))\n                              \nz <- ggplot(df %>% filter(generation==\"Generation Z\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n      scale_fill_manual(values=c(\"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#61563f\",\n                              \"#baac91\",\n                              \"#897d65\",\n                              \"#897d65\"))\n\n\nThe treemap was, in fact, five glued treemaps. For that reason, the legend could not be displayed properly, so we made a very simple bar plot containing a legend, and the get_leyend function extracted it. Then, we converted it into an ggplot2 element with the as_ggplot function. This procedure allowed us to use the patchwork package and paste the 5 treemaps plus the legend. The ggpubr and cowplot packages were used for these purposes.\n\n\n# Summarize the spendings per generation\ndf_summ <- df %>%\n    group_by(generation) %>%\n    summarise(total_per_generation = sum(dollars))\n\n\n\n\ngen_order <- c(\"Silent\", \n       \"Boomers\", \n       \"Generation X\", \n       \"Millennials\", \n       \"Generation Z\")\n\n\n\n\n# Set custom colors\nbar_colors <- c(\"#9a7447\",\n                          \"#be7c4d\",\n                          \"#717342\",\n                          \"#c49350\",\n                          \"#897d65\"\n)\n\nbar2 <- ggplot(df_summ) +\n  aes(\n    x = generation,\n    fill = generation,\n    weight = total_per_generation) +\n  geom_bar() +\n  scale_fill_manual(breaks=gen_order, \n                    values = bar_colors,\n                    name = \"\",\n                    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\", \n                               \"**Boomers**<br>1946 to 1964<br>$**62,203**\", \n                               \"**Generation X**<br>1965 to 1980<br>**$83,357**\", \n                               \"**Millennials**<br>1981 to 1996<br>**$69,061**\", \n                               \"**Generation Z**<br>1997 or later<br>**$41,636**\")) +\n  scale_x_discrete(\n    limits = gen_order) +\n  theme_minimal() +\n  theme(plot.margin = unit(c(0,0,0,0), \"pt\")) +\n  theme(legend.text = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) + # top, right, bottom, left\n  theme(legend.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) +\n  theme(legend.position = \"bottom\") +\n  theme(legend.spacing.x = unit(0.5, 'cm'))\n\nbar2\n\n\n\n\n\n# Extract the legend\nlegend_extract <- get_legend(bar2) \n\n\n\n\n# Turn the legend into a ggplot2 object\nlegend <- as_ggplot(legend_extract)\n\n\nPaste all graphics:\n\n\ntree <- legend + ((silent / boomers) | (x / millennials) + z) + \n  plot_layout(\n              nrow = 2,\n              ncol = 1,\n              heights = c(0.5, 6)) +\n  plot_annotation(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n    \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n    theme = theme_tree()\n                  )\n\ntree\n\n\n\nSave plot:\nggsave(\"alternative_tree.png\", \n       plot = last_plot(), \n       path = \"images\", \n       width = 8.29, \n       height = 6.88, \n       units = \"in\", \n       dpi = 300)\nNeedless to say, replicating the graphic and proposing new visualizations were very learning exercises. Being able to design better graphics with cleaner and shorter code is still a longer term task.\n\n\n\nBateman, Scott, Regan L. Mandryk, Carl Gutwin, Aaron Genest, David McDine, and Christopher Brooks. 2010. “Useful Junk?: The Effects of Visual Embellishment on Comprehension and Memorability of Charts.” In Proceedings of the 28th International Conference on Human Factors in Computing Systems - CHI ’10, 2573. Atlanta, Georgia, USA: ACM Press. https://doi.org/10.1145/1753326.1753716.\n\n\nBump, Philip. 2021. “America’s Favorite Dog Breeds for the Past Two Decades, Ranked.” Washington Post, November 25, 2021. https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/.\n\n\nCleveland, William S. 1985. The Elements of Graphing Data. Monterey, Calif: Wadsworth Advanced Books and Software.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical Introduction. Princeton, NJ: Princeton University Press.\n\n\nHeer, Jeffrey, and Michael Bostock. 2010. “Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.”\n\n\nLodha, Preethi. 2022. “How Do Americans Spend Their Money, By Generation?” Visual Capitalist. September 25, 2022. https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/.\n\n\nTufte, Edward R. 2013. The visual display of quantitative information. 2nd ed., 8th print. Cheshire, Conn: Graphics Press.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n\n\n\n",
    "preview": "projects/2022/100481925/images/replica.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 994,
    "preview_height": 825
  },
  {
    "path": "projects/2022/100483607/",
    "title": "Distribution of state investment by autonomous communities",
    "description": "This following page is a guide, of how to reproduce step by step, the plot of \"El Mundo Gráficos\" done by the student Pablo Arroyo as a final project for the subject.",
    "author": [
      {
        "name": "Pablo Arroyo Rodriguez",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLabs\nLegend\n\nImprovements\nCode\n\nConclusion\n\nThe distribution of state investment by autonomous communities, it is a tricky topic that each year comes to the news. When the State´s budget is published, almost the first thing that each media do is to analyze what are the communities that receive more, and what are the ones that receive less. This could be important, because depending on the needing of support for the governance, more money would go to one community or another.\nThe point here, is in the differences between Madrid and Catalonia. However, as illustrated here, the budget from Catalonia is closer to Andalusia rather than Madrid. We can see notices of this kind in the national press channel “Catalonia and Andalusia lead state investment with almost twice the budget of Madrid and the Valencian Community” or the “El Mundo” from which I took the graph.\nJ.Aguirre | EL MUNDO GRÁFICOS. Figure from elmundo.es.Getting the data\nApparently, the data could be really easy to obtain from an official source, because if you observe this same data from different papers, figures vary a bit. But, as expected with public institutions, the process is really tedious. So, what I did is to obtain the data from the public institution in charge of this figures in Spain, La Intervención General de la Administración del Estado with data from 2009 to 2022.\nFor data about the budget for the next year, 2023, I used another official page which show the information in a visual way, Ministerio de Hacienda, epdata.\nOnce you get the file with the whole datasheet from one specific year, you have to sum the different budget items by communities. It appears spread by different concepts, as a page in an excel book and repeating the process for the four years. Having done that, it is possible to obtain the data in a .cvs file format. So, we will see how our data looks like:\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggsci)\nlibrary(ggforce)\nlibrary(glue)\nlibrary(systemfonts)\nlibrary(cowplot)\n\nsysfonts::font_add_google(\"Be Vietnam Pro\")\nshowtext::showtext_opts(dpi=300)\n\ndata<- read_delim(\"Clean_Data.csv\", delim = \";\", col_types = \"cnnnn\"  )\nglimpse(data)\n\nRows: 19\nColumns: 5\n$ Comunidad <chr> \"Andalucia\", \"Cataluña\", \"Com. de Madrid\", \"C. Val…\n$ `2018`    <dbl> 1379.7, 1312.1, 1117.2, 700.0, 894.8, 962.7, 533.9…\n$ `2021`    <dbl> 2146.16, 2199.30, 1133.90, 1106.90, 792.60, 799.20…\n$ `2022`    <dbl> 2267.07, 2430.74, 1054.90, 1155.60, 1033.50, 935.2…\n$ `2023`    <dbl> 2318.8, 2508.9, 1305.4, 1269.5, 1077.9, 955.8, 600…\n\nIt is impossible to observe the whole datasheet. So, with the previous function glimpse(), we can take a quick view of the general structure, in order to observe more or less how it is. But for observing the main measures of central tendency from our data and its evolution through this for years, it would be nice to include the summary () function.\n\n\nsummary(data)\n\n  Comunidad              2018             2021        \n Length:19          Min.   :  23.5   Min.   :  24.48  \n Class :character   1st Qu.: 195.3   1st Qu.: 216.80  \n Mode  :character   Median : 363.9   Median : 384.10  \n                    Mean   : 504.7   Mean   : 622.11  \n                    3rd Qu.: 797.4   3rd Qu.: 795.90  \n                    Max.   :1379.7   Max.   :2199.30  \n      2022              2023       \n Min.   :  31.85   Min.   :  28.9  \n 1st Qu.: 192.60   1st Qu.: 241.4  \n Median : 439.30   Median : 481.5  \n Mean   : 666.25   Mean   : 718.1  \n 3rd Qu.: 984.35   3rd Qu.:1016.9  \n Max.   :2430.74   Max.   :2508.9  \n\nOnce we have our raw data, it is time to start giving format to our variables, in order that they appear specifically how we want them, not as mere values in a table.\n\n\ndata<-data %>% \n  pivot_longer(c(\"2018\", \"2021\", \"2022\", \"2023\")) %>% \n  mutate(\n    Comunidad=as.factor(Comunidad),\n    name=as.factor(name),\n  )\n\n\nFirst thing to do is to mutate them as a long format, which is more useful for visualization and statistics approaches. Also, it is important to convert the name of the communities and the name of the year, 2023, 2022, 2021, 2018, as factors. That is the way that we have in R to specify the categories in the representation.\nNow, it is possible to say that our data seems to be what it would be expected to start the construction of the graph.\nBuilding the chart\nThe plot was selected because it could seem easy to reproduce, and was the first time dealing with this kind of representation on my own. However, it started to get harder and harder to deal with this grouped bar chart, and the small details were really time consuming. But finally, it was possible to come up with a result as could be seen in the following lines:\nCoordinates and axes\nI will try to reproduce the graph, step by step, before adding the data and obtaining the whole plot.\n\n\np <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\np\n\n\n\nWith this first chunk of code, the baseline of the plot appears. Based on which, we will be adding information and modifying the different characteristic, in order to satisfy the same specification as in the selected one. However, the names of the communities are all together and it is really difficult to understand. It is a pointless point, so it´s worth it to have a vertical disposition instead of a horizontal one, the categories would be more readable.\nAs it could be seen in the example, the graph has certain limits for the values of our data. One of the first points that we have to do, is to fix those values within the specific categories. In this case from 0 to 3000 in steps of 500. I decided to expand the limits a bit more than this 3000, because otherwise the label for this 3000 extended passed the axis and we could not see it.\nThere are also coordinates for the negative part of the graph despite not having negative information for the budgets. That is because we have to extend the lines and add the names of the communities in this part as annotations, otherwise it would be impossible.\nA good point to highlight here, and which was really hard to find, is how to set the y axis on both sides. Although it is a simple line of code, it took me a while to find this specific chunk of code, so if some of you need this in the future pay attention at this point, because the rest is more or less the same as in all plots.\n\n\np <- p + scale_y_continuous(\n    breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000),\n    limits = c(-1500, 3200),\n    sec.axis = dup_axis(),\n    name = NULL,\n    expand = c(0,0)\n  ) +\n  \n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \"Baleares\", \n               \"Cantabria\", \"Canarias\", \"Asturias\", \"Extremadura\", \n               \"Murcia\", \n               \"Aragón\", \"País Vasco\", \"Castilla-La Mancha\", \n               \"Castilla y León\", \"Galicia\", \"C. Valenciana\", \n               \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\np\n\n\n\nA last comment about this previous chunk. The names of the axis have been deleted, because we do not want it to appear in our last graph, but also, we set a specific order for the name of the communities, based on the highest budget for the year 2023.\nTheme\nThe theme for this project is very easy. As it can be seen, the background of the graph is empty, nothing inside, but for, the lines below the name of each community which separate one community from another. A key point here is that we have established the small tick that appears below each break. Maybe, in this position it is hard to identify, but once we apply for coord_flip() it is more easy to observe.\n\n\np <- p + theme_minimal()+\n  \n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n    \np\n\n\n\nWe have an empty graph, with nothing inside which is the case that we are trying to replicate. However, we need to add the guides, and coord_flip() to see something similar to the original one. So, we will do it.\n\n\np <- p +  coord_flip(clip = \"off\", ylim = c(-1500, 3100))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 3100),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\np\n\n\n\nInstead of having a vertical bar chart which is the usual scenario after applying for these changes, we have a horizontal plot, with nothing inside. The graph is starting to seem similar to the original one. However, it is a kind of graph that by its nature, it is much longer than wider, so we have to change the adjustment of our R.Markdown to obtain what we want.\nNotice, that we have changed the specification of the graph, the plot is more or less what we want. Now is the time to add the data and the annotations.\nAnnotations\nApparently, this graph does not have any kind of annotation. However, it is a bit misleading and there was no other way to add the name of the communities rather than as an annotation. To do so, what I did is to extend the dimension of the plot past the axis, and once we have that, adding in the negative part the name corresponding to the different communities as annotations.\n\n\np <- p + annotate(\"text\", x = 19, y = -1400, hjust=0, \n           label = \"Cataluña\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 18, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13, y = -1400, hjust=0,  \n           label = \"Castilla-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\np\n\n\n\nData\nThis graph is based on grouped data by an autonomous community. With the name of the different communities and their budget from four different years, that is why in the previous steps it was important to pivot longer the data, and establish the different year and communities as_factor(). So, it is the type of grouped bar chart.\nNow, we will add the data to the previous coordinates and axis that we have been preparing, but also we will establish the different colors of the bars.\n\n\np <- p + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\np\n\n\n\nThe graph it is closer to our final result. Few things are still left such as a good title, subtitle and caption. But also, we have to establish a good position for the legend which is almost higher than the plot, and this does not make any sense.\nLabs\nA key point that it is still missing in this graph are the labs. If we see the graph until this point, we do not know what the graph is about without an appropriate title, it is mandatory to modify it, and also adding the different subtitles and comments.\n\n\np <- p + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\n\nHowever, when we add all of these things, our plot is completely a mess, because we have added many different things, without the necessary adjustment. So, everything has moved from one place to another and appears to be untidy. Let´s try to solve it! Basically, we will be adjusting almost every position of the element on the plot.\n\n\np <- p + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n     axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, face=\"bold\", \n                              margin=margin(0,0,0,0)),\n     plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                  size=9.5, color= \"black\", \n                                  face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n    ) \np\n\n\n\nLegend\nHowever, we still have the legend in a position that modifies the whole graph, and we have to change that to obtain a real reproduction.\n\n\np<- p +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.285, 1.05), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n    ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\np\n\n\n\nOnce we have done that, the representation is consistent with what we want, because everything is adjusted and aligned, not as in the previous steps, that when you modify something everything changes and you have to start again. But never give up, you will finish doing it!\nIt is time to introduce the annotation near to the name of each community. I tried to do it at the same time in just one chunk of code, but only the names from 3 different communities and the other disappeared. I do not know the reason well. So that is why I decided to do it step by step although it is longer. Sure, there is a better option.\nAnd also we have to add a little more. Notice that at the bottom of the graph there is more information than just a simple caption, so we have to add also this information. The way that I found better to add this information is by using the ggdraw(), which will be included at the end of the next chunk.\n\n\np<- p +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\np <- ggdraw(add_sub(p, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\n\np\n\n\n\nImprovements\nThe plot that I decided to reproduce, was quite complete with almost all the elements that should be included for a good representation, such as: a nice axis with its reference, annotations of different values, a clear legend, nice colors and so on.\nHowever, as a reader of newspapers I miss an interesting point that all graphs should have, something that draws our attention and keeps us reading the notice. This could be done by introducing some interesting point, or maybe some controversial that keeps readers awake, that is why I decided to do the following graph:\nP.Arroyo | MUCSS.Mainly, I decided to do two thing:\nAdding the name of the policy party that is in charge of each community.\nIncluding the evolution of the budget per community with an ascending or descending arrow.\nBy doing that, we include some controversial questions that encourage readers to go deeper in the theme. That is because, as said in the introduction, in Spain it is believed by many people that the budget that each community receives depends on sympathy with the central government.\nWhat, surprised me when I was doing this tutorial, is that also the original author of the previous graph, Javier Aguirre, has introduced some modifications in line with the ones that I was doing. The idea was the same, but his ones were more visual so I decided to continue my path in that way because it was just a few lines of code and the appearance was better. “See news with the final graph” This is a good point to remark, that once you get a nice graph, there is always a way to improve it based on the previous one.\nI have to point out that I don’t like in his definitive graph the inclusion of the top X axis, because there is so much information in the positive part that you will end up missing.\nCode\nI want to comment on the key point that I made to modify the whole graph. Also, I know that a good point of improvement is reducing the code to reproduce exactly the same, by for example using sequences that is something that I would like to do in future steps.\nMain points to highlight:\nExtending the limits of the axis passed the data, from -1500 to 4500, to introduce the different elements as annotations.\nSelecting just one X axis for reference instead of dup_axis(), in order not to overload the plot.\nCompute the percentage variation and add the different elements as annotations in this new axis.\nNevertheless, I include the whole chunk of code, knowing as I said before that there is enough space to do it in fewer lines, but the first step is a nice way of starting.\n\n\n### Coordinates and axes\nt <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\nt <- t + scale_y_continuous(\n  breaks = c(0, 1000, 2000, 3000),\n  #sec.axis = dup_axis(),\n  name = NULL,\n  expand = c(0,0)\n) +\n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \n               \"Baleares\", \"Cantabria\", \"Canarias\", \"Asturias\", \n               \"Extremadura\", \"Murcia\", \"Aragón\", \"País Vasco\", \n               \"Castilla-La Mancha\", \"Castilla y León\", \"Galicia\", \n               \"C. Valenciana\", \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\n### Theme\nt <- t + theme_minimal()+\n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n\nt <- t +  coord_flip(clip = \"off\", ylim = c(-1500, 4500))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 4500),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\n### Annotations for the left name of the communities\nt <- t + annotate(\"text\", x = 19.2, y = -1400, hjust=0, \n                  label = \"Cataluña\", size = 3, \n                  colour = \"#262626\")+\n  annotate(\"text\", x = 18.2, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17.2, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16.2, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15.2, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14.2, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13.2, y = -1400, hjust=0,  \n           label = \"C.-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12.2, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11.2, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10.2, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9.2, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8.2, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7.2, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6.2, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5.2, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4.2, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3.2, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2.2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1.2, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\n##Annotations for adding the different boxes based on the party in charge of each community\nt<- t + annotate(geom = \"rect\", xmin = 19, xmax = 18.75,\n                 ymin = -1400, ymax = -1200, fill = \"#f3af44\", alpha = 1) + #Cataluña\n  annotate(geom = \"rect\", xmin = 18, xmax = 17.75, #Andalucia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 17, xmax = 16.75, #Com.Mad\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 16, xmax = 15.75, #C.Valenciana\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) + \n  annotate(geom = \"rect\", xmin = 15, xmax = 14.75, #Galicia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 14, xmax = 13.75, #CyL\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 13, xmax = 12.75, #C.Mancha\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 12, xmax = 11.75, #País Vasco\n           ymin = -1400, ymax = -1200, fill = \"#22823a\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 11, xmax = 10.75, #Aragon\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 10, xmax = 9.75, #Murcia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 9, xmax = 8.75, #Extremadura\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 8, xmax = 7.75, #Asturias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 7, xmax = 6.75, #Canarias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 6, xmax = 5.75, #Cantabria\n           ymin = -1400, ymax = -1200, fill = \"#81b881\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 5, xmax = 4.75, #Baleares\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 4, xmax = 3.75, #Navarra\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 3, xmax = 2.75, #Rioja\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 2, xmax = 1.75, #Melilla\n           ymin = -1400, ymax = -1200, fill = \"#d9d9d9\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 1, xmax = 0.75, #Ceuta\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1)\n\n###Annotation for the ascendent/descent arrow based on the budget.\nt<- t + geom_segment(\n  x = 18.85, y = 3700,\n  xend = 19.1, yend = 3700,\n  lineend = \"round\", \n  linejoin = \"round\",\n  size = 1, \n  arrow = arrow(length = unit(0.3, \"cm\")),\n  colour = \"#1d1d1b\" \n) +\n  geom_segment(\n    x = 17.85, y = 3700,\n    xend = 18.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 16.85, y = 3700,\n    xend = 17.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 15.85 , y = 3700,\n    xend = 16.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 14.85 , y = 3700,\n    xend = 15.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) + \n  geom_segment(\n    x = 14.1 , y = 3700,\n    xend = 13.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 12.85 , y = 3700,\n    xend = 13.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 11.85 , y = 3700,\n    xend = 12.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.85 , y = 3700,\n    xend = 11.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.1 , y = 3700,\n    xend = 9.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 8.85 , y = 3700,\n    xend = 9.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 7.85 , y = 3700,\n    xend = 8.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 6.85 , y = 3700,\n    xend = 7.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 5.85 , y = 3700,\n    xend = 6.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 4.85 , y = 3700,\n    xend = 5.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 3.85 , y = 3700,\n    xend = 4.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.85 , y = 3700,\n    xend = 3.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.1, y = 3700,\n    xend = 1.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 1.1 , y = 3700,\n    xend = 0.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  )\n\n### Annotation fot the variations in the GDP.\n\nt<- t + annotate(geom = \"text\", x = 18.975, y = 3950,\n                 label = \"3.2\", hjust = 0, size = 3) + #Cataluña\n  annotate(geom = \"text\", x = 17.975, y = 3950,\n           label = \"2.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.975, y = 3950,\n           label = \"13.4\", hjust = 0, size = 3) + #Madrid\n  annotate(geom = \"text\", x = 15.975, y = 3950,\n           label = \"5\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.975, y = 3950,\n           label = \"0.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.975, y = 3950,\n           label = \"-4.2\", hjust = 0, size = 3) + #CyL\n  annotate(geom = \"text\", x = 12.975, y = 3950,\n           label = \"11.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 11.975, y = 3950,\n           label = \"14.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.975, y = 3950,\n           label = \"4.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.975, y = 3950,\n           label = \"-33.4\", hjust = 0, size = 3) + #Murcia\n  annotate(geom = \"text\", x = 8.975, y = 3950,\n           label = \"16.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.975, y = 3950,\n           label = \"7.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.975, y = 3950,\n           label = \"23.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 4.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.975, y = 3950,\n           label = \"34.7\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.975, y = 3950,\n           label = \"12.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.975, y = 3950,\n           label = \"-24.4\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.975, y = 3950,\n           label = \"-9.3\", hjust = 0, size = 3) \n\n\n##Anotation for adding the different text of the party in charge!\n\nt<- t + annotate(geom = \"text\", x = 18.875, y = -1100,\n                 label = \"ERC\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 17.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 15.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 12.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) + \n  annotate(geom = \"text\", x = 11.875, y = -1100,\n           label = \"PNV\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 8.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.875, y = -1100,\n           label = \"PRC\", hjust = 0, size = 3) + ##Cantabria\n  annotate(geom = \"text\", x = 4.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.875, y = -1100,\n           label = \"Indep\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) \n\n\n##Anottation for the tittle of this column\nt<- t + annotate(geom = \"text\", x = 19.68, y = 3200,\n                 label = \"Var. % 2022/23\", hjust = 0, size = 3, fontface = \"bold\")\n\n### Adding the data\nt <- t + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\n### Labs\nt <- t + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\nt <- t + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n    axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, \n                              face=\"bold\", margin=margin(0,0,0,0)),\n    plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                 size=9.5, color= \"black\", \n                                 face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n  ) \n\n###Anotations for the homemade guide about the different policies parties.\n\nt<- t + annotate(geom = \"text\", x = 20.5, y = -1500,\n                 label = \"Presidencias de las CCAA\", hjust = 0, size = 3) +\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -1500, ymax = -1300, fill = \"#e52b43\", alpha = 1) +#Color PSOE\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -500, ymax = -300, fill = \"#0086c5\", alpha = 1) + #Color PP\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 500, ymax = 700, fill = \"#f3af44\", alpha = 1)+ #Color ERC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 1500, ymax = 1700, fill = \"#22823a\", alpha = 1)+ #Color PNV\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 2500, ymax = 2700, fill = \"#81b881\", alpha = 1)+ #Color PRC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 3500, ymax = 3700, fill = \"#d9d9d9\", alpha = 1)+ #Color Indep.\n  annotate(geom = \"text\", x = 20.125, y = -1275,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 20.125, y = -275,\n           label = \"PP\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 725,\n           label = \"ERC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 1725,\n           label = \"PNV\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 2725,\n           label = \"PRC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 3725,\n           label = \"Indep.\", hjust = 0, size = 3)\n\n### Legend\nt<- t +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.295, 1.027), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n  ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\n\nt<- t +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\nt <- ggdraw(add_sub(t, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\nt\n\n\n\nConclusion\nOnce I completed the whole project, I have to say that it is a challenging process. You will be dealing with new tools that we have never seen before although they are really useful.\nYou will realize that after many hours of work, those things that in the first lesson sound like double Dutch to us, little by little everything starts to make sense. So, enjoy the process because this wonderful world of Data Visualization has many things to discover.\n\n\n\n",
    "preview": "projects/2022/100483607/ccaa470.jpg",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {}
  },
  {
    "path": "projects/2022/100489635/",
    "title": "GDP Forecasts for China's Cities by 'The Economist': Coastal Areas Have the Highest Growth Potential",
    "description": "A layer-by-layer construction of a map of China containing information on forecasted GDP growth and population for over 100 cities.",
    "author": [
      {
        "name": "Elena Yustres",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original chart\nObtaining and processing the data\nBuilding the plot\n\nEvaluation and potential enhancements\nAlternative visualization\n\nAs both a cause and consequence of China’s rapid economic growth, the proportion of the country’s population living in cities has soared from 20% in 1980 to 60% in 2020. However, China’s Zero-Covid policy has stilted growth significantly. The “China Emerging City Rankings, 2022” Report, launched by the Economist Intelligence Unit (EIU), assesses the growth potential of 108 cities predicted to have a population of more than 1 million by 2025. Scores are calculated using historical data and forecasts on variables including demography, the local economy or the environment.\nThe Economist’s “March of the cities” map. Figure from economist.com.This post will seek to replicate this map, propose incremental enhancements and suggest an alternative visualization that depicts the relationship between growth potential, population and location (or distance to the coastline) taking cities as our units of analysis.\nThe original chart\nObtaining and processing the data\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(showtext)\nlibrary(maps)\nlibrary(maptools)\nlibrary(svglite)\nlibrary(plyr)\n\nsysfonts::font_add_google(\"IBM Plex Sans\", family=\"IBM Plex Sans\")\nshowtext::showtext_auto()\n\n\nDiving into data collection, we obtained the data on the ranking and population of our units of analysis from the EIU (‘Global Geo-Political Trends and Economics’ section) after contacting their office in Asia by email.\n\n\nranking <- read_csv(\"ranking.csv\")\npopulation <- read_csv(\"population.csv\")\n\n\nOnce we have loaded both sets of data, the summaries below show that the ‘ranking’ dataset contains data on scores for 106 cities (ordered from highest, i.e. Ranking = 1, to lowest) while the ‘population’ dataset includes population data for 397 cities in China.\n\n\nglimpse(ranking)\n\nRows: 106\nColumns: 2\n$ City    <chr> \"Hangzhou\", \"Shenzhen\", \"Shanghai\", \"Suzhou\", \"Guang…\n$ Ranking <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\nglimpse(population)\n\nRows: 397\nColumns: 2\n$ City       <chr> \"Shanghai\", \"Beijing\", \"Shenzhen\", \"Guangzhou\", \"…\n$ Population <dbl> 22315474, 18960744, 17494398, 16096724, 13568357,…\n\nIn order to get both attributes (“Ranking” and “Population”) on the same dataset, we used a left_join to merge both datasets by the unit of analysis (“City”). This produced a dataset with both variables for the 106 cities provided by the EIU. Please note that, while the original map in the article by ‘The Economist’ includes 108 cities, the EIU only provided us with data on 106.\n\n\noutput <- ranking %>% left_join(population, by=\"City\")\n\n\nIn order to obtain the “longitude” and “latitude” of each city, we used the world.cities database. This database includes these and other variables for over 40,000 cities in the world. We then filtered the cities in China and selected (as well as renamed) the variables of interest to later on construct my final database.\n\n\ndata <- world.cities %>%\n  filter(country.etc==\"China\") %>%\n  dplyr::select(name, lat, long) %>%\n  dplyr::rename(\"City\"=\"name\", \n         \"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\") \n\n\nWe then merged the location dataset (‘data’) and the dataset with information on ranking and location (‘output’).\n\n\nfulloutput <- output %>% left_join(data, by=\"City\")\n\n\nThe data also required some cleaning and adjustment. First, there were two cities with the same name (i.e. Suzhou) in the EIU ranking. Since they are located in different provinces, we used population and location data to cross check which city corresponded to which score provided by the EIU and renamed one of them to establish the difference. Second, there were several other cities in the ‘data’ dataset with the same name as cities in the ‘output’ one, which led to there being more than one row for each unit of analysis in the ‘fulloutput’ table. We removed the appropriate rows, as well as the rows for which latitude and longitude data were not available (i.e. NAs for those variables). We are left with 104 rows.\n\n\nfulloutputclean <- fulloutput[-c(5, 23, 49, 51, 70, 81, 104, 113),]\nfulloutputclean <- fulloutputclean[!is.na(fulloutputclean$Latitude) \n                                   & !is.na(fulloutputclean$Longitude), ]\nhead(fulloutputclean, 5)\n\n# A tibble: 5 × 5\n  City      Ranking Population Latitude Longitude\n  <chr>       <dbl>      <dbl>    <dbl>     <dbl>\n1 Hangzhou        1    9236032     30.2      120.\n2 Shenzhen        2   17494398     22.5      114.\n3 Shanghai        3   22315474     31.2      121.\n4 Suzhou          4    6715559     31.3      121.\n5 Guangzhou       5   16096724     23.1      113.\n\nThe final step in data processing was obtaining the data to plot the underlying map of China and its provinces. The ggplot2-china-map repository contains such information. We used the readOGR function to read the ‘shapefile’, cleaned the data and fortified into a dataframe. We then instructed that the islands in the South China Sea not be drawn by selecting only observations with “AREA” above 0.005. Finally, again, we renamed variables accordingly.\n\n\nchina <- rgdal::readOGR(dsn=(\"./china_shapefile/\"), layer=\"bou2_4p\", verbose=FALSE)\nchina@data$id<-rownames(china@data)\nchina.points<-fortify(china, region=\"id\")\nchina.df<-join(china.points, china@data, by=\"id\")\nchina<-subset(china.df, AREA>0.005) %>% \n  dplyr::rename(\"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\",\n         \"Grouping\"=\"group\")\n\n\nBuilding the plot\nCoordinates of the map and data points\nUsing the data loaded in ‘china’ in the last step, we use geom_polygon() to draw the underlying map. The aes argument maps the longitude and latitude columns to the x and y coordinates, respectively. This function is also used to specify the fill and the transparency (alpha) level of the map.\nWe then use geom_path() to set the line demarcating the province limits. After indicating the use of the same variables and the same dataset as for the geom_polygon() function, we set the color and size of the border.\nFurther, coord_map() sets the coordinate system for the map by projecting the defined portion of the Earth onto a flat 2D plane.\n\n\np <- ggplot() +\n  geom_polygon(data=china,\n            aes(x=Longitude, y=Latitude, group=Grouping),\n            fill=\"cornsilk3\",\n            alpha=0.3) +\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping),\n            color=\"white\",\n            size=0.2) +\n  coord_map() \np\n\n\n\nNext, we add the data points at the specific locations of the 104 cities (defined by their latitude and longitude) with geom_point(). Thus, on top of the map, we are plotting a scatterplot using data from ‘fulloutputclean’ where each point represents one city. The size of the point (more specifically, its area) represents its population and its fill depicts the relative position of a given city vis-à-vis other cities in the EIU ranking. We then set a black line around the point (shape=21) while specifying the color and thickness (stroke) of the border.\nA title, subtitle and caption are added to replicate the original chart using the labs function.\n\n\np2 <- p + \n  geom_point(data=fulloutputclean, \n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking), \n             shape=21,\n             color=\"black\",\n             stroke=0.03) +\n  labs(title=\"March of the cities\",                                                                   \n       subtitle=\"China, emerging city ranking, 2022\",\n       caption=\"Source: EIU\") \np2\n\n\n\nScales\nNext, the scale_fill_stepsn() and scale_size() functions are used to customize the appearance of the legends for the color and size aesthetics, respectively.\nFor the color legend (or rather, fill legend, given our points have borders defined by the color argument as introduced in the previous section), we first specify its title and title position. We then specify the details relating to the ticks and limits between the different boxes of the legend. We set the values for the 7 breaks in the variable ‘Ranking’ so as to create six categories of rank scores. By means of a drawing tool using the hexadecimal system, we set the colors for each of the six categories. Note that higher-ranked cities are represented with shades of blue and lower-ranked cities are represented with shades of orange or brown, whereby darker shades of both colors represent the ends of the spectrum.\nFor the size legend, we do the same as with the fill legend regarding the title and the breaks, although this time we are specifying 3 breaks. In this case we are also setting the labels for those breaks. This is because, by default, R uses scientific notation for population but the legend title already states that values are provided in millions. Finally, we set the range of the size of the bubbles from 0.04 to 6 mm.\n\n\np3 <- p2 + \n  scale_fill_stepsn(\n      guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE, \n                             show.limits=TRUE, \n                             ticks.colour= \"black\",\n                             ticks.linewidth = 1, \n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1),\n      breaks=c(1, 20, 40, 60, 80, 100, 106), \n      colors=c(\"#1c2c74\", \"#5483b3\", \"#99ccff\", \"#fcdb9b\", \"#fcbc04\", \"#ac6404\"),\n      space=\"Lab\") +\n  scale_size(\n      guide=guide_legend(title=\"Population, 2020, m\", \n                         title.position=\"top\",\n                         order=2),\n      breaks=c(1000000, 10000000, 20000000),\n      labels=c(\"1\", \"10\", \"20\"),\n      range=c(0.04, 6))\np3\n\n\n\nTheme\nDespite there being a special ‘The Economist’ theme, a completely empty theme (without the default background and axis elements) is what we want. Hence we use theme_void(). Under the theme() function, we first specify the (previously loaded) font most closely resembling the one used in the original map. Concerning title, subtitle and caption, we specify their size, as well as their vertical (vjust) and horizontal justification (hjust). Also using the helping function element_text(), we instruct that the title be bold and the caption have the color “gray”. We then set the position, direction and justification of the legend so that it is horizontal and gets centered to the north of China (approximately where Mongolia would be). We then specify that both legends be left-justified and set the font size for both the title and the text inside the legend (as well as the face in the case of the legend title). Finally, we customize the margins around the legend area and set the key width to 8mm, the key height to 2.5mm and the spacing between keys in the size legend to 0.1mm.\n\n\np4 <- p3 +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=22, vjust=-8, hjust=0.05), \n        plot.subtitle=element_text(size=18, vjust=-10, hjust=0.058),\n        plot.caption=element_text(color = \"gray\", size = 17, hjust = 0.05),\n        legend.position=c(0.73, 0.96),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.text=element_text(size=14),\n        legend.margin=margin(1, 1, 1, 1),\n        legend.key.width=unit(8, \"mm\"),\n        legend.key.height=unit(2.5, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'))\np4\n\n\n\nAnnotations\nThe last step to replicate the original map is the annotations, for which we use the annotate() function. While it may appear to be a caption, the text “1=best” is actually inside the plot and hence is introduced as an annotation. For this and the rest of annotations, we specify the type, the coordinates (x, y), the label, the size and the family (as well as the hjust, vjust, fontface and color for some).\nFor the textbox in the lower left corner in the original chart, we create a separate annotation for the title in order to be able to set its fontface to bold and assign it a different color. Further, we separate each of the five cities into different annotations as well because grouping them together under the same one led to there being too large of a vertical space between each of the five lines.\nFor the individual annotations of the eight highest ranked cities on their locations on the map, we simply use the coordinates for each city and adjust them to be able to see which point corresponds to each label. We also added separate annotations with the lines for five cities: Dongguan, Guangzhou, Suzhou, Jiaxing and Hangzhou (type= “segment”). These lines make identifying which label corresponds to each point easier when cities are clustered together.\n\n\np5 <- p4 + \n  annotate(\"text\", x=67, y=51.5, label=\"1=best\", \n           size=5.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=30, label=\"Highest ranked\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\",\n           fontface=\"bold\", color=\"blue4\") +\n  annotate(\"text\", x=65, y=28, label=\"1  Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=26, label=\"2  Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=24, label=\"3  Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=22, label=\"4  Suzhou\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=20, label=\"5  Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=26, label=\"Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=21, label=\"Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=33, label=\"Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114, y=29, label=\"Suzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=102, y=23, label=\"Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=41,label=\"Beijing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=123, y=29, label=\"Jiaxing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=110, y=26, label=\"Dongguan\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=113, y=25.5, \n           xend=113, yend=24) +\n  annotate(\"segment\", x=110, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=117, y=30, \n           xend=120, yend=31.5) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=122, y=27, \n           xend=120, yend=30)\np5\n\n\n\nEvaluation and potential enhancements\nThis section starts with a brief discussion of the positive and negative qualities of both the original chart and its replication. First, there are several limitations with our reproduction of the map. First, we were not able to reproduce the curved segments joining Hangzhou and Suzhou with their respective points or bubbles as the chart did not support geom_curve(). We were also unable to imitate the appearance of the fill legend exactly as the one in the original map contains spaces between the different boxes or ranges of scores.\nNext, an evaluation of the strengths and weaknesses of the original map is also necessary in order to suggest minor improvements.\nOverall, the original map is an effective visualization. The title and subtitle are concise and informative of its purpose and object, i.e. showing how, because of urbanization (“March of the cities”), cities of varying populations on the coast of China have different levels of growth potential as measured by a comprehensive score. The underlying map, which does not encode any information, does not distract from the information being shown as it is given a light color. Moreover, the legends are clear. This is especially important in the case of the size legend, which could be problematic since people perceive areas rather than radii as visual features in circles. In this case, the area of the circle seems to be proportional to population and so it correctly provides a reference point for readers to estimate the population of individual cities. The ‘expressiveness’ criterion is also met, as ordered data (“Ranking”) appears ordered by means of the hue scale. Finally, the annotations help readers focus on a small number of cities (eight for on-the-map annotations and five for the annotation on the bottom left corner), which facilitates the understanding of which cities have highest growth potential as well as of their characteristics (namely population and location).\nTherefore, the mapping of data into visual features communicates (and thus helps us understand) the “story” the author wants to tell in a clear, precise, efficient and truthful way.\nHowever, there may be some areas of potential improvement. The chart below includes several changes so as to enhance the ease of decoding visual information.\n\n\np <- ggplot() +\n  geom_polygon(data=china, \n               aes(x=Longitude, y=Latitude, group=Grouping),\n               fill=\"cornsilk3\",\n               alpha=0.3) +   \n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping), \n            color=\"white\", \n            size=0.2) +\n  coord_map(xlim=c(100, 155), ylim=c(20, 50)) +\n  geom_point(data=fulloutputclean,\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking),\n             shape=21, color=\"black\") +       \n  labs(title=\"March of the cities\",\n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Source: EIU\") +\n  scale_fill_stepsn(\n       guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE,\n                             show.limits=TRUE,\n                             ticks.colour=\"black\",\n                             ticks.linewidth=1,\n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1), \n       colors=c(\"#00008b\", \"#6495ed\", \"#87cefa\", \"#e0ffff\"),\n       breaks=c(1, 30, 60, 90, 106),\n       space=\"Lab\") +\n  scale_size(\n       guide=guide_legend(title=\"Population, 2020, m\",\n                          title.position=\"top\",\n                          order=2), \n       breaks=c(1000000, 10000000, 20000000), \n       labels=c(\"1\", \"10\", \"20\"),\n       range=c(0.04, 6)) +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=20, \n                                vjust=-14, hjust=0), \n        plot.subtitle=element_text(size=13, \n                                   vjust=-21, hjust=0),\n        plot.caption=element_text(color=\"gray\", size=14, \n                                  hjust=0),\n        legend.position=c(1.01, 1.01),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.box.background=element_rect(fill=\"white\"),\n        legend.margin=margin(5, 15, 5, 10),\n        legend.key.width=unit(12, \"mm\"),\n        legend.key.height=unit(3, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'),\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.title.align=0,\n        legend.text=element_text(size=14)) +\n  annotate(\"text\", x=99, y=47.5, label=\"1=best\",\n           size=4.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=121, y=28, label=\"(1) Hangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=115, y=21.5, label=\"(2) Shenzhen\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=32, label=\"(3) Shanghai\",\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114.5, y=28, label=\"(4) Suzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=103, y=23, label=\"(5) Guangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=110.5, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=117.5, y=29, \n           xend=120, yend=31.5) +\n  geom_vline(xintercept=112, linetype=\"dashed\") \np\n\n\n\nAs suggested by the famous author in the field of visualization Edward Tufte, we should seek to maximize the data-ink ratio when displaying data. To that end, we should ask ourselves whether all elements (“ink”) in the chart are necessary to convey our message. Applying this notion to our map, we set limits for the coordinates through the arguments xlim and ylim inside the coord_map() function. This way, as seen in the map above, we “zoom in” to show the relevant data and remove the area west of meridian 100°. If we did this, we would only lose one observation (i.e. one city) and so it may be worth exploring this alternative. Since we have less “unused” space, we also set the legend background fill to “white” in order to establish a clear contrast between the legend and the map.\nMoreover, some changes to the fill legend may increase the ease of decoding visual information on ranking. In order to enhance discriminability on this scale, we reduce the number of categories from six to four. This way, it is easier for readers to figure out the order of cities according to their ranking and relate their scores to location and population without having to distinguish between too many values.\nAdditionally, despite being a small detail, the choice of the color palette may not be the most appropriate to depict this ordering. There does not seem to be an obvious reason for why stronger colors are assigned to the extremes in the ranking spectrum (i.e. highest- and lowest-ranked cities). Allocating different levels of saturation or lightness of the same hue could be an alternative way of visually conveying the ordering of cities according to growth potential. In the code above, we simply replace the colors for the original ‘40-60’ and ‘60-80’ categories with two lighter shades of blue under the scale_fill_stepsn()function.\nFurthermore, the fact that eight cities are annotated on the map and only five are included in the bottom left textbox is not too easy to realize at first and both annotations seem to include redundant information. By removing the textbox and adding the rank numbers directly to the cities annotated on the map, we simplify the visualization without removing essential information.\nFinally, in order to emphasize the idea that cities with the highest growth potential are on the coast, we might want to insert a vertical line (we use geom_vline()) at the (arbitrary) level of longitude 112°. This way we can see that among the 10 cities with the highest growth potential, only Chengdu (i.e. the “dark blue” bubble farthest west) is to the west of this longitude.\nAlternative visualization\nThe final section of this post proposes an alternative visualization to represent the relationship between the population, location and growth potential of cities in China. One possibility is the scatterplot shown below. We plot the ranking on the x-axis and population on the y-axis. We also use the geom_point() function just like in the original map.\nWe change the title and subtitle of the plot. We also add an informative caption and change the axis labels so as to make it even easier to understand what each variable represents and the message being conveyed. We alter the theme to theme_light() so as to increase the contrast between the background and the text and data points.\nThis time, by using the scale_y_continuous() function, we change the default scientific notation so that the axis itself shows population in ‘M’ (million). We then set the specifics for the font, title, subtitle, caption, axis title and axis text under the theme() function.\n\n\np <- ggplot(fulloutputclean) +\n  aes(x=Ranking, y=Population) +\n  geom_point() +\n  labs(title=\"Urbanization and economic growth in China\",      \n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Coastal cities have highest growth potential\",\n       x=\"City Growth Ranking\",\n       y=\"City Population\") +\n  scale_y_continuous(labels=scales::label_number_si()) +\n  theme_light() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=26),                                                            \n        plot.subtitle=element_text(size=20),\n        plot.caption=element_text(size=20, hjust=0),\n        axis.title=element_text(size=15),\n        axis.text=element_text(size=13))\np\n\n\n\nIn general, we can see that higher growth potential (lower value for the variable “City Growth Ranking”) tends to be associated with a larger population, which was perhaps harder to see on the original map. However, we still need to include information about the location (coordinates) of cities. Within the location variable, it seems that longitude is the most important factor: cities closer to the coastline (i.e. farther east, or higher values of x) appear to have higher growth potential. These high-ranking cities seem to be distributed more or less evenly from north to south, hence we disregard the latitude information for simplicity. Therefore, we could encode longitude through the color of the points by highlighting in blue those points representing cities that are located east of the (again, arbitrarily chosen) 112° meridian. We also add a text label (on top of a white rectangle constructed with geom_rect()) to indicate that blue dots represent cities farther east in China.\n\n\nannotation <- dplyr::filter(fulloutputclean, Longitude>112)\np <- p + \n    geom_point(data=annotation, color=\"#6495ED\") +\n    geom_rect(aes(xmin=79, xmax=130, ymin=15000000, ymax=16600000),\n              fill=\"white\",\n              color = \"#6495ED\") +\n    geom_text(aes(x=80, y=15800000, \n                  label=\"Cities to the east of the 112th meridian\"),\n              size=6, hjust=0, vjust=0, color = \"#6495ED\")\np\n\n\n\nFinally, to highlight the top 5 cities from the original map, We construct another annotation and insert it as an argument in the geom_text() function. We adjust the size and horizontal justification of the labels, and make them bold.\n\n\nannotation2 <- dplyr::filter(fulloutputclean, Ranking<=5)\np <- p +\n  geom_text(aes(label=City),\n            annotation2,\n            hjust=-0.2, nudge_x=0.1, size=6,\n            family = \"IBM Plex Sans\",\n            fontface=\"bold\") \np\n\n\n\nWe can see that highly-ranked cities are all near the coast (i.e. all highlighted in blue because they are east of the meridian 112°), but there is a rather wide range of population sizes among the top 5. For instance, both Shanghai and Suzhou have very high growth potential. Yet, the former has more than 3.5 times the population of the latter. This is because many variables are included in the calculation of scores. For instance, Hangzhou tops the ranking due to its nature as a big tech hub. While government regulation targeting tech firms may hamper its medium- and long-term growth, other factors such as its fiscal position, economic diversity or metropolitan development jointly yield a high growth potential for the city.\nAll in all, as the caption suggests, it seems that location (whose effect is hard to separate from other historical, economic and environmental factors) is more important than current population as a predictor of future economic growth.\n\n\n\n",
    "preview": "projects/2022/100489635/economist.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1118
  },
  {
    "path": "projects/gapminder/",
    "title": "Gapminder's World Health Chart",
    "description": "This tutorial reproduces one of the most popular data visualizations ever\nand serves as an example project for this course",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-09-09",
    "categories": [
      "example"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLegend\n\nFinal result\nSingle year\nMultiple years, static\nMultiple years, dynamic\n\n\nHans Rosling was a Swedish professor of International Health at the Karolinska Institute,\nand co-founder of the Gapminder Foundation,\nwhich developed the Trendalyzer software for animated data visualization.\nHis famous 2006 TED Talk,\nDebunking myths about the “third world”,\nhas inspired millions over the world thanks to his celebrated bubble chart\ndepicting the relationship between life expectancy and income.\nGapminder’s World Health Chart. Figure from gapminder.org.The goal of this tutorial is to replicate this famous data visualization step by step.\nGetting the data\nThe data consists of yearly observations of life expectancy values and GDP per capita for a number of countries in the world.\nThis is a very popular dataset.\nWe could download the data directly from the Gapminder homepage,\nbut we will use instead the gapminder package,\nwhich contains ready-to-use data for 142 countries from 1952 to 2007.\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\n\nLet’s take a glimpse of the data:\n\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afgh…\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, As…\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 19…\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nThese are all the variables we need in a tidy format,\nincluding population counts, which will serve to define the size of the bubbles.\nAs we can see, the original visualization includes Oceania into Asia,\nso let’s do the same for our exercise:\n\n\ngapminder <- gapminder %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\"))\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Europe  :360   Median :1980   Median :60.71  \n Angola     :  12   Asia    :420   Mean   :1980   Mean   :59.47  \n Argentina  :  12                  3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nBuilding the chart\nCoordinates and axes\nWe will work with a single year for now.\nThe base panel consists of simple Cartesian coordinates,\nand depicts life expectancy vs. GDP per capita,\nalthough the x label says the more understandable term “Income”.\n\n\np <- ggplot(filter(gapminder, year == 2007)) +\n  aes(gdpPercap, lifeExp) +\n  ylab(\"Life expectancy\") + xlab(\"Income\")\np\n\n\n\nBoth axes have fixed limits across the whole animation.\nAnother thing to note about the axes is that income is in logarithmic scale with very specific breaks.\nAlso, numbers above 10 thousand are labeled as “10k”.\nThe function scales::label_number comes in handy for this.\nNote that we make some space for annotations on top of the chart\nby setting the maximum limit of the y axis to 95.\n\n\nbreaks <- 500*2^c(0:8)\nklabel <- scales::label_number(suffix=\"k\", scale=1e-3)\nlabels <- c(breaks[1:5], klabel(breaks[-(1:5)]))\n\np <- p + scale_y_continuous(limits=c(10, 95), breaks=seq(10, 90, 10)) +\n  scale_x_log10(limits=range(breaks), breaks=breaks, labels=labels)\np\n\n\n\nTheme\nNote that the theme is very similar to theme_classic, but shows the major grid.\nWe also instruct the theme to remove the legend,\nbecause we will add a custom one later on.\n\n\np <- p + theme_classic() +\n  theme(panel.grid.major=element_line(), legend.position=\"none\")\np\n\n\n\nAdditionally, we could continue to tinker with fonts and other parameters.\nAnnotations\nThe base panel depicts three annotations:\nA big background number indicating the year in the middle.\nFour income levels on the top part, whose breaks seem to be 3k, 8k and 24k.\nThe axes’ units on the top left and bottom right corners.\nFor the background number, we could use annotate with a fixed label,\nbut we will use geom_text instead, even if we overplot it many times,\nso that the year is read from the data.\n\n\np <- p + geom_text(aes(8000, 50, label=year), size=65, color=\"lightgray\")\np\n\n\n\nNext, we add the income levels.\nAdditionally, we will take the liberty of adding vertical lines to clearly demarcate the breaks.\n\n\ntlevel <- c(1300, 5000, 14000, 40000)\nblevel <- c(3000, 8000, 24000)\nilevel <- c(\"INCOME LEVEL 1\", \"LEVEL 2\", \"LEVEL 3\", \"LEVEL 4\")\n\np <- p + geom_vline(xintercept=blevel, color=\"darkgray\") +\n  annotate(\"text\", x=tlevel, y=95, color=\"darkgray\", vjust=0, size=3, label=ilevel) +\n  annotate(\"text\", x=blevel, y=95, color=\"darkgray\", vjust=0, size=5, label=\"◆\")\np\n\n\n\nFinally, let’s add the units to the axes.\n\n\np <- p +\n  annotate(\"text\", x=128000, y=10, hjust=0.95, vjust=1, size=3,\n           label=\"per person (GDP/capita, PPP$ inflation-adjusted\") +\n  annotate(\"text\", x=500, y=95, hjust=0.5, vjust=-1.5, size=3, angle=90, label=\"years\")\np\n\n\n\nData\nThe chart is a type of scatterplot, with one point per country, and colored by continent.\nThe novelty here is that every dot is scaled up to represent the population size.\nAlso, we will add some transparency to the points.\n\n\np <- p + geom_point(aes(color=continent, size=pop), alpha=0.7)\np\n\n\n\nWe are close, but a couple of adjustments are required.\nLet’s add a black line around the points (see shape 21),\nand adjust the range of the bubbles a bit.\n\n\np <- p + geom_point(aes(size=pop), color=\"#333333\", shape=21) +\n  scale_size_area(max_size=25)\np\n\n\n\nFinally, let’s replicate the same color scale.\nWe need to provide them in the same order as the factor levels:\n\n\nlevels(gapminder$continent)\n\n[1] \"Africa\"   \"Americas\" \"Europe\"   \"Asia\"    \n\nTherefore, from the web, page we obtain:\nAfrica: Blue rgb(0, 213, 233) -> #00d5e9\nAmericas: Green rgb(127, 235, 0) -> #7feb00\nEurope: Yellow rgb(255, 231, 0) -> #ffe700\nAsia: Red rgb(255, 88, 114) -> #ff5872\n\n\nccolors <- c(\"#00d5e9\", \"#7feb00\", \"#ffe700\", \"#ff5872\")\np <- p + scale_color_manual(values=ccolors)\np\n\n\n\nLegend\nThis chart has an interesting legend:\nit takes advantage from the fact that continents are easily recognizable to use a map as a legend.\nLet’s replicate it separately using data from ggplot2::map_data.\n\n\nworld <- map_data(\"world\")\nglimpse(world)\n\nRows: 99,338\nColumns: 6\n$ long      <dbl> -69.89912, -69.89571, -69.94219, -70.00415, -70.06…\n$ lat       <dbl> 12.45200, 12.42300, 12.43853, 12.50049, 12.54697, …\n$ group     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,…\n$ order     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16,…\n$ region    <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Arub…\n$ subregion <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\nThis data needs to be tweaked a little bit. We need to:\nFilter out the Antarctica region.\nAdd a new column continent with the help of the countrycode package.\nInclude Oceania into Asia.\nDrop any missing values for continent.\n\n\nworld <- world %>%\n  filter(region != \"Antarctica\") %>%\n  mutate(continent = countrycode::countrycode(\n    sourcevar=region, origin=\"country.name\", destination=\"continent\")) %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\")) %>%\n  drop_na(continent)\n\n\nNow, let’s create the map:\n\n\nlegend <- ggplot(world) +\n  aes(long, lat, group=group, map_id=region, fill=continent) +\n  geom_map(map=world) +\n  scale_fill_manual(values=ccolors) +\n  theme_void() + theme(legend.position=\"none\")\nlegend\n\n\n\nFinal result\nSingle year\nIn summary, so far we have\nBuild steps:\nset coordinates and axes, with custom breaks;\nset an appropriate theme and prevent the default legend from appearing;\nadded several annotations, including year, income levels and axis units;\nadded the data points and made several adjustments, including size and color;\ncreated a custom legend based on a simple colored world map.\nThere are several ways we can merge the main plot and the legend.\nIn this case, let’s add it as an inset with the custom annotation function.\nNote that, in contrast to the regular annotation function,\nthis one doesn’t seem to support logarithmic scales very well.\nAs a result, the user needs to provide the transformed values directly.\n\n\np <- p + annotation_custom(\n  ggplotGrob(legend), xmin=log10(16000), ymin=10, ymax=40)\np\n\n\n\nFinally, we can improve this static single-year visualization by adding some context,\ni.e. a title, a subtitle and a caption.\n\n\np + labs(\n  title = \"World Life Expectancy vs. Income in 2007\",\n  subtitle = paste(\n    \"African countries are still lagging behind in terms of general life\",\n    \"expectancy.\\nEuropean and American countries are the healthiest\",\n    \"and richest countries in the world.\"),\n  caption = \"Source: gapminder.org\"\n)\n\n\n\nMultiple years, static\nSo far, we covered the case for a single year.\nHow could we show the evolution, which is the point in this dataset?\nOf course we can define facets to plot all the years.\nIn the following chart,\ngginnards::delete_layers is used to remove the background year;\nwe switch to the whole dataset using the %+% operator;\ndata is faceted in two rows;\naxis labels are slightly rotated to make space for them.\nNote also that we need to manually scale down a bit the range of the bubbles\nto preserve more or less the previous aspect ratio.\n\n\ngginnards::delete_layers(p, match_type=\"GeomText\") %+% gapminder +\n  facet_wrap(\"year\", nrow=2) +\n  scale_size_area(max_size=7) +\n  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))\n\n\n\nMultiple years, dynamic\nAnd we can of course animate it!\nWe can easily convert any ggplot2 chart to plotly using plotly::ggplotly,\nwhich produces interactive web-based charts.\nFurthermore, if we set the frame aesthetic, it is automatically detected,\nand an animation is added based on the corresponding variable.\n\n\nplotly::ggplotly(p %+% gapminder + aes(frame=year))\n\n\n\n\n\n\n",
    "preview": "projects/gapminder/gapminder_files/figure-html5/titled-1.png",
    "last_modified": "2025-01-13T15:56:28+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  }
]
