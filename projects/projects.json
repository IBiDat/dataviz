[
  {
    "path": "projects/2022/100383017/",
    "title": "Country Convergence",
    "description": "This project enables the user to recreate a specific graph in OurWorldinData on GDP per capita layer by layer. It also introduces two alternative representations resorting to the same data.",
    "author": [
      {
        "name": "Nacho Pulido Ruiz",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nOn the topic of Economics and Country Convergence\nGraph enhancement\nAlternative representation 1\nAlternative representation 2\n\nOn the topic of Economics and Country Convergence\nOur aim will be to resort to visual tools in R studio and ggplot to study the topic of country economic growth and convergence. Classical Solow-Swan models of growth predict convergence as a function of the deviation of a country from its stationary state (natural level) such that we should expect convergence between LEDC´S and MEDC´s. Our point of departure will be to launch the libraries we will use and to obtain the data from the Maddison Project Database.\nOriginal plot:\n\n\n\nlibrary(tidyverse)\nlibrary(scales)\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                delim = \";\"))\n\n\nA prior step to develop our plot will be to clean and sort the data to prepare it for our ggplot() operations. We will filter for rows containing data for 1950 and 2016 and reshape the data to have two columns accounting for GDP per capita for each country and for each year. This enables the analyst to depict a different axis for each of the years containing observations on GDP per capita.\n\n\ngdp <- gdp %>% \n  rename(gdp_capita = gdp_per_capita) %>% \n  select(country, year,gdp_capita, ) %>% \n  filter(year %in% c(1950,2016)) %>% \n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>% \n  drop_na(\"1950\", \"2016\") %>% \n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\")\n\n\nIt will be useful for us to categorize our countries in three groups (poor, medium and rich countries) by generating a factor column using the ifelse() command in the following way:\n\n\ngdp <- gdp %>% \n  mutate(type = ifelse(gdp_capita_2016<6000,\n                       \"poor\",\n                       ifelse(gdp_capita_2016<40000,\n                              \"medium\",\n                              \"rich\")))\n\n\nIt will be convenient for later (at the labelling stage) to generate a new column indicating the amount of growth an economy has undergone.\n\n\ngdp <- gdp %>% \nmutate(fold = round(gdp_capita_2016/gdp_capita_1950,1)) %>%\n  mutate(fold = paste(fold,\"-fold\"))\n\n\nSince we will have many observations for each of the countries (especially for those with middle income), we will filter for a subset of the data by selecting a random sample of middle income countries and then binding the resulting dataframe to the original one:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n  slice(sample(1:73,35,replace = FALSE))\ngdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nNow we have everything we need to start depicting our graph! We will call our gdp data and pipe it into the ggplot() function, defining the aesthetics desired. The advantage of having previously pivoted our data is that now we have 2 columns which account for the desired variables to be plotted:\n\n\nplot <- gdp %>% \n  ggplot()+\n  aes(gdp_capita_1950,gdp_capita_2016)\nplot\n\n\n\nNow we will add some geometry to our plot. We will choose shape 21 in order to be able to fill the points with a different color from the one we will use for the contouring of it.\n\n\nplot <- plot +\n  geom_point(shape = 21,color = \"red\", size = 1.5, fill = \"aquamarine3\")\nplot\n\n\n\nOur plot requires a lot of labels inside the graph, both for lines and for points. We will take advantage of geom_text() and add some label to the geometry including a subheading accounting for the amount of growth each economy has undergone. We will later work on our annotations to the diagonal lines.\n\n\nplot <- plot +\ngeom_text(aes(label = country), size = 1, nudge_y = -0.02)+\n    geom_text(aes(label = fold), size = 1, nudge_y = -0.05)\nplot\n\n\n\nIt is time to choose appropriately the scales of our plot. A logarithmic scale will we used for both axis and we will have to introduce the dollar symbol to account for the unit of measurement. The breaks have to be manually provided by the analyst to mimic as much as possible the original plot.\n\n\nplot <- plot +\n   scale_x_log10(label = label_number(prefix = \"$\"), \n                 breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                            7000,10000,15000,20000,30000,40000,50000,70000))+\n   \n  scale_y_log10(label = label_number(prefix = \"$\"),\n                breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                           7000,10000,15000,20000,30000,40000,70000))\nplot\n\n\n\nTo stick with the original plot as much as possible, we will introduce some text in our axis and title (including a subtitle) and use a bold font for the latter.\n\n\nplot <- plot +\n  labs(x=\"GDP per capita in 1950\",\n       y = \"GDP per capita in 2016\",\n       title = \"GDP per capita in 1950 and 2016\",\n       subtitle = paste0(\n         \"GDP per capita is expressed in international -$. \",\n         \"This means that it is adjusted for price changes over \",\n         \"time (inflation) and for price differences between countries.\"))\nplot\n\n\n\nThere are many informative lines in our plot used to depict the growth rate of a country in comparison to 1950.. We will use the geom_abline() to choose the slope and intercept of each one and change the color to stick to the original plot. The RGB technique will be used to determine the color of interest and the fourth argument of this function refers to the transparency (alpha), which we will set for the diagonal lines. The intercepts with the y-axis have to be transformed by the logarithm.\n\n\nplot <- plot +\ngeom_abline(slope = 1,intercept = 0, color = \"darkblue\")+\n    geom_abline(slope=1,\n                intercept=log10(c(0.5, 2, 3,\n                                  4.4, 10, 15, 30)), linetype=\"dotted\",\n                color = rgb(0,0,0.5,0.3))\nplot\n\n\n\nIn this section we will work on the theme (appearance of the plot). Notice that each of the axis has some specific color associated with it (in accordance with the horizontal and vertical grid lines). In this case, the background lines are faded and we will resort to the RGB mixture of colors providing an alpha for each color. These kind of lines will be chosen as linetype “dotted to achieve the desired dashed effect. The aspect.ratio will be set to 1 inside the theme to ensure that the proportions of the final plot obey the ones of the original graph.\n\n\nplot <- plot +\ntheme(axis.text.x = element_text(colour = \"darkorchid3\", size = 2.9),\n      axis.title.x = element_text(colour = \"darkorchid3\", size = 9,family = \"serif\"),\n      axis.text.y = element_text(colour = \"cyan3\", size = 4,family = \"serif\"),\n      axis.title.y = element_text(colour = \"cyan3\", size = 9, family = \"serif\"),\n      plot.subtitle = element_text(size = 5, colour = rgb(0,0,0,0.6),hjust = 0.4,\n                                   vjust = 5,family = \"serif\"),\n      panel.background = element_rect(fill = \"white\"),\n      panel.grid.major.x = element_line(color = rgb(0.6,0.196,0.8,0.4),\n                                        linetype = \"dotted\"),\n      panel.grid.major.y = element_line(color = rgb(0,1,1,0.4), linetype = \"dotted\"),\n      plot.title = element_text(size = 14,hjust = -0.2, vjust = 1, family = \"serif\"),\n      aspect.ratio = 1)\nplot\n\n\n\nCoordinates will be kept ass Cartesian but we will employ the use of some limits to mimic the ones from the original plot.\n\n\nplot <- plot +\ncoord_cartesian(xlim = c(400,70000), ylim = c(400,70000))\nplot\n\n\n\nWe will now work on the annotations accompanying the vertical lines which will indicate the amount of growth that each of the countries have experienced since 1950, thus, conveying the idea of convergence/divergence among them.\n\n\nplot <- plot +\nannotate(\"text\", label = \"Countries above this line had positive growth\",\n         color = \"darkgreen\", x = 22000, y = 25000, angle = 45, size = 2.3,\n         family = \"serif\") +\n    annotate(\"text\", label = \"Countries below this line had negative growth\",\n             color = \"red\", x = 26000, y = 23000, angle = 45, size = 2.3,\n             family = \"serif\")\nplot\n\n\n\nIn addition to these annotations, we will add the final text annotations pertaining to the rest of diagonal lines adding a smaller size and accounting them with a different color. The 45 degree angle will be held constant since all lines hold a slope equal to unity but with different intercepts.\n\n\nplot<- plot+\n  annotate(\"text\", label = \"2x poorer\", color = rgb(0,0,0.6,1), \n           x = 61000, y = 36000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"2x richer\", color = rgb(0,0,0.6,1),\n             x = 30000, y = 65000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"3x richer\", color = rgb(0,0,0.6,1),\n             x = 19000, y = 65000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"Global average \\n growth (4.4x)\",\n             color = rgb(0,0,0.6,1),  x = 11000, y = 63000, angle = 45, \n             size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"10x richer\", color = rgb(0,0,0.6,1),\n             x = 5700, y = 67000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"15x richer\", color = rgb(0,0,0.6,1),\n             x = 4000, y = 68000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"30x richer\", color = rgb(0,0,0.6,1),\n             x = 2000, y = 68000, angle = 45, size = 1.9,family = \"serif\")\nplot\n\n\n\nAs a final note, we will recall all the problems we encounter on this plot and use this to propose an enhancement:\nEven with a subset of countries, there is a lot of geometry text overlapping -> We will improve the labelling\nIt is difficult to account for convergence across countries since all countries are plotted independent of their nature -> We will distinguish between groups of countries\nIn order to enable the reader extract information on both the country and the level of growth rate, we will provide to distinctive plots such that one contains country labels whereas the other one will resort to quantitative (regression analysis) information\nConvergence is difficult to observe due to axis selection -> We will modify the vertical axis to depict growth rate and help the reader check for convergence with ease\nGraph enhancement\nWe will use the same graph to propose some enhancements or changes in the way the data is presented in an attempt to ease reader´s comprehension. We will reload the data to our Rstudio code:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                  delim = \";\"))\n\n\nThe same technique employed before to clean and prepare our data will be recycled. Recall we are just proposing an improvement of the visualization, an alternative graph will be proposed in the last section of the project. Once again, we categorize our countries into rich, medium and poor:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nThe main difference with the first plot is that, this time, we will resort to the inclusion of a new column which will summarize the average annual growth rate that each economy has undergone since 1950.\n\n\ngdp <- gdp %>% \n mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100)%>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nAs we mentioned previously, the plot will be the same but we will just change the way the data is presented, so the random filter to select countries will be preserved:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n    slice(sample(1:73,35,replace = FALSE))\n  gdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nWe can begin with our enhanced graph! The aesthetics provided now will be set to the gdp per capita in 1950 and the annual growth rate we computed before. We will make use of our geom_label() again but we will omit supplying R with geom_point() this time. The color of the text will be set to white in order to generate a comfortable contrast with the “filling” by type of economy we had established in our aesthetics.\n\n\nlibrary(ggrepel)\nplot_1 <-gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)+\n    geom_label_repel(aes(label = country), size = 2,\n                     segment.color = 'transparent', max.overlaps = 40,\n                     force = 1, color = \"white\",\n                     show.legend = FALSE)\n    plot_1\n\n\n\nWe will add some labels to our axis and set the title to convey the idea that we are working with convergence. The word “conditional” here refers to the fact that we are going one step further and categorizing our data between types of economies and we will finally visualize the concept of “conditional convergence” presented in the classical Solow model of growth.\n\n\nplot_1 <- plot_1 +\nlabs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_1\n\n\n\nWe will provide a continuous y scale with the percentage suffix to make it obvious that we are working with growth rates here. We will also begin by applying a minimal theme to our plot which will be modified later with slight changes.\n\n\nplot_1 <-\nplot_1 + theme_minimal()+\n    scale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)\n    plot_1\n\n\n\nWe will work on the themes by providing some font in the type of “serif” and eliminating any background grid which may distract the reader. We will not devote much effort into changing the theme appearance because we are just modifying some changes of the original plot, not changing the graph completely. The aspect ratio will be set again to 1 to keep the original proportions.\n\n\nplot_1 <- plot_1 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid = element_blank(),\n      plot.title = element_blank(),\n      aspect.ratio = 1)\nplot_1\n\n\n\nFinally, let´s change the limits on the plot to make it more readable by modifying the arguments of the coordinate system:\n\n\nplot_1 <- plot_1+\n  coord_cartesian(xlim = c(0,10000), ylim = c(-2,7))\nplot_1\n\n\n\nNow we will generate the second plot required for our enhancement resorting to a similar analyis as the one depicted above but focusing on the quantitative side. We will append next to plot_1 the corresponding representation of each linear regression accounting for our three country groups. As usual, we will have to read again our data to make from scratch the desirable transformations:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nOne again, we will have to split our country in three categories and generate our “Growth” column accounting for the rate of increase of GDP per capita that each economy experiences. Factor levels will be reset to obtain the desired order:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\"))) %>%\n    mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100) %>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nNow we can start depicting the second part of our enhancement graph! The first part will consist of piping our already filtered data into ggplot() and select the appropriate aesthetics in which we will feed our argument “fill” with our country type.\n\n\nplot_2 <-  gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)\nplot_2\n\n\n\nNotice that, different to plot_1 in which we mapped a text geometry into the plot to be able to spot each of the countries, our task now is to account for types of countries regardless of their label. Therefore, we will change the geometry to geom_point() and let the point be filled with the type of country while contouring it with a white color:\n\n\nplot_2 <- plot_2 +\ngeom_point(shape = 21, color = \"white\", size = 3)\nplot_2\n\n\n\nWe will add some labels to the axis (the same that we had for our previous plot):\n\n\nplot_2 <- plot_2 +\n labs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_2\n\n\n\nLet´s change the label of the vertical axis by adding a percentage symbol to indicate that it is a measure of percentage growth rate. This has been computed as the average annual growth rate, which is the growth rate required for a country to portray year by year (constant) to achieve the final level of GDP per capita:\n\n\nplot_2 <- plot_2+\nscale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)+\n  theme_minimal()\nplot_2\n\n\n\nNext, we will change the appearance of our plot by modifying slightly the theme layout. Family “serif” will be chosen for the font in order to mimic the one used in the replication of the original plot and the background will be fill with grey. Panel grid lanes will be removed by setting the corresponding argument into element_blank().\n\n\nplot_2 <- plot_2 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid= element_blank(),\n      legend.position = \"bottom\",\n      legend.background = element_rect(size = 2),\n      aspect.ratio = 1)\nplot_2\n\n\n\nFinally, a linear regression line will be passed through each of the country groups to account for conditional convergence. The negative relationship which can be easily spotted once the line of best fit is included shows that, within groups of similar countries holding similar characteristics (depreciation rates, population growth rates etc.), there is convergence. However, the transition of a country from one group to another one is rarely seen.\n\n\nplot_2 <- plot_2 +\ngeom_smooth(method = \"lm\", size = 1, color = rgb(1,1,1,0.3))\nplot_2\n\n\n\nWe will change some limits of this plot to enable the reader focus on the inside and not get distracted with a hughe portion of unused plot:\n\n\nplot_2 <- plot_2 +\n coord_cartesian(xlim = c(0,15000), ylim = c(-2,7))\nplot_2\n\n\n\n\n\nlibrary(ggpubr)\nenhancement <- ggarrange(plot_1,plot_2,  common.legend = TRUE, legend=\"bottom\")\nannotate_figure(enhancement,\n                top = text_grob(\"Gdp per Capita Conditional Convergence\",\n            color = \"red\", size = 19))\n\n\n\nAlternative representation 1\nNow that we have resorted to an enhancement of the original plot in order to provide a measure of within group convergence, we will propose an alternative graphical analysis to show between group divergence. In other words, we will see, for each year, how the distribution of income holds for each of our country groups to highlight the difficulty of an economy of jumping from one group to another one.\nWe will have to read again the data to start from scratch our alternative plot:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nWe will only keep data from 1950 onwards and we will filter for any NA´s present (missing observations). The difference with our previous plots is that we will now use all of our economies (no filter selection) and we will plot, for each year, how income per capita is distributed among our countries (the evolution of distribution of wealth).\n\n\ngdp <- gdp %>%\n    select(country,year,gdp_per_capita) %>%\n    filter(year>=1950) %>%\n    drop_na(gdp_per_capita)\n\n\nWe will pivot our data into wide format because we desire a column indicating the GDP per capita and the corresponding year in order to enable the analyst to generate the new column assigning the type of economy (factor).\n\n\ngdp <- gdp %>% \npivot_wider(names_from = \"year\",\n                values_from = gdp_per_capita,\n                names_prefix = \"Year\") %>%\n    mutate(type = ifelse(Year2016<6000,\n                         \"Poor\",\n                         ifelse(Year2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nNow we will reshape our data back to long format for the sake of our alternative representation. This is a different route we are taking with respect to the original plots, but it will be useful for operating with all years and not just 2 specific ones (as earlier). We separate the pivoted columns to eliminate the unnecesary ones and keep just a year and a gdp per capita column:\n\n\ngdp <- gdp %>% \npivot_longer(starts_with(\"Year\"),\n                 names_to = \"Year\",\n                 values_to = \"gdp_per_capita\") %>%\n    separate(Year, c(\"Yeard\", \"Year\"), remove = TRUE, sep =4) %>%\n    select(-Yeard) %>%\n    drop_na(everything())\n\n\nFinally, we will reorder the levels of our factor for a more appealing representation of our faceting and we will generate a new dataframe which contains all information that our original dataset contained with the exception of country type. We do this because we will use both dataframes in our plot to work with the faceting.\n\n\ngdp <- gdp %>%\n   mutate(type = factor(type, levels = c(\"Poor\",\n                                         \"Medium\",\n                                         \"Rich\")))\n gdp_2 <-\n  gdp %>%\n  select(-type)\n\n\nWe pipe our gdp dataset into ggplot() and define our desired aesthetics:\n\n\nplot <-\ngdp %>%\n  ggplot()+\n    aes(Year,gdp_per_capita)\nplot\n\n\n\nNow we will add two geometries which correspond, in this case, to lines that account for the distribution of income per capita each year and for each economy. First we do this with the original data frame and then we mimic the code with the filtered dataframe and we add some alpha in order to achieve this effect in which the important segment of the data is being highlighted.\n\n\nplot<-\nplot+\ngeom_line(data = gdp_2, color = rgb(0,1,0,0.3))+\n  geom_line(color= rgb(0,1,0,1))\nplot\n\n\n\nNow we facet by type of economy…\n\n\nplot <- plot+\nfacet_wrap(~factor(type))\nplot\n\n\n\nLet´s add some labels to our plot. We will improve the readings of the axis and set a title to account for the divergence between countries. This is the case because we see that, although we did see within group (conditional) convergence in our enhancement plot, now one observes that, if we treat countries as a whole by groups, there is some divergence taking place.\n\n\nplot <-\n  plot+\nlabs(y = \"GDP per capita\", x = \"Time\",\n       title = \"Between Group Divergence\")\nplot\n\n\n\nOnce again, we work the scaling of our graph and change the label of the vertical axis to dollars. Timing will only display some years to avoid overlapping and improve readability.\n\n\nplot <- plot +\nscale_x_discrete(breaks = c(1950,1960,1970,1980,1990,2000,2010))+\n  scale_y_continuous(labels = label_dollar())\nplot\n\n\n\nThe final theme will be set now. We begin with a general dark theme and then make some final adjustments. Years in the horizontal axis will be given some angle to enable us to fit more information and the title will be set in the center of our plot. This will be our first proposal for an alternative representation.\n\n\nplot <- plot +\ntheme_dark()+\n  theme(axis.text.x = element_text(size = 10, angle = 90),\n        strip.text.x =element_text(face = \"bold\"),\n        plot.title = element_text(hjust = 0.5, size =14))\nplot\n\n\n\nAlternative representation 2\nOur previous plot operated with the distribution of income per capita within groups to be able to compare across our three types of economies (e.g. variance and overal growth). Our second proposal for alternative visualization will focus on the between-group convergence and reinforce the idea of the set of hardships involved in the process of an economy evolving from a lower class to a higher one. We load again our data to start from scratch, as usual:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                delim = \";\"))\n\n\nNext, we will have to perform similar operations we resorted to in previous sections by filtering only those years corresponding to 1950 and 2016 and arranging each country into its corresponding group.\n\n\ngdp <- gdp %>%\n  rename(gdp_capita = gdp_per_capita) %>%\n  select(country, year,gdp_capita, ) %>%\n  filter(year %in% c(1950,2016)) %>%\n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n  drop_na(\"1950\", \"2016\") %>%\n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n  mutate(Class = ifelse(gdp_capita_2016<6000,\n                       \"Poor\",\n                       ifelse(gdp_capita_2016<30000,\n                              \"Medium\",\n                              \"Rich\")))\n\n\nThe difference with previous plots is that we will now use the overall average annual growth rate from 1950 to 2016 which is the average growth an economy has yearly undergone to achieve their gdp per capita level in 2016. We also attach a measure of the mean average growth for each of our classes to enable the reader to spot the first differences:\n\n\ngdp <- gdp %>%\n  mutate(AAGR = ((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950))-1)*100)\ngdp %>%\n  group_by(Class) %>%\n  summarise(av_AAGR = mean(AAGR))\n\n# A tibble: 3 × 2\n  Class  av_AAGR\n  <chr>    <dbl>\n1 Medium   2.79 \n2 Poor     0.917\n3 Rich     3.27 \n\ngdp <- gdp %>%\n  filter(Class != \"Rich\") %>%\n  mutate(AAGR_diff = 3.26 - AAGR)\n\n\nWe can now start building our plot layer by layer. We pipe in our already filtered data into ggplot() and set the aesthetics such that the horizontal axis accounts for each of the economies and the vertical one measures the growth rate difference between each country and the average one for rich countries. Therefore, high figures for the vertical axis correspond to countries that need to inject a considerable amount of per capita growth rate (annually) in order to catch up with rich economies and viceversa. The argument introduced in geom_bar() will be set to identity because the default for a bar plot is to count th enumber of observations in a column, and we want to plot the column corresponding to the growth rate difference. Notice that we have reordered from lowest to highest to achieve a visually more attractive graph.\n\n\nplot <- gdp %>%\n  ggplot()+\n  aes(reorder(country,AAGR_diff), AAGR_diff, fill = Class)+\n  geom_bar(stat = \"identity\")\nplot\n\n\n\nNow we will set a void theme for our plot because we want to eliminate any axis text and clean the general appearance (we will work in the themes at the end) and add some labels for the acknowledge the reader with a better understanding of the plot:\n\n\nplot <- plot +\ntheme_void()+\n  labs(title = \"The Spiral of convergence\",\n       subtitle = paste0(\n         \"Countries contained inside the white circle are already growing \",\n         \"at the rate of a rich economy\"),\n       caption = paste0(\n         \"Countries falling in the dark regions require an additional \\n\",\n         \"annual average growth rate to catch up with leading economies\"))\nplot\n\n\n\nNow its time to work on the appareance of our graph. The panel grid lines will be removed by setting an element_blank() argument and the aspect ratio will be set so that we can observe a wider spiral in the final graph. The colors chosen for the bar plots are green and purple which contrast among then whereas the background layers will be set in black as a final step:\n\n\nplot <- plot +\nscale_fill_discrete(type = c(\"purple\", \"green\"))+\n  theme(legend.background = element_rect(color = \"black\"),\n        plot.title = element_text(hjust = 0.5, vjust = 3, size =16),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_blank(),\n        aspect.ratio = 0.8,\n        plot.subtitle = element_text(size = 9,hjust = 0),\n        plot.caption = element_text(size = 9,hjust = 0),\n        legend.key = element_rect(color = \"white\", size = 2),\n        legend.key.width = unit(2,\"lines\"),\n        legend.title = element_text(hjust = 0.5))\nplot\n\n\n\nWe will have to add some annotations in our plot to point the amount of growth injection each economy needs. These lines and annotations will make more sense once the polar coordinates have been applied. We encourage the reader to come back to these steps after the plot is over to understand how each of our elements gets settled in the final spiral.\n\n\nplot <- plot +\ngeom_abline(slope = 0,\n            intercept = c(-2,-1,0,1,2,3,4),\n            color = rgb(0,0,0,0.3), linetype = \"dotted\")+\n  annotate(geom=\"text\", x=-10,\n           y=c(-2,-1,0,1,2,3,4), label=c(\"-2%\",\"-1%\",\"0%\",\"1%\",\"2%\",\"3%\",\"4%\"),\n           color=\"black\",size =3,angle = 28)\nplot\n\n\n\nFinally, we have to add some rectangular geometries for different segments of the plot which will be given some alpha (transparency) to account for best to worse layers. These layers mimic the level curves of a three dimensional bowl in which each layer projected in the floor corresponds to a circle. We will see this once we apply our polar coordinates.\n\n\nplot <- plot +\nannotate(\"rect\", ymin = -2, ymax = -1,\n         xmin = -10, xmax = 110, fill = \"black\", alpha = 0.1)+\n  annotate(\"rect\", ymin = -1, ymax = 0,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.2)+\n  annotate(\"rect\", ymin = 0, ymax = 1,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.3)+\n  annotate(\"rect\", ymin = 1, ymax = 2,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.4)+\n  annotate(\"rect\", ymin = 2, ymax = 3,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.5)+\n  annotate(\"rect\", ymin = 3, ymax = 4,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.6)\nplot\n\n\n\nWe can now apply our polar coordinates!\n\n\nplot <- plot +\ncoord_polar()\nplot\n\n\n\nThe first alternative representation deals with the evolution of the distribution of GDP per capita whereas the second one conveys this information in terms of differences in average growth rates with respect to rich economies. The results arising from the first section of the paper point at the existence of conditional convergence between similar economies and we highlight the difficulties an economy faces in jumping from one class to another in the outcome stemming from our alternative plots.\n\n\n\n",
    "preview": "projects/2022/100383017/images/original_plot.png",
    "last_modified": "2023-01-06T00:56:10+01:00",
    "input_file": {},
    "preview_width": 898,
    "preview_height": 897
  },
  {
    "path": "projects/2022/100481925/",
    "title": "Bump chart: How Americans spend their money",
    "description": "Code to replicate the graph in `ggplot2` and some improvements.",
    "author": [
      {
        "name": "Carolina Cornejo Castellano",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nBackground\nWhat is it for? Representing how Americans distributed their spending in 2021\nWhat can be seen here? Encodings, channels and strengths\nReplication in R\n\nHow can it be improved? Enhancements\nDesigning the enhancements proposal\n\nAlternative visualization(s)\nDesigning the bar plot\nDesigning the lollipop plot\nDesigning the treemap\n\n\nIntroduction\nOn September 25, 2022, the Visual Capitalist, a digital media focused on generating data-centric visual content, published the article How Do Americans Spend Their Money, By Generation? The author of the visualization is Preethi Lodha, and the author of the article is Carmen Ang.\nThis report aims to discuss Preethi Lodha’s (Lodha 2022) graphic in the light of data visualization theory. Thus, some questions that will guide this narrative are: What information does it intend to show? Does it achieve it? How and through what encodings and channels? What are its strengths and points of improvement? Likewise, improvements and alternative visualizations are proposed, which are also not without their own room for improvement.\nBackground\nThe article collected data from the 2021 Consumer Expenditure Surveys (CES) from the U.S. Bureau of Labor Statistics. Specifically, the data used for the visualization was that published in PDF format in Table 2602. Generation of reference person: Annual expenditure means, shares, standard errors, and coefficients of variation.\nThe source of the article and the original graphic can be accessed here. This report was written in December 2022.\nWhat is it for? Representing how Americans distributed their spending in 2021\nFirst, the context and intentionality must be understood. The graphics must be understandable by themselves, and also in their context.\nAs for the article on the Visual Capitalist website, it has as newsworthiness —in Spanish journalist jargon we call it “la pepa”— to show the distribution of Americans’ spending in 2021. Although the title of the article does not specify that the information is from the previous year —it was written and published in 2022—, but the information is from 2021- this type of generalization or omissions are common in the titles and/or in the headlines of journalistic articles: they are licenses that journalists give themselves to attract the reader’s attention. The content of the article clearly specifies the source of information—the PDF—and that it refers to 2021. So it’s not a time series, it’s just a picture of that moment.\nScreenshot of the public Tableau dashboard How Americans spend their money, by Preethi Lodha. Published in: https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/As for the graphic, the author used Tableau to build a bump chart that includes interactive elements when hovering over the dots; but for the purposes of this report, those elements will not be taken into account: only what is seen in the screenshot above is considered.\n\nNote that we use the term bump chart because this type of visualization is commonly found with that name on the Internet. However, in the article of the Visual Capitalist they refer to it as a “graph” and in this report we try to call the other visualizations as “graphic,” as proposed by Wilkinson and Wills (2005).\nBump charts are useful for exploring changes in rank over time across different categories. That is, they usually do not show the actual values of the categories —which in this case would be the money spent by each generation for each spending category—, but the positions in the ranking. In this case, the ranking moves of 14 spending categories are shown, based on the birth year range from the Silent generation (the oldest) to Generation Z.\nAt first glance, this and, in general, all bump charts shows three variables in an easy-to-understand way: category, time and position. That’s especially true in cases of graphics where the only important thing is the ranking. For example, this image from The Washington Post from 2015 shows the “favorite” dog breeds, according to the American Kennel Club, where the three important variables are breed of dog, year, and position in the ranking (Bump 2021).\nArticle published by Philip Bump in The Washington Post: https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/However, there is another important piece of information in Preethi Lodha’s graph, which is the dollar amount spent by each generation for each expenditure category. This is presented within each point and is undoubtedly important if one wants to know how spending is distributed; however, that oscillation is not displayed with any other visual mark and can be misleading. This point will be discussed later.\nWhat can be seen here? Encodings, channels and strengths\nThere are 14 spending categories represented on the Y axis and 5 generations or age ranges showed on the X axis, above the graph and below the title and subtitle, from the Silent generation (the oldest) to the Generation Z.\nAccording to Cleveland (1985), graphs encode data in distinct elements, such as symbols, colors, position, etc. When we study a graphic we perform several mental-visual tasks to extract quantitative information. Some of the basic judgements we perform to decode quantitative information are 1) angle, 2) area, 3) color hue, 4) color saturation, 5) density, 6) length, 7) position along a common scale, 8) position along identical, nonaligned scales, 9) slope, and 10) volume (Cleveland 1985).\nIn consideration of this, the information in the bump chart can be extracted by judgements of position along the vertical scale, which represents the spending categories; the color of each line, which represents the categories of expenditure; the position of each point on the X axis, which represents the generation; and the thickness of the lines, which represents the money spent in each category (the thicker the line the more money has been spent). The closeness of the dots stands for the closeness in the ranking positions. The size of the points does not represent anything.\nCleveland also discusses detection, which he qualifies as the most fundamental perception issue, because before executing any graphical perception task, we must be able to detect the graphical element (Cleveland 1985). Lodha’s bump chart does not show overlaps in the dots, which together with color and position is the most important symbol. The jumps in the ranking are well understood. In broad terms, the graphic is very readable, which is not the same as effective.\nReplication in R\nAn almost exact replica was created using ggplot2,\nThe libraries used were as follows:\n\n\n# Import libraries\nlibrary(tidyverse) # for data manipulation\nlibrary(ggplot2) # for data graphics.\nlibrary(ggtext) # provides markdown and HTML text rendering\nlibrary(grid) # for adding the two white lines at the top and bottom\n\n\nThen, the data was imported. As mentioned above, the data is only a PDF, so the values had to be transcribed manually. After that, we made some transformations.\n\n\ndf <- read_csv(\"data.csv\")\nhead(df)\n\n# A tibble: 5 × 15\n  generation  housing healthcare  food trans…¹ cash_…² enter…³ insur…⁴\n  <chr>         <dbl>      <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 silent        16656       7053  5487    5263    4045    2027    1213\n2 boomers       21273       6594  7651    9327    2876    3476    6309\n3 gen_X         26385       5550 10388   13956    2747    4694   11656\n4 millennials   24052       4026  8463   11052    1163    3457    9249\n5 gen_Z         15449       1354  5529    7929     760    1693    3871\n# … with 7 more variables: miscellaneous <dbl>, apparel <dbl>,\n#   personal_care <dbl>, education <dbl>, alcohol <dbl>,\n#   reading <dbl>, smoking <dbl>, and abbreviated variable names\n#   ¹​transportation, ²​cash_contributions, ³​entertainment, ⁴​insurance\n\n\n\n# Pivot longer, add ranks and order chronologically\ndf <- df %>%\n  pivot_longer(-generation, names_to = \"variables\", values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Manually renaming\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \n  \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance and pensions\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n\n\n# Formatting the dollars' column\ndf$dollars <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars <- paste0(\"$\", df$dollars)\n\n\nCharacter vectors were created to 1) sort the generation names chronologically because ggplot2 displayed them in alphabetical order, 2) format them in HTML language that will later be rendered by the ggtext package, and 3) to add as tag the description of the X-axis.\n\n\nx_names_ordered <- c(\"Silent\", \n                     \"Boomers\", \n                     \"Generation X\", \n                     \"Millennials\", \n                     \"Generation Z\")\n\n\n\n\nx_names_full = c(\n  \n  paste(\"<span style='font-size: 9.55pt'>**Silent**<\/span>\",\n        \"1945 or earlier\",\n        \"**$44,683**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\"<span style='font-size: 9.55pt'>**Boomers**<\/span>\",\n        \"1946 to 1964\",\n        \"**$62,203**\",\n        sep = \"<br>\"),\n\n\n  paste(\"<span style='font-size: 9.55pt'>**Generation X**<\/span>\",\n        \"1965 to 1980\",\n        \"**$83,357**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Millennials**<\/span>\",\n    \"1981 to 1996\",\n    \"**$69,061**\",\n    sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Generation Z**<\/span>\",\n    \"1997 or later\",\n    \"**$41,636**\",\n    sep = \"<br>\")\n\n                )\n\n\n\n\nx_lab <- paste(\n  \"<span style='font-size: 10pt'>**Generation**<\/span>\",\n  \"Birth Year Range\",\n  \"**Average Annual Expenditure**\",\n  sep = \"<br>\"\n              )\n\n\nThen the theme was built. We call this theme theme_bump. Before that, we saved as objects the codes of the two main colors: the one of the background and the one of the text.\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nThe textual elements were changed from element_text to element_markdown of the ggtext package. This allows to use markdown or HTML to design text strings.\n\n\ntheme_bump <- function() {\n\n  # Begin construction of the theme\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n}\n\n\nWe then proceeded to build the bump chart. Note that the following chunk must start with {r fig.width = 8.29, fig.height = 6.88} to display the replica in the same proportions as the original.\n\n\nreplica <- ggplot(\n  data = df,\n  aes(x = generation, \n      y = ranking, \n      group = variables)) +\n  # Add the custom theme just designed\n   theme_bump() +\n  # Add the horizontal lines per generation\n     geom_line(aes(color = variables, \n                   alpha = 1, \n                   # Change line thickness accordingly:\n                   linewidth = rev(ranking))) + \n  # Add the points. The white ones are for the border  \n   geom_point(size = 11.85, \n                color = \"white\") +\n     geom_point(aes(color = variables), \n                size = 11.3) +\n     scale_y_reverse(breaks = 1:nrow(df)) +\n  # Order and \n     scale_x_discrete(\n       limits = x_names_ordered,\n       labels = x_names_full,\n       position = \"top\",\n       expand = expansion(mult = c(0.356, 0.1))\n                    ) +\n  # Titles, subtitle, caption and tag \n  labs(\n    title = \"HOW AMERICANS SPEND THEIR MONEY\",\n    subtitle = \"By Age Group | 2021\",\n    caption = \"Author: Preethi Lodha\",\n    tag = x_lab\n  ) +\n  # Add the two horizontal white lines at the top and the bottom\n    coord_cartesian(clip = \"off\") +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(1.11, 1.11), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(-0.05, -0.05), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n  # Add the Y axis text     \n  geom_text(data = df %>% \n                    filter(generation == \"Silent\"), \n                  aes(label = variables, \n                      x = 0.72236), \n                  hjust = \"outward\", \n                  fontface = \"bold\", \n                  color = \"#272727\", \n                  size = 2.4) +\n  # Add the amount money spent.\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.25, \n                fontface = \"bold\") +\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.253, \n                fontface = \"bold\") +\n      geom_text(data = df, aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.257, \n                fontface = \"bold\") +\n  # Add line colors\n      scale_color_manual(values = c(\n        \"#9c6255\",\n        \"#a0d4ee\",\n        \"#9d8379\",\n        \"#8f93b5\",\n        \"#494c4d\",\n        \"#2f634a\",\n        \"#ed444a\",\n        \"#8a8887\",\n        \"#a13b5d\",\n        \"#87a7a0\",\n        \"#af9e2e\",\n        \"#6d1f29\",\n        \"#466f9d\",\n        \"#3896c4\"\n      )) \nreplica\n\n\n\nTo save the plot:\nggsave(\"replica.png\", \nplot = last_plot(), \npath = \"images\", \nwidth = 8.29, \nheight = 6.88, \nunits = \"in\", \ndpi = 120)\nAs can be seen below, only the small icons at the bottom left and the interactive box at the top right were not reproduced. Since these are interactive elements in the original dashboard, we did not consider it necessary.\nOriginal bump chart created by Preethi Lodha.My replica in ggplot2.How can it be improved? Enhancements\nFrom the start, one might question the need to design a graphic to display these data. Tufte (2013) points out that “[t]ables usually outperform graphics in reporting on small data sets of 20 numbers or less” and that “[t]he special power of graphs comes in the display of large data sets.” This case is not a large data set: in fact, the source is a PDF. This peculiarity has pros and cons: on the one hand, to represent expenditure by generation and expenditure category, it is unnecessary to perform many transformations; but on the other hand, it limits the options for alternative graphics.\nIn terms of features, notwithstanding its goodness, it is noted that this bump chart —and indeed, all of them— give readers the feeling that the difference between each category is about the same because the channels used —width of the lines and distance between them— are the same. Although in this case the thickness of the lines has been manipulated to represent each amount of money, its effect in counteracting that feeling is limited.\nUsing labels within the circles to show the money spent per category and per generation could have been a wise move, following the postulates of Tufte (2013), who points that “[c]lear, detailed and thorough labeling should be used to avoid graphic distortion and ambiguity […].” But, in this case, such labels add an extra layer of information and if the bump chart represents jumps in ranking, these were already encoded in the position of the dots and the jumps in the lines. Moreover, there are examples that even though spending in a certain category decreases from one generation to the next, its position in the ranking goes up and vice versa: just look at the jump from Millennials to Generation Z in the category Personal care products and services; and the jump from Boomers to Generation X in the Food category. Tufte himself would call it “a lying graphic” (Tufte 2013).\n\n“A second defense of the lying graphic is that, although the design itself lies, the actual numbers are printed on the graphic for those picky folks who want to know the correct size of the effects displayed. […]” (Tufte 2013)\n\nSo, if the purpose is to represent the spending distribution of Americans, showing rankings can be misleading. For this reason, the main point of improvement would be to represent spending rather than ranking. This implies to change the type of graph to one where the data items are the money spent and the data attributes are the generation and the category of spending. Tufte (2013), in this regard, postulates that “[t]he representation of numbers, as physically measured on the surface of the graph itself, should be directly proportional to the numerical quantities represented” (Tufte 2013). What visual marks would be the most efficient?\nIn order to continue using lines and dots to represent the data, the proposed enhancements are in a line plot:\nA line plot based on Preethi Lodha’s bump chart. This enhancements proposal also has much room for improvement in concept and implementation. Own elaboration.This is not exempt from problems, both in terms of conception and execution. First, the category with the highest expenditure by far is Housing, but the other categories are very close, which caused problems with overlapping labels. That was the driving force behind plotting only the first 6 expenditure categories. Even so, overlapping continued to exist and the ggrepel package, which would help to solve it, did not really avoid them; it only helped to eliminate the labels that were too close at the cost of dislocating others. Another problem is that, according to Healy (2018), lines illustrate “connection and common fate in that the lines joining the shapes tend to be read left-to-right as part of a series” (Healy 2018). He mentions this when explaining Gestalt rules, which are “the strong inferences we make about relationships between visual elements from relatively sparse visual information.” The author emphasizes that line graphs suggest that the underlying variable is continuous and that is not necessarily advantageous for our data, since the X axis contains the generations, but it is not a continuous variable over time.\nThe Gestalt inferences. Extracted from: Data vizualization: a practical introduction, by Kieran Healy. Published by the author in https://socviz.co/One option was to make a Sankey diagram. These visualize flows of quantities through a process and, as an opinion, are more eye-catching. With a Sankey diagram, we would have split the amount spent by each generation in 2021 into 14 categories of data —or fewer, if we also decide to show only the top categories or to group several ones into “Others”—, and each generation would be a breakdown. However, this would give the false sense that the flow of money changes over a period of time and, in stricto sensu, it is not: spending does not change over time: all the data represented is from 2021. What does change is another categorical variable: generation.\nAn example of a Sanky diagram from Wikimedia Commons:\nWikimedia Commons.In addition, in data visualization, clarity should be privileged over the pomposity: Healy (2018) quotes Tufte about graphical excellence, commenting that it “consists of complex ideas communicated with clarity, precision, and efficiency.” Thus, the idea of a Sankey, despite being relatively simple to execute with the ggsankey package, was discarded. A cleaner, clearer and closer option to Lodha’s original graph is the line plot.\nDesigning the enhancements proposal\n\n\n#Libraries, most of them already used in the replica\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel) # To (try to) avoid label overlappings\n\n\nThe following pipes were useful for obtaining a suitable dataframe:\n\n\ndf <- read_csv(\"data.csv\") %>% \n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  #group_by(generation) %>%\n  arrange(desc(dollars))\n\n\nThen, the data was manipulated. Those code chunks will not be showed here as are the same than in the replica (renaming variables using indexing and generating the same character vectors).\nThe theme was a bit edited. This new version is called theme_lines().\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\n\n\ntheme_lines <- function() {\n\n  theme_bw(base_size = 15) +\n\n    # Background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_blank()) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Legend\n    theme(legend.position = \"bottom\") +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_rect(\n      fill = color_background)) +\n    theme(legend.text  = element_markdown(\n      color = color_text, \n      size = 6.5, \n      face = \"bold\")) +\n    theme(legend.title = element_blank()) +\n    theme(legend.direction = \"horizontal\") +\n    theme(legend.spacing.x = unit(0.3, 'cm')) +\n      \n    # Caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_markdown()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n\n}\n\n\nHere, we started the construction of the line plot. Note that each ggplot2 chunk must start with {r fig.width = 8.29, fig.height = 6.88} for it to be displayed with the same proportions of the original bump chart.\n\n\n# Used by the `ggrepel`. Ensures reproducibility of the same labels disposition\nset.seed(78)\n\n#Select only the head categories:\ndf <- \n  subset(df, variables %in% \n           c(head(unique(df$variables)))) \n\nenhan <- df %>% \nggplot() +\n  aes(x = generation, \n      y =dollars, \n      group = variables, \n      color= variables) + \n # Add lines\n   geom_line(\n    alpha = 0.6, \n    linewidth = 1.4) + \n  # Add points and their border:\n  geom_point(size = 4, \n           shape = 20, \n           alpha = 0.6) +\n  geom_point(size = 3, \n             shape = 1, \n             color=\"white\", \n             alpha = 0.7, \n             stroke = 0.7) +\n  # Order the axis x text\n  scale_x_discrete(\n     limits = x_names_ordered,\n     labels = x_names_full,\n     position = \"top\",\n     expand = expansion(mult = c(0.09, 0.1))\n                  ) +\n  scale_y_discrete(\n    expand = expansion(mult = c(0.001, 0.001))\n                  ) +\n  # Title, subtitle and caption. No tag this time.\nlabs(\n  title = \"HOW AMERICANS SPEND THEIR MONEY\",\n  subtitle = \"Top 6 categories by age group | 2021\",\n  caption = \"Author: Preethi Lodha\"\n) +\n\n# Format dollars spent labels\n   geom_text_repel(\n    aes(label = \n          paste0(\"$\", (format(df$dollars, \n                              big.mark=\",\", \n                              trim=TRUE))), \n      segment.square  = TRUE,\n      segment.inflect = TRUE\n    ),\n    # Max labels overlappings allowed:\n    max.overlaps  = 2, \n    size          = 2.5,\n    fontface      = \"bold\",\n    direction     = \"y\"\n    ) +\n  guides(colour = guide_legend(nrow = 1)) +\n  scale_color_manual(values = c(\n                                \"#ab3a6b\",\n                                \"#494c4d\",\n                                \"#3896c4\",\n                                \"#2f634a\", \n                                \"#af9e2e\",\n                                \"#ed444a\")) +\n  # Add the 2 horizontal white lines\n  coord_cartesian(clip = \"off\") +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(1.13, 1.13), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(-0.05, -0.05), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n  # Add the custom theme \n  theme_lines()\n\nenhan\n\n\n\nThere are 9 unlabeled data points, according to the warning message of the ggrepel package. We save the plot with the following code:\n# Save the plot\nggsave(\"enhancements.png\", \n       plot = last_plot(), \n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,\n       units = \"in\", \n       dpi = 120) # Resolution\nAlternative visualization(s)\nAn attempt was made to design an alternative graphic—and an alternative to the alternative. These, although better, still have some flaws.\nThe design of an alternative graph with the same data involved a nonlinear flow. Cleveland explains that data graphing should be an iterative process: “Iteration and experimentation are important for all of data analysis, including graphical data display. Most times when we make a graph it is immediately [sic] clear that some aspect is inadequate and we regraph the data. In many other cases we make a graph, and all is well, but we get an idea for studying the data in a different way with a different graph; one successful graph often suggests another” (Cleveland 1985).\nThe purposes that the new graph should follow were to make the data stand out and eliminate superfluity (Cleveland 1985). Another important point is ease of understanding. Heer and Bostock (2010) replicated previous studies on graphical perception by evaluating charts that encoded data in different ways. Basically, the best way to represent data is with comparison on a common scale —such as grouped bar charts— and the worst is to show it in areas like treemaps do (these performed even worse than pie charts!) (Heer and Bostock 2010). Given this, the theory suggests simplicity, cleanliness and clarity rather than fancy design details and pomposity. In this case, we went for simplicity even in contradiction to Cleveland, who argues that “[t]he important criterion for a graph is not simply how fast we can see a result; rather, it is whether through the use of the graph we can see something that would have been harder to see otherwise […]” (1985). We believe that it is very important that the graphic shows its main idea at first glance, especially in these days when we have so many visual stimuli on the Internet and they all fight for our attention.\nThus, visual cleanliness is a must, but for those intended for publication in websites such as the Visual Capitalist that target a wide and not necessarily expert audience, it is also a challenge. In addition, there are also studies that suggest that visual embellishment has a positive effect on the comprehension and memorability of graphics (Bateman et al. 2010). How to balance aesthetic taste and graphical excellence and integrity? We had to achieve all this without creating a chartjunk, as Tufte would call it, and without losing the purpose of the data, of the original bump chart and its context, and with a data that is only a small table.\nFor these reasons, the safe bet was to develop a grouped bar chart that shows spending categories, generation and amounts in a clear, simple and uncluttered way, but with a custom theme.\nA grouped bar chart, colorblind-friendly. This is the proposed alternative visualization. Own elaboration.The underlying cause why it is flipped is mainly to avoid label overlappings, which were the major problem in all the visualizations we tried with this data. A colorblind-friendly color palette was made. Also, the grid was eliminated according to Tufte: “one of the most sedate graphical elements, the grid, should usually be muted or completely suppressed so that its presence is only implicit—lest it compete with the data […]. Dark grid lines are chartjunk” (Tufte 2013). We do not agree that much with him in that regard, but we must accept that, at least in this case, they are not necessary: that information is already provided by the labels, which Tufte endorses. The choice of font was a personal choice.\nThis graphic has, however, some flaws: we find that the number of bars make it look bloated even though we reduced their number by including several in the “Others” category.\nAlso, the presence of a legend is not bad per sé, but in this case there are still several categories and the audience would have to constantly go back and forth from the legend to the plot to decipher what represents which bar. However, positioning the name of each spending category instead of the name, birth year range and total spent would make it even more bloated.\nAs the display of multiple bars seemed a bit cluttered even if, in our opinion, the plot delivers the correct visualization, a similar visualization was made. We considered that a lollipop plot could be an even better option, and is a close relative of bar plots.\nA grouped lollipop, also colorblind-friendly. Own elaboration.Clarity was the guideline for this lollipop graphic, too. However, some drawbacks arose: the overlapping labels made us decide to remove any geom_text or geom_label from our code and, contravening Tufte, plot a grid as an alternative. Only minor grids are shown and we set a number of grids that we felt was not exaggerated. We also it dashed and used a very subtle color so that it does not overload the plot too much. Still, it exists.\nBoth plots, even if simple, show the expenses per generation more clearly than the bump chart and have visual encodings, according to Heer and Bostock (2010), capable of being better interpreted than stacked bar charts, bubble charts, pie charts and treemaps, the latter being even less effective than pie charts. This last case caught our attention, as treemaps are quite common in all types of publications and are, in our personal opinion, visually appealing. See here an example of a treemap published by Le Monde newspaper.\nSo, we made one, just for comparison (and learning how-to) purposes:\nA treemap just for clarity comparison. Authors argue that it is not a good option due that areas are hard to compare, even more than angles (like the case of pie charts). Own elaboration.As can be seen, the bar plot is simpler and easier to understand than the treemap, as it uses a single visual mark, the bar, to represent the data. That specific visual mark is always of the same width, so the viewer decodes only the height of the bar to interpret the quantity it encodes. For that reason, the proposed bar plot is more effective at conveying the patterns of the data and to compare the values of different categories.\nWhat cannot be denied about the treemap is that it is visually more attractive, at least to our personal taste. Unfortunately, with this one it is more complicated to interpret the differences in the money spent by each generation in a single category. For example, if there were no money spent labels added, it would be difficult to compare Generation X and Generation Z spending on Housing. Besides, it was way more difficult to design. We could have designed one treemap with 5 subgroups —and not 5 invidivual treemaps and then paste them— and the result would have been more or less similar, but without the spaces between each subgroup and with problems to add specific colors for each generation. The code is at the end of this report.\nDesigning the bar plot\n\n\n# Libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel)\nlibrary(ggpubr)\n\n\nWe first computed the rankings just for the selecting the first categories.\n\n\ndf <- \n  read_csv(\"data.csv\") %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Rename categories lower in the ranking as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\n\nThen, the data was manipulated, and variables renamed.\n\n\n# Format the dollar column\n\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nA character vector for ordering the generations:\n\n\ngen_order <- c(\n  \"Generation Z\",\n  \"Millennials\",\n  \"Generation X\",\n  \"Boomers\",\n  \"Silent\"\n      )\n\n\nWe used the same colors:\n\n\n# Theme colours\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nLater, the custom theme was built. This was called theme_bar().\n\n\ntheme_bar <- function() {\n\n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Format the legend\n    theme(legend.position = \"top\") +\n    theme(\n       legend.text = element_markdown(\n        color = color_text,\n        family = \"Consolas\",\n        size = 7.5,\n        face = \"bold\",\n        hjust = 0)) + \n    theme(legend.title = element_blank()) +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_blank()) +\n\n    # Format de caption\n      theme(plot.caption = element_markdown(\n        hjust = 1, \n        family = \"Consolas\",\n        size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5,\n      margin=margin(4,0.2,4,0.2))) +\n    theme(plot.title.position = \"plot\") +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(4,0.2,4,0.2))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.y = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size = 8.5\n    )) +\n    theme(axis.text.x = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    \n    # Plot margins\n      theme(plot.margin = \n              unit(c(0.2, 0.7, 0.2, 0.7), \"cm\")) # top, right, bottom, left\n}\n\n\nThis is the colorblind friendly palette:\n\n\n#Colorblind friendly palette\ncolorblind <- c(\n                \"#5d3686\",\n                \"#c3a939\",\n                \"#6c7ed7\",\n                \"#b95336\",\n                \"#74a344\",\n                \"#a19f9f\",\n                \"#ba496b\",\n                \"#43c9b0\",\n                \"#c26abb\",\n                \"#ae853d\"\n                )\n\n\nThen the bar plot was designed:\n\n\ntag_house <- \"$26,385\"\n\nbar <- ggplot(df, aes(\n                      fill = reorder(variables, \n                                     desc(dollars)), \n                      y    = dollars,\n                      x    = generation)) +\n    geom_bar(position  = \"dodge\", # for groups\n             stat      = \"identity\",\n             linewidth = 0.05,\n             color     = color_background) +\n  # Add dollars' labels\n geom_text(aes(label = dollars2),\n            position      = position_dodge(0.9),\n            color         = color_text,\n            family        = \"Consolas\",\n            #vjust         = 0.5,\n            hjust         = -0.3,\n            size          = 2.5\n            ) +\n  # Order of the x Axis text\n  scale_x_discrete(\n    limits = gen_order,\n    labels = c(\n       \"**Generation Z**<br>1997 or later<br>**$41,636**\",\n       \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n       \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n       \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n      \"**Silent**<br>1945 or earlier<br>**$44,683**\"\n                )\n    ) +\n  # To manipulate the width of the graphic:\n  scale_y_continuous(\n        expand = c(0.005,0), #0.0632\n                    ) +\n  scale_fill_manual(\n    values = colorblind #colorblind-friendly palette\n                    ) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n   # As one of the bars was too large, we added its label manually as a tag\n    tag = tag_house \n       ) +\n  theme_bar() +\n  theme(\n    legend.box.margin = margin(0.2,2,0.2,0.1, unit = \"cm\"),\n    legend.spacing.x = unit(0.4, 'cm'),\n    plot.title.position = \"plot\",\n    plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 7.5,\n      color = color_background),\n    plot.tag.position = c(0.965, 0.332)) + #horizontal, vertical\n  coord_flip() \n  \nbar\n\n\n\nCode for saving the plot:\nggsave(\"alternative_bar.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the lollipop plot\nThe same bar plot theme was used.\n\n\ngen_order <- c(\n        \"Silent\",\n       \"Boomers\",\n       \"Generation X\",\n       \"Millennials\",\n       \"Generation Z\")\n\n\n\n\nlol <-\nggplot(df)+\n    geom_linerange(aes(\n      x = generation,\n      ymin = 0, \n      ymax = dollars, \n      colour = reorder(variables, desc(dollars))), \n      position = position_dodge(0.8))+\n    geom_point(\n      aes(\n        x = generation,\n        y = dollars,\n        colour = reorder(variables, desc(dollars)),\n      ),\n      size = 4,\n      position = position_dodge(0.8)\n    ) +\n    scale_x_discrete(\n    limits = gen_order,\n    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\",\n               \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n               \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n               \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n               \"**Generation Z**<br>1997 or later<br>**$41,636**\")\n               ) +\n  scale_y_continuous(\n        expand = c(0.03,0),\n        n.breaks = 8\n        ) +\n  scale_color_manual(values = colorblind) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\"\n       ) +\n  theme_bar() +\n    theme(\n          legend.box.margin = margin(0.2,1,0.2,0.2, unit = \"cm\"),\n          legend.spacing.x = unit(0.4, 'cm'),\n          axis.text.x = element_markdown(\n                                        color = \"#3b3b3a\", \n                                        family = \"Consolas\", \n                                        size=7.5\n                                      ),\n          plot.title.position = \"plot\",\n          panel.grid.major.y = element_line(color = \"#b0aeae\",\n                                          linewidth = 0.25,\n                                          linetype = \"dashed\"))\nlol\n\n\n\nThe plot was saved with:\nggsave(\"alternative_lol.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the treemap\nFinally, just for learning and comparison purposes, the treemap code is shown below. As said before, authors do not recommend this kind of visualizations because differences in areas are hard to perceive. Besides, when compared with the bar plot or the lollipop, looks way more bloated and less effective.\n\n\n# Import libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(treemapify)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(ggpubr)\n\n\n\n\n# Import data\ndf <- read_csv(\"data.csv\")\n\n# Data wrangling\n\ndf <- df %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products \\n and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n# Categorize observations with a ranking <= 9 as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\n\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\ndf$ranking <- NULL\n\n\n\n\ntheme_tree <- function() {\n  \n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    #theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_markdown(\n      hjust = 1, \n      family = \"Consolas\",\n      size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), \"cm\")) # top, right, bottom, left\n}\n\n\n\n\n# Format the dollars column.\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nDesigning the 5 treemaps:\n\n\nx <- ggplot(df %>% filter(generation==\"Generation X\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#4b4d27\",\n                              \"#a4a671\",\n                              \"#717342\",\n                              \"#717342\"))\n\nmillennials <- ggplot(df %>% filter(generation==\"Millennials\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#805b28\",\n                              \"#e3af6b\",\n                              \"#c49350\",\n                              \"#c49350\"))\n                              \n\nboomers <- ggplot(df %>% filter(generation==\"Boomers\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left        \n    scale_fill_manual(values=c(\"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#96592d\",\n                              \"#e39762\",\n                              \"#be7c4d\",\n                              \"#be7c4d\"))\n                              \n\nsilent <- ggplot(df %>% filter(generation==\"Silent\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n    scale_fill_manual(values=c(\"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#63431d\",\n                              \"#ba9a73\",\n                              \"#9a7447\",\n                              \"#9a7447\"))\n                              \nz <- ggplot(df %>% filter(generation==\"Generation Z\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n      scale_fill_manual(values=c(\"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#61563f\",\n                              \"#baac91\",\n                              \"#897d65\",\n                              \"#897d65\"))\n\n\nThe treemap was, in fact, five glued treemaps. For that reason, the legend could not be displayed properly, so we made a very simple bar plot containing a legend, and the get_leyend function extracted it. Then, we converted it into an ggplot2 element with the as_ggplot function. This procedure allowed us to use the patchwork package and paste the 5 treemaps plus the legend. The ggpubr and cowplot packages were used for these purposes.\n\n\n# Summarize the spendings per generation\ndf_summ <- df %>%\n    group_by(generation) %>%\n    summarise(total_per_generation = sum(dollars))\n\n\n\n\ngen_order <- c(\"Silent\", \n       \"Boomers\", \n       \"Generation X\", \n       \"Millennials\", \n       \"Generation Z\")\n\n\n\n\n# Set custom colors\nbar_colors <- c(\"#9a7447\",\n                          \"#be7c4d\",\n                          \"#717342\",\n                          \"#c49350\",\n                          \"#897d65\"\n)\n\nbar2 <- ggplot(df_summ) +\n  aes(\n    x = generation,\n    fill = generation,\n    weight = total_per_generation) +\n  geom_bar() +\n  scale_fill_manual(breaks=gen_order, \n                    values = bar_colors,\n                    name = \"\",\n                    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\", \n                               \"**Boomers**<br>1946 to 1964<br>$**62,203**\", \n                               \"**Generation X**<br>1965 to 1980<br>**$83,357**\", \n                               \"**Millennials**<br>1981 to 1996<br>**$69,061**\", \n                               \"**Generation Z**<br>1997 or later<br>**$41,636**\")) +\n  scale_x_discrete(\n    limits = gen_order) +\n  theme_minimal() +\n  theme(plot.margin = unit(c(0,0,0,0), \"pt\")) +\n  theme(legend.text = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) + # top, right, bottom, left\n  theme(legend.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) +\n  theme(legend.position = \"bottom\") +\n  theme(legend.spacing.x = unit(0.5, 'cm'))\n\nbar2\n\n\n\n\n\n# Extract the legend\nlegend_extract <- get_legend(bar2) \n\n\n\n\n# Turn the legend into a ggplot2 object\nlegend <- as_ggplot(legend_extract)\n\n\nPaste all graphics:\n\n\ntree <- legend + ((silent / boomers) | (x / millennials) + z) + \n  plot_layout(\n              nrow = 2,\n              ncol = 1,\n              heights = c(0.5, 6)) +\n  plot_annotation(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n    \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n    theme = theme_tree()\n                  )\n\ntree\n\n\n\nSave plot:\nggsave(\"alternative_tree.png\", \n       plot = last_plot(), \n       path = \"images\", \n       width = 8.29, \n       height = 6.88, \n       units = \"in\", \n       dpi = 300)\nNeedless to say, replicating the graphic and proposing new visualizations were very learning exercises. Being able to design better graphics with cleaner and shorter code is still a longer term task.\n\n\n\nBateman, Scott, Regan L. Mandryk, Carl Gutwin, Aaron Genest, David McDine, and Christopher Brooks. 2010. “Useful Junk?: The Effects of Visual Embellishment on Comprehension and Memorability of Charts.” In Proceedings of the 28th International Conference on Human Factors in Computing Systems - CHI ’10, 2573. Atlanta, Georgia, USA: ACM Press. https://doi.org/10.1145/1753326.1753716.\n\n\nBump, Philip. 2021. “America’s Favorite Dog Breeds for the Past Two Decades, Ranked.” Washington Post, November 25, 2021. https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/.\n\n\nCleveland, William S. 1985. The Elements of Graphing Data. Monterey, Calif: Wadsworth Advanced Books and Software.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical Introduction. Princeton, NJ: Princeton University Press.\n\n\nHeer, Jeffrey, and Michael Bostock. 2010. “Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.”\n\n\nLodha, Preethi. 2022. “How Do Americans Spend Their Money, By Generation?” Visual Capitalist. September 25, 2022. https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/.\n\n\nTufte, Edward R. 2013. The visual display of quantitative information. 2nd ed., 8th print. Cheshire, Conn: Graphics Press.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n\n\n\n",
    "preview": "projects/2022/100481925/images/replica.png",
    "last_modified": "2023-01-06T00:56:10+01:00",
    "input_file": {},
    "preview_width": 994,
    "preview_height": 825
  },
  {
    "path": "projects/2022/100483607/",
    "title": "Distribution of state investment by autonomous communities",
    "description": "This following page is a guide, of how to reproduce step by step, the plot of \"El Mundo Gráficos\" done by the student Pablo Arroyo as a final project for the subject.",
    "author": [
      {
        "name": "Pablo Arroyo Rodriguez",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLabs\nLegend\n\nImprovements\nCode\n\nConclusion\n\nThe distribution of state investment by autonomous communities, it is a tricky topic that each year comes to the news. When the State´s budget is published, almost the first thing that each media do is to analyze what are the communities that receive more, and what are the ones that receive less. This could be important, because depending on the needing of support for the governance, more money would go to one community or another.\nThe point here, is in the differences between Madrid and Catalonia. However, as illustrated here, the budget from Catalonia is closer to Andalusia rather than Madrid. We can see notices of this kind in the national press channel “Catalonia and Andalusia lead state investment with almost twice the budget of Madrid and the Valencian Community” or the “El Mundo” from which I took the graph.\nJ.Aguirre | EL MUNDO GRÁFICOS. Figure from elmundo.es.Getting the data\nApparently, the data could be really easy to obtain from an official source, because if you observe this same data from different papers, figures vary a bit. But, as expected with public institutions, the process is really tedious. So, what I did is to obtain the data from the public institution in charge of this figures in Spain, La Intervención General de la Administración del Estado with data from 2009 to 2022.\nFor data about the budget for the next year, 2023, I used another official page which show the information in a visual way, Ministerio de Hacienda, epdata.\nOnce you get the file with the whole datasheet from one specific year, you have to sum the different budget items by communities. It appears spread by different concepts, as a page in an excel book and repeating the process for the four years. Having done that, it is possible to obtain the data in a .cvs file format. So, we will see how our data looks like:\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggsci)\nlibrary(ggforce)\nlibrary(glue)\nlibrary(systemfonts)\nlibrary(cowplot)\n\nsysfonts::font_add_google(\"Be Vietnam Pro\")\nshowtext::showtext_opts(dpi=300)\n\ndata<- read_delim(\"Clean_Data.csv\", delim = \";\", col_types = \"cnnnn\"  )\nglimpse(data)\n\nRows: 19\nColumns: 5\n$ Comunidad <chr> \"Andalucia\", \"Cataluña\", \"Com. de Madrid\", \"C. Val…\n$ `2018`    <dbl> 1379.7, 1312.1, 1117.2, 700.0, 894.8, 962.7, 533.9…\n$ `2021`    <dbl> 2146.16, 2199.30, 1133.90, 1106.90, 792.60, 799.20…\n$ `2022`    <dbl> 2267.07, 2430.74, 1054.90, 1155.60, 1033.50, 935.2…\n$ `2023`    <dbl> 2318.8, 2508.9, 1305.4, 1269.5, 1077.9, 955.8, 600…\n\nIt is impossible to observe the whole datasheet. So, with the previous function glimpse(), we can take a quick view of the general structure, in order to observe more or less how it is. But for observing the main measures of central tendency from our data and its evolution through this for years, it would be nice to include the summary () function.\n\n\nsummary(data)\n\n  Comunidad              2018             2021        \n Length:19          Min.   :  23.5   Min.   :  24.48  \n Class :character   1st Qu.: 195.3   1st Qu.: 216.80  \n Mode  :character   Median : 363.9   Median : 384.10  \n                    Mean   : 504.7   Mean   : 622.11  \n                    3rd Qu.: 797.4   3rd Qu.: 795.90  \n                    Max.   :1379.7   Max.   :2199.30  \n      2022              2023       \n Min.   :  31.85   Min.   :  28.9  \n 1st Qu.: 192.60   1st Qu.: 241.4  \n Median : 439.30   Median : 481.5  \n Mean   : 666.25   Mean   : 718.1  \n 3rd Qu.: 984.35   3rd Qu.:1016.9  \n Max.   :2430.74   Max.   :2508.9  \n\nOnce we have our raw data, it is time to start giving format to our variables, in order that they appear specifically how we want them, not as mere values in a table.\n\n\ndata<-data %>% \n  pivot_longer(c(\"2018\", \"2021\", \"2022\", \"2023\")) %>% \n  mutate(\n    Comunidad=as.factor(Comunidad),\n    name=as.factor(name),\n  )\n\n\nFirst thing to do is to mutate them as a long format, which is more useful for visualization and statistics approaches. Also, it is important to convert the name of the communities and the name of the year, 2023, 2022, 2021, 2018, as factors. That is the way that we have in R to specify the categories in the representation.\nNow, it is possible to say that our data seems to be what it would be expected to start the construction of the graph.\nBuilding the chart\nThe plot was selected because it could seem easy to reproduce, and was the first time dealing with this kind of representation on my own. However, it started to get harder and harder to deal with this grouped bar chart, and the small details were really time consuming. But finally, it was possible to come up with a result as could be seen in the following lines:\nCoordinates and axes\nI will try to reproduce the graph, step by step, before adding the data and obtaining the whole plot.\n\n\np <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\np\n\n\n\nWith this first chunk of code, the baseline of the plot appears. Based on which, we will be adding information and modifying the different characteristic, in order to satisfy the same specification as in the selected one. However, the names of the communities are all together and it is really difficult to understand. It is a pointless point, so it´s worth it to have a vertical disposition instead of a horizontal one, the categories would be more readable.\nAs it could be seen in the example, the graph has certain limits for the values of our data. One of the first points that we have to do, is to fix those values within the specific categories. In this case from 0 to 3000 in steps of 500. I decided to expand the limits a bit more than this 3000, because otherwise the label for this 3000 extended passed the axis and we could not see it.\nThere are also coordinates for the negative part of the graph despite not having negative information for the budgets. That is because we have to extend the lines and add the names of the communities in this part as annotations, otherwise it would be impossible.\nA good point to highlight here, and which was really hard to find, is how to set the y axis on both sides. Although it is a simple line of code, it took me a while to find this specific chunk of code, so if some of you need this in the future pay attention at this point, because the rest is more or less the same as in all plots.\n\n\np <- p + scale_y_continuous(\n    breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000),\n    limits = c(-1500, 3200),\n    sec.axis = dup_axis(),\n    name = NULL,\n    expand = c(0,0)\n  ) +\n  \n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \"Baleares\", \n               \"Cantabria\", \"Canarias\", \"Asturias\", \"Extremadura\", \n               \"Murcia\", \n               \"Aragón\", \"País Vasco\", \"Castilla-La Mancha\", \n               \"Castilla y León\", \"Galicia\", \"C. Valenciana\", \n               \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\np\n\n\n\nA last comment about this previous chunk. The names of the axis have been deleted, because we do not want it to appear in our last graph, but also, we set a specific order for the name of the communities, based on the highest budget for the year 2023.\nTheme\nThe theme for this project is very easy. As it can be seen, the background of the graph is empty, nothing inside, but for, the lines below the name of each community which separate one community from another. A key point here is that we have established the small tick that appears below each break. Maybe, in this position it is hard to identify, but once we apply for coord_flip() it is more easy to observe.\n\n\np <- p + theme_minimal()+\n  \n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n    \np\n\n\n\nWe have an empty graph, with nothing inside which is the case that we are trying to replicate. However, we need to add the guides, and coord_flip() to see something similar to the original one. So, we will do it.\n\n\np <- p +  coord_flip(clip = \"off\", ylim = c(-1500, 3100))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 3100),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\np\n\n\n\nInstead of having a vertical bar chart which is the usual scenario after applying for these changes, we have a horizontal plot, with nothing inside. The graph is starting to seem similar to the original one. However, it is a kind of graph that by its nature, it is much longer than wider, so we have to change the adjustment of our R.Markdown to obtain what we want.\nNotice, that we have changed the specification of the graph, the plot is more or less what we want. Now is the time to add the data and the annotations.\nAnnotations\nApparently, this graph does not have any kind of annotation. However, it is a bit misleading and there was no other way to add the name of the communities rather than as an annotation. To do so, what I did is to extend the dimension of the plot past the axis, and once we have that, adding in the negative part the name corresponding to the different communities as annotations.\n\n\np <- p + annotate(\"text\", x = 19, y = -1400, hjust=0, \n           label = \"Cataluña\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 18, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13, y = -1400, hjust=0,  \n           label = \"Castilla-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\np\n\n\n\nData\nThis graph is based on grouped data by an autonomous community. With the name of the different communities and their budget from four different years, that is why in the previous steps it was important to pivot longer the data, and establish the different year and communities as_factor(). So, it is the type of grouped bar chart.\nNow, we will add the data to the previous coordinates and axis that we have been preparing, but also we will establish the different colors of the bars.\n\n\np <- p + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\np\n\n\n\nThe graph it is closer to our final result. Few things are still left such as a good title, subtitle and caption. But also, we have to establish a good position for the legend which is almost higher than the plot, and this does not make any sense.\nLabs\nA key point that it is still missing in this graph are the labs. If we see the graph until this point, we do not know what the graph is about without an appropriate title, it is mandatory to modify it, and also adding the different subtitles and comments.\n\n\np <- p + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\n\nHowever, when we add all of these things, our plot is completely a mess, because we have added many different things, without the necessary adjustment. So, everything has moved from one place to another and appears to be untidy. Let´s try to solve it! Basically, we will be adjusting almost every position of the element on the plot.\n\n\np <- p + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n     axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, face=\"bold\", \n                              margin=margin(0,0,0,0)),\n     plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                  size=9.5, color= \"black\", \n                                  face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n    ) \np\n\n\n\nLegend\nHowever, we still have the legend in a position that modifies the whole graph, and we have to change that to obtain a real reproduction.\n\n\np<- p +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.285, 1.05), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n    ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\np\n\n\n\nOnce we have done that, the representation is consistent with what we want, because everything is adjusted and aligned, not as in the previous steps, that when you modify something everything changes and you have to start again. But never give up, you will finish doing it!\nIt is time to introduce the annotation near to the name of each community. I tried to do it at the same time in just one chunk of code, but only the names from 3 different communities and the other disappeared. I do not know the reason well. So that is why I decided to do it step by step although it is longer. Sure, there is a better option.\nAnd also we have to add a little more. Notice that at the bottom of the graph there is more information than just a simple caption, so we have to add also this information. The way that I found better to add this information is by using the ggdraw(), which will be included at the end of the next chunk.\n\n\np<- p +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\np <- ggdraw(add_sub(p, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\n\np\n\n\n\nImprovements\nThe plot that I decided to reproduce, was quite complete with almost all the elements that should be included for a good representation, such as: a nice axis with its reference, annotations of different values, a clear legend, nice colors and so on.\nHowever, as a reader of newspapers I miss an interesting point that all graphs should have, something that draws our attention and keeps us reading the notice. This could be done by introducing some interesting point, or maybe some controversial that keeps readers awake, that is why I decided to do the following graph:\nP.Arroyo | MUCSS.Mainly, I decided to do two thing:\nAdding the name of the policy party that is in charge of each community.\nIncluding the evolution of the budget per community with an ascending or descending arrow.\nBy doing that, we include some controversial questions that encourage readers to go deeper in the theme. That is because, as said in the introduction, in Spain it is believed by many people that the budget that each community receives depends on sympathy with the central government.\nWhat, surprised me when I was doing this tutorial, is that also the original author of the previous graph, Javier Aguirre, has introduced some modifications in line with the ones that I was doing. The idea was the same, but his ones were more visual so I decided to continue my path in that way because it was just a few lines of code and the appearance was better. “See news with the final graph” This is a good point to remark, that once you get a nice graph, there is always a way to improve it based on the previous one.\nI have to point out that I don’t like in his definitive graph the inclusion of the top X axis, because there is so much information in the positive part that you will end up missing.\nCode\nI want to comment on the key point that I made to modify the whole graph. Also, I know that a good point of improvement is reducing the code to reproduce exactly the same, by for example using sequences that is something that I would like to do in future steps.\nMain points to highlight:\nExtending the limits of the axis passed the data, from -1500 to 4500, to introduce the different elements as annotations.\nSelecting just one X axis for reference instead of dup_axis(), in order not to overload the plot.\nCompute the percentage variation and add the different elements as annotations in this new axis.\nNevertheless, I include the whole chunk of code, knowing as I said before that there is enough space to do it in fewer lines, but the first step is a nice way of starting.\n\n\n### Coordinates and axes\nt <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\nt <- t + scale_y_continuous(\n  breaks = c(0, 1000, 2000, 3000),\n  #sec.axis = dup_axis(),\n  name = NULL,\n  expand = c(0,0)\n) +\n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \n               \"Baleares\", \"Cantabria\", \"Canarias\", \"Asturias\", \n               \"Extremadura\", \"Murcia\", \"Aragón\", \"País Vasco\", \n               \"Castilla-La Mancha\", \"Castilla y León\", \"Galicia\", \n               \"C. Valenciana\", \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\n### Theme\nt <- t + theme_minimal()+\n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n\nt <- t +  coord_flip(clip = \"off\", ylim = c(-1500, 4500))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 4500),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\n### Annotations for the left name of the communities\nt <- t + annotate(\"text\", x = 19.2, y = -1400, hjust=0, \n                  label = \"Cataluña\", size = 3, \n                  colour = \"#262626\")+\n  annotate(\"text\", x = 18.2, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17.2, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16.2, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15.2, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14.2, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13.2, y = -1400, hjust=0,  \n           label = \"C.-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12.2, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11.2, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10.2, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9.2, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8.2, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7.2, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6.2, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5.2, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4.2, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3.2, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2.2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1.2, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\n##Annotations for adding the different boxes based on the party in charge of each community\nt<- t + annotate(geom = \"rect\", xmin = 19, xmax = 18.75,\n                 ymin = -1400, ymax = -1200, fill = \"#f3af44\", alpha = 1) + #Cataluña\n  annotate(geom = \"rect\", xmin = 18, xmax = 17.75, #Andalucia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 17, xmax = 16.75, #Com.Mad\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 16, xmax = 15.75, #C.Valenciana\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) + \n  annotate(geom = \"rect\", xmin = 15, xmax = 14.75, #Galicia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 14, xmax = 13.75, #CyL\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 13, xmax = 12.75, #C.Mancha\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 12, xmax = 11.75, #País Vasco\n           ymin = -1400, ymax = -1200, fill = \"#22823a\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 11, xmax = 10.75, #Aragon\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 10, xmax = 9.75, #Murcia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 9, xmax = 8.75, #Extremadura\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 8, xmax = 7.75, #Asturias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 7, xmax = 6.75, #Canarias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 6, xmax = 5.75, #Cantabria\n           ymin = -1400, ymax = -1200, fill = \"#81b881\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 5, xmax = 4.75, #Baleares\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 4, xmax = 3.75, #Navarra\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 3, xmax = 2.75, #Rioja\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 2, xmax = 1.75, #Melilla\n           ymin = -1400, ymax = -1200, fill = \"#d9d9d9\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 1, xmax = 0.75, #Ceuta\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1)\n\n###Annotation for the ascendent/descent arrow based on the budget.\nt<- t + geom_segment(\n  x = 18.85, y = 3700,\n  xend = 19.1, yend = 3700,\n  lineend = \"round\", \n  linejoin = \"round\",\n  size = 1, \n  arrow = arrow(length = unit(0.3, \"cm\")),\n  colour = \"#1d1d1b\" \n) +\n  geom_segment(\n    x = 17.85, y = 3700,\n    xend = 18.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 16.85, y = 3700,\n    xend = 17.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 15.85 , y = 3700,\n    xend = 16.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 14.85 , y = 3700,\n    xend = 15.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) + \n  geom_segment(\n    x = 14.1 , y = 3700,\n    xend = 13.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 12.85 , y = 3700,\n    xend = 13.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 11.85 , y = 3700,\n    xend = 12.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.85 , y = 3700,\n    xend = 11.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.1 , y = 3700,\n    xend = 9.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 8.85 , y = 3700,\n    xend = 9.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 7.85 , y = 3700,\n    xend = 8.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 6.85 , y = 3700,\n    xend = 7.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 5.85 , y = 3700,\n    xend = 6.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 4.85 , y = 3700,\n    xend = 5.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 3.85 , y = 3700,\n    xend = 4.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.85 , y = 3700,\n    xend = 3.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.1, y = 3700,\n    xend = 1.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 1.1 , y = 3700,\n    xend = 0.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  )\n\n### Annotation fot the variations in the GDP.\n\nt<- t + annotate(geom = \"text\", x = 18.975, y = 3950,\n                 label = \"3.2\", hjust = 0, size = 3) + #Cataluña\n  annotate(geom = \"text\", x = 17.975, y = 3950,\n           label = \"2.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.975, y = 3950,\n           label = \"13.4\", hjust = 0, size = 3) + #Madrid\n  annotate(geom = \"text\", x = 15.975, y = 3950,\n           label = \"5\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.975, y = 3950,\n           label = \"0.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.975, y = 3950,\n           label = \"-4.2\", hjust = 0, size = 3) + #CyL\n  annotate(geom = \"text\", x = 12.975, y = 3950,\n           label = \"11.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 11.975, y = 3950,\n           label = \"14.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.975, y = 3950,\n           label = \"4.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.975, y = 3950,\n           label = \"-33.4\", hjust = 0, size = 3) + #Murcia\n  annotate(geom = \"text\", x = 8.975, y = 3950,\n           label = \"16.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.975, y = 3950,\n           label = \"7.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.975, y = 3950,\n           label = \"23.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 4.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.975, y = 3950,\n           label = \"34.7\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.975, y = 3950,\n           label = \"12.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.975, y = 3950,\n           label = \"-24.4\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.975, y = 3950,\n           label = \"-9.3\", hjust = 0, size = 3) \n\n\n##Anotation for adding the different text of the party in charge!\n\nt<- t + annotate(geom = \"text\", x = 18.875, y = -1100,\n                 label = \"ERC\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 17.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 15.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 12.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) + \n  annotate(geom = \"text\", x = 11.875, y = -1100,\n           label = \"PNV\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 8.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.875, y = -1100,\n           label = \"PRC\", hjust = 0, size = 3) + ##Cantabria\n  annotate(geom = \"text\", x = 4.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.875, y = -1100,\n           label = \"Indep\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) \n\n\n##Anottation for the tittle of this column\nt<- t + annotate(geom = \"text\", x = 19.68, y = 3200,\n                 label = \"Var. % 2022/23\", hjust = 0, size = 3, fontface = \"bold\")\n\n### Adding the data\nt <- t + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\n### Labs\nt <- t + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\nt <- t + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n    axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, \n                              face=\"bold\", margin=margin(0,0,0,0)),\n    plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                 size=9.5, color= \"black\", \n                                 face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n  ) \n\n###Anotations for the homemade guide about the different policies parties.\n\nt<- t + annotate(geom = \"text\", x = 20.5, y = -1500,\n                 label = \"Presidencias de las CCAA\", hjust = 0, size = 3) +\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -1500, ymax = -1300, fill = \"#e52b43\", alpha = 1) +#Color PSOE\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -500, ymax = -300, fill = \"#0086c5\", alpha = 1) + #Color PP\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 500, ymax = 700, fill = \"#f3af44\", alpha = 1)+ #Color ERC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 1500, ymax = 1700, fill = \"#22823a\", alpha = 1)+ #Color PNV\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 2500, ymax = 2700, fill = \"#81b881\", alpha = 1)+ #Color PRC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 3500, ymax = 3700, fill = \"#d9d9d9\", alpha = 1)+ #Color Indep.\n  annotate(geom = \"text\", x = 20.125, y = -1275,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 20.125, y = -275,\n           label = \"PP\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 725,\n           label = \"ERC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 1725,\n           label = \"PNV\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 2725,\n           label = \"PRC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 3725,\n           label = \"Indep.\", hjust = 0, size = 3)\n\n### Legend\nt<- t +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.295, 1.027), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n  ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\n\nt<- t +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\nt <- ggdraw(add_sub(t, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\nt\n\n\n\nConclusion\nOnce I completed the whole project, I have to say that it is a challenging process. You will be dealing with new tools that we have never seen before although they are really useful.\nYou will realize that after many hours of work, those things that in the first lesson sound like double Dutch to us, little by little everything starts to make sense. So, enjoy the process because this wonderful world of Data Visualization has many things to discover.\n\n\n\n",
    "preview": "projects/2022/100483607/ccaa470.jpg",
    "last_modified": "2023-01-06T00:56:10+01:00",
    "input_file": {}
  },
  {
    "path": "projects/2022/100489635/",
    "title": "GDP Forecasts for China's Cities by 'The Economist': Coastal Areas Have the Highest Growth Potential",
    "description": "A layer-by-layer construction of a map of China containing information on forecasted GDP growth and population for over 100 cities.",
    "author": [
      {
        "name": "Elena Yustres",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original chart\nObtaining and processing the data\nBuilding the plot\n\nEvaluation and potential enhancements\nAlternative visualization\n\nAs both a cause and consequence of China’s rapid economic growth, the proportion of the country’s population living in cities has soared from 20% in 1980 to 60% in 2020. However, China’s Zero-Covid policy has stilted growth significantly. The “China Emerging City Rankings, 2022” Report, launched by the Economist Intelligence Unit (EIU), assesses the growth potential of 108 cities predicted to have a population of more than 1 million by 2025. Scores are calculated using historical data and forecasts on variables including demography, the local economy or the environment.\nThe Economist’s “March of the cities” map. Figure from economist.com.This post will seek to replicate this map, propose incremental enhancements and suggest an alternative visualization that depicts the relationship between growth potential, population and location (or distance to the coastline) taking cities as our units of analysis.\nThe original chart\nObtaining and processing the data\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(showtext)\nlibrary(maps)\nlibrary(maptools)\nlibrary(svglite)\nlibrary(plyr)\n\nsysfonts::font_add_google(\"IBM Plex Sans\", family=\"IBM Plex Sans\")\nshowtext::showtext_auto()\n\n\nDiving into data collection, we obtained the data on the ranking and population of our units of analysis from the EIU (‘Global Geo-Political Trends and Economics’ section) after contacting their office in Asia by email.\n\n\nranking <- read_csv(\"ranking.csv\")\npopulation <- read_csv(\"population.csv\")\n\n\nOnce we have loaded both sets of data, the summaries below show that the ‘ranking’ dataset contains data on scores for 106 cities (ordered from highest, i.e. Ranking = 1, to lowest) while the ‘population’ dataset includes population data for 397 cities in China.\n\n\nglimpse(ranking)\n\nRows: 106\nColumns: 2\n$ City    <chr> \"Hangzhou\", \"Shenzhen\", \"Shanghai\", \"Suzhou\", \"Guang…\n$ Ranking <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\nglimpse(population)\n\nRows: 397\nColumns: 2\n$ City       <chr> \"Shanghai\", \"Beijing\", \"Shenzhen\", \"Guangzhou\", \"…\n$ Population <dbl> 22315474, 18960744, 17494398, 16096724, 13568357,…\n\nIn order to get both attributes (“Ranking” and “Population”) on the same dataset, we used a left_join to merge both datasets by the unit of analysis (“City”). This produced a dataset with both variables for the 106 cities provided by the EIU. Please note that, while the original map in the article by ‘The Economist’ includes 108 cities, the EIU only provided us with data on 106.\n\n\noutput <- ranking %>% left_join(population, by=\"City\")\n\n\nIn order to obtain the “longitude” and “latitude” of each city, we used the world.cities database. This database includes these and other variables for over 40,000 cities in the world. We then filtered the cities in China and selected (as well as renamed) the variables of interest to later on construct my final database.\n\n\ndata <- world.cities %>%\n  filter(country.etc==\"China\") %>%\n  dplyr::select(name, lat, long) %>%\n  dplyr::rename(\"City\"=\"name\", \n         \"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\") \n\n\nWe then merged the location dataset (‘data’) and the dataset with information on ranking and location (‘output’).\n\n\nfulloutput <- output %>% left_join(data, by=\"City\")\n\n\nThe data also required some cleaning and adjustment. First, there were two cities with the same name (i.e. Suzhou) in the EIU ranking. Since they are located in different provinces, we used population and location data to cross check which city corresponded to which score provided by the EIU and renamed one of them to establish the difference. Second, there were several other cities in the ‘data’ dataset with the same name as cities in the ‘output’ one, which led to there being more than one row for each unit of analysis in the ‘fulloutput’ table. We removed the appropriate rows, as well as the rows for which latitude and longitude data were not available (i.e. NAs for those variables). We are left with 104 rows.\n\n\nfulloutputclean <- fulloutput[-c(5, 23, 49, 51, 70, 81, 104, 113),]\nfulloutputclean <- fulloutputclean[!is.na(fulloutputclean$Latitude) \n                                   & !is.na(fulloutputclean$Longitude), ]\nhead(fulloutputclean, 5)\n\n# A tibble: 5 × 5\n  City      Ranking Population Latitude Longitude\n  <chr>       <dbl>      <dbl>    <dbl>     <dbl>\n1 Hangzhou        1    9236032     30.2      120.\n2 Shenzhen        2   17494398     22.5      114.\n3 Shanghai        3   22315474     31.2      121.\n4 Suzhou          4    6715559     31.3      121.\n5 Guangzhou       5   16096724     23.1      113.\n\nThe final step in data processing was obtaining the data to plot the underlying map of China and its provinces. The ggplot2-china-map repository contains such information. We used the readOGR function to read the ‘shapefile’, cleaned the data and fortified into a dataframe. We then instructed that the islands in the South China Sea not be drawn by selecting only observations with “AREA” above 0.005. Finally, again, we renamed variables accordingly.\n\n\nchina <- rgdal::readOGR(dsn=(\"./china_shapefile/\"), layer=\"bou2_4p\", verbose=FALSE)\nchina@data$id<-rownames(china@data)\nchina.points<-fortify(china, region=\"id\")\nchina.df<-join(china.points, china@data, by=\"id\")\nchina<-subset(china.df, AREA>0.005) %>% \n  dplyr::rename(\"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\",\n         \"Grouping\"=\"group\")\n\n\nBuilding the plot\nCoordinates of the map and data points\nUsing the data loaded in ‘china’ in the last step, we use geom_polygon() to draw the underlying map. The aes argument maps the longitude and latitude columns to the x and y coordinates, respectively. This function is also used to specify the fill and the transparency (alpha) level of the map.\nWe then use geom_path() to set the line demarcating the province limits. After indicating the use of the same variables and the same dataset as for the geom_polygon() function, we set the color and size of the border.\nFurther, coord_map() sets the coordinate system for the map by projecting the defined portion of the Earth onto a flat 2D plane.\n\n\np <- ggplot() +\n  geom_polygon(data=china,\n            aes(x=Longitude, y=Latitude, group=Grouping),\n            fill=\"cornsilk3\",\n            alpha=0.3) +\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping),\n            color=\"white\",\n            size=0.2) +\n  coord_map() \np\n\n\n\nNext, we add the data points at the specific locations of the 104 cities (defined by their latitude and longitude) with geom_point(). Thus, on top of the map, we are plotting a scatterplot using data from ‘fulloutputclean’ where each point represents one city. The size of the point (more specifically, its area) represents its population and its fill depicts the relative position of a given city vis-à-vis other cities in the EIU ranking. We then set a black line around the point (shape=21) while specifying the color and thickness (stroke) of the border.\nA title, subtitle and caption are added to replicate the original chart using the labs function.\n\n\np2 <- p + \n  geom_point(data=fulloutputclean, \n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking), \n             shape=21,\n             color=\"black\",\n             stroke=0.03) +\n  labs(title=\"March of the cities\",                                                                   \n       subtitle=\"China, emerging city ranking, 2022\",\n       caption=\"Source: EIU\") \np2\n\n\n\nScales\nNext, the scale_fill_stepsn() and scale_size() functions are used to customize the appearance of the legends for the color and size aesthetics, respectively.\nFor the color legend (or rather, fill legend, given our points have borders defined by the color argument as introduced in the previous section), we first specify its title and title position. We then specify the details relating to the ticks and limits between the different boxes of the legend. We set the values for the 7 breaks in the variable ‘Ranking’ so as to create six categories of rank scores. By means of a drawing tool using the hexadecimal system, we set the colors for each of the six categories. Note that higher-ranked cities are represented with shades of blue and lower-ranked cities are represented with shades of orange or brown, whereby darker shades of both colors represent the ends of the spectrum.\nFor the size legend, we do the same as with the fill legend regarding the title and the breaks, although this time we are specifying 3 breaks. In this case we are also setting the labels for those breaks. This is because, by default, R uses scientific notation for population but the legend title already states that values are provided in millions. Finally, we set the range of the size of the bubbles from 0.04 to 6 mm.\n\n\np3 <- p2 + \n  scale_fill_stepsn(\n      guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE, \n                             show.limits=TRUE, \n                             ticks.colour= \"black\",\n                             ticks.linewidth = 1, \n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1),\n      breaks=c(1, 20, 40, 60, 80, 100, 106), \n      colors=c(\"#1c2c74\", \"#5483b3\", \"#99ccff\", \"#fcdb9b\", \"#fcbc04\", \"#ac6404\"),\n      space=\"Lab\") +\n  scale_size(\n      guide=guide_legend(title=\"Population, 2020, m\", \n                         title.position=\"top\",\n                         order=2),\n      breaks=c(1000000, 10000000, 20000000),\n      labels=c(\"1\", \"10\", \"20\"),\n      range=c(0.04, 6))\np3\n\n\n\nTheme\nDespite there being a special ‘The Economist’ theme, a completely empty theme (without the default background and axis elements) is what we want. Hence we use theme_void(). Under the theme() function, we first specify the (previously loaded) font most closely resembling the one used in the original map. Concerning title, subtitle and caption, we specify their size, as well as their vertical (vjust) and horizontal justification (hjust). Also using the helping function element_text(), we instruct that the title be bold and the caption have the color “gray”. We then set the position, direction and justification of the legend so that it is horizontal and gets centered to the north of China (approximately where Mongolia would be). We then specify that both legends be left-justified and set the font size for both the title and the text inside the legend (as well as the face in the case of the legend title). Finally, we customize the margins around the legend area and set the key width to 8mm, the key height to 2.5mm and the spacing between keys in the size legend to 0.1mm.\n\n\np4 <- p3 +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=22, vjust=-8, hjust=0.05), \n        plot.subtitle=element_text(size=18, vjust=-10, hjust=0.058),\n        plot.caption=element_text(color = \"gray\", size = 17, hjust = 0.05),\n        legend.position=c(0.73, 0.96),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.text=element_text(size=14),\n        legend.margin=margin(1, 1, 1, 1),\n        legend.key.width=unit(8, \"mm\"),\n        legend.key.height=unit(2.5, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'))\np4\n\n\n\nAnnotations\nThe last step to replicate the original map is the annotations, for which we use the annotate() function. While it may appear to be a caption, the text “1=best” is actually inside the plot and hence is introduced as an annotation. For this and the rest of annotations, we specify the type, the coordinates (x, y), the label, the size and the family (as well as the hjust, vjust, fontface and color for some).\nFor the textbox in the lower left corner in the original chart, we create a separate annotation for the title in order to be able to set its fontface to bold and assign it a different color. Further, we separate each of the five cities into different annotations as well because grouping them together under the same one led to there being too large of a vertical space between each of the five lines.\nFor the individual annotations of the eight highest ranked cities on their locations on the map, we simply use the coordinates for each city and adjust them to be able to see which point corresponds to each label. We also added separate annotations with the lines for five cities: Dongguan, Guangzhou, Suzhou, Jiaxing and Hangzhou (type= “segment”). These lines make identifying which label corresponds to each point easier when cities are clustered together.\n\n\np5 <- p4 + \n  annotate(\"text\", x=67, y=51.5, label=\"1=best\", \n           size=5.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=30, label=\"Highest ranked\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\",\n           fontface=\"bold\", color=\"blue4\") +\n  annotate(\"text\", x=65, y=28, label=\"1  Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=26, label=\"2  Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=24, label=\"3  Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=22, label=\"4  Suzhou\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=20, label=\"5  Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=26, label=\"Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=21, label=\"Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=33, label=\"Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114, y=29, label=\"Suzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=102, y=23, label=\"Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=41,label=\"Beijing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=123, y=29, label=\"Jiaxing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=110, y=26, label=\"Dongguan\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=113, y=25.5, \n           xend=113, yend=24) +\n  annotate(\"segment\", x=110, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=117, y=30, \n           xend=120, yend=31.5) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=122, y=27, \n           xend=120, yend=30)\np5\n\n\n\nEvaluation and potential enhancements\nThis section starts with a brief discussion of the positive and negative qualities of both the original chart and its replication. First, there are several limitations with our reproduction of the map. First, we were not able to reproduce the curved segments joining Hangzhou and Suzhou with their respective points or bubbles as the chart did not support geom_curve(). We were also unable to imitate the appearance of the fill legend exactly as the one in the original map contains spaces between the different boxes or ranges of scores.\nNext, an evaluation of the strengths and weaknesses of the original map is also necessary in order to suggest minor improvements.\nOverall, the original map is an effective visualization. The title and subtitle are concise and informative of its purpose and object, i.e. showing how, because of urbanization (“March of the cities”), cities of varying populations on the coast of China have different levels of growth potential as measured by a comprehensive score. The underlying map, which does not encode any information, does not distract from the information being shown as it is given a light color. Moreover, the legends are clear. This is especially important in the case of the size legend, which could be problematic since people perceive areas rather than radii as visual features in circles. In this case, the area of the circle seems to be proportional to population and so it correctly provides a reference point for readers to estimate the population of individual cities. The ‘expressiveness’ criterion is also met, as ordered data (“Ranking”) appears ordered by means of the hue scale. Finally, the annotations help readers focus on a small number of cities (eight for on-the-map annotations and five for the annotation on the bottom left corner), which facilitates the understanding of which cities have highest growth potential as well as of their characteristics (namely population and location).\nTherefore, the mapping of data into visual features communicates (and thus helps us understand) the “story” the author wants to tell in a clear, precise, efficient and truthful way.\nHowever, there may be some areas of potential improvement. The chart below includes several changes so as to enhance the ease of decoding visual information.\n\n\np <- ggplot() +\n  geom_polygon(data=china, \n               aes(x=Longitude, y=Latitude, group=Grouping),\n               fill=\"cornsilk3\",\n               alpha=0.3) +   \n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping), \n            color=\"white\", \n            size=0.2) +\n  coord_map(xlim=c(100, 155), ylim=c(20, 50)) +\n  geom_point(data=fulloutputclean,\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking),\n             shape=21, color=\"black\") +       \n  labs(title=\"March of the cities\",\n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Source: EIU\") +\n  scale_fill_stepsn(\n       guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE,\n                             show.limits=TRUE,\n                             ticks.colour=\"black\",\n                             ticks.linewidth=1,\n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1), \n       colors=c(\"#00008b\", \"#6495ed\", \"#87cefa\", \"#e0ffff\"),\n       breaks=c(1, 30, 60, 90, 106),\n       space=\"Lab\") +\n  scale_size(\n       guide=guide_legend(title=\"Population, 2020, m\",\n                          title.position=\"top\",\n                          order=2), \n       breaks=c(1000000, 10000000, 20000000), \n       labels=c(\"1\", \"10\", \"20\"),\n       range=c(0.04, 6)) +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=20, \n                                vjust=-14, hjust=0), \n        plot.subtitle=element_text(size=13, \n                                   vjust=-21, hjust=0),\n        plot.caption=element_text(color=\"gray\", size=14, \n                                  hjust=0),\n        legend.position=c(1.01, 1.01),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.box.background=element_rect(fill=\"white\"),\n        legend.margin=margin(5, 15, 5, 10),\n        legend.key.width=unit(12, \"mm\"),\n        legend.key.height=unit(3, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'),\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.title.align=0,\n        legend.text=element_text(size=14)) +\n  annotate(\"text\", x=99, y=47.5, label=\"1=best\",\n           size=4.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=121, y=28, label=\"(1) Hangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=115, y=21.5, label=\"(2) Shenzhen\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=32, label=\"(3) Shanghai\",\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114.5, y=28, label=\"(4) Suzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=103, y=23, label=\"(5) Guangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=110.5, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=117.5, y=29, \n           xend=120, yend=31.5) +\n  geom_vline(xintercept=112, linetype=\"dashed\") \np\n\n\n\nAs suggested by the famous author in the field of visualization Edward Tufte, we should seek to maximize the data-ink ratio when displaying data. To that end, we should ask ourselves whether all elements (“ink”) in the chart are necessary to convey our message. Applying this notion to our map, we set limits for the coordinates through the arguments xlim and ylim inside the coord_map() function. This way, as seen in the map above, we “zoom in” to show the relevant data and remove the area west of meridian 100°. If we did this, we would only lose one observation (i.e. one city) and so it may be worth exploring this alternative. Since we have less “unused” space, we also set the legend background fill to “white” in order to establish a clear contrast between the legend and the map.\nMoreover, some changes to the fill legend may increase the ease of decoding visual information on ranking. In order to enhance discriminability on this scale, we reduce the number of categories from six to four. This way, it is easier for readers to figure out the order of cities according to their ranking and relate their scores to location and population without having to distinguish between too many values.\nAdditionally, despite being a small detail, the choice of the color palette may not be the most appropriate to depict this ordering. There does not seem to be an obvious reason for why stronger colors are assigned to the extremes in the ranking spectrum (i.e. highest- and lowest-ranked cities). Allocating different levels of saturation or lightness of the same hue could be an alternative way of visually conveying the ordering of cities according to growth potential. In the code above, we simply replace the colors for the original ‘40-60’ and ‘60-80’ categories with two lighter shades of blue under the scale_fill_stepsn()function.\nFurthermore, the fact that eight cities are annotated on the map and only five are included in the bottom left textbox is not too easy to realize at first and both annotations seem to include redundant information. By removing the textbox and adding the rank numbers directly to the cities annotated on the map, we simplify the visualization without removing essential information.\nFinally, in order to emphasize the idea that cities with the highest growth potential are on the coast, we might want to insert a vertical line (we use geom_vline()) at the (arbitrary) level of longitude 112°. This way we can see that among the 10 cities with the highest growth potential, only Chengdu (i.e. the “dark blue” bubble farthest west) is to the west of this longitude.\nAlternative visualization\nThe final section of this post proposes an alternative visualization to represent the relationship between the population, location and growth potential of cities in China. One possibility is the scatterplot shown below. We plot the ranking on the x-axis and population on the y-axis. We also use the geom_point() function just like in the original map.\nWe change the title and subtitle of the plot. We also add an informative caption and change the axis labels so as to make it even easier to understand what each variable represents and the message being conveyed. We alter the theme to theme_light() so as to increase the contrast between the background and the text and data points.\nThis time, by using the scale_y_continuous() function, we change the default scientific notation so that the axis itself shows population in ‘M’ (million). We then set the specifics for the font, title, subtitle, caption, axis title and axis text under the theme() function.\n\n\np <- ggplot(fulloutputclean) +\n  aes(x=Ranking, y=Population) +\n  geom_point() +\n  labs(title=\"Urbanization and economic growth in China\",      \n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Coastal cities have highest growth potential\",\n       x=\"City Growth Ranking\",\n       y=\"City Population\") +\n  scale_y_continuous(labels=scales::label_number_si()) +\n  theme_light() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=26),                                                            \n        plot.subtitle=element_text(size=20),\n        plot.caption=element_text(size=20, hjust=0),\n        axis.title=element_text(size=15),\n        axis.text=element_text(size=13))\np\n\n\n\nIn general, we can see that higher growth potential (lower value for the variable “City Growth Ranking”) tends to be associated with a larger population, which was perhaps harder to see on the original map. However, we still need to include information about the location (coordinates) of cities. Within the location variable, it seems that longitude is the most important factor: cities closer to the coastline (i.e. farther east, or higher values of x) appear to have higher growth potential. These high-ranking cities seem to be distributed more or less evenly from north to south, hence we disregard the latitude information for simplicity. Therefore, we could encode longitude through the color of the points by highlighting in blue those points representing cities that are located east of the (again, arbitrarily chosen) 112° meridian. We also add a text label (on top of a white rectangle constructed with geom_rect()) to indicate that blue dots represent cities farther east in China.\n\n\nannotation <- dplyr::filter(fulloutputclean, Longitude>112)\np <- p + \n    geom_point(data=annotation, color=\"#6495ED\") +\n    geom_rect(aes(xmin=79, xmax=130, ymin=15000000, ymax=16600000),\n              fill=\"white\",\n              color = \"#6495ED\") +\n    geom_text(aes(x=80, y=15800000, \n                  label=\"Cities to the east of the 112th meridian\"),\n              size=6, hjust=0, vjust=0, color = \"#6495ED\")\np\n\n\n\nFinally, to highlight the top 5 cities from the original map, We construct another annotation and insert it as an argument in the geom_text() function. We adjust the size and horizontal justification of the labels, and make them bold.\n\n\nannotation2 <- dplyr::filter(fulloutputclean, Ranking<=5)\np <- p +\n  geom_text(aes(label=City),\n            annotation2,\n            hjust=-0.2, nudge_x=0.1, size=6,\n            family = \"IBM Plex Sans\",\n            fontface=\"bold\") \np\n\n\n\nWe can see that highly-ranked cities are all near the coast (i.e. all highlighted in blue because they are east of the meridian 112°), but there is a rather wide range of population sizes among the top 5. For instance, both Shanghai and Suzhou have very high growth potential. Yet, the former has more than 3.5 times the population of the latter. This is because many variables are included in the calculation of scores. For instance, Hangzhou tops the ranking due to its nature as a big tech hub. While government regulation targeting tech firms may hamper its medium- and long-term growth, other factors such as its fiscal position, economic diversity or metropolitan development jointly yield a high growth potential for the city.\nAll in all, as the caption suggests, it seems that location (whose effect is hard to separate from other historical, economic and environmental factors) is more important than current population as a predictor of future economic growth.\n\n\n\n",
    "preview": "projects/2022/100489635/economist.png",
    "last_modified": "2023-01-06T00:56:10+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1118
  },
  {
    "path": "projects/gapminder/",
    "title": "Gapminder's World Health Chart",
    "description": "This tutorial reproduces one of the most popular data visualizations ever\nand serves as an example project for this course",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-09-09",
    "categories": [
      "gapminder"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLegend\n\nFinal result\nSingle year\nMultiple years, static\nMultiple years, dynamic\n\n\nHans Rosling was a Swedish professor of International Health at the Karolinska Institute,\nand co-founder of the Gapminder Foundation,\nwhich developed the Trendalyzer software for animated data visualization.\nHis famous 2006 TED Talk,\nDebunking myths about the “third world”,\nhas inspired millions over the world thanks to his celebrated bubble chart\ndepicting the relationship between life expectancy and income.\nGapminder’s World Health Chart. Figure from gapminder.org.The goal of this tutorial is to replicate this famous data visualization step by step.\nGetting the data\nThe data consists of yearly observations of life expectancy values and GDP per capita for a number of countries in the world.\nThis is a very popular dataset.\nWe could download the data directly from the Gapminder homepage,\nbut we will use instead the gapminder package,\nwhich contains ready-to-use data for 142 countries from 1952 to 2007.\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\n\nLet’s take a glimpse of the data:\n\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afgh…\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, As…\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 19…\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nThese are all the variables we need in a tidy format,\nincluding population counts, which will serve to define the size of the bubbles.\nAs we can see, the original visualization includes Oceania into Asia,\nso let’s do the same for our exercise:\n\n\ngapminder <- gapminder %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\"))\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Europe  :360   Median :1980   Median :60.71  \n Angola     :  12   Asia    :420   Mean   :1980   Mean   :59.47  \n Argentina  :  12                  3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nBuilding the chart\nCoordinates and axes\nWe will work with a single year for now.\nThe base panel consists of simple Cartesian coordinates,\nand depicts life expectancy vs. GDP per capita,\nalthough the x label says the more understandable term “Income”.\n\n\np <- ggplot(filter(gapminder, year == 2007)) +\n  aes(gdpPercap, lifeExp) +\n  ylab(\"Life expectancy\") + xlab(\"Income\")\np\n\n\n\nBoth axes have fixed limits across the whole animation.\nAnother thing to note about the axes is that income is in logarithmic scale with very specific breaks.\nAlso, numbers above 10 thousand are labeled as “10k”.\nThe function scales::label_number comes in handy for this.\nNote that we make some space for annotations on top of the chart\nby setting the maximum limit of the y axis to 95.\n\n\nbreaks <- 500*2^c(0:8)\nklabel <- scales::label_number(suffix=\"k\", scale=1e-3)\nlabels <- c(breaks[1:5], klabel(breaks[-(1:5)]))\n\np <- p + scale_y_continuous(limits=c(10, 95), breaks=seq(10, 90, 10)) +\n  scale_x_log10(limits=range(breaks), breaks=breaks, labels=labels)\np\n\n\n\nTheme\nNote that the theme is very similar to theme_classic, but shows the major grid.\nWe also instruct the theme to remove the legend,\nbecause we will add a custom one later on.\n\n\np <- p + theme_classic() +\n  theme(panel.grid.major=element_line(), legend.position=\"none\")\np\n\n\n\nAdditionally, we could continue to tinker with fonts and other parameters.\nAnnotations\nThe base panel depicts three annotations:\nA big background number indicating the year in the middle.\nFour income levels on the top part, whose breaks seem to be 3k, 8k and 24k.\nThe axes’ units on the top left and bottom right corners.\nFor the background number, we could use annotate with a fixed label,\nbut we will use geom_text instead, even if we overplot it many times,\nso that the year is read from the data.\n\n\np <- p + geom_text(aes(8000, 50, label=year), size=65, color=\"lightgray\")\np\n\n\n\nNext, we add the income levels.\nAdditionally, we will take the liberty of adding vertical lines to clearly demarcate the breaks.\n\n\ntlevel <- c(1300, 5000, 14000, 40000)\nblevel <- c(3000, 8000, 24000)\nilevel <- c(\"INCOME LEVEL 1\", \"LEVEL 2\", \"LEVEL 3\", \"LEVEL 4\")\n\np <- p + geom_vline(xintercept=blevel, color=\"darkgray\") +\n  annotate(\"text\", x=tlevel, y=95, color=\"darkgray\", vjust=0, size=3, label=ilevel) +\n  annotate(\"text\", x=blevel, y=95, color=\"darkgray\", vjust=0, size=5, label=\"◆\")\np\n\n\n\nFinally, let’s add the units to the axes.\n\n\np <- p +\n  annotate(\"text\", x=128000, y=10, hjust=0.95, vjust=1, size=3,\n           label=\"per person (GDP/capita, PPP$ inflation-adjusted\") +\n  annotate(\"text\", x=500, y=95, hjust=0.5, vjust=-1.5, size=3, angle=90, label=\"years\")\np\n\n\n\nData\nThe chart is a type of scatterplot, with one point per country, and colored by continent.\nThe novelty here is that every dot is scaled up to represent the population size.\nAlso, we will add some transparency to the points.\n\n\np <- p + geom_point(aes(color=continent, size=pop), alpha=0.7)\np\n\n\n\nWe are close, but a couple of adjustments are required.\nLet’s add a black line around the points (see shape 21),\nand adjust the range of the bubbles a bit.\n\n\np <- p + geom_point(aes(size=pop), color=\"#333333\", shape=21) +\n  scale_size_area(max_size=25)\np\n\n\n\nFinally, let’s replicate the same color scale.\nWe need to provide them in the same order as the factor levels:\n\n\nlevels(gapminder$continent)\n\n[1] \"Africa\"   \"Americas\" \"Europe\"   \"Asia\"    \n\nTherefore, from the web, page we obtain:\nAfrica: Blue rgb(0, 213, 233) -> #00d5e9\nAmericas: Green rgb(127, 235, 0) -> #7feb00\nEurope: Yellow rgb(255, 231, 0) -> #ffe700\nAsia: Red rgb(255, 88, 114) -> #ff5872\n\n\nccolors <- c(\"#00d5e9\", \"#7feb00\", \"#ffe700\", \"#ff5872\")\np <- p + scale_color_manual(values=ccolors)\np\n\n\n\nLegend\nThis chart has an interesting legend:\nit takes advantage from the fact that continents are easily recognizable to use a map as a legend.\nLet’s replicate it separately using data from ggplot2::map_data.\n\n\nworld <- map_data(\"world\")\nglimpse(world)\n\nRows: 99,338\nColumns: 6\n$ long      <dbl> -69.89912, -69.89571, -69.94219, -70.00415, -70.06…\n$ lat       <dbl> 12.45200, 12.42300, 12.43853, 12.50049, 12.54697, …\n$ group     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,…\n$ order     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16,…\n$ region    <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Arub…\n$ subregion <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\nThis data needs to be tweaked a little bit. We need to:\nFilter out the Antarctica region.\nAdd a new column continent with the help of the countrycode package.\nInclude Oceania into Asia.\nDrop any missing values for continent.\n\n\nworld <- world %>%\n  filter(region != \"Antarctica\") %>%\n  mutate(continent = countrycode::countrycode(\n    sourcevar=region, origin=\"country.name\", destination=\"continent\")) %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\")) %>%\n  drop_na(continent)\n\n\nNow, let’s create the map:\n\n\nlegend <- ggplot(world) +\n  aes(long, lat, group=group, map_id=region, fill=continent) +\n  geom_map(map=world) +\n  scale_fill_manual(values=ccolors) +\n  theme_void() + theme(legend.position=\"none\")\nlegend\n\n\n\nFinal result\nSingle year\nIn summary, so far we have\nBuild steps:\nset coordinates and axes, with custom breaks;\nset an appropriate theme and prevent the default legend from appearing;\nadded several annotations, including year, income levels and axis units;\nadded the data points and made several adjustments, including size and color;\ncreated a custom legend based on a simple colored world map.\nThere are several ways we can merge the main plot and the legend.\nIn this case, let’s add it as an inset with the custom annotation function.\nNote that, in contrast to the regular annotation function,\nthis one doesn’t seem to support logarithmic scales very well.\nAs a result, the user needs to provide the transformed values directly.\n\n\np <- p + annotation_custom(\n  ggplotGrob(legend), xmin=log10(16000), ymin=10, ymax=40)\np\n\n\n\nFinally, we can improve this static single-year visualization by adding some context,\ni.e. a title, a subtitle and a caption.\n\n\np + labs(\n  title = \"World Life Expectancy vs. Income in 2007\",\n  subtitle = paste(\n    \"African countries are still lagging behind in terms of general life\",\n    \"expectancy.\\nEuropean and American countries are the healthiest\",\n    \"and richest countries in the world.\"),\n  caption = \"Source: gapminder.org\"\n)\n\n\n\nMultiple years, static\nSo far, we covered the case for a single year.\nHow could we show the evolution, which is the point in this dataset?\nOf course we can define facets to plot all the years.\nIn the following chart,\ngginnards::delete_layers is used to remove the background year;\nwe switch to the whole dataset using the %+% operator;\ndata is faceted in two rows;\naxis labels are slightly rotated to make space for them.\nNote also that we need to manually scale down a bit the range of the bubbles\nto preserve more or less the previous aspect ratio.\n\n\ngginnards::delete_layers(p, match_type=\"GeomText\") %+% gapminder +\n  facet_wrap(\"year\", nrow=2) +\n  scale_size_area(max_size=7) +\n  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))\n\n\n\nMultiple years, dynamic\nAnd we can of course animate it!\nWe can easily convert any ggplot2 chart to plotly using plotly::ggplotly,\nwhich produces interactive web-based charts.\nFurthermore, if we set the frame aesthetic, it is automatically detected,\nand an animation is added based on the corresponding variable.\n\n\nplotly::ggplotly(p %+% gapminder + aes(frame=year))\n\n\n\n\n\n\n",
    "preview": "projects/gapminder/gapminder_files/figure-html5/titled-1.png",
    "last_modified": "2022-10-07T12:58:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  }
]
