[
  {
    "path": "projects/2022/100489635/",
    "title": "GDP Forecasts for China's Cities by 'The Economist': Coastal Areas Have the Highest Growth Potential",
    "description": "A layer-by-layer construction of a map of China containing information on forecasted GDP growth and population for over 100 cities.",
    "author": [
      {
        "name": "Elena Yustres",
        "url": {}
      }
    ],
    "date": "2023-01-01",
    "categories": [
      "2022"
    ],
    "contents": "\r\n\r\nContents\r\nThe original chart\r\nObtaining and processing the data\r\nBuilding the plot\r\n\r\nEvaluation and potential enhancements\r\nAlternative visualization\r\n\r\nAs both a cause and consequence of China’s rapid economic growth, the proportion of the country’s population living in cities has soared from 20% in 1980 to 60% in 2020. However, China’s Zero-Covid policy has stilted growth significantly. The “China Emerging City Rankings, 2022” Report, launched by the Economist Intelligence Unit (EIU), assesses the growth potential of 108 cities predicted to have a population of more than 1 million by 2025. Scores are calculated using historical data and forecasts on variables including demography, the local economy or the environment.\r\nThe Economist’s “March of the cities” map. Figure from economist.com.This post will seek to replicate this map, propose incremental enhancements and suggest an alternative visualization that depicts the relationship between growth potential, population and location (or distance to the coast) taking cities as our units of analysis.\r\nThe original chart\r\nObtaining and processing the data\r\nFirst, several libraries are required for processing and plotting the data, including the customization of fonts for our plot:\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\nlibrary(showtext)\r\nlibrary(maps)\r\nlibrary(maptools)\r\nlibrary(rgdal)  \r\nlibrary(svglite)\r\nlibrary(plyr)\r\n\r\nsysfonts::font_add_google(\"IBM Plex Sans\", family=\"IBM Plex Sans\")\r\nshowtext::showtext_auto()\r\n\r\n\r\nDiving into data collection, we obtained the data on the ranking and population of our units of analysis from the EIU (‘Global Geo-Political Trends and Economics’ section) after contacting their office in Asia by email.\r\n\r\n\r\nranking <- read_csv(\"ranking.csv\")\r\npopulation <- read_csv(\"population.csv\")\r\n\r\n\r\nOnce we have loaded both sets of data, the summaries below show that the ‘ranking’ dataset contains data on scores for 106 cities (ordered from highest, i.e. Ranking = 1, to lowest) while the ‘population’ dataset includes population data for 397 cities in China.\r\n\r\n\r\nglimpse(ranking)\r\n\r\nRows: 106\r\nColumns: 2\r\n$ City    <chr> \"Hangzhou\", \"Shenzhen\", \"Shanghai\", \"Suzhou\", \"Guang…\r\n$ Ranking <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\r\n\r\nglimpse(population)\r\n\r\nRows: 397\r\nColumns: 2\r\n$ City       <chr> \"Shanghai\", \"Beijing\", \"Shenzhen\", \"Guangzhou\", \"…\r\n$ Population <dbl> 22315474, 18960744, 17494398, 16096724, 13568357,…\r\n\r\nIn order to get both attributes (“Ranking” and “Population”) on the same dataset, we used a left_join to merge both datasets by the unit of analysis (“City”). This produced a dataset with both variables for the 106 cities provided by the EIU. Please note that, while the original map in the article by ‘The Economist’ includes 108 cities, the EIU only provided us with data on 106.\r\n\r\n\r\noutput <- ranking %>% left_join(population, by=\"City\")\r\n\r\n\r\nIn order to obtain data on the “longitude” and “latitude” of each city, we used the world.cities database. This database includes data on these and other variables for over 40,000 cities in the world. I then filtered the cities in China and selected (as well as renamed) the variables of interest to later on construct my final database.\r\n\r\n\r\ndata <- world.cities %>%\r\n  filter(country.etc==\"China\") %>%\r\n  dplyr::select(name, lat, long) %>%\r\n  dplyr::rename(\"City\"=\"name\", \r\n         \"Latitude\"=\"lat\", \r\n         \"Longitude\"=\"long\") \r\n\r\n\r\nWe then merged the location dataset (‘data’) and the dataset with information on ranking and location (‘output’).\r\nThe data also required some cleaning and adjustment. First, there were two cities with the same name (i.e. Suzhou) in the EIU ranking. Since they are located in different provinces, we used population data to cross check which city corresponded to which score provided by the EIU and renamed one of them to establish the difference. Second, there were several other cities in the ‘data’ dataset with the same name as cities in the ‘output’ one, which led to there being more than one row for each unit of analysis in the ‘fulloutput’ table. We removed the appropriate rows, as well as the rows for which latitude and longitude data were not available (i.e. NAs for those variables).\r\n\r\n\r\nfulloutput <- output %>% left_join(data, by=\"City\")\r\nfulloutputclean <- fulloutput[-c(5, 23, 49, 51, 70, 81, 104, 113),]\r\nfulloutputclean <- fulloutputclean[!is.na(fulloutputclean$Latitude) \r\n                                   & !is.na(fulloutputclean$Longitude), ]\r\nhead(fulloutputclean, 5)\r\n\r\n# A tibble: 5 × 5\r\n  City      Ranking Population Latitude Longitude\r\n  <chr>       <dbl>      <dbl>    <dbl>     <dbl>\r\n1 Hangzhou        1    9236032     30.2      120.\r\n2 Shenzhen        2   17494398     22.5      114.\r\n3 Shanghai        3   22315474     31.2      121.\r\n4 Suzhou          4    6715559     31.3      121.\r\n5 Guangzhou       5   16096724     23.1      113.\r\n\r\nThe final step in data processing was obtaining the data to plot the underlying map of China. We used the ggplot2-china-map repository. This provides us with the necessary data to be able to draw the provinces in China. We used the readOGR function to read the ‘shapefile’, cleaned the data and fortified into a dataframe. We then instructed that the islands in the South China Sea not be drawn by selecting only observations with “AREA” above 0.005. Finally, again, we renamed variables accordingly.\r\n\r\n\r\nchina <- readOGR(dsn=(\"./china_shapefile/\"), layer=\"bou2_4p\")\r\n\r\nOGR data source with driver: ESRI Shapefile \r\nSource: \"C:\\Users\\elena\\OneDrive\\Desktop\\MUCSS\\V. Data Visualization\\dataviz\\_projects\\2022\\100489635\\china_shapefile\", layer: \"bou2_4p\"\r\nwith 925 features\r\nIt has 7 fields\r\nInteger64 fields read as strings:  BOU2_4M_ BOU2_4M_ID \r\n\r\nchina@data$id<-rownames(china@data)\r\nchina.points<-fortify(china, region=\"id\")\r\nchina.df<-join(china.points, china@data, by=\"id\")\r\n\r\nchina<-subset(china.df, AREA>0.005) %>% \r\n  dplyr::rename(\"Latitude\"=\"lat\", \r\n         \"Longitude\"=\"long\",\r\n         \"Grouping\"=\"group\")\r\n\r\n\r\nBuilding the plot\r\nCoordinates of the map and data points\r\nUsing the data loaded in ‘China’ in the last step, we use geom_polygon() to draw the underlying map. The aes argument maps the longitude and latitude columns to the x and y coordinates, respectively. This function is also used to specify the fill and the transparency (alpha) level of the map.\r\nWe then use geom_path to set the line demarcating the province limits. After indicating the use of the same variables in the ‘china’ dataset as for geom_polygon(), we set the color and size of the border. Further, coord_map() sets the coordinate system for the map by projecting the defined portion of the Earth onto a flat 2D plane.\r\n\r\n\r\np <- ggplot() +\r\n  geom_polygon(data=china,\r\n            aes(x=Longitude, y=Latitude, group=Grouping),\r\n            fill=\"cornsilk3\",\r\n            alpha=0.3) +\r\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping),\r\n            color=\"white\",\r\n            size=0.2) +\r\n  coord_map() \r\np\r\n\r\n\r\n\r\nThen we add the data points at the specific locations of the 104 cities (defined by their latitude and longitude) with geom_point(). Thus, on top of the map, we are plotting a scatterplot using data from ‘fulloutputclean’ where each point represents one city. The size of the point (more specifically, its area) represents its population and its fill depicts the relative position of a given city vis-à-vis other cities in the EIU ranking. We then set a black line around the point (shape=21) while specifying the color and thickness (stroke) of the border.\r\nA title, subtitle and caption are added to replicate the original chart using the labs function.\r\n\r\n\r\np2 <- p + \r\n  geom_point(data=fulloutputclean, \r\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking), \r\n             shape=21,\r\n             color=\"black\",\r\n             stroke=0.03) +\r\n  labs(title=\"March of the cities\",                                                                   \r\n       subtitle=\"China, emerging city ranking, 2022\",\r\n       caption=\"Source: EIU\") \r\np2\r\n\r\n\r\n\r\nScales\r\nNext, the scale_fill_stepsn() and scale_size() functions are used to customize the appearance of the legends for the color and size aesthetics, respectively.\r\nFor the color legend (or rather, fill legend, given our points have borders defined by the color argument as introduced in the previous section), we first specify its title and title position. We then specify the details relating to the ticks and limits between the different boxes of the legend. We set the values for the 7 breaks in the variable ‘Ranking’ so as to create six categories of rank scores. By means of a drawing tool using the hexadecimal system, we set the colors for each of the six categories. Note that higher-ranked cities are represented with shades of blue and lower-ranked cities are represented with shades of orange or brown, whereby darker shades of both colors represent the ends of the spectrum.\r\nFor the size legend, we do the same as with the fill legend regarding the title and the breaks, although this time we are specifying 3 breaks. In this case we are also setting the labels for those breaks. This is because, by default, R uses scientific notation for population but the legend title already states that values are provided in millions. Finally, we set the range of the size of the bubbles from 0.04 to 6 mm.\r\n\r\n\r\np3 <- p2 + \r\n  scale_fill_stepsn(\r\n      guide=guide_colorsteps(title=\"Rank\",\r\n                             title.position=\"top\",\r\n                             ticks=TRUE, \r\n                             show.limits=TRUE, \r\n                             ticks.colour= \"black\",\r\n                             ticks.linewidth = 1, \r\n                             draw.llim=TRUE,\r\n                             draw.ulim=TRUE),\r\n      breaks=c(1, 20, 40, 60, 80, 100, 106), \r\n      colors=c(\"#1c2c74\", \"#5483b3\", \"#99ccff\", \"#fcdb9b\", \"#fcbc04\", \"#ac6404\"),\r\n      space=\"Lab\") +\r\n  scale_size(\r\n      guide=guide_legend(title=\"Population, 2020, m\", \r\n                         title.position=\"top\"),\r\n      breaks=c(1000000, 10000000, 20000000),\r\n      labels=c(\"1\", \"10\", \"20\"),\r\n      range=c(0.04, 6))\r\np3\r\n\r\n\r\n\r\nTheme\r\nDespite there being a special ‘The Economist’ theme, a completely empty theme (without the default background and axis elements) is what we want. Hence we use theme_void(). Under the theme() function, we first specify the (previously loaded) font most closely resembling the one used in the original map. Concerning title, subtitle and caption, we specify their size, as well as their vertical (vjust) and horizontal justification (hjust). Also using the helping function element_text(), we instruct that the title be bold and the caption have the color “gray”. We then set the position, direction and justification of the legend so that it is horizontal and gets centered to the north of China (approximately where Mongolia would be). We then specify that both legends be left-justified and set the font size for both the title and the text inside the legend (as well as the face in the case of the legend title). Finally, we set customized margins around the legend area and set the key width to 8mm, the key height to 2.5mm and the spacing between keys in the size legend to 0.1mm.\r\n\r\n\r\np4 <- p3 +\r\n  theme_void() +\r\n  theme(text=element_text(family=\"IBM Plex Sans\"),\r\n        plot.title=element_text(face=\"bold\", size=22, vjust=-8, hjust=0.05), \r\n        plot.subtitle=element_text(size=18, vjust=-10, hjust=0.058),\r\n        plot.caption=element_text(color = \"gray\", size = 17, hjust = 0.05),\r\n        legend.position=c(0.73, 0.96),\r\n        legend.direction=\"horizontal\",\r\n        legend.justification=c(\"right\", \"top\"),\r\n        legend.box.just=\"left\",\r\n        legend.title=element_text(face=\"bold\", size=14),\r\n        legend.text=element_text(size=14),\r\n        legend.margin=margin(1, 1, 1, 1),\r\n        legend.key.width=unit(8, \"mm\"),\r\n        legend.key.height=unit(2.5, \"mm\"),\r\n        legend.spacing.x=unit(0.1, 'mm'))\r\np4\r\n\r\n\r\n\r\nAnnotations\r\nThe last step to replicate the original map is the annotations, for which we use the annotate() function. While it may appear to be a caption, the text “1=best” is actually inside the plot and hence is introduced as an annotation. For this and the rest of annotations, we specify the type (“text”), set the coordinates (x, y), the label, the size and the family (as well as the hjust, vjust, fontface and color for some).\r\nFor the textbox in the lower left corner in the original graph, we create a separate annotation for the title in order to be able to set it in bold and with a different color. Further, we separate each of the five cities into different annotations as well because grouping them together under the same one led to there being too large of a vertical space between each of the give lines.\r\nFor the individual annotations of the eight highest ranked cities on their locations on the map, we simply use the coordinates for each city and adjust them to be able to see which point corresponds to each label. I also added separate annotations with the lines for five cities: Dongguan, Guangzhou, Suzhou, Jiaxing and Hangzhou (type= “segment”). These lines make identifying which label corresponds to each point easier when cities are clustered together.\r\n\r\n\r\np5 <- p4 + \r\n  annotate(\"text\", x=67, y=51.5, label=\"1=best\", \r\n           size=5.5, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=65, y=30, label=\"Highest ranked\", \r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\",\r\n           fontface=\"bold\", color=\"blue4\") +\r\n  annotate(\"text\", x=65, y=28, label=\"1  Hangzhou\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=65, y=26, label=\"2  Shenzhen\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=65, y=24, label=\"3  Shanghai\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=65, y=22, label=\"4  Suzhou\", \r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=65, y=20, label=\"5  Guangzhou\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=122, y=26, label=\"Hangzhou\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=116, y=21, label=\"Shenzhen\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=122, y=33, label=\"Shanghai\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=114, y=29, label=\"Suzhou\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=102, y=23, label=\"Guangzhou\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=116, y=41,label=\"Beijing\", \r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=123, y=29, label=\"Jiaxing\", \r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=110, y=26, label=\"Dongguan\",\r\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"segment\", x=113, y=25.5, \r\n           xend=113, yend=24) +\r\n  annotate(\"segment\", x=110, y=23, \r\n           xend=112.5, yend=23) +\r\n  annotate(\"segment\", x=117, y=30, \r\n           xend=120, yend=31.5) +\r\n  annotate(\"segment\", x=123, y=29, \r\n           xend=121, yend=31) +\r\n  annotate(\"segment\", x=122, y=27, \r\n           xend=120, yend=30)\r\np5\r\n\r\n\r\n\r\nEvaluation and potential enhancements\r\nThis section starts with a brief discussion of the positive and negative qualities of both the original chart and its replication. First, there are several limitations with our reproduction of the map. First, we were not able to reproduce the curved segments joining Hangzhou and Suzhou with their respective points or bubbles as the chart did not support geom_curve(). We were also unable to imitate the appearance of the fill legend exactly as the one in the original map contains spaces between the different boxes or ranges of scores.\r\nNext, an evaluation of the strengths and weaknesses of the original map is also necessary in order to suggest minor improvements.\r\nOverall, the original map is an effective visualization. The title and subtitle are concise and informative of its purpose and object, i.e. showing how, because of urbanization (“March of the cities”), cities of varying populations on the coast of China have different levels of growth potential as measured by a comprehensive score. The underlying map, which does not encode any information, does not distract from the information being shown as it is given a light color. Moreover, the legends are clear. This is especially important in the case of the size legend, which could be problematic since people perceive areas rather than radii as visual features in circles. In this case, the area of the circle seems to be proportional to population and so it correctly provides a reference point for readers to estimate the population of individual cities. The ‘expressiveness’ criterion is also met, as ordered data (“Ranking”) appears ordered by means of the hue scale. Finally, the annotations help readers focus on a small number of cities (eight for on-the-map annotations and five for the annotation on the bottom left corner), which facilitates the understanding of which cities have highest growth potential as well as of their characteristics (namely population and location).\r\nTherefore, the mapping of data into visual features communicates (and thus helps us understand) the “story” the author wants to tell in a clear, precise, efficient and truthful way.\r\nHowever, there may be some areas of potential improvement. The chart below includes several changes so as to enhance the ease of decoding visual information.\r\n\r\n\r\np <- ggplot() +\r\n  geom_polygon(data=china, \r\n               aes(x=Longitude, y=Latitude, group=Grouping),\r\n               fill=\"cornsilk3\",\r\n               alpha=0.3) +   \r\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping), \r\n            color=\"white\", \r\n            size=0.2) +\r\n  coord_map(xlim=c(100, 155), ylim=c(20, 50)) +\r\n  geom_point(data=fulloutputclean,\r\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking),\r\n             shape=21, color=\"black\") +       \r\n  labs(title=\"March of the cities\",\r\n       subtitle=\"Emerging city ranking, 2022\",\r\n       caption=\"Source: EIU\") +\r\n  scale_fill_stepsn(\r\n       guide=guide_colorsteps(title=\"Rank\",\r\n                             title.position=\"top\",\r\n                             ticks=TRUE,\r\n                             show.limits=TRUE,\r\n                             ticks.colour=\"black\",\r\n                             ticks.linewidth=1,\r\n                             draw.llim=TRUE,\r\n                             draw.ulim=TRUE), \r\n       colors=c(\"#00008b\", \"#6495ed\", \"#87cefa\", \"#e0ffff\"),\r\n       breaks=c(1, 30, 60, 90, 106),\r\n       space=\"Lab\") +\r\n  scale_size(\r\n       guide=guide_legend(title=\"Population, 2020, m\",\r\n                          title.position=\"top\"), \r\n       breaks=c(1000000, 10000000, 20000000), \r\n       labels=c(\"1\", \"10\", \"20\"),\r\n       range=c(0.04, 6)) +\r\n  theme_void() +\r\n  theme(text=element_text(family=\"IBM Plex Sans\"),\r\n        plot.title=element_text(face=\"bold\", size=20, \r\n                                vjust=-14, hjust=0), \r\n        plot.subtitle=element_text(size=13, \r\n                                   vjust=-21, hjust=0),\r\n        plot.caption=element_text(color=\"gray\", size=14, \r\n                                  hjust=0),\r\n        legend.position=c(1.01, 1.01),\r\n        legend.direction=\"horizontal\",\r\n        legend.justification=c(\"right\", \"top\"),\r\n        legend.box.just=\"left\",\r\n        legend.box.background=element_rect(fill=\"white\"),\r\n        legend.margin=margin(5, 15, 5, 10),\r\n        legend.key.width=unit(12, \"mm\"),\r\n        legend.key.height=unit(3, \"mm\"),\r\n        legend.spacing.x=unit(0.1, 'mm'),\r\n        legend.title=element_text(face=\"bold\", size=14),\r\n        legend.title.align=0,\r\n        legend.text=element_text(size=14)) +\r\n  annotate(\"text\", x=99, y=47.5, label=\"1=best\",\r\n           size=4.5, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=121, y=28, label=\"(1) Hangzhou\", \r\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=115, y=21.5, label=\"(2) Shenzhen\", \r\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=122, y=32, label=\"(3) Shanghai\",\r\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=114.5, y=28, label=\"(4) Suzhou\", \r\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"text\", x=103, y=23, label=\"(5) Guangzhou\", \r\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\r\n  annotate(\"segment\", x=110.5, y=23, \r\n           xend=112.5, yend=23) +\r\n  annotate(\"segment\", x=123, y=29, \r\n           xend=121, yend=31) +\r\n  annotate(\"segment\", x=117.5, y=29, \r\n           xend=120, yend=31.5) +\r\n  geom_vline(xintercept=112, linetype=\"dashed\") \r\np\r\n\r\n\r\n\r\nAs suggested by the famous author in the field of visualization Edward Tufte, we should seek to maximize the data-ink ratio when displaying data. To that end, we should ask ourselves whether all elements (“ink”) in the chart are necessary to convey our message. Applying this notion to our map, we set limits for the coordinates through the argument xlim and ylim inside the coord_map() function. This way, as seen in the map above, we “zoom in” to show the relevant data and remove the area west of meridian 110°. If we did this, we would only lose one observation (i.e. one city) and so it may be worth exploring this alternative. Since we have less “unused” space, we also set the legend background fill to “white” in order to establish a clear contrast between the legend and the map.\r\nMoreover, some changes to the fill legend may increase the ease of decoding visual information on ranking. Despite being a small detail, the choice of the color palette may not be the most appropriate to depict the ordering of cities according to their EIU scores. There does not seem to be an obvious reason for why stronger colors are assigned to the extremes in the ranking spectrum (i.e. highest- and lowest-ranked cities). Allocating different levels of saturation or lightness of the same hue could be an alternative way of visually conveying the order of cities according to ranking. In the code above, we simply change the last three colors in the ‘scales’ section for lighter shades of blue. Additionally, in order to enhance discriminability on the fill scale, we reduce the number of categories from six to four. This way it is easier for readers to figure out the order of cities according to their ranking and relate their scores to location and population.\r\nFurthermore, the fact that eight cities are annotated on the map and only five are included in the bottom-left textbox is not too easy to realize at first and both annotations seem to include redundant information. By removing the textbox and adding the rank numbers directly to the cities annotated on the map, we simplify the visualization without removing essential information.\r\nFinally, in order to emphasize the idea that cities with the highest growth potential are on the coast, we might want to insert a vertical line (we use geom_vline()) at the (arbitrary) level of longitude 112°. This way we can see that among the 10 cities with the highest growth potential, only Chengdu is to the west of this longitude.\r\nAlternative visualization\r\nThe final section of this post proposes an alternative visualization to represent the relationship between the population, location and growth potential of cities in China. One possibility is the scatterplot shown below. We plot the ranking on the x-axis and population on the y-axis. We also use the geom_point()function just like in the original map.\r\nWe change the title and subtitle of the plot. We also add an informative caption and change the axis labels so as to make it even easier to understand what each variable represents and the message being conveyed. We alter the theme to theme_light() so as to increase the contrast between the background and the text and data points.\r\nThis time, by using the scale_y_continuous() function, we change the default scientific notation so that the axis itself shows population in ‘M’ (million). We then set the specifics for the font, title, subtitle, caption, axis title and axis text under the theme() function.\r\n\r\n\r\np <- ggplot(fulloutputclean) +\r\n  aes(x=Ranking, y=Population) +\r\n  geom_point() +\r\n  labs(title=\"Urbanization and economic growth in China\",      \r\n       subtitle=\"Emerging city ranking, 2022\",\r\n       caption=\"Coastal cities have highest growth potential\",\r\n       x=\"City Growth Ranking\",\r\n       y=\"City Population\") +\r\n  scale_y_continuous(labels=scales::label_number_si()) +\r\n  theme_light() +\r\n  theme(text=element_text(family=\"IBM Plex Sans\"),\r\n        plot.title=element_text(face=\"bold\", size=26),                                                            \r\n        plot.subtitle=element_text(size=20),\r\n        plot.caption=element_text(size=20, hjust=0),\r\n        axis.title=element_text(size=15),\r\n        axis.text=element_text(size=13))\r\np\r\n\r\n\r\n\r\nIn general, we can see that higher growth potential (lower value for the variable “City Growth Ranking”) tends to be associated with a larger population, which was perhaps harder to see on the original map. However, we still need to include information about the location (coordinates) of cities. Within the location variable, it seems that longitude is the most important factor: cities closer to the coast (i.e. farther east, or higher values of x) appear to have higher growth potential. These high-ranking cities seem to be distributed more or less evenly from North to South, hence we disregard the latitude information for simplicity. Therefore, we could encode longitude through the color of the points by highlighting in blue those points representing cities that are located east of the (again, arbitrarily chosen) 112° meridian. I also add a text label (on top of a white rectangle constructed with geom_rect()) to indicate that blue dots represent cities farther to the east in China.\r\n\r\n\r\nannotation <- dplyr::filter(fulloutputclean, Longitude>112)\r\np <- p + \r\n    geom_point(data=annotation, color=\"#6495ED\") +\r\n    geom_rect(aes(xmin=79, xmax=130, ymin=15000000, ymax=16600000),\r\n              fill=\"white\",\r\n              color = \"#6495ED\") +\r\n    geom_text(aes(x=80, y=15800000, \r\n                  label=\"Cities to the east of the 112th meridian\"),\r\n              size=6, hjust=0, vjust=0, color = \"#6495ED\")\r\np\r\n\r\n\r\n\r\nFinally, to highlight the top 5 cities from the original map, I construct another annotation and insert it as an argument in the geom_text() function. I adjust the size and horizontal justification of the labels, and make them bold.\r\n\r\n\r\nannotation2 <- dplyr::filter(fulloutputclean, Ranking<=5)\r\np <- p +\r\n  geom_text(aes(label=City),\r\n            annotation2,\r\n            hjust=-0.2, nudge_x=0.1, size=6,\r\n            family = \"IBM Plex Sans\",\r\n            fontface=\"bold\") \r\np\r\n\r\n\r\n\r\nWe can see that highly-ranked cities are all near the coast (i.e. all highlighted in blue because they are east of the meridian 112°), but there is a rather wide range of population numbers among the top 5. For instance, both Shanghai and Suzhou have very high growth potential. Yet the former has more than 3.5 times the population of the latter. This is because many variables are included in the calculation of scores. For instance, Hangzhou tops the ranking due to its nature as a big tech hub. While government regulation targeting tech firms may hamper its medium- and long-term growth, other factors such as its fiscal position, economic diversity or metropolitan development jointly yield a high growth potential for the city.\r\nAll in all, as the caption suggests, it seems that location (whose effect is hard to separate from other historical, economic and environmental factors) is more important than current population as a predictor of future economic growth.\r\n\r\n\r\n\r\n",
    "preview": "projects/2022/100489635/100489635_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2023-01-01T14:13:51+01:00",
    "input_file": "100489635.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/gapminder/",
    "title": "Gapminder's World Health Chart",
    "description": "This tutorial reproduces one of the most popular data visualizations ever\nand serves as an example project for this course",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-09-09",
    "categories": [
      "gapminder"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLegend\n\nFinal result\nSingle year\nMultiple years, static\nMultiple years, dynamic\n\n\nHans Rosling was a Swedish professor of International Health at the Karolinska Institute,\nand co-founder of the Gapminder Foundation,\nwhich developed the Trendalyzer software for animated data visualization.\nHis famous 2006 TED Talk,\nDebunking myths about the “third world”,\nhas inspired millions over the world thanks to his celebrated bubble chart\ndepicting the relationship between life expectancy and income.\nGapminder’s World Health Chart. Figure from gapminder.org.The goal of this tutorial is to replicate this famous data visualization step by step.\nGetting the data\nThe data consists of yearly observations of life expectancy values and GDP per capita for a number of countries in the world.\nThis is a very popular dataset.\nWe could download the data directly from the Gapminder homepage,\nbut we will use instead the gapminder package,\nwhich contains ready-to-use data for 142 countries from 1952 to 2007.\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\n\nLet’s take a glimpse of the data:\n\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afgh…\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, As…\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 19…\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nThese are all the variables we need in a tidy format,\nincluding population counts, which will serve to define the size of the bubbles.\nAs we can see, the original visualization includes Oceania into Asia,\nso let’s do the same for our exercise:\n\n\ngapminder <- gapminder %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\"))\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Europe  :360   Median :1980   Median :60.71  \n Angola     :  12   Asia    :420   Mean   :1980   Mean   :59.47  \n Argentina  :  12                  3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nBuilding the chart\nCoordinates and axes\nWe will work with a single year for now.\nThe base panel consists of simple Cartesian coordinates,\nand depicts life expectancy vs. GDP per capita,\nalthough the x label says the more understandable term “Income”.\n\n\np <- ggplot(filter(gapminder, year == 2007)) +\n  aes(gdpPercap, lifeExp) +\n  ylab(\"Life expectancy\") + xlab(\"Income\")\np\n\n\n\nBoth axes have fixed limits across the whole animation.\nAnother thing to note about the axes is that income is in logarithmic scale with very specific breaks.\nAlso, numbers above 10 thousand are labeled as “10k”.\nThe function scales::label_number comes in handy for this.\nNote that we make some space for annotations on top of the chart\nby setting the maximum limit of the y axis to 95.\n\n\nbreaks <- 500*2^c(0:8)\nklabel <- scales::label_number(suffix=\"k\", scale=1e-3)\nlabels <- c(breaks[1:5], klabel(breaks[-(1:5)]))\n\np <- p + scale_y_continuous(limits=c(10, 95), breaks=seq(10, 90, 10)) +\n  scale_x_log10(limits=range(breaks), breaks=breaks, labels=labels)\np\n\n\n\nTheme\nNote that the theme is very similar to theme_classic, but shows the major grid.\nWe also instruct the theme to remove the legend,\nbecause we will add a custom one later on.\n\n\np <- p + theme_classic() +\n  theme(panel.grid.major=element_line(), legend.position=\"none\")\np\n\n\n\nAdditionally, we could continue to tinker with fonts and other parameters.\nAnnotations\nThe base panel depicts three annotations:\nA big background number indicating the year in the middle.\nFour income levels on the top part, whose breaks seem to be 3k, 8k and 24k.\nThe axes’ units on the top left and bottom right corners.\nFor the background number, we could use annotate with a fixed label,\nbut we will use geom_text instead, even if we overplot it many times,\nso that the year is read from the data.\n\n\np <- p + geom_text(aes(8000, 50, label=year), size=65, color=\"lightgray\")\np\n\n\n\nNext, we add the income levels.\nAdditionally, we will take the liberty of adding vertical lines to clearly demarcate the breaks.\n\n\ntlevel <- c(1300, 5000, 14000, 40000)\nblevel <- c(3000, 8000, 24000)\nilevel <- c(\"INCOME LEVEL 1\", \"LEVEL 2\", \"LEVEL 3\", \"LEVEL 4\")\n\np <- p + geom_vline(xintercept=blevel, color=\"darkgray\") +\n  annotate(\"text\", x=tlevel, y=95, color=\"darkgray\", vjust=0, size=3, label=ilevel) +\n  annotate(\"text\", x=blevel, y=95, color=\"darkgray\", vjust=0, size=5, label=\"◆\")\np\n\n\n\nFinally, let’s add the units to the axes.\n\n\np <- p +\n  annotate(\"text\", x=128000, y=10, hjust=0.95, vjust=1, size=3,\n           label=\"per person (GDP/capita, PPP$ inflation-adjusted\") +\n  annotate(\"text\", x=500, y=95, hjust=0.5, vjust=-1.5, size=3, angle=90, label=\"years\")\np\n\n\n\nData\nThe chart is a type of scatterplot, with one point per country, and colored by continent.\nThe novelty here is that every dot is scaled up to represent the population size.\nAlso, we will add some transparency to the points.\n\n\np <- p + geom_point(aes(color=continent, size=pop), alpha=0.7)\np\n\n\n\nWe are close, but a couple of adjustments are required.\nLet’s add a black line around the points (see shape 21),\nand adjust the range of the bubbles a bit.\n\n\np <- p + geom_point(aes(size=pop), color=\"#333333\", shape=21) +\n  scale_size_area(max_size=25)\np\n\n\n\nFinally, let’s replicate the same color scale.\nWe need to provide them in the same order as the factor levels:\n\n\nlevels(gapminder$continent)\n\n[1] \"Africa\"   \"Americas\" \"Europe\"   \"Asia\"    \n\nTherefore, from the web, page we obtain:\nAfrica: Blue rgb(0, 213, 233) -> #00d5e9\nAmericas: Green rgb(127, 235, 0) -> #7feb00\nEurope: Yellow rgb(255, 231, 0) -> #ffe700\nAsia: Red rgb(255, 88, 114) -> #ff5872\n\n\nccolors <- c(\"#00d5e9\", \"#7feb00\", \"#ffe700\", \"#ff5872\")\np <- p + scale_color_manual(values=ccolors)\np\n\n\n\nLegend\nThis chart has an interesting legend:\nit takes advantage from the fact that continents are easily recognizable to use a map as a legend.\nLet’s replicate it separately using data from ggplot2::map_data.\n\n\nworld <- map_data(\"world\")\nglimpse(world)\n\nRows: 99,338\nColumns: 6\n$ long      <dbl> -69.89912, -69.89571, -69.94219, -70.00415, -70.06…\n$ lat       <dbl> 12.45200, 12.42300, 12.43853, 12.50049, 12.54697, …\n$ group     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,…\n$ order     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16,…\n$ region    <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Arub…\n$ subregion <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\nThis data needs to be tweaked a little bit. We need to:\nFilter out the Antarctica region.\nAdd a new column continent with the help of the countrycode package.\nInclude Oceania into Asia.\nDrop any missing values for continent.\n\n\nworld <- world %>%\n  filter(region != \"Antarctica\") %>%\n  mutate(continent = countrycode::countrycode(\n    sourcevar=region, origin=\"country.name\", destination=\"continent\")) %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\")) %>%\n  drop_na(continent)\n\n\nNow, let’s create the map:\n\n\nlegend <- ggplot(world) +\n  aes(long, lat, group=group, map_id=region, fill=continent) +\n  geom_map(map=world) +\n  scale_fill_manual(values=ccolors) +\n  theme_void() + theme(legend.position=\"none\")\nlegend\n\n\n\nFinal result\nSingle year\nIn summary, so far we have\nBuild steps:\nset coordinates and axes, with custom breaks;\nset an appropriate theme and prevent the default legend from appearing;\nadded several annotations, including year, income levels and axis units;\nadded the data points and made several adjustments, including size and color;\ncreated a custom legend based on a simple colored world map.\nThere are several ways we can merge the main plot and the legend.\nIn this case, let’s add it as an inset with the custom annotation function.\nNote that, in contrast to the regular annotation function,\nthis one doesn’t seem to support logarithmic scales very well.\nAs a result, the user needs to provide the transformed values directly.\n\n\np <- p + annotation_custom(\n  ggplotGrob(legend), xmin=log10(16000), ymin=10, ymax=40)\np\n\n\n\nFinally, we can improve this static single-year visualization by adding some context,\ni.e. a title, a subtitle and a caption.\n\n\np + labs(\n  title = \"World Life Expectancy vs. Income in 2007\",\n  subtitle = paste(\n    \"African countries are still lagging behind in terms of general life\",\n    \"expectancy.\\nEuropean and American countries are the healthiest\",\n    \"and richest countries in the world.\"),\n  caption = \"Source: gapminder.org\"\n)\n\n\n\nMultiple years, static\nSo far, we covered the case for a single year.\nHow could we show the evolution, which is the point in this dataset?\nOf course we can define facets to plot all the years.\nIn the following chart,\ngginnards::delete_layers is used to remove the background year;\nwe switch to the whole dataset using the %+% operator;\ndata is faceted in two rows;\naxis labels are slightly rotated to make space for them.\nNote also that we need to manually scale down a bit the range of the bubbles\nto preserve more or less the previous aspect ratio.\n\n\ngginnards::delete_layers(p, match_type=\"GeomText\") %+% gapminder +\n  facet_wrap(\"year\", nrow=2) +\n  scale_size_area(max_size=7) +\n  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))\n\n\n\nMultiple years, dynamic\nAnd we can of course animate it!\nWe can easily convert any ggplot2 chart to plotly using plotly::ggplotly,\nwhich produces interactive web-based charts.\nFurthermore, if we set the frame aesthetic, it is automatically detected,\nand an animation is added based on the corresponding variable.\n\n\nplotly::ggplotly(p %+% gapminder + aes(frame=year))\n\n\n\n\n\n\n",
    "preview": "projects/gapminder/gapminder_files/figure-html5/titled-1.png",
    "last_modified": "2022-10-07T12:58:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  }
]
