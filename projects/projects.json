[
  {
    "path": "projects/2022/100376720/",
    "title": "Education Attainment Graph",
    "description": "This project consists in the replicaion and alternative representation of a graph from a New York Times article called \"Where Education Drives Mobility\".",
    "author": [
      {
        "name": "Edgar Chicurel",
        "url": {}
      }
    ],
    "date": "2023-01-09",
    "categories": [],
    "contents": "\n\nContents\nIntroduction\nGraph to replicate (two graphs in one)\nLoad libraries and read the database\nAdjusting the data\nFirst graph\nAdjusting the data for second graph\nSecond graph\nMerge both graphs into one\nAlternative Representations\nGraph 1:\nGraph 2\nMerge them together\n\nConclusion\n\nIntroduction\nThe graph for this project was inspired by a New York Times article about education mobility and gender differences in education. The first part of the article talks about how young students’ highest level of education compares to their parents’ highest level of education. Students who achieved a higher level than their parents are considered upwardly mobile, those who achieved the same level are considered to have experienced status quo mobility, and those who achieved a lower level are considered downward mobile. The second part of the article examines gender differences in education at a specific level. You can find the full article here.\nGraph to replicate (two graphs in one)\nThe graph that needs to be replicated is actually two graphs in one. The first graph (on the left) shows the differences in education mobility among OECD countries for students aged 25-34. The graph uses a dark purple color for students who achieved a higher education level than their parents, a light grey color for students who achieved the same level, and a yellow color for students who achieved a lower level. The second graph (on the right) shows the difference for the same countries, except for Russia and Japan (for which data is not available), but by country and gender for students who achieved a highest education level higher than high school. The first graph is a stacked percentage bar graph, and the second graph consists of dotted lines and points. Both graphs have annotations to label the categories. At first glance, the graphs do not appear to be complicated. Here is a link to the original graph:\nGraph to replicateLoad libraries and read the database\nThe first step was to load the libraries, in this case I only used two: tidyverse and patchworks. The second step was to read the database which was on a csv file.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\ndf <- read_csv(\"Data_on_intergenerational_mobility.csv\")\n\n\nAdjusting the data\nIn this part, the data for the first graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Mobility_type” column. After this I created 3 different databases, each one of them containing only one category, this was done in order to arrange the graph in descending order of a specific category inside the “Mobility_type” column.\n\n\neduc <- df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\"\n  ) %>%\n  pivot_longer(cols = ends_with(\"ility\"), \n               names_to = \"Mobility_type\", \n               values_to = \"Mobility_perc\") \n\ndf_order <- educ[educ$Mobility_type == \"Upward_mobility\", ]\ndf_order2 <- educ[educ$Mobility_type == \"Status_quo_Mobility\",]\ndf_order3 <- educ[educ$Mobility_type == \"Downward_Mobility\",]\n\n\nFirst graph\nThe code for this visual representation can be divided into six parts:\nPlotting the data as vertical columns (“stack”) and arranging it in descending order based on the Upward_mobility category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adding a percent symbol or adding extra space).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) + \n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        plot.background = element_rect(fill = \"white\", colour = NA), \n        panel.background = element_rect(fill = \"white\", colour = NA),\n        legend.background = element_rect(fill = \"white\", colour = NA),\n        legend.key = element_rect(fill = \"white\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x))+\n geom_text(data = df_order, \n            aes(x=12, label = ifelse(\n              Country == \"South Korea\", paste0(Mobility_perc, \"%\"), \n              ifelse(\n              Country != \"South Korea\", paste0(Mobility_perc, \"    \"), \n              Mobility_perc))), \n           size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=150, label = ifelse(\n              Country != \"South Korea\", \n              paste0(Mobility_perc, \"       \"), Mobility_perc)), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, \n            aes(x=200, label = Mobility_perc), size=3, \n            position = position_stack(vjust = 0.485)) +\n  labs(\n  subtitle = \"\\nPercentage of people who got more, the same or\\nless education than their parents, as of 2012.\") +\n  theme(\n        plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\", \n                                  margin=margin(0,0,-20,0)),\n        plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                                     margin=margin(0,0,70,0)),\n axis.text.y = element_text(margin=margin(0,-15,0,0))) +\n  annotate(\"text\", x=7.5, y=28, label=\"MORE\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=8, y=26.7, label=\"  (upwardly\\nmobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=3, xend=3, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=60, y=28, label=\"SAME\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=60,  y=26.7, label=\"(status\\n   quo)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=66, xend=66, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=97, y=28, yend = 32, label=\"         LESS\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=97,  y=26.7, label=\"(downardly\\n       mobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=99.9, xend=99.9, y = 23.6, yend = 25.2, \n           color=\"grey30\",alpha = 0.5) +\n  coord_cartesian(xlim = c(0, 200), ylim = c(0, 22), clip = \"off\")\n\n\nAdjusting the data for second graph\nIn this part, the data for the second graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Beyond_Sex” column. After this I created 1 different database, containing only one category, this was done in order to arrange the graph in descending order of that specific category inside the “Beyond_Sex” column, in this case by female.\n\n\nbeyond =  df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\" &\n         Country != \"Russia\" &\n         Country != \"Japan\"\n  ) %>%\n  pivot_longer(\n    cols= starts_with(\"Beyond\"),\n    names_to = \"Beyond_Sex\",\n    values_to = \"Beyond_perc\"\n  ) \n\n\n  bey_ordered = beyond %>% \n    filter(Beyond_Sex == \"Beyond_highscool_2014_F\") %>%\n    arrange(desc(Beyond_perc))\n\n\nSecond graph\nThe code for this visual representation can be divided into seven parts:\nPlotting the data points using “geom_point” and arranging them in descending order based on the Female category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adjusting the position of the first numbers to the left and the position of the second numbers to the right).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nChanging the panel.grid composition to include horizontal dotted lines and solid vertical lines with the correct measures and positions.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np2 = beyond %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_point(size=3, color = \"#5e4c5f\", aes(\n    color = Beyond_Sex), data = bey_ordered) + \n  geom_point(size=3, color = \"#b8bdd0\", aes(color = Beyond_Sex), \n             data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",\n                           ]) +\n  labs(y=NULL) +\n  theme(plot.background = element_rect(fill = \"white\",colour = NA), \n        panel.background = element_rect(fill = \"white\",colour = NA),\n        legend.background = element_rect(fill = \"white\",colour = NA),\n        legend.key = element_rect(fill = \"white\"),\n        legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_text(size = 8.5),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0, \n                                   margin=margin(0,-10,0,0))) +\n  geom_text(data = subset(bey_ordered, \n                          Country %in% c(\n                            \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = 2, nudge_y = 0.1, size=3) +\n  geom_text(\n    data = subset( beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n                           Country %in% c(\n                             \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = -2, nudge_y = 0.1, size= 3) +\nlabs(\n  subtitle = \"Percentage of people who attained\\neducation beyond high scool, as of 2014.\",\n     caption = \"Gender data for Russia and Japan not available.\") +\ntheme(\n  plot.caption = element_text(hjust = 0, size = 7.5, color = \"grey30\", \n                              margin = margin(20,0,0,0)),\n  plot.caption.position = \"plot\",\n  panel.grid.major = element_line(color = '#80808066', linetype = 'dotted'),\n  panel.grid.major.x = element_line(color = '#80808066', linetype = 'solid'),\n  plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                               margin = margin(-30,0,0,0)),\n  plot.title = element_text(colour = \"grey30\"),\n  plot.title.position = \"plot\",\n) +\ncoord_cartesian(xlim = c(3.3, 71.2),ylim = c(1.3, 22), clip = 'off') +\nscale_x_continuous(breaks = c(0, 25, 50), \n                   position = \"top\", \n                   labels = c(\"0\", expression(paste(\"25\",\"%\", \"\")),\"50\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n  annotate(\"text\", x=72, y=25, label=\"WOMEN\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=64, y=23.5, label=\"MEN\",\n            fontface = \"bold\",size=3) +\n  annotate(\"segment\", x=64, xend=64, y = 21.3, yend = 22.9, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"segment\", x=72, xend=72, y = 21.3, yend = 24.4, \n           color=\"grey30\", alpha = 0.5)\n\n\nMerge both graphs into one\nIn the final part, I had to merge both graphs into one.This part was the most tricky for me because the dimensions of the plot were different and a lot of editing of the margins, plot_layout had to be done so they merged correctly. I also added a common title as a plot_annotation and a line in the middle just as the original graph.\n\n\np + p2 + plot_layout(ncol=2,widths=c(6,5)) + \n  annotate(\"segment\", x = -25, xend = -25, y = -15, \n           yend = 30, color = \"grey30\", alpha = 0.3) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nAlternative Representations\nI thought of creating different visual representations to display data. I first tried a tree map, but the values were difficult to read. I then considered using a multi-level circular packing, but this made it difficult to see the relative magnitudes of the values, and there were too many categories because each country was treated as a separate category. As a result, I chose to use the facet_wrap option and split the plot into categories based on the type of mobility for the first plot and sex for the second, with the same y-axis for all categories. I created two separate plots and combined them.\nGraph 1:\nTo create the first graph of the alternative representation, I followed these steps:\nI created a labeller argument to change the titles of each facet.\nI used geom(col) to add the data and arrange it in descending order of Upward_mobility value.\nI used facet_wrap to separate the data by type of mobility.\nIn the theme function, I removed some elements and adjusted others to achieve the desired aesthetics.\nI finally added numbers to the graph by using geom_text and adjusting their size.\n\n\neduc_names <- list(\n  'Downward_Mobility'=\"Downward mobile\",\n  'Upward_mobility'=\"Upward mobile \",\n  'Status_quo_Mobility'=\" Status quo mobile\"\n)\n\n\neduc_labeller <- function(variable,value){\n  return(educ_names[value])\n}\n\na1 = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) +\n    facet_wrap(~Mobility_type, labeller = educ_labeller )+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = df_order, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), \n        Mobility_perc))), size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", \n         paste0(Mobility_perc, \"  \"), Mobility_perc))), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, aes(x=7, \n                                  label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), Mobility_perc))), \n  size=3, position = position_stack(vjust = 0.485)) +\n  labs(\n    subtitle = \"Percentage of people who got more, the same or less education than their parents, as of 2012.\") +\n  theme(\n        plot.subtitle = element_text(colour = \"grey30\", size = 11, \n                                     margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5), plot.title.position = \"plot\")\n\na1\n\n\n\nGraph 2\nThe Second graph of the alternative representation followed similar steps as the alternative graph 1 with the only difference being that now there are two categories that the facet wrap is done by: Female and Male.\n\n\neduc_names2 <- list(\n  \"Beyond_highscool_2014_M\"=\"Beyond higschool males\",\n  'Beyond_highscool_2014_F'=\"Beyond higschool females\"\n)\n\n\neduc_labeller2 <- function(variable,value){\n  return(educ_names2[value])\n}\n\na2 = beyond %>%\n  group_by(Country, Beyond_perc) %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_col(data = bey_ordered, position = \"stack\") +\n  scale_fill_manual(values = c(\"#5e4c5f\", \"#b8bdd0\")) + \n  geom_col(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\", ], \n    position = \"stack\") +\n  geom_col(aes(fill = Beyond_Sex)) +\n    facet_wrap(~Beyond_Sex, labeller = educ_labeller2)+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\", expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = bey_ordered, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n        Beyond_perc))), size=3,\n            position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n         Beyond_perc))), size=3,position = position_stack(vjust = 0.44)) +\n  labs(\n    subtitle = \"Percentage of people who attained education beyond high scool, as of 2014.\") +\n  theme(\n        plot.subtitle = element_text(\n          colour = \"grey30\", size = 11, \n          margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60,80), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\",\"80%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5),\n      plot.title.position = \"plot\")\n\na2\n\n\n\nMerge them together\nIn this part the two alternative graphs are merged together specifying the correct width and height so they look nice and adding a general title for both.\n\n\na2 + a1 + plot_layout(ncol=1) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nConclusion\nReplicating these graphs involved some challenges, such as arranging the data in the desired order of the category and adding specific elements to only a few values like axis titles or geom texts. While the rest of the process was relatively straightforward, the most difficult part for me was merging the two graphs together. Determining the correct dimensions, aspect ratios, plot layout, coordinate limits, etc. was challenging. The final result may not have the exact desired dimensions, but it is similar to the original. I chose the facet_wrap option for the alternative representation because, in my opinion, it was a clear and tidy way to view the data, although it may not have been the most complex method I am satified with the end result.\n\n\n\n",
    "preview": "projects/2022/100376720/original.png",
    "last_modified": "2023-01-09T18:57:46+01:00",
    "input_file": {},
    "preview_width": 832,
    "preview_height": 871
  },
  {
    "path": "projects/2022/100470958/",
    "title": "Satellite images defy economic data of authoritarian regimes",
    "description": "Highly customized dumbbell chart that compares official GDP against satellite-based estimation of GDP, across 103 countries.",
    "author": [
      {
        "name": "Freddy Andrés Camargo",
        "url": {}
      }
    ],
    "date": "2023-01-09",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData collection\nVisualization assembly\nThe grid\nData layer\nScales\nAppereance\nLegend\nAnnotations\n\nAlternative\n\nSatellite images of the brightness of the earth, also called nighttime lights data (NTL, from the US Air Force’s Defense Meteorological Satellite Program), have been used as a proxy for economic activity. Luis R. Martínez, professor at the Harris School of Public Policy at the University of Chicago, not only developed a model to calculate the GDP of every country based in the NTL data set, but he also found that countries with less political rights and civil liberties report overestimated GDP. The goal of this article is to rebuild a chart designed by The Economist to show the magnitude of this finding.\nThe Economist’s chartData collection\nThe data includes different records per country: the GDP from World Bank, the GDP estimated based on NTL, and the yearly growth of each one between 2002 and 2021. In addition, it includes the status in the Freedom in the World Index 2021, published by Freedom House, which classifies each country in three categories (Free, Partly Free, and Not Free). Finally, the population is incorporated, because for visualization purposes the chart only shows countries with more than 5 million population. Mr. Martínez provided me the projections of the NTL model, after contacting him by email.\n\n\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\nLet’s see how the data looks like:\n\n\nDF <- read.csv(\"economist.csv\")\n\n\n\nCountry.Name\nYear\nGDP. growth.LCU.R\nGDP.in. 2015.USD.R\nGDP.growth. LCU.adjExag.NTL\n1\nLibya\n2021\n31\n60910775962\n20\n2\nYemen, Rep.\n2021\n-2\n33429671860\n-2\n3\nZimbabwe\n2021\n6\n20562359266\n4\n4\nGreece\n2021\n8\n200827546085\n8\n5\nLebanon\n2021\n-11\n30979755568\n-11\n\n\n\n\n\n\n\nGDP.in. 2015.USD.NTL\nGDP.var.R\nGDP.var.NTL\nFIW.Status\nPopu.2021\n\n36634943488\n8.73\n-34.61\nNF\n6958538\n\n29289246720\n-25.33\n-34.58\nNF\n30490639\n\n15954965504\n10.36\n-14.36\nNF\n15092171\n\n197563367424\n-7.88\n-9.38\nF\n10664568\n\n26433470464\n11.82\n-4.59\nPF\n6769151\nVisualization assembly\nThe grid\nThe chart emphasizes the importance of the Y-axis, which shows percentage change in GDP. The X-axis doesn’t include a new variable. We just order the countries from lowest to highest GDP growth. We add 3 facets that correspond to the categories in the Freedom in the World Index, assigning a color to each one.\n\n\nc <- ggplot(DF, aes(x = order, y = GDP.var.NTL, xend = order, \n                    yend = GDP.var.R, color = FIW.Status)) +\n  facet_wrap(~ factor(FIW.Status, levels = c(\"F\", \"PF\", \"NF\")))\n\nc\n\n\n\nData layer\nWe want to draw a vertical dumbbell chart. As a consequence, we specify two sets of coordinates in the Y-axis, one for the GDP-NTL growth, and the other for the GDP-official growth. In order to connect both points, we add a segment that evidences how big is the distance between them. Then, we create a dumbbell per country.\nWe scale the size of each point to show the size of the economy, according to the respective methodology.\n\n\nc <- c + geom_segment() +\n  geom_point(aes(xend = order, y = GDP.var.R, size = GDP.in.2015.USD.R/1e+12), \n             shape = 21, fill = \"#C7C5BD\", color = \"white\") +\n  geom_point(aes(size = GDP.in.2015.USD.NTL / 1e+12, fill = FIW.Status), \n             shape = 21, color = \"white\") \n\nc\n\n\n\nScales\nWe adjust manually the bubbles colors, according to the freedom categories. However, as we defined a point shape that allows us to specify a border color (# 21), we see that each point has a border color ‘white’ to facilitate the distinction between countries.\nWe adapt the size, to highlight largest economies, but keeping visible the smallest with the help of the range argument. In addition, we define the breaks for the size scale.\nThe Y-axis has breaks for every 50 percentage points in a range between -50 and 450. Note that this axis is placed on the right. Furthermore, the X-axis needs an extra space for annotations.\n\n\nc <- c + scale_color_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_fill_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_size(range = c(1, 12), breaks = c(0.1, 2, 10), \"GDP in 2021, $trn†\") + \n  scale_y_continuous(\n    position = \"right\",\n    limits = c(-50, 450),\n    n.breaks = 10,\n    expand = expansion(0)\n  ) +\n  lims(x = c(0.5, 46)) \n\nc\n\n\n\nAppereance\nThe Economist’s chart has a minimalist and clean design. We use the correspondent theme provided by the “ggthemes” library, as a base. It is required to include many theme adjustments to conclude the design. As an important piece of the visual aspect, we incorporate the “PT Sans” font type to make the chart more light and stylized.\n\n\nsysfonts::font_add_google(\"PT Sans\")\nshowtext::showtext_auto()\n\n\nWe assign a white background, and remove the divisions between facets, as well as its titles, to integrate the canvas. Observe that we reduce the grid linewidth and change its color, to highlight the dumbbells. Now, the bottom line is not a frame of the chart, while a horizontal reference line is created where Y is equal to 0.\n\n\nc <- c + geom_hline(yintercept = 0, linewidth = 0.5) + \n  theme_economist_white() + \n  theme(\n    plot.background = element_rect(fill = \"white\"),\n    panel.spacing.x = unit(0, \"cm\"),\n    strip.background = element_rect(fill = \"white\"), \n    strip.text = element_text(color = \"white\"), \n    panel.grid = element_line(color = \"ligthgray\", linewidth = 0.10), \n    axis.line.x.bottom = element_line(color = \"gray\", linewidth = 0.10),\n  )\n\nc\n\n\n\nWe remove the titles from both axis. Besides, we withdraw texts and ticks from X-axis. On the other hand, we move the legends to the top right position, saving a space for the dumbbell legend. Also we change their color to harmonize the chart. Perceive that now the Y-Axis texts are aligned with the horizontal gridlines.\n\n\nc <- c + theme(\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank(), \n  axis.text.y = element_text(vjust = -0.5), \n  axis.text.x = element_blank(),\n  axis.ticks.x = element_blank(),\n  legend.background = element_rect(fill = \"white\"),\n  legend.position = c(0,0.81),\n  legend.direction = \"horizontal\",\n  legend.justification = c(0, 1),\n  legend.key = element_rect(fill = \"transparent\"),\n  plot.caption = element_text(hjust = 0, vjust = -1, \n                              color = \"#454545\", size = 8)\n)\n\nc\n\n\n\nLegend\nWe take out the fill and size legends. But most importantly, we adjust the position of the legend title of the size. What’s more, we create an additional chart to represent the dumbbell legend. Later, we add it to the main chart as an inset.\n\n\nc <- c + guides(color = FALSE, fill = FALSE, \n                size = guide_legend(title.position = \"top\"))\n\nz <- data.frame(\n  name = c(\"Satelite-based\\n estimate\"),\n  x = c(3), y = c(5)\n)\n\nv <- data.frame(\n  name = c(\"Reported\"),\n  x = c(3), y = c(7)\n)\n\npinset <- ggplot(z, aes(x, y)) +\n  geom_segment(aes(x=3, xend=3, y=5, yend=7), linewidth=0.5) +\n  geom_point(size=2)+\n  geom_point(data=v,size=2, color=\"grey\")+\n  geom_text(aes(label=name), hjust= -0.1, size=4, lineheight = .5) +\n  geom_text(data=v,aes(label=name), hjust= -0.2, size=4) + \n  lims(x = c(2.9, 4), y = c(4.7, 7.3)) +\n  ggtitle(\"Change in GDP, 2002-21, %*\", ) +\n  theme_void() + \n  theme(\n    panel.background = element_rect(fill = \"white\", color=\"white\"),\n    plot.background = element_rect(fill = \"white\", color=\"white\"),\n    panel.border = element_rect(colour = \"white\", fill=NA),\n    plot.title = element_text(face = \"bold\", hjust = 0.3, size= 12, vjust = 3)\n  )\n\npinset\n\n\n\nAnnotations\nThe chart has 4 annotations types:\nText labels for a group of countries per category, including largest economies.\nCategories titles inside of each facet.\nThe average values per category.\nA brief summary of the average values for autocratic countries.\nThe caption that includes some clarifications about the chart.\nWe add the labels bringing geom_text() into play, and filtering the data set to keep those countries that we need. Note that we separate the 4 largest economies, because we place them with independent coordinates taking into account its bubble size. In addition, we include category titles.\n\n\ntitles <- data.frame(\n  labels = c(\"Free countries\", \"Partly free\", \"Not free\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = 20,\n  GDP.var.NTL = c(175, 225, 275),\n  GDP.var.R = c(170, 220, 270)\n)\n\ncountriestxt <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\"),\n  order = c(4, 11, 20, 34),\n  GDP.var.NTL = c(-6, 14, 25, 175),\n  GDP.var.R = c(-6, 14, 25, 175)\n  )\n\nc <- c +\n   geom_text(data = DF%>% filter(label == 1 & \n          !(Country.Name %in% c(\"Japan\", \"Britain\",\"United States\", \"China\"))), \n            aes(label = Country.Name), color = \"#454545\",\n            vjust = 1.5, hjust = -0.1, check_overlap = T) +\n  geom_text(data= countriestxt, aes(label = labels), color=\"#454545\", hjust=0)+\n  geom_text(data = titles, aes(label = labels), fontface = \"bold\", size=4.5)\n\nc\n\n\n\nTo point out the averages, we draw a set of 3 dumbbells with a black border, and we include a label for them. Observe that we should create independent data frames, for annotations that require a specific location inside the chart. Then, we map these data frames with ggplot components.\n\n\nav_data <- DF %>% \n  group_by(FIW.Status)  %>%\n  summarise(\n    av.GDP.var.R = mean(GDP.var.R),\n    av.GDP.var.NTL = mean(GDP.var.NTL),\n    av.GDP.usd.R = mean(GDP.in.2015.USD.NTL)/1000000000000,\n    av.GDP.usd.NTL = mean(GDP.in.2015.USD.NTL)/1000000000000\n  )\n\nav_data <- av_data[c(1,3,2),]\n\naverage <- data.frame(\n  Country.Name = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  GDP.in.2015.USD.NTL = as.vector(av_data$av.GDP.usd.NTL),\n  GDP.in.2015.USD.R = as.vector(av_data$av.GDP.usd.R),\n  GDP.var.R = as.vector(av_data$av.GDP.var.R),\n  GDP.var.NTL = as.vector(av_data$av.GDP.var.NTL),\n  order= c(22,19,17),\n  colorT = c(\"grey\", \"grey\", \"grey\"),\n  colorB = c(\"#FFC259\", \"#F6423C\",\"#FFA9A6\"),\n  fill = c(\"black\", \"black\", \"black\")\n)\n\navTitles <- data.frame(\n  labels = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = c(20, 16, 14),\n  GDP.var.NTL = c(85, 138, 165),\n  GDP.var.R = c(80, 133, 160)\n  )\n\nc <- c +\n  geom_segment(data = average, aes(x=order, xend=order, y=GDP.var.NTL, \n                                   yend=GDP.var.R), color=\"black\") +\n  geom_point(data = average,aes(x=order, y=GDP.var.NTL, \n             size=GDP.in.2015.USD.NTL, fill=FIW.Status), \n             shape=21, color=\"black\") + \n  geom_point(data = average, aes(x=order, y=GDP.var.R, size=GDP.in.2015.USD.R), \n             shape=21, color=\"black\", fill=\"gray\") +\n  geom_text(data= avTitles, aes(label= labels), fontface = \"bold\", \n            size= 3.5, color = \"black\") \n\nc\n\n\n\nThe autocratic category summary and the caption are added. We highlight that the summary is incorporated just to one facet. It means that we should specify the level of the factor that we want to use. To conclude, we combine the inset with the “Patchwork” library, specifying the desired position.\n\n\nsumQuote <- data.frame(\n  text = \"↓ Autocratic countries reported\\nGDP growth of 147% on average.\nSatellite imagery suggests the\\ntrue figure is 76%\",\n  FIW.Status = factor(\"NF\", levels = c(\"F\", \"PF\", \"NF\")),\n  order = 0.5,\n  GDP.var.NTL = 420,\n  GDP.var.R = 420\n)\n\ncaptiontx <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate\", sep=\" \"\n            )\n\nc <- c +\n  geom_label(data = sumQuote, aes(label = text), color = \"black\", \n             size = 3, hjust = 0, vjust = 1, lineheight = .8, fill = \"white\", \n             label.size = NA, label.padding = unit(0, \"cm\")) +\n  labs(caption = captiontx) + \n  inset_element(pinset, left=0, bottom=0.83, right=0.3, top=1, align_to=\"full\")\n\nc\n\n\n\nAlternative\nAnalyzing the original chart, we can see that it has some advantages. For instance, it allows us to identify each of the 103 countries, or it separates clearly the Freedom categories. Nevertheless, we realize that the X-axis is used to create an order among dumbbells, but it doesn’t add more information. Therefore, we propose an alternative visualization that uses this axis to compare GDP values.\nIn our chart, the Y-axis shows the officialy reported GDP growth, while the X-axis illustrates the NTL-based estimate of GDP. As a result, we should expect that each country will be located in the intersection line where Y is equal to X. However, the autocratic countries are far away from this line, as their value of the officialy reported GDP.\n\n\nlineAnnotations <- data.frame(\n  labels = c(\"Countries close to this line have official GDP = NTL GDP \", \n             \"+50 pp Inflation\", \"+100 pp Inflation\", \"+200 pp Inflation\"),\n  GDP.var.R = c(340, 445,445,445),\n  GDP.var.NTL = c(353, 387, 337, 237),\n  FIW.Status = c(\"PF\", \"PF\", \"PF\", \"PF\")\n  )\n\nEcountrieslbl <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\",\"Russia\", \n             \"Turkiye\", \"Mexico\", \"Philippines\", \"India\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\",\"NF\", \"NF\", \"PF\", \"PF\", \"PF\"),\n  GDP.var.R = c(-5, 10, 30, 390, 83, 179, 50, 135, 228),\n  GDP.var.NTL = c(18, 31, 58, 149, 16, 92, 4, 110, 173)\n  )\n\ncaptiontxt <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate\", sep=\" \"\n            )\n\nDF$FIW.Status <- factor(DF$FIW.Status, levels=c(\"F\", \"PF\", \"NF\"))\n\n\n\n\nggplot(DF, aes(GDP.var.NTL, GDP.var.R, fill= FIW.Status)) + \n  geom_abline(slope = 1, intercept = 0, linetype=\"dashed\") +\n  geom_abline(slope = 1, intercept = 50, linetype=2, size=0.1) +\n  geom_abline(slope = 1, intercept = 100, linetype=2, size=0.1) +\n  geom_abline(slope = 1, intercept = 200, linetype=2, size=0.1) +\n  geom_point(aes(size=GDP.in.2015.USD.NTL/1e+12), shape=21, alpha=0.8) + \n  geom_text(data = DF%>% filter(label == 1 & (Country.Name %in% \n            c(\"Greece\", \"Australia\", \"South Korea\", \"Ghana\",\"Poland\", \n              \"Ireland\", \"Yemen, Rep.\", \"Libya\", \"Rwanda\"))), \n    aes(label = Country.Name), check_overlap = T, hjust = -0.15, vjust=1.3) +\n  geom_text(data = Ecountrieslbl, aes(label=labels), hjust=0) + \n  geom_text(data = lineAnnotations[1,], aes(label = labels), angle = 25.8, \n            fontface=\"bold\", color=\"#44B4C1\") +\n  geom_text(data = lineAnnotations[2:4,], aes(label = labels), \n            angle = 26, fontface=\"bold\", size = 4) +\n  lims(x= c(-50,450)) + \n  scale_size(range = c(1,12), breaks= c(0.1,2,10), \"GDP in 2021, $trn†\") +\n  scale_fill_manual(values=c(\"#FEC427\",\"#255D91\", \"#B41D11\"), \n    name= \"Freedom Status\", labels=c(\"Free\", \"Partly Free\", \"Not Free\")) + \n  scale_x_continuous(limits=c(-50, 450), n.breaks=10, expand=expansion(0)) +\n  scale_y_continuous(limits = c(-50, 450), n.breaks = 10) +\n  labs(x= \"NTL-estimated GDP\", y=\"Official GDP\") + \n  ggtitle(\"GDP growth, 2002-21, %*\", ) +\n  labs(caption = captiontxt) +\n  theme_minimal()+\n  theme(\n    panel.background = element_rect(fill= \"#F3F0EA\"),\n    plot.background = element_rect(fill= \"#F3F0EA\"),\n    panel.grid = element_line(linetype = 2),\n    panel.grid.major = element_line(size = 0.5, colour = \"grey\"),\n    panel.border = element_rect(color = \"#F3F0EA\", fill=NA),\n    axis.title.y =  element_text(color = \"black\"), \n    axis.text.y = element_text(color = \"black\"),\n    legend.position=c(1, 0.01),\n    legend.justification=c(1, 0),\n    legend.background = element_rect(fill=\"#F3F0EA\", color=\"#F3F0EA\"),\n    axis.line.x.bottom = element_line(color = \"#F3F0EA\"),\n    axis.line.y.left  = element_line(color = \"#F3F0EA\"),\n    plot.title = element_text(face = \"bold\", hjust = 0, size= 15, vjust = 3),\n    plot.caption = element_text(hjust = 0, color =\"#454545\", size = 8)\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2022/100470958/100470958_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2023-01-09T18:57:43+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100385586/",
    "title": "Restrictions on religion among the most populated countries across time",
    "description": "A replication of a graph from Pew Research Center on the \nrestrictions on religion among the 25 most populous countries.",
    "author": [
      {
        "name": "Alejandro Aísa",
        "url": {}
      }
    ],
    "date": "2023-01-08",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original graph\nSet up and libraries\nPrerequisites for the graph\nAdapting the database\nElements and labels\n\nGraph construction\nTechnical features of the graph\nFull code\n\nThe Graph(s)\nVisual features and information transmitted\nUnachieved features\nInteractive options with plotly\n\n\nThe original graph\nThe graph to replicate was originally created by the Pew Research Center.\nIt is an interactive graph depicting the evolution in time of two measures related to religious conflicts: Goverment Restrictions Index (GRI) and Social Hostilities Index (SHI). The 25 most populous countries are included in the graph. Our goal: to replicate it as closely as possible.\nSet up and libraries\nAs with any other project, we have to load some the libraries that will be needed to complete the graph.\n\n\nlibrary(tidyverse)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(ggtext)\nlibrary(RColorBrewer)\nlibrary(showtext)\n\n\nPrerequisites for the graph\nAdapting the database\nFirst, we have to load the data. In this case, it has been directly compiled from the Pew Research Center.\nSome columns are going to be renamed and/or modified to make easier the coding. Also, a new variable is created to give later the colour to the bubbles (geom_point()) via the case_when() function.\n\n\nreligion.df <- read_delim(\"rel.csv\", show_col_types = FALSE)\n\nreligion <- religion.df %>% transmute(\n  year = as.integer(`Year `), \n  GRI = GRI, \n  SHI = SHI,\n  Country = Country, \n  Pop = `Population Size `) %>% \n  mutate(\n# The position is numerically defined according to the score in the variables\n  pos = case_when( \n    (GRI < 2.3 & SHI < 1.4) ~ 1, \n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 1.4) ~ 2, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 1.4) ~ 3, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 1.4) ~ 4,\n    ((GRI >= 0 & GRI < 2.3)   & SHI < 3.6) ~ 2,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 3.6) ~ 3, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 3.6) ~ 4, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 3.6) ~ 5, \n    ((GRI >= 0 & GRI < 2.3)   & SHI < 7.2) ~ 3,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 7.2) ~ 4, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 7.2) ~ 5, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 7.2) ~ 6,\n    ((GRI >= 0 & GRI < 2.3)   & SHI <= 10) ~ 4,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI <= 10) ~ 5, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI <= 10) ~ 6, \n    ((GRI >= 6.6 & GRI < 10)  & SHI <= 10) ~ 7)) %>% \n  mutate(\n    pos = as.factor(pos), \n    Country = as.factor(Country))\n\n\nElements and labels\nAt this preliminary stage, some elements of the graph, such as the breaks, titles and subtitles are defined for the same purpose of making the code easier and more understandable.\nText elements\n\n\ntitle <- paste (\"Restrictions on religion among the 25 most populous countries,\",  \n                \"2007-2020\", sep = \"\\n\")\n\nsubtitle  <- paste ( \n  \"Among the 25 most populous countries, India, Egypt, Pakistan, Indonesia\",\n  \"and Nigeria had the highest levels of overall restrictions on\\n\",\n  \"religion in 2020, while Japan, the United States, Italy, the Democratic\",\n  \"Republic of the Congo and Tanzania had the fewest restrictions.\\n\", \n  \"Click play to see how restrictions have changed in each country since 2007.\",\n  \"Read the full report.\\nYear: {closest_state}\")\n\nX <- \"Government Restrictions Index (GRI)\"\nY <- \"Social Hostilities Index (SHI)\"\n\ncaption <- paste(\n  \"Note, Population data comes from United Nations 2020 population estimates.\", \n  \"Source of the original graph: Pew Research Center, 2022\", \n  sep = \"\\n\")\n\n\nBreaks and aesthetics\n\n\nbreaks_x <- c(0.1, 1.1, 3.35, 5.55, 8.3, 10)\nbreaks_y <- c(0.1, 1.35, 4.1, 6, 9.9, 10)\n\nlabels_x <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\nlabels_y <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\n\n\npal <-c(\"#f7f3d7\",\"#f6e9c8\",\"#f4dbbd\",\"#f5c6ac\",\"#f2b0a2\",\"#e89389\",\"#d48379\")\n\nsysfonts::font_add_google(\"Playfair Display\", family = \"playfair display\")\nshowtext::showtext_auto()  \n\n\nGraph construction\nTechnical features of the graph\nFirst, we include the main aesthetics of the graph; the two variables of the X (GRI) and Y (SHI) axis. The main visual representation is the geom_point(), labelled by country. Sizes depending on population and colour depending on position are also included.\nAt this stage, all the points, regardless of the year are included in the graph.\n\n\np <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 20)+\n  geom_text(aes(label=Country), size = 1.6)\np\n\n\n\nLet’s include the scales!\nWith respect to the colour, we have already defined the palette of colour at the beginning of the construction. Then, we only have to mention it in the scale_colour_manual().\nThe graph is also limited between 0 and 10 in both axis, under a continuous scale (scale_x_continuous). We take advantage of using this function by already including the breaks and labels that would define the levels of religious conflicts.\n\n\np <- p + scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y, \n    labels = labels_y)\n\np  \n\n\n\nIn the next step we add the text elements that will be included in the graph, from the title to the caption. As they were defined before, we only have to specify them in the labs() function.\n\n\np <- p + labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) \np\n\n\n\nNow that we have all the elements that should be included, we have to customize them and bring some order. With a theme_classic() we can have the axis removed. Only some custom horizontal and vertical lines will be needed. The particular features of each element_text() are specified also at this stage.\n\n\np <- p + theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 21),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 11),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())\n\np \n\n\n\nThe final step in constructing the static graph involves the removal of the the guides providing the legend for different aesthetics. Finally, we include the custom lines (geom_vline() and geom_hline()).\nNow we have the fixed graph built, but we have to include a last aesthetic. The one that will be needed to create the animation: the frame. (one per year).\n\n\np <- p + guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\") + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year) \n\np \n\n\n\nFull code\nThe entire process looks like this:\nThe_graph <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 20)+\n  geom_text(aes(label=Country), size = 1.6)+\n  scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y, \n    labels = labels_y)+\n  labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) +\n  theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 21),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 11),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())+\n  guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\") + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year)\nThe Graph(s)\nVisual features and information transmitted\nThe graph consist in a basic scatter plot accounting for the relationship between two variables: GRI and SHI. However, more information is included on it.\nOn the one hand, the size of the geom_points is going to be determined by the population of each country. On the other hand, the colour of the bubble is given by the position in the graph. Each quadrant has its own colour. These combination of factors makes possible that, visually, the amount of religious constraints for each country is rapidly comprehend. The darker the point, the more conflicts related to religion. Technically speaking, it was achieved with the case_when() function at the beginning.\nLastly, we have to include the most important characteristics of the graph. While the interactive part had to be forfeited due to logistical and time constraints, it possesses the animation depicting the evolution in time.\nThis evolutionary feature is provided by GGanimated. Notice how each country change the colour depending on the position within the graph.\n\n\np + transition_states(year) \n\n\n\nUnachieved features\nApart from the interactivity, there are some issues that could not not be fully replicated:\nThe fonts for the titles are not exactly the same as the original.\nThe spacing between lines is smaller than the original.\nThe orientation of the 0 and the 10 of the Y axis is not the correct. The “very high” label is also wrongly positioned.\nIt was not possible to include the link in the last part of the subtitle.\nInteractive options with plotly\nThe library that may be used to provide interactivity to the graph is Plotly via ggplotly(p). However, some technical issues arise when we include this option:\nFirst, dimensions of the chart can not be properly modelled. Fig.height() and fig.weight do not work the same way. As a consequence, the title and subtitle disappear from the graph, some labels move along the axis, etc.\nMore importantly, when the time animation is included, some geom_points get lost, moving along the chart without sense. Thus, as plotly was not the scope of the work, and due the time that would have to be invested to solve these problems, it was decided to forfeit this version of the graph.\n\n\nfig <- ggplotly(p) %>% \nconfig(displayModeBar = FALSE) %>% \nanimation_slider(currentvalue = {\"year\"}) \nfig\n\n\n\n\n\n\n",
    "preview": "projects/2022/100385586/100385586_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2023-01-09T18:57:42+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100386498/",
    "title": "The World Bank's Richer Countries Tend to Have Higher National Poverty Lines Chart",
    "description": "The aim of this project is to recreate and improve a chart from the first Atlas of Sustainable Development Goals.",
    "author": [
      {
        "name": "Isabela Zeberio",
        "url": {}
      }
    ],
    "date": "2023-01-08",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nSustainable Development Goals\nGetting the data\nLibraries\nCountry groups\n\nBuilding the chart\nData\nScale transformation\nAxes and panel grid\nColor of dots\nCountry labels\nText\nLegend\nBackground\n\nFinal chart\nInteractive chart\n\n\nDiagram listing the 17 Sustainable Development Goals. Figure from un.orgThe Atlas of Sustainable Development Goals is a compilation of statistics from over 200 economies about global development and the quality of people’s lives. The Atlas is a visual guide to the trends, challenges and measurement issues related to each of the 17 Sustainable Development Goals (SDGs). The SDGs are an urgent call for action by all countries in a global partnership. The Atlas was first created in 2017 and since then two more editions have been published, 2018 and 2020. From 2017 to 2020 there has been a big change in the visualization of the data.. Therefore, for this project I have decided to focus on recreating a chart from the first Atlas and improve some elements to better represent the idea that richer countries tend to have higher national poverty lines.\nSustainable Development Goals\n\n1. No poverty\n2. Zero hunger\nEnd poverty in all its forms everywhere\nEnd hunger, achieve food security and improved nutrition, and promote sustainable agriculture\n3. Good health and well-being\n4. Quality education\nEnsure healthy lives and promote well-being for all at all ages\nEnsure inclusive and equitable quality education and promote lifelong learning opportunities for all\n5. Gender equality\n6. Clean water and sanitation\nAchieve gender equality and empower all women and girls\nEnsure availability and sustainable management of water and sanitation for all\n7. Affordable and clean energy\n8. Decent work and economic growth\nEnsure access to affordable, reliable, sustainable, and modern energy for all\nPromote sustained, inclusive, and sustainable economic growth, full and productive employment, and decent work for all\n9. Industry, innovation, and infrastructure\n10. Reduced inequalities\nBuild resilient infrastructure, promote inclusive and sustainable industrialization, and foster innovation\nReduce inequality within and among countries\n11. Sustainable cities and communities\n12. Responsible consumption and production\nMake cities and human settlements inclusive, safe, resilient, and sustainable\nEnsure sustainable consumption and production patterns\n13. Climate action\n14. Life below water\nTake urgent action to combat climate change and its impacts by regulating emissions and promoting developments in renewable energy\nConserve and sustainably use the oceans, seas and marine resources for sustainable development\n15. Life on land\n16. Peace, justice and strong institutions\nProtect, restore and promote sustainable use of terrestrial ecosystems, sustainably manage forests, combat desertification, and halt and reverse land degradation and halt biodiversity loss\nPromote peaceful and inclusive societies for sustainable development, provide access to justice for all and build effective, accountable and inclusive institutions at all levels\n17. Partnership for the goals\n\nStrengthen the means of implementation and revitalize the global partnership for sustainable development\n\n\nThe chart I have chosen is from the first SDGs: No poverty. In the section on Reducing poverty in all its dimensions according to national definitions, the figure 1c is introduced to represent how richer countries tend to have higher national poverty lines than poorer ones, and in some cases a richer country may even have a higher national poverty rate than a poorer country.\nThe World Bank’s Chart. Figure from worldbank.orgGetting the data\nThe data consist on country observations of national poverty lines and household final consumption expenditure (HFCE). I retrieved the data from the Jolliffe & Beer Prydz (2016) paper on Estimating International Poverty Lines from Comparable National Thresholds. In the Appendix 2: Poverty lines and economic variables, used in main specifications, there is a table with the data required to replicate the chart.\nLibraries\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(janitor)\nlibrary(showtext)\nlibrary(ggtext) \n\n\nI created the csv file coping the data from the Appendix 2 table. The variables needed to recreate the chart are the following:\n\n\nworld_bank <- read_delim(\n  \"povertyline.csv\", delim = \";\", escape_double = FALSE,\n  col_types = cols(`National poverty line 2011 PPPs` = col_number(),\n                   `Household survey mean 2011 PPPs` = col_number(),\n                   `HFCE (2011 PPPs)` = col_number(),\n                   `GNI (2011 USD, Atlas)` = col_number()),\n  trim_ws = TRUE, skip = 1)\n\n\nworld_bank <-  world_bank %>% \n  janitor::clean_names() %>% \n  select(-c(source_of_national_poverty_rate)) %>% \n  rename(\"country\" = country_territory,\n         \"national_povt_line\" = national_poverty_line_2011_pp_ps,\n         \"household_survey\" = household_survey_mean_2011_pp_ps,\n         \"HFCE\" = hfce_2011_pp_ps,\n         \"GNI\" = gni_2011_usd_atlas) \n\n\n\n\nglimpse(world_bank)\n\nRows: 126\nColumns: 6\n$ country            <chr> \"Zambia\", \"West Bank and Gaza\", \"Vietnam\"…\n$ year               <dbl> 2007, 2009, 2012, 2006, 2011, 2010, 2011,…\n$ national_povt_line <dbl> 1.83, 6.06, 3.35, 6.28, 6.92, 21.70, 21.2…\n$ household_survey   <dbl> 2.66, 10.76, 8.07, 11.63, 23.09, 62.38, 4…\n$ HFCE               <dbl> NA, 9.72, 7.83, 20.99, 30.49, 92.57, 59.1…\n$ GNI                <dbl> 2.62, 5.91, 4.23, 18.59, 32.90, 136.28, 1…\n\n\n\nsummary(world_bank)\n\n   country               year      national_povt_line\n Length:126         Min.   :2001   Min.   : 1.270    \n Class :character   1st Qu.:2009   1st Qu.: 2.203    \n Mode  :character   Median :2011   Median : 4.585    \n                    Mean   :2010   Mean   : 7.872    \n                    3rd Qu.:2011   3rd Qu.: 8.290    \n                    Max.   :2012   Max.   :35.120    \n                                                     \n household_survey       HFCE             GNI        \n Min.   :  1.450   Min.   : 1.220   Min.   :  0.43  \n 1st Qu.:  3.865   1st Qu.: 5.635   1st Qu.:  2.77  \n Median :  9.335   Median :15.880   Median : 11.04  \n Mean   : 22.403   Mean   :22.083   Mean   : 33.57  \n 3rd Qu.: 20.523   3rd Qu.:30.915   3rd Qu.: 35.51  \n Max.   :800.000   Max.   :92.570   Max.   :247.32  \n                   NA's   :11       NA's   :2       \n\nCountry groups\nThe World Bank has an income classification by which it separates countries into four categories based on per capita gross national income (GNI): low-income, lower-middle, upper-middle, and high-income countries. To create the categories, I first calculated the GNI per capita quartile:\n\n\nquantile(world_bank$GNI, na.rm=TRUE)\n\n     0%     25%     50%     75%    100% \n  0.430   2.770  11.040  35.505 247.320 \n\nAfter calculating GNI per capita quartile, I create a new column to group each country in its corresponding category:\n\n\nqntile <-  world_bank %>% \n  mutate(GNI = replace_na(GNI, 0)) %>% \n  mutate(country_class = \n           case_when(GNI <= 2.770  ~ \"Low income\",\n                     GNI > 2.770  & GNI <= 11.040 ~ \"Lower middle income\",\n                     GNI > 11.040 & GNI <= 35.505   ~ \"Upper middle income\",\n                     GNI > 35.505 ~ \"High income\")) \n\n\nqntile %>% group_by(country_class) %>% \n    summarise(country = n_distinct(country)) %>% \n    arrange(desc(country))\n\n# A tibble: 4 × 2\n  country_class       country\n  <chr>                 <int>\n1 Low income               33\n2 High income              31\n3 Lower middle income      31\n4 Upper middle income      31\n\nDespite grouping the countries following the indications from the article by Jolliffe & Beer Prydz (2016), I obtained a slightly different classification. These differences mean that in my final chart some countries (dots) are colored differently than in the original chart.\nTable 2: International Poverty Lines: Median and mean national lines, by group. Figure from Jolliffe & Beer Prydz (2016)In order to maintain the order in which the categories are shown in the legend I used the function factor:\n\n\nqntile$country_class <- factor(\n  qntile$country_class,levels = c(\"Low income\",\"Lower middle income\",\n                                  \"Upper middle income\", \"High income\"))\n\n\nBuilding the chart\nData\nThe World Bank’s chart is a scatterplot in which each dot represents a country, they are colored by income group. The idea is to create a scatterplot with points that have different colors and fills depending on the value of the country_class variable.\nThe variable country_class will be used to determine the color and fill of the plotted points by using these arguments through aes().\nThe y axis has a blank space as label because in the original it is displayed under the title.\nShape 21 of geom_point allows us to use the outline and fill arguments for the dots, which will be important later on.\nstroke enables us to change the line’s width. I will recreate the dots from the original chart by setting a thick outline and filling the dots in white.\n\n\np<-ggplot(qntile) +\n  aes(x=HFCE, y=national_povt_line, \n      color=country_class,\n      fill=country_class) + \n  ylab(\"\") + \n  xlab(\n    \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\"\n    ) +\n  geom_point(size=3, shape=21, stroke=3) \np\n\n\n\nScale transformation\nIn the original chart what is plotted is the log of HFCE and the log of the national poverty line. The limit of the x axis is 100 and the limit of the y axis is 40, and the origin is 1. The breaks of both axes are really specific, thus I specified all of them.\n\n\np <- p + scale_y_log10(\n  limits=c(1, 40),\n  expand=expansion(0),\n  breaks=c(1,1.5,2,3,4,5,7,10,15,20,30,40),\n  labels=c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\"30\",\"40\"))+\n  scale_x_log10(\n    limits = c(1, 100),\n    expand = expansion(0),\n    breaks= c(1,1.5,2,3,4,5,7,10,15,20,30,40,50,70,100),\n    labels = c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\n               \"30\",\"40\",\"50\",\"70\",\"100\"))\np\n\n\n\nThe other major difference with respect to the distribution and classification of the data is that in my chart the relationship between the national poverty line and HFCE starts lower than in the original. I have not been able to figure out why this happens or how to fix it.\nAxes and panel grid\nAs the theme of the original graph is quite peculiar and very different from R’s aesthetics, I will be changing every element to make it as similar as the original instead of using a complete theme.\nI used the theme function to customize the panel and the axes. After specifying the colors of the panel background and lines, and also removing the lines in between the numbers with element_blank, I specified the style of the axes’ numbers and removed the its ticks.\n\n\np <- p + theme(panel.background = element_rect(fill=\"#f8f8f8\"), \n        panel.grid.major = element_line(\n          color = \"#dbddde\",size = 0.5,linetype = 1),\n        panel.border = element_rect(\n          fill = \"transparent\",color = \"#d5d7d8\",size = 0.5), \n        panel.grid.minor = element_blank(),\n        axis.text = element_text(face=\"bold\",\n                                 color=\"#58595b\",size=12),\n        axis.ticks = element_blank())\np\n\n\n\nColor of dots\nThe color of the dots are what made this graph more difficult to recreate. By combining stroke aesthetic with scale_manual, I created a unique scale to specify the World Bank’s aesthetic values. I filled the dots from the Low income and Lower middle income categories in white and those from Upper middle income and High income with its respective color to create the impression that they are solid.\n\n\np <- p +\n  scale_fill_manual(values=c(\"Low income\" =\"white\",\n                             \"Lower middle income\" =\"white\",\n                             \"Upper middle income\" =\"#e28e8e\", \n                             \"High income\" = \"#cd1349\")) +\n  scale_colour_manual(values=c(\"Low income\" =\"#58595b\",\n                               \"Lower middle income\" =\"#939598\",\n                               \"Upper middle income\" =\"#e28e8e\", \n                               \"High income\" = \"#cd1349\")) \np\n\n\n\nCountry labels\nWith the function annotate we can add geoms to the plot passed as vectors which is very useful to display the countries’ labels.\nIn the original chart some dots have a label which indicates the country and the reference year in which data was collected. It is not stated why these countries should be highlighted over the others. In addition, in some cases it is not very clear to which dot the label refers to as some are really close to each other. I specified the position of each label with hjust and vjust which control the alignment of the labels.\nHorizontal(hjust) and vertical(vjust) justification have the same parameterisation, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1. Although it is recommended not to use number outside the range (0, 1), in order to recreate the country labeling of the original chart, I used numbers outside the range.\nTop = 1, middle = 0.5, bottom = 0\nLeft = 0, center = 0.5, right = 1\n\n\np <- p + annotate(\n  \"text\",\n  x = c(1.44, 1.9, 1.58, 2.72, 2.76, 5.96, 5.31, 4.4, 3.79, 5.2, 6.48, 9.28,\n        9.47, 13.9,7.96, 13.36, 12.52, 17.91, 29.61, 22.88,16.46,15.88,\n        28.99, 26.12, 31.85, 35.4, 33.95, 29.28, 27.98, 35.52,35.9,46.8,\n        39.98, 49.03, 63.41),\n  y = c(1.27, 1.45, 1.86, 2.1, 2.53, 1.76, 2.75, 3.7, 3.89, 4.46, 5.19,6.43,\n        7.63, 6.32,2.97, 2.14, 2.60, 3.08, 2.82, 3.38, 3.8, 3.87,5.24, 6.06,\n        7.17, 8.01, 9.16, 9.62,11.07, 12.98, 15.69, 18.63,19.37, 20.33, \n        35.12), \n  label = c(\"Malawi (2010)\",\"Mozambique (2009)\",\"Niger (2011)\",\"Togo (2011)\",\n            \"Guinea (2012)\",\"Lesotho (2010)\",\"Cong, Rep. (2011)\",\"Mauritania \n            (2008)\",\"Comoros (2004)\",  \"Tajikistan (2009)\",\"Azerbaijan \n            (2001)\",\"Honduras (2011)\",\"Bolivia (2011)\",\"Paraguay \n            (2011)\",\"Bhutan (2012)\", \"Namibia (2010)\",\"Sri Lanka \n            (2010)\",\"Swaziland (2010)\",\"Turkey (2011)\", \"Malaysia \n            (2009)\",\"Albania (2012)\",\"Armenia (2011)\",\"Romania (2011)\", \n            \"Montenegro (2011)\",\"Chile (2011)\",\"Poland (2011)\", \"Lithuania \n            (2011)\",\"Croatia (2011)\",\"Estonia (2011)\",\"Czech Rep \n            (2011)\",\"Slovak Rep. (2011)\", \"Spain (2011)\",\"Slovenia (2011)\", \n            \"Ireland (2011)\", \"Norway(2011)\"),\n  hjust = c(0.5, 0.15, 0.5, 1.2, 1.2, 0.65, 1.2, 0.5, 1.25, 1.25, 1.2,1.25,\n            -0.2, 0.5, -0.25, -0.2, -0.15, 0.5,0.3, -0.15, 0.65, -0.2, -0.2,\n            -0.1, -0.15, -0.15, -0.1, 1.15, -0.15, 1.15,-0.15, -0.15, 1.15, \n            0.95, 1.15),\n  vjust = c(2, 2, 2, 0.45, 0.45, 2.5, -1.5, 2.5, 0.35, 0.5, 0.15, 0.1,0,-1.5,\n            0.15, 0.2, 1.15, 3, 3, 0.25, 2, -1.6,0.55, 0, 0.5,0.25, 0.3, \n            0.25, 0.35, 0.5, 0.35, 2.5,0.45, -2, 0.25),\n  size= 3.5,\n  color = \"#58595b\") \np\n\n\n\nText\nIn this segment I add to the chart the title, the subtitle, and the caption. I used a <span> element to set the two colors of the title.\n\n\np <- p +\n  labs(title = \"<span style='color: #cd1449;'>1c<span><span style=\n  'color: #444444;'> Richer countriestend to have higher national poverty lines<span>\",\n       subtitle = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n       x = \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\",\n       y = \"\",\n       caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, \n       Estimating International Poverty Lines from Comparable National Thresholds,\n       Policy Research Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  theme(text = element_text(size = 12),\n        plot.title = element_markdown(face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(hjust=0),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1))\np\n\n\n\nLegend\nThe legend of the original chart is located on the upper left corner of the panel, to move it out there I used the argument of legend.position. Because the legend does not have a title or a key I used element_blank to remove them.\n\n\np <- p + theme(legend.text=element_text(size=10),\n        legend.position = c(0.095,0.91), \n        legend.title = element_blank(),  \n        legend.key = element_blank())\np\n\n\n\nBackground\nThe last touch to replicate the original chart is to color the background in light grey with plot.background. To do this, I first use plot.margin to control the margins around the plot. This code sets top margin to 1 cm, the right margin to 4 cm, the bottom margin to 1 cm, and the left margin to 4 cm. Despite setting the caption to the left of the plot, I could not figure put how to align it with the title and the subtitle.\n\n\np <- p + theme(plot.margin = unit(c(1,4,1,4),\"cm\"),\n          plot.background = element_rect(fill=\"#f8f8f8\"),\n          plot.title = element_markdown (hjust =-0.35),\n          plot.subtitle = element_markdown(hjust=-0.25),\n          plot.caption.position = \"plot\",\n          plot.caption = element_markdown(hjust= -0.25))   \np\n\n\n\nFinal chart\nThe World Bank’s chart is trying to represent the relationship between the HFCE and the national poverty line to showcase how richer countries have higher national poverty lines. The visual channels I will focus on to build an alternative chart are the xy position and the hue.\nTo represent this relationship it is important that the dots of the scatterplot inform us about the values of each country and the global pattern. One possible way to deal with overplotting faceting: the same plot is repeated, each time highlighting another group. A nice way to keep the global and the between groups comparisons is to plot the non-group dots in the background and in light grey (general context data).\nMoreover, I have decided to keep the logarithmic transformation because it helps the visualization of the data. It also helps to the representation of the information that the axes are not shown in logarithmic scale, and are rather displayed in the original scale.\nAs in the original graph it was a bit confusing to know precisely which dot the label was referring to, by now having four facets, there is more space to specify each country. To do this I used library(ggrepel).\nIn addition, to enhance the colors of the dots I used the color scheme by Carto to make more visible the different groups.\n\n\np1 <- ggplot(qntile, \n             aes(HFCE, national_povt_line, color=country_class, label=country)) + \n  geom_point(data = transform(qntile,\n     country_class = NULL), colour = \"grey80\") + \n  geom_point(alpha=0.7) +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\"))+\n  facet_grid(~country_class, scales = \"free\") + \n  theme_bw() + \n  labs(title = \"<span style='color: #CC503E;'>1c<span><span style='color: #000000;'> \n  Richer countries tend to have higher national poverty lines<span>\",\n  subtitle=\"Class country\",\n  x = \"Household final consumption expenditure per capita per day, 2000-12 \n  (2011 PPP $)\",\n  y = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n  caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, Estimating \n  International PovertyLines from Comparable National Thresholds, Policy Research \n  Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  scale_x_log10()+\n  scale_y_log10()+\n  theme(text = element_text(size = 6),\n        legend.position=\"top\",\n        legend.title = element_blank(),\n        legend.background = element_rect(size=0.5, linetype=\"solid\", \n                                  colour =\"#b2b2b2\"),\n        plot.title = element_markdown (face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(face = \"bold\",hjust = 0.5),\n        axis.title.x  = element_markdown(),\n        axis.title.y = element_markdown(),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1)) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\n\np1 <- p1 + ggrepel::geom_text_repel(size=2, aes(label=country),\n                                    box.padding = 0.1,  max.overlaps = 6,\n                                     min.segment.length = 0.05,\n                                    point.size = 2) \np1\n\n\n\nInteractive chart\nAnother alternative visualization is to plot an interactive scatterplot by using ploytly. This way more information is added to every dot without increasing data density:\nCountry\nYear\nNational poverty line\nHousehold final consumption\nGNI\n\n\nlibrary(plotly)\n\np2 <-  qntile %>%\n   mutate(text = paste(\"Country: \", country, \"\\nYear: \", \n                       year, \"\\nNational poverty live: \", national_povt_line,\n                       \"\\nHousehold final consumption: \", \n                       HFCE, \"\\nGNI: \", GNI,sep=\"\")) %>% \n   ggplot(aes(x=HFCE, y=national_povt_line, color = country_class, text=text)) +\n   geom_point(alpha=0.7) +\n   scale_size(range = c(1.4, 19), name=\"Dollars ($)\") +\n   scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\")) +\n   theme(legend.position=\"none\")\n\n\n\n\np2 <- p2 +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_minimal() \n\np2 <- plotly::ggplotly(p2, tooltip=\"text\", type='scatter', mode='markers')\n \np2 <- p2 %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np2 <- p2 %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                              'Household final consumption expenditure',\n                              ticks=\"inside\",showline=TRUE), \n               yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                            showline=TRUE),\n               title=\"1c Richer countries tend to have higher national poverty lines\")\np2\n\n\n\n\n\n\n",
    "preview": "projects/2022/100386498/100386498_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2023-01-09T18:57:42+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 748
  },
  {
    "path": "projects/2022/100392586/",
    "title": "HDI - What a time to be alive",
    "description": "Using the United Nation's Human Development Index (HDI) data to produce The Economist's map and other visualizations.",
    "author": [
      {
        "name": "Emma Perez Hernandez",
        "url": {}
      }
    ],
    "date": "2023-01-08",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting and cleaning data\nBasic elements\nMap and main legend\nSecond legend\n\nProjection and annotations\nProjection\nSpatial coordinates\nAnnotations\n\nFinal result\nAlternative visualization\nPreparing data\nAxes and annotations\nData\nFinal static result\nMoving the wrong direction? 1990 VS 2021\nAdding motion\nAnd finally… a GIF\n\n\nThe Economist published this map in September 2022 in order to highlight that ‘living standards are moving in the wrong direction’.\nIt is striking how most countries in the world have worsened their scores in the Human Development Index (HDI) between 2019 and 2021, which makes the map mainly red. The HDI, calculated by the United Nations since 1990, is a summary measure of average achievement in three key dimensions of human development: life expectancy, education and have a decent standard of living (income per person.)\nThe aim of this tutorial is to reproduce the map and propose an alternative visualization using the same dataset.\nHDI map. Source: The Economist.\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(sf)\nlibrary(giscoR)\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(patchwork)\n\n\n\n\nsysfonts::font_add_google(\"Open Sans\", family = \"Open Sans\")\nshowtext::showtext_auto()\n\n\nGetting and cleaning data\nAll the data needed for this map can be downloaded directly from the UNDP website.\nThey provide a complete data set with the latest ranking (2021), the index value for each country since 1990 and its components. Since the map only shows the change between 2019 and 2021, I select a subset of the data to compute the growth change in the required period, the country name and the ISO3 code.\n\n\nHDI <- read.csv(\"HDR21-22_Composite_indices_complete_time_series.csv\")\n\nmy_data <- HDI %>%\n  select(country, iso3, hdi_2019, hdi_2021) %>%\n  mutate(change = ((hdi_2021 / hdi_2019) - 1) * 100) %>%\n  mutate(change = round(change, 1))\n\n\nTo draw the world map, the giscoR packaged is used to get the geographic information of each country in an sf format, which is required to use geom_sf in ggplot.\n\n\nworld <- giscoR::gisco_get_countries()\nclass(world)\n\n[1] \"sf\"         \"data.frame\"\n\nNow, the geographical information and the HDI data can be joined by the ISO3 code to form the complete dataset. This dataset must also be class sf, so I use st_as_sf to keep this format. Then, the Antarctica is removed from the final data, since this region does not appear in the original map.\n\n\n# checking that both data sets contain the same countries\nhdi_data <- HDI %>%\n  distinct(iso3) %>%\n  as_vector()\nnat_data <- world$ISO3_CODE\ndiffer <- as.data.frame(setdiff(hdi_data, nat_data))\n\nall_data <- st_as_sf(left_join(world, my_data, by = c(\"ISO3_CODE\" = \"iso3\")))\n\nall_data <- all_data %>% filter(!ISO3_CODE %in% c(\"ATA\"))\n\nsummary(all_data)\n\n   CNTR_ID           NAME_ENGL          ISO3_CODE        \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n  CNTR_NAME             FID              country         \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n    hdi_2019         hdi_2021          change       \n Min.   :0.3930   Min.   :0.3850   Min.   :-5.2000  \n 1st Qu.:0.6105   1st Qu.:0.5995   1st Qu.:-1.5000  \n Median :0.7460   Median :0.7390   Median :-0.9000  \n Mean   :0.7275   Mean   :0.7206   Mean   :-0.9838  \n 3rd Qu.:0.8435   3rd Qu.:0.8350   3rd Qu.:-0.3000  \n Max.   :0.9620   Max.   :0.9620   Max.   : 2.6000  \n NA's   :65       NA's   :65       NA's   :65       \n          geometry  \n MULTIPOLYGON :134  \n POLYGON      :122  \n epsg:4326    :  0  \n +proj=long...:  0  \n                    \n                    \n                    \n\nBasic elements\nMap and main legend\nTo start with, the map is plotted by using geom_sf, which automatically interprets the geographical data.\nThe fill aesthetic is set to the variable “change”, and the proper scale fill is added to fix the same breaks and colors than The Economist. The guide for it is guide_colorsteps.\nColor is fixed in white and the size in 0.1 to generate the lines for countries’ contour.\nTheme_map is added, since it sets all chart elements in blank but for the map.\n\n\nm <- ggplot(data = all_data) +\n  geom_sf(aes(fill = change), color = \"white\", size = 0.1) +\n  scale_fill_stepsn(\n    breaks = c(-4, -2, 0, 2),\n    colors = c(\"#be0f08\", \"#f6423c\", \"#ffa9a6\", \"#a4bfd6\", \"#1e5c98\"),\n    na.value = \"#e0ded4\",\n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 1,\n      direction = \"horizontal\",\n      title = NULL,\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  theme_map()\n\nm\n\n\n\nSecond legend\nSince the previous legend does not show the missing values, another legend has to be configured for them. To do so, I get a very small region (Gibraltar), and add it as another map layer with color aesthetic in blank. For this aes, a scale color is defined in which a guide_bins is added specifying the proper color in the override.aes argument.\n\n\nGibraltar <- all_data %>% filter(ISO3_CODE == \"GIB\")\n\nm <- m + geom_sf(data = Gibraltar, aes(color = \"\")) +\n  scale_color_discrete(guide = guide_legend(\n    axis = FALSE,\n    label = FALSE,\n    title = \"No data\",\n    title.position = \"right\",\n    title.vjust = 0.5,\n    title.hjust = 0,\n    title.theme = element_text(\n      size = 8,\n      color = \"grey50\"),\n    override.aes = list(color = \"#e0ded4\", fill = \"#e0ded4\"),\n    order = 2,\n    direction = \"horizontal\"))\nm\n\n\n\nNow that we have both legends, we adjust them with themeoptions to place them in their correct positions and with the same spaces in between\n\n\nm <- m + theme(\n  legend.position = c(0.63, 0.95),\n  legend.key = element_rect(color = \"white\"),\n  legend.key.height = unit(2.2, \"mm\"),\n  legend.key.width = unit(4.7, \"mm\"),\n  legend.margin = margin(0, 0, 0, 0),\n  legend.direction = \"horizontal\",\n  legend.box = \"horizontal\",\n  legend.spacing = unit(4.7, \"mm\"),\n  legend.spacing.y = unit(1, \"mm\"),\n  legend.background = element_blank())\nm\n\n\n\nProjection and annotations\nTo add the black points placed in the center of each of the countries annotated, we can filter them from the\ndataset and get their geographical centers with st_point_on_surface\nAnother dataframe is created for Australia\n\n\npoints <- all_data %>% filter(ISO3_CODE %in% c(\"LBN\", \"BGD\", \"VEN\", \"NAM\"))\ncountries_center <- st_point_on_surface(points)\n\naustralia <- all_data %>% filter(ISO3_CODE == \"AUS\")\n\n\nThen, we can add them in two different layers\n\n\nm <- m + geom_sf_text(\n  data = australia, aes(label = paste(NAME_ENGL, \"1.1\")),\n  size = 2.5,\n  color = \"#1e5c98\") +\n  geom_sf(data = countries_center, size = 0.5)\n\nm\n\n\n\nProjection\nTo this point, all the geographic information available in our dataset has been used, but the map does not look the same than the original because by default the projection used by geom_sf is ……\nSince the one used by The Economist is the Robinson projection, the coordinate system of the map has to be changed in accordance.\n\n\nm <- m +\n  coord_sf(crs = st_crs(\"+proj=robin\"))\n\nm\n\n\n\nSpatial coordinates\nAfter changing the projection, all the following annotations must be in the same Coordinate Reference System, so a new sf object is created with the standard coordinates (latitude and longitude) of each country to be annotated and other for the end of the segment linked to it. Then, they are transformed to the Robinson projection.\n\n\nlebanon <- st_sfc(st_point(c(35.49, 33.9)), crs = 4326)\nlebanon <- st_transform(lebanon, \"+proj=robin\")\nlebanon_end <- st_sfc(st_point(c(-14, 33.9)), crs = 4326)\nlebanon_end <- st_transform(lebanon_end, \"+proj=robin\")\n\nnamibia <- st_sfc(st_point(c(17.7, -23)), crs = 4326)\nnamibia <- st_transform(namibia, \"+proj=robin\")\nnamibia_end <- st_sfc(st_point(c(8, -23)), crs = 4326)\nnamibia_end <- st_transform(namibia_end, \"+proj=robin\")\n\nvenezuela <- st_sfc(st_point(c(-65, 6.5)), crs = 4326)\nvenezuela <- st_transform(venezuela, \"+proj=robin\")\nvenezuela_end <- st_sfc(st_point(c(-85, 6.5)), crs = 4326)\nvenezuela_end <- st_transform(venezuela_end, \"+proj=robin\")\n\nbangladesh <- st_sfc(st_point(c(90, 23.7)), crs = 4326)\nbangladesh <- st_transform(bangladesh, \"+proj=robin\")\nbangladesh_end <- st_sfc(st_point(c(130, 23.7)), crs = 4326)\nbangladesh_end <- st_transform(bangladesh_end, \"+proj=robin\")\n\n\nAnnotations\nWith the elements above, segments and text annotations can be put in place using annotate. The name and the change value of each country are used as labels, and their corresponding colors are also added.\n\n\nm <- m + annotate(\"segment\",\n  x = lebanon[[1]][1], y = lebanon[[1]][2],\n  xend = lebanon_end[[1]][1], yend = lebanon_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = lebanon_end[[1]][1], y = lebanon_end[[1]][2],\n    label = \"Lebanon -5.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = namibia[[1]][1], y = namibia[[1]][2],\n    xend = namibia_end[[1]][1], yend = namibia_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = namibia_end[[1]][1], y = namibia_end[[1]][2],\n    label = \"Namibia -3.8\",\n    hjust = 1.05,\n    color = \"#f6423c\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = venezuela[[1]][1], y = venezuela[[1]][2],\n    xend = venezuela_end[[1]][1], yend = venezuela_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = venezuela_end[[1]][1], y = venezuela_end[[1]][2],\n    label = \"Venezuela -4.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = bangladesh[[1]][1], y = bangladesh[[1]][2],\n    xend = bangladesh_end[[1]][1], yend = bangladesh_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = bangladesh_end[[1]][1], y = bangladesh_end[[1]][2],\n    label = \"Bangladesh 2.6\",\n    hjust = -0.05,\n    color = \"#1e5c98\",\n    size = 2.5)\n\nm\n\n\n\nFinal result\nLastly, adding the proper title, subtitle and caption, and placing them in the same positions, the final map is achieved. The font used is “Open Sans”, which can be downloaded from Google Fonts.\n\n\nm + labs(\n  title = \"What a time to be alive\",\n  subtitle = \"Change in UN Human Development Index, 2019-21, %\",\n  caption = \"Source: United Nations\") +\n  theme(\n    plot.title = element_text(\n      face = \"bold\",\n      family = \"Open Sans\",\n      size = 8,\n      hjust = 0.14,\n      margin = margin(10, 0, 5, 0)),\n    plot.title.position = \"panel\",\n    plot.subtitle = element_text(\n      size = 8,\n      family = \"Open Sans\",\n      hjust = 0.195,\n      margin = margin(0, 0, 1, 0)),\n    plot.caption = element_text(\n      size = 6.5,\n      family = \"Open Sans\",\n      hjust = 0.14,\n      color = \"grey50\",\n      margin = margin(0, 0, 0, 0)),\n    plot.caption.position = \"panel\")\n\n\n\nAlternative visualization\nThe Economist’s map shows just a narrow time span of the evolution of living standards, and it does not allow to see which areas are better off worldwide either. Since the data provided by UN does contain all this information, I want to produce a chart that convey regional disparities and temporal evolution.\nAdditionally, as the HDI index is also produce separately for men and women, it is possible to compute the difference between them for each country and year (if available). In this way, a measure of the gender gap is generated as HDI male - HDI female, whose evolution in time can also be tracked. In this way, a gender perspective is added to the alternative visualization.\nPreparing data\nThe UN’s dataset is in a wide format, with years added to the name of each variable, having more than 1000 columns.\nIn order to produce a tidy dataset with only the required information, I compute it by joining 3 different sub dataframes (main index, male and female) by country and year.\n\n\nHDI <- HDI %>% rename(ranking_2021 = hdi_rank_2021)\n\np <- HDI %>%\n  select(matches(\"^(hdi)(_)([0-9]+)$\"), iso3, country, ranking_2021, region, hdicode) %>%\n  pivot_longer(contains(\"hdi_\"),\n    names_sep = \"_\",\n    names_to = c(\"hdi\", \"year\"), values_to = \"value\"\n  )\n\n\nf <- HDI %>%\n  select(contains(\"hdi_f\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_f\") %>%\n  mutate(year = str_remove(year, \"hdi_f_\"))\n\nm <- HDI %>%\n  select(contains(\"hdi_m\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_m\") %>%\n  mutate(year = str_remove(year, \"hdi_m_\"))\n\nhditotal <- left_join(p, m, by = c(\"year\" = \"year\", \"country\" = \"country\"))\nhditotal <- left_join(hditotal, f, by = c(\"year\" = \"year\", \"country\" = \"country\"))\n\n\nOnce the data is ready, I generate the gender gap variable and convert year to numeric.\nIn addition, I remove the observations related to aggregated areas () and create a Region variable based on the original one used to classify developing regions, where missing values correspond to developed countries.\n\n\nhditotal <- hditotal %>%\n  mutate(\n    f_m_diff = hdi_m - hdi_f,\n    year = as.numeric(year)\n  ) %>%\n  filter(!startsWith(iso3, \"ZZ\")) %>%\n  mutate(Region = case_when(\n    region == \"AS\" ~ \"Arab States\",\n    region == \"EAP\" ~ \"East Asia & Pacific\",\n    region == \"ECA\" ~ \"Europe & Central Asia\",\n    region == \"LAC\" ~ \"Latin America & Caribbean\",\n    region == \"SA\" ~ \"South Asia\",\n    region == \"SSA\" ~ \"Sub-Saharan Africa\",\n    TRUE ~ \"Developed\"))\n\n\nAxes and annotations\nTo start with, I create a vector with the different levels of HDI according to UNDP, which will be used to mark the Y axe.\n\n\nhdi_levels <- c(0.5, 0.7, 0.8, 1)\nhdi_text_levels <- c(\"Low\", \"Medium\", \"High\", \"Very High\")\n\n\nThe axes are fix in a way that maximize the ink ratio, so I first analyze the range of the variables to be displayed in all available years\n\n\nrange(hditotal$value, na.rm = TRUE)\n\n[1] 0.216 0.962\n\nrange(hditotal$f_m_diff, na.rm = TRUE)\n\n[1] -0.0373798  0.2707924\n\nThe year 1990 is selected to create the static plot. The Y axe starts in 0.2 since is the lowest value achieved by HDI, and maximum 1.\nThe X axe limits allow to show the maximum and minimum values of HDI Gender Gap.\n\n\na <- hditotal %>%\n  filter(year == 1990) %>%\n  ggplot() +\n  scale_y_continuous(limits = c(0.2, 1), breaks = hdi_levels) +\n  scale_x_continuous(limits = c(-0.08, 0.28), expand = c(0, 0)) +\n  xlab(\"HDI Gender gap\") +\n  ylab(\"Human Development Index (HDI)\")\na\n\n\n\nNotice that countries in which women are better off than men have a negative value, so they will appear on the left size of 0. To highlight this fact, I add a dashed line in 0. I also add dashed lines in each of the levels of HDI to differentiate them clearly. Additionally, I add an annotation showing the corresponding level under the dashed line. To do so, I specify its position just two decimals below the HDI level mark.\n\n\nhdi_pos_levels <- c(0.48, 0.68, 0.78, 0.98)\n\na <- a + geom_hline(yintercept = c(0.5, 0.7, 0.8, 1), linetype = \"dashed\", color = \"grey\") +\n  geom_vline(xintercept = c(0), linetype = \"dashed\", color = \"grey50\") +\n  annotate(\"text\",\n    y = hdi_pos_levels, x = -0.08,\n    color = \"darkgray\", vjust = 1.3, hjust = 0, size = 3.5,\n    label = hdi_text_levels)\na\n\n\n\nSince I want the background to be blank and other visual details differently, I adjust the elements in theme in accordance.\n\n\na <- a + theme(\n  text = element_text(family = \"Open Sans\"),\n  axis.line.y = element_blank(),\n  axis.line.x = element_line(color = \"gray50\"),\n  axis.ticks = element_blank(),\n  axis.text = element_text(size = 9),\n  axis.title = element_text(size = 9),\n  axis.text.y.left = element_text(margin = margin(10, 10, 10, 10)),\n  panel.grid.major.x = element_line(linetype = 1, color = \"grey\", size = 0.05),\n  panel.grid.minor = element_blank(),\n  panel.background = element_blank())\na\n\n\n\nNow, I add the year we are referring to in a new geom_text layer.\n\n\na <- a + geom_text(aes(0.24, 0.9, label = as.factor(year)), size = 8.5, color = \"gray\")\na\n\n\n\nData\nWe are ready to add the data. In order to show the situation of each country in each year, I will generate a scatter plot with using geom_jitter, in which the aesthetics are set as follows:\n- Human Development Index value for the given year mapped to position Y\n- HDI Gender Gap mapped to position X\n- HDI female for the given year mapped to size\n- Development region mapped to color (hue)\n\n\na <- a + geom_jitter(aes(y = value, x = f_m_diff, color = Region, size = hdi_f), alpha = 0.6)\na\n\n\n\nSince I want to adjust the color paletter and the elements of the legends, I add scale_color_brewer for the color, and scale_size_area for the bubbles’ size.\nIn them, I set the legends options with guide_legend and make bigger color points and title adjustments.\n\n\na <- a +\n  scale_color_brewer(\n    palette = \"Set1\",\n    guide = guide_legend(\n      title = \"Region\",\n      override.aes = list(size = 5),\n      direction = \"vertical\",\n      title.vjust = 1,\n      title.hjust = 0,\n      title.position = \"top\",\n      order = 2,\n      label.theme = element_text(size = 7))) +\n  scale_size_area(\n    breaks = c(0.2, 0.5, 0.7, 0.8, 1),\n    guide = guide_legend(\n      title = \"HDI female\",\n      title.vjust = 1,\n      title.hjust = 0.5,\n      title.position = \"top\",\n      direction = \"vertical\",\n      label.position = \"right\",\n      order = 1))\n\na\n\n\n\nAddint title, subtitle and caption\n\n\na <- a + labs(\n  title = \"Human Development Index and Gender gaps\",\n  subtitle = \"Gender gap =  HDI male - HDI female\",\n  caption = \"Source: United Nations\")\na\n\n\n\nFinal static result\nTweaking legend and titles’ details to fix their sizes and background\n\n\na <- a + theme(\n  plot.title = element_text(face = \"bold\", size = 10),\n  plot.caption = element_text(size = 7.5, hjust = 0, color = \"grey50\"),\n  plot.subtitle = element_text(face = \"italic\", size = 9),\n  plot.title.position = \"plot\",\n  plot.caption.position = \"plot\",\n  legend.key = element_blank(),\n  legend.direction = \"v\",\n  legend.title = element_text(size = 8))\na\n\n\n\nFinally, it is worth annotating the countries which are outliers or have interesting positions in the plot. To do so, I select a bunch of countries and save them in a vector. Them, I filter the dataset to get this names along with its data in 1990. Finally, I add a new geom_text\n\n\ncountries <- c(\"Spain\", \"Afghanistan\", \"China\", \"Yemen\", \"India\", \"Niger\", \"Uruguay\")\n\nlabels1990 <- hditotal %>% filter(country %in% countries, year == 1990)\n\na_lab <- a + geom_text(\n  data = labels1990, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3) \n\na_lab\n\n\n\nMoving the wrong direction? 1990 VS 2021\nHaving the chart for 1990 ready, we can reproduce it for different years using %+% to use the whole data set and filtering the desired year. I create the static chart for 2021 like this\n\n\nd <- a %+% (hditotal %>% filter(year == 2021))\n\nlabels2021 <- hditotal %>% filter(country %in% countries, year == 2021)\n\nd_lab <- d + geom_text(\n  data = labels2021, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3)\n\nd_lab\n\n\n\nPlacing both years together, we can see the changes produced in 40 years of evolution:\nMuch more countries in the “Very High” HDI area\nLess Y dispersion: concentrated in the top par, implying higher HDI in general\nLess X dispersion: most countries between 0 an 0.1 HDI gender gap, with some outliers\nMany more countries at the left side of 0, implying better liver standards for women than for men\nLess very small bubbles: in general, HDI female has risen worldwide\nGreat movement up of the two most populated countries (China, India)\nLow HDI area: Sub-Saharan countries + those with highest gender gap in 2021\n\n\na_lab + (d_lab +plot_layout(guides=\"keep\")) + plot_layout(guides=\"collect\")\n\n\n\nAdding motion\nThe main goal of this visualization is to show historical evolution taking advantage of the time series availability in UNDP data.\nTo achieve that, I use plotly to add the variable year as a frame aesthetic used to add animation.\nIn order to have the labels for all years, I do the same than for 1990 but without filtering for 1990. Then, I add the geom_text as before and save it with a new name (b). Additionally, I set scale_x_continuous(limits = c(-0.08, 0.28)) which replaces the previous one, in which expand was fixed to 0. Now, since plotly does not keep much of the formatting, I allow for more space to keep visible all the elements.\n\n\nall_labels <- hditotal %>% filter(country %in% countries)\n\nb <- a + geom_text(\n  data = all_labels, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3\n) + scale_x_continuous(limits = c(-0.08, 0.28))  \n\n\nBy using %+% hditotal we switch to use the whole data set\n\n\nggplotly(b %+% hditotal + aes(frame = year),\n  width = 750, height = 550,\n  dynamicTicks = FALSE) \n\n\n\nAnd finally… a GIF\nThe package gganimate also allows us add a different kind of motion. It keeps all formatting much better than ggplotly, showing clearly how regions have evolved over the past 40 years, converging towards higher levels of human development (moving up) and reducing the HDI gender gap (moving to the left).\nAs before, we have to use the whole data set. I create a new object for that (c). We also have to add two more lines specific of this package in which we specify the transition time and the way in which it moves.\n\n\nc <-  b %+% hditotal\n\nc <- c +\n  transition_time(as.integer(year)) +\n  ease_aes(\"linear\")\n\n\nNow we just use animate\n\n\n# sizes fit better with this option in the gif\nshowtext::showtext_opts(dpi=96)\nanimate(c, height = 400, width = 600)\n\n\n\n\n\n\n",
    "preview": "projects/2022/100392586/100392586_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2023-01-09T18:57:43+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100383017/",
    "title": "Country Convergence",
    "description": "This project enables the user to recreate a specific graph in OurWorldinData on GDP per capita layer by layer. It also introduces two alternative representations resorting to the same data.",
    "author": [
      {
        "name": "Nacho Pulido Ruiz",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nOn the topic of Economics and Country Convergence\nGraph enhancement\nAlternative representation 1\nAlternative representation 2\n\nOn the topic of Economics and Country Convergence\nOur aim will be to resort to visual tools in R studio and ggplot to study the topic of country economic growth and convergence. Classical Solow-Swan models of growth predict convergence as a function of the deviation of a country from its stationary state (natural level) such that we should expect convergence between LEDC´S and MEDC´s. Our point of departure will be to launch the libraries we will use and to obtain the data from the Maddison Project Database.\nOriginal plot:\n\n\n\nlibrary(tidyverse)\nlibrary(scales)\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                delim = \";\"))\n\n\nA prior step to develop our plot will be to clean and sort the data to prepare it for our ggplot() operations. We will filter for rows containing data for 1950 and 2016 and reshape the data to have two columns accounting for GDP per capita for each country and for each year. This enables the analyst to depict a different axis for each of the years containing observations on GDP per capita.\n\n\ngdp <- gdp %>% \n  rename(gdp_capita = gdp_per_capita) %>% \n  select(country, year,gdp_capita, ) %>% \n  filter(year %in% c(1950,2016)) %>% \n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>% \n  drop_na(\"1950\", \"2016\") %>% \n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\")\n\n\nIt will be useful for us to categorize our countries in three groups (poor, medium and rich countries) by generating a factor column using the ifelse() command in the following way:\n\n\ngdp <- gdp %>% \n  mutate(type = ifelse(gdp_capita_2016<6000,\n                       \"poor\",\n                       ifelse(gdp_capita_2016<40000,\n                              \"medium\",\n                              \"rich\")))\n\n\nIt will be convenient for later (at the labelling stage) to generate a new column indicating the amount of growth an economy has undergone.\n\n\ngdp <- gdp %>% \nmutate(fold = round(gdp_capita_2016/gdp_capita_1950,1)) %>%\n  mutate(fold = paste(fold,\"-fold\"))\n\n\nSince we will have many observations for each of the countries (especially for those with middle income), we will filter for a subset of the data by selecting a random sample of middle income countries and then binding the resulting dataframe to the original one:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n  slice(sample(1:73,35,replace = FALSE))\ngdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nNow we have everything we need to start depicting our graph! We will call our gdp data and pipe it into the ggplot() function, defining the aesthetics desired. The advantage of having previously pivoted our data is that now we have 2 columns which account for the desired variables to be plotted:\n\n\nplot <- gdp %>% \n  ggplot()+\n  aes(gdp_capita_1950,gdp_capita_2016)\nplot\n\n\n\nNow we will add some geometry to our plot. We will choose shape 21 in order to be able to fill the points with a different color from the one we will use for the contouring of it.\n\n\nplot <- plot +\n  geom_point(shape = 21,color = \"red\", size = 1.5, fill = \"aquamarine3\")\nplot\n\n\n\nOur plot requires a lot of labels inside the graph, both for lines and for points. We will take advantage of geom_text() and add some label to the geometry including a subheading accounting for the amount of growth each economy has undergone. We will later work on our annotations to the diagonal lines.\n\n\nplot <- plot +\ngeom_text(aes(label = country), size = 1, nudge_y = -0.02)+\n    geom_text(aes(label = fold), size = 1, nudge_y = -0.05)\nplot\n\n\n\nIt is time to choose appropriately the scales of our plot. A logarithmic scale will we used for both axis and we will have to introduce the dollar symbol to account for the unit of measurement. The breaks have to be manually provided by the analyst to mimic as much as possible the original plot.\n\n\nplot <- plot +\n   scale_x_log10(label = label_number(prefix = \"$\"), \n                 breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                            7000,10000,15000,20000,30000,40000,50000,70000))+\n   \n  scale_y_log10(label = label_number(prefix = \"$\"),\n                breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                           7000,10000,15000,20000,30000,40000,70000))\nplot\n\n\n\nTo stick with the original plot as much as possible, we will introduce some text in our axis and title (including a subtitle) and use a bold font for the latter.\n\n\nplot <- plot +\n  labs(x=\"GDP per capita in 1950\",\n       y = \"GDP per capita in 2016\",\n       title = \"GDP per capita in 1950 and 2016\",\n       subtitle = paste0(\n         \"GDP per capita is expressed in international -$. \",\n         \"This means that it is adjusted for price changes over \",\n         \"time (inflation) and for price differences between countries.\"))\nplot\n\n\n\nThere are many informative lines in our plot used to depict the growth rate of a country in comparison to 1950.. We will use the geom_abline() to choose the slope and intercept of each one and change the color to stick to the original plot. The RGB technique will be used to determine the color of interest and the fourth argument of this function refers to the transparency (alpha), which we will set for the diagonal lines. The intercepts with the y-axis have to be transformed by the logarithm.\n\n\nplot <- plot +\ngeom_abline(slope = 1,intercept = 0, color = \"darkblue\")+\n    geom_abline(slope=1,\n                intercept=log10(c(0.5, 2, 3,\n                                  4.4, 10, 15, 30)), linetype=\"dotted\",\n                color = rgb(0,0,0.5,0.3))\nplot\n\n\n\nIn this section we will work on the theme (appearance of the plot). Notice that each of the axis has some specific color associated with it (in accordance with the horizontal and vertical grid lines). In this case, the background lines are faded and we will resort to the RGB mixture of colors providing an alpha for each color. These kind of lines will be chosen as linetype “dotted to achieve the desired dashed effect. The aspect.ratio will be set to 1 inside the theme to ensure that the proportions of the final plot obey the ones of the original graph.\n\n\nplot <- plot +\ntheme(axis.text.x = element_text(colour = \"darkorchid3\", size = 2.9),\n      axis.title.x = element_text(colour = \"darkorchid3\", size = 9,family = \"serif\"),\n      axis.text.y = element_text(colour = \"cyan3\", size = 4,family = \"serif\"),\n      axis.title.y = element_text(colour = \"cyan3\", size = 9, family = \"serif\"),\n      plot.subtitle = element_text(size = 5, colour = rgb(0,0,0,0.6),hjust = 0.4,\n                                   vjust = 5,family = \"serif\"),\n      panel.background = element_rect(fill = \"white\"),\n      panel.grid.major.x = element_line(color = rgb(0.6,0.196,0.8,0.4),\n                                        linetype = \"dotted\"),\n      panel.grid.major.y = element_line(color = rgb(0,1,1,0.4), linetype = \"dotted\"),\n      plot.title = element_text(size = 14,hjust = -0.2, vjust = 1, family = \"serif\"),\n      aspect.ratio = 1)\nplot\n\n\n\nCoordinates will be kept ass Cartesian but we will employ the use of some limits to mimic the ones from the original plot.\n\n\nplot <- plot +\ncoord_cartesian(xlim = c(400,70000), ylim = c(400,70000))\nplot\n\n\n\nWe will now work on the annotations accompanying the vertical lines which will indicate the amount of growth that each of the countries have experienced since 1950, thus, conveying the idea of convergence/divergence among them.\n\n\nplot <- plot +\nannotate(\"text\", label = \"Countries above this line had positive growth\",\n         color = \"darkgreen\", x = 22000, y = 25000, angle = 45, size = 2.3,\n         family = \"serif\") +\n    annotate(\"text\", label = \"Countries below this line had negative growth\",\n             color = \"red\", x = 26000, y = 23000, angle = 45, size = 2.3,\n             family = \"serif\")\nplot\n\n\n\nIn addition to these annotations, we will add the final text annotations pertaining to the rest of diagonal lines adding a smaller size and accounting them with a different color. The 45 degree angle will be held constant since all lines hold a slope equal to unity but with different intercepts.\n\n\nplot<- plot+\n  annotate(\"text\", label = \"2x poorer\", color = rgb(0,0,0.6,1), \n           x = 61000, y = 36000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"2x richer\", color = rgb(0,0,0.6,1),\n             x = 30000, y = 65000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"3x richer\", color = rgb(0,0,0.6,1),\n             x = 19000, y = 65000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"Global average \\n growth (4.4x)\",\n             color = rgb(0,0,0.6,1),  x = 11000, y = 63000, angle = 45, \n             size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"10x richer\", color = rgb(0,0,0.6,1),\n             x = 5700, y = 67000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"15x richer\", color = rgb(0,0,0.6,1),\n             x = 4000, y = 68000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"30x richer\", color = rgb(0,0,0.6,1),\n             x = 2000, y = 68000, angle = 45, size = 1.9,family = \"serif\")\nplot\n\n\n\nAs a final note, we will recall all the problems we encounter on this plot and use this to propose an enhancement:\nEven with a subset of countries, there is a lot of geometry text overlapping -> We will improve the labelling\nIt is difficult to account for convergence across countries since all countries are plotted independent of their nature -> We will distinguish between groups of countries\nIn order to enable the reader extract information on both the country and the level of growth rate, we will provide to distinctive plots such that one contains country labels whereas the other one will resort to quantitative (regression analysis) information\nConvergence is difficult to observe due to axis selection -> We will modify the vertical axis to depict growth rate and help the reader check for convergence with ease\nGraph enhancement\nWe will use the same graph to propose some enhancements or changes in the way the data is presented in an attempt to ease reader´s comprehension. We will reload the data to our Rstudio code:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                  delim = \";\"))\n\n\nThe same technique employed before to clean and prepare our data will be recycled. Recall we are just proposing an improvement of the visualization, an alternative graph will be proposed in the last section of the project. Once again, we categorize our countries into rich, medium and poor:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nThe main difference with the first plot is that, this time, we will resort to the inclusion of a new column which will summarize the average annual growth rate that each economy has undergone since 1950.\n\n\ngdp <- gdp %>% \n mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100)%>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nAs we mentioned previously, the plot will be the same but we will just change the way the data is presented, so the random filter to select countries will be preserved:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n    slice(sample(1:73,35,replace = FALSE))\n  gdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nWe can begin with our enhanced graph! The aesthetics provided now will be set to the gdp per capita in 1950 and the annual growth rate we computed before. We will make use of our geom_label() again but we will omit supplying R with geom_point() this time. The color of the text will be set to white in order to generate a comfortable contrast with the “filling” by type of economy we had established in our aesthetics.\n\n\nlibrary(ggrepel)\nplot_1 <-gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)+\n    geom_label_repel(aes(label = country), size = 2,\n                     segment.color = 'transparent', max.overlaps = 40,\n                     force = 1, color = \"white\",\n                     show.legend = FALSE)\n    plot_1\n\n\n\nWe will add some labels to our axis and set the title to convey the idea that we are working with convergence. The word “conditional” here refers to the fact that we are going one step further and categorizing our data between types of economies and we will finally visualize the concept of “conditional convergence” presented in the classical Solow model of growth.\n\n\nplot_1 <- plot_1 +\nlabs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_1\n\n\n\nWe will provide a continuous y scale with the percentage suffix to make it obvious that we are working with growth rates here. We will also begin by applying a minimal theme to our plot which will be modified later with slight changes.\n\n\nplot_1 <-\nplot_1 + theme_minimal()+\n    scale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)\n    plot_1\n\n\n\nWe will work on the themes by providing some font in the type of “serif” and eliminating any background grid which may distract the reader. We will not devote much effort into changing the theme appearance because we are just modifying some changes of the original plot, not changing the graph completely. The aspect ratio will be set again to 1 to keep the original proportions.\n\n\nplot_1 <- plot_1 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid = element_blank(),\n      plot.title = element_blank(),\n      aspect.ratio = 1)\nplot_1\n\n\n\nFinally, let´s change the limits on the plot to make it more readable by modifying the arguments of the coordinate system:\n\n\nplot_1 <- plot_1+\n  coord_cartesian(xlim = c(0,10000), ylim = c(-2,7))\nplot_1\n\n\n\nNow we will generate the second plot required for our enhancement resorting to a similar analyis as the one depicted above but focusing on the quantitative side. We will append next to plot_1 the corresponding representation of each linear regression accounting for our three country groups. As usual, we will have to read again our data to make from scratch the desirable transformations:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nOne again, we will have to split our country in three categories and generate our “Growth” column accounting for the rate of increase of GDP per capita that each economy experiences. Factor levels will be reset to obtain the desired order:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\"))) %>%\n    mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100) %>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nNow we can start depicting the second part of our enhancement graph! The first part will consist of piping our already filtered data into ggplot() and select the appropriate aesthetics in which we will feed our argument “fill” with our country type.\n\n\nplot_2 <-  gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)\nplot_2\n\n\n\nNotice that, different to plot_1 in which we mapped a text geometry into the plot to be able to spot each of the countries, our task now is to account for types of countries regardless of their label. Therefore, we will change the geometry to geom_point() and let the point be filled with the type of country while contouring it with a white color:\n\n\nplot_2 <- plot_2 +\ngeom_point(shape = 21, color = \"white\", size = 3)\nplot_2\n\n\n\nWe will add some labels to the axis (the same that we had for our previous plot):\n\n\nplot_2 <- plot_2 +\n labs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_2\n\n\n\nLet´s change the label of the vertical axis by adding a percentage symbol to indicate that it is a measure of percentage growth rate. This has been computed as the average annual growth rate, which is the growth rate required for a country to portray year by year (constant) to achieve the final level of GDP per capita:\n\n\nplot_2 <- plot_2+\nscale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)+\n  theme_minimal()\nplot_2\n\n\n\nNext, we will change the appearance of our plot by modifying slightly the theme layout. Family “serif” will be chosen for the font in order to mimic the one used in the replication of the original plot and the background will be fill with grey. Panel grid lanes will be removed by setting the corresponding argument into element_blank().\n\n\nplot_2 <- plot_2 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid= element_blank(),\n      legend.position = \"bottom\",\n      legend.background = element_rect(size = 2),\n      aspect.ratio = 1)\nplot_2\n\n\n\nFinally, a linear regression line will be passed through each of the country groups to account for conditional convergence. The negative relationship which can be easily spotted once the line of best fit is included shows that, within groups of similar countries holding similar characteristics (depreciation rates, population growth rates etc.), there is convergence. However, the transition of a country from one group to another one is rarely seen.\n\n\nplot_2 <- plot_2 +\ngeom_smooth(method = \"lm\", size = 1, color = rgb(1,1,1,0.3))\nplot_2\n\n\n\nWe will change some limits of this plot to enable the reader focus on the inside and not get distracted with a hughe portion of unused plot:\n\n\nplot_2 <- plot_2 +\n coord_cartesian(xlim = c(0,15000), ylim = c(-2,7))\nplot_2\n\n\n\n\n\nlibrary(ggpubr)\nenhancement <- ggarrange(plot_1,plot_2,  common.legend = TRUE, legend=\"bottom\")\nannotate_figure(enhancement,\n                top = text_grob(\"Gdp per Capita Conditional Convergence\",\n            color = \"red\", size = 19))\n\n\n\nAlternative representation 1\nNow that we have resorted to an enhancement of the original plot in order to provide a measure of within group convergence, we will propose an alternative graphical analysis to show between group divergence. In other words, we will see, for each year, how the distribution of income holds for each of our country groups to highlight the difficulty of an economy of jumping from one group to another one.\nWe will have to read again the data to start from scratch our alternative plot:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nWe will only keep data from 1950 onwards and we will filter for any NA´s present (missing observations). The difference with our previous plots is that we will now use all of our economies (no filter selection) and we will plot, for each year, how income per capita is distributed among our countries (the evolution of distribution of wealth).\n\n\ngdp <- gdp %>%\n    select(country,year,gdp_per_capita) %>%\n    filter(year>=1950) %>%\n    drop_na(gdp_per_capita)\n\n\nWe will pivot our data into wide format because we desire a column indicating the GDP per capita and the corresponding year in order to enable the analyst to generate the new column assigning the type of economy (factor).\n\n\ngdp <- gdp %>% \npivot_wider(names_from = \"year\",\n                values_from = gdp_per_capita,\n                names_prefix = \"Year\") %>%\n    mutate(type = ifelse(Year2016<6000,\n                         \"Poor\",\n                         ifelse(Year2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nNow we will reshape our data back to long format for the sake of our alternative representation. This is a different route we are taking with respect to the original plots, but it will be useful for operating with all years and not just 2 specific ones (as earlier). We separate the pivoted columns to eliminate the unnecesary ones and keep just a year and a gdp per capita column:\n\n\ngdp <- gdp %>% \npivot_longer(starts_with(\"Year\"),\n                 names_to = \"Year\",\n                 values_to = \"gdp_per_capita\") %>%\n    separate(Year, c(\"Yeard\", \"Year\"), remove = TRUE, sep =4) %>%\n    select(-Yeard) %>%\n    drop_na(everything())\n\n\nFinally, we will reorder the levels of our factor for a more appealing representation of our faceting and we will generate a new dataframe which contains all information that our original dataset contained with the exception of country type. We do this because we will use both dataframes in our plot to work with the faceting.\n\n\ngdp <- gdp %>%\n   mutate(type = factor(type, levels = c(\"Poor\",\n                                         \"Medium\",\n                                         \"Rich\")))\n gdp_2 <-\n  gdp %>%\n  select(-type)\n\n\nWe pipe our gdp dataset into ggplot() and define our desired aesthetics:\n\n\nplot <-\ngdp %>%\n  ggplot()+\n    aes(Year,gdp_per_capita)\nplot\n\n\n\nNow we will add two geometries which correspond, in this case, to lines that account for the distribution of income per capita each year and for each economy. First we do this with the original data frame and then we mimic the code with the filtered dataframe and we add some alpha in order to achieve this effect in which the important segment of the data is being highlighted.\n\n\nplot<-\nplot+\ngeom_line(data = gdp_2, color = rgb(0,1,0,0.3))+\n  geom_line(color= rgb(0,1,0,1))\nplot\n\n\n\nNow we facet by type of economy…\n\n\nplot <- plot+\nfacet_wrap(~factor(type))\nplot\n\n\n\nLet´s add some labels to our plot. We will improve the readings of the axis and set a title to account for the divergence between countries. This is the case because we see that, although we did see within group (conditional) convergence in our enhancement plot, now one observes that, if we treat countries as a whole by groups, there is some divergence taking place.\n\n\nplot <-\n  plot+\nlabs(y = \"GDP per capita\", x = \"Time\",\n       title = \"Between Group Divergence\")\nplot\n\n\n\nOnce again, we work the scaling of our graph and change the label of the vertical axis to dollars. Timing will only display some years to avoid overlapping and improve readability.\n\n\nplot <- plot +\nscale_x_discrete(breaks = c(1950,1960,1970,1980,1990,2000,2010))+\n  scale_y_continuous(labels = label_dollar())\nplot\n\n\n\nThe final theme will be set now. We begin with a general dark theme and then make some final adjustments. Years in the horizontal axis will be given some angle to enable us to fit more information and the title will be set in the center of our plot. This will be our first proposal for an alternative representation.\n\n\nplot <- plot +\ntheme_dark()+\n  theme(axis.text.x = element_text(size = 10, angle = 90),\n        strip.text.x =element_text(face = \"bold\"),\n        plot.title = element_text(hjust = 0.5, size =14))\nplot\n\n\n\nAlternative representation 2\nOur previous plot operated with the distribution of income per capita within groups to be able to compare across our three types of economies (e.g. variance and overal growth). Our second proposal for alternative visualization will focus on the between-group convergence and reinforce the idea of the set of hardships involved in the process of an economy evolving from a lower class to a higher one. We load again our data to start from scratch, as usual:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                delim = \";\"))\n\n\nNext, we will have to perform similar operations we resorted to in previous sections by filtering only those years corresponding to 1950 and 2016 and arranging each country into its corresponding group.\n\n\ngdp <- gdp %>%\n  rename(gdp_capita = gdp_per_capita) %>%\n  select(country, year,gdp_capita, ) %>%\n  filter(year %in% c(1950,2016)) %>%\n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n  drop_na(\"1950\", \"2016\") %>%\n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n  mutate(Class = ifelse(gdp_capita_2016<6000,\n                       \"Poor\",\n                       ifelse(gdp_capita_2016<30000,\n                              \"Medium\",\n                              \"Rich\")))\n\n\nThe difference with previous plots is that we will now use the overall average annual growth rate from 1950 to 2016 which is the average growth an economy has yearly undergone to achieve their gdp per capita level in 2016. We also attach a measure of the mean average growth for each of our classes to enable the reader to spot the first differences:\n\n\ngdp <- gdp %>%\n  mutate(AAGR = ((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950))-1)*100)\ngdp %>%\n  group_by(Class) %>%\n  summarise(av_AAGR = mean(AAGR))\n\n# A tibble: 3 × 2\n  Class  av_AAGR\n  <chr>    <dbl>\n1 Medium   2.79 \n2 Poor     0.917\n3 Rich     3.27 \n\ngdp <- gdp %>%\n  filter(Class != \"Rich\") %>%\n  mutate(AAGR_diff = 3.26 - AAGR)\n\n\nWe can now start building our plot layer by layer. We pipe in our already filtered data into ggplot() and set the aesthetics such that the horizontal axis accounts for each of the economies and the vertical one measures the growth rate difference between each country and the average one for rich countries. Therefore, high figures for the vertical axis correspond to countries that need to inject a considerable amount of per capita growth rate (annually) in order to catch up with rich economies and viceversa. The argument introduced in geom_bar() will be set to identity because the default for a bar plot is to count th enumber of observations in a column, and we want to plot the column corresponding to the growth rate difference. Notice that we have reordered from lowest to highest to achieve a visually more attractive graph.\n\n\nplot <- gdp %>%\n  ggplot()+\n  aes(reorder(country,AAGR_diff), AAGR_diff, fill = Class)+\n  geom_bar(stat = \"identity\")\nplot\n\n\n\nNow we will set a void theme for our plot because we want to eliminate any axis text and clean the general appearance (we will work in the themes at the end) and add some labels for the acknowledge the reader with a better understanding of the plot:\n\n\nplot <- plot +\ntheme_void()+\n  labs(title = \"The Spiral of convergence\",\n       subtitle = paste0(\n         \"Countries contained inside the white circle are already growing \",\n         \"at the rate of a rich economy\"),\n       caption = paste0(\n         \"Countries falling in the dark regions require an additional \\n\",\n         \"annual average growth rate to catch up with leading economies\"))\nplot\n\n\n\nNow its time to work on the appareance of our graph. The panel grid lines will be removed by setting an element_blank() argument and the aspect ratio will be set so that we can observe a wider spiral in the final graph. The colors chosen for the bar plots are green and purple which contrast among then whereas the background layers will be set in black as a final step:\n\n\nplot <- plot +\nscale_fill_discrete(type = c(\"purple\", \"green\"))+\n  theme(legend.background = element_rect(color = \"black\"),\n        plot.title = element_text(hjust = 0.5, vjust = 3, size =16),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_blank(),\n        aspect.ratio = 0.8,\n        plot.subtitle = element_text(size = 9,hjust = 0),\n        plot.caption = element_text(size = 9,hjust = 0),\n        legend.key = element_rect(color = \"white\", size = 2),\n        legend.key.width = unit(2,\"lines\"),\n        legend.title = element_text(hjust = 0.5))\nplot\n\n\n\nWe will have to add some annotations in our plot to point the amount of growth injection each economy needs. These lines and annotations will make more sense once the polar coordinates have been applied. We encourage the reader to come back to these steps after the plot is over to understand how each of our elements gets settled in the final spiral.\n\n\nplot <- plot +\ngeom_abline(slope = 0,\n            intercept = c(-2,-1,0,1,2,3,4),\n            color = rgb(0,0,0,0.3), linetype = \"dotted\")+\n  annotate(geom=\"text\", x=-10,\n           y=c(-2,-1,0,1,2,3,4), label=c(\"-2%\",\"-1%\",\"0%\",\"1%\",\"2%\",\"3%\",\"4%\"),\n           color=\"black\",size =3,angle = 28)\nplot\n\n\n\nFinally, we have to add some rectangular geometries for different segments of the plot which will be given some alpha (transparency) to account for best to worse layers. These layers mimic the level curves of a three dimensional bowl in which each layer projected in the floor corresponds to a circle. We will see this once we apply our polar coordinates.\n\n\nplot <- plot +\nannotate(\"rect\", ymin = -2, ymax = -1,\n         xmin = -10, xmax = 110, fill = \"black\", alpha = 0.1)+\n  annotate(\"rect\", ymin = -1, ymax = 0,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.2)+\n  annotate(\"rect\", ymin = 0, ymax = 1,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.3)+\n  annotate(\"rect\", ymin = 1, ymax = 2,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.4)+\n  annotate(\"rect\", ymin = 2, ymax = 3,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.5)+\n  annotate(\"rect\", ymin = 3, ymax = 4,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.6)\nplot\n\n\n\nWe can now apply our polar coordinates!\n\n\nplot <- plot +\ncoord_polar()\nplot\n\n\n\nThe first alternative representation deals with the evolution of the distribution of GDP per capita whereas the second one conveys this information in terms of differences in average growth rates with respect to rich economies. The results arising from the first section of the paper point at the existence of conditional convergence between similar economies and we highlight the difficulties an economy faces in jumping from one class to another in the outcome stemming from our alternative plots.\n\n\n\n",
    "preview": "projects/2022/100383017/images/original_plot.png",
    "last_modified": "2023-01-09T11:25:59+01:00",
    "input_file": {},
    "preview_width": 898,
    "preview_height": 897
  },
  {
    "path": "projects/2022/100481925/",
    "title": "Bump chart: How Americans spend their money",
    "description": "Code to replicate the graph in `ggplot2` and some improvements.",
    "author": [
      {
        "name": "Carolina Cornejo Castellano",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nBackground\nWhat is it for? Representing how Americans distributed their spending in 2021\nWhat can be seen here? Encodings, channels and strengths\nReplication in R\n\nHow can it be improved? Enhancements\nDesigning the enhancements proposal\n\nAlternative visualization(s)\nDesigning the bar plot\nDesigning the lollipop plot\nDesigning the treemap\n\n\nIntroduction\nOn September 25, 2022, the Visual Capitalist, a digital media focused on generating data-centric visual content, published the article How Do Americans Spend Their Money, By Generation? The author of the visualization is Preethi Lodha, and the author of the article is Carmen Ang.\nThis report aims to discuss Preethi Lodha’s (Lodha 2022) graphic in the light of data visualization theory. Thus, some questions that will guide this narrative are: What information does it intend to show? Does it achieve it? How and through what encodings and channels? What are its strengths and points of improvement? Likewise, improvements and alternative visualizations are proposed, which are also not without their own room for improvement.\nBackground\nThe article collected data from the 2021 Consumer Expenditure Surveys (CES) from the U.S. Bureau of Labor Statistics. Specifically, the data used for the visualization was that published in PDF format in Table 2602. Generation of reference person: Annual expenditure means, shares, standard errors, and coefficients of variation.\nThe source of the article and the original graphic can be accessed here. This report was written in December 2022.\nWhat is it for? Representing how Americans distributed their spending in 2021\nFirst, the context and intentionality must be understood. The graphics must be understandable by themselves, and also in their context.\nAs for the article on the Visual Capitalist website, it has as newsworthiness —in Spanish journalist jargon we call it “la pepa”— to show the distribution of Americans’ spending in 2021. Although the title of the article does not specify that the information is from the previous year —it was written and published in 2022—, but the information is from 2021- this type of generalization or omissions are common in the titles and/or in the headlines of journalistic articles: they are licenses that journalists give themselves to attract the reader’s attention. The content of the article clearly specifies the source of information—the PDF—and that it refers to 2021. So it’s not a time series, it’s just a picture of that moment.\nScreenshot of the public Tableau dashboard How Americans spend their money, by Preethi Lodha. Published in: https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/As for the graphic, the author used Tableau to build a bump chart that includes interactive elements when hovering over the dots; but for the purposes of this report, those elements will not be taken into account: only what is seen in the screenshot above is considered.\n\nNote that we use the term bump chart because this type of visualization is commonly found with that name on the Internet. However, in the article of the Visual Capitalist they refer to it as a “graph” and in this report we try to call the other visualizations as “graphic,” as proposed by Wilkinson and Wills (2005).\nBump charts are useful for exploring changes in rank over time across different categories. That is, they usually do not show the actual values of the categories —which in this case would be the money spent by each generation for each spending category—, but the positions in the ranking. In this case, the ranking moves of 14 spending categories are shown, based on the birth year range from the Silent generation (the oldest) to Generation Z.\nAt first glance, this and, in general, all bump charts shows three variables in an easy-to-understand way: category, time and position. That’s especially true in cases of graphics where the only important thing is the ranking. For example, this image from The Washington Post from 2015 shows the “favorite” dog breeds, according to the American Kennel Club, where the three important variables are breed of dog, year, and position in the ranking (Bump 2021).\nArticle published by Philip Bump in The Washington Post: https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/However, there is another important piece of information in Preethi Lodha’s graph, which is the dollar amount spent by each generation for each expenditure category. This is presented within each point and is undoubtedly important if one wants to know how spending is distributed; however, that oscillation is not displayed with any other visual mark and can be misleading. This point will be discussed later.\nWhat can be seen here? Encodings, channels and strengths\nThere are 14 spending categories represented on the Y axis and 5 generations or age ranges showed on the X axis, above the graph and below the title and subtitle, from the Silent generation (the oldest) to the Generation Z.\nAccording to Cleveland (1985), graphs encode data in distinct elements, such as symbols, colors, position, etc. When we study a graphic we perform several mental-visual tasks to extract quantitative information. Some of the basic judgements we perform to decode quantitative information are 1) angle, 2) area, 3) color hue, 4) color saturation, 5) density, 6) length, 7) position along a common scale, 8) position along identical, nonaligned scales, 9) slope, and 10) volume (Cleveland 1985).\nIn consideration of this, the information in the bump chart can be extracted by judgements of position along the vertical scale, which represents the spending categories; the color of each line, which represents the categories of expenditure; the position of each point on the X axis, which represents the generation; and the thickness of the lines, which represents the money spent in each category (the thicker the line the more money has been spent). The closeness of the dots stands for the closeness in the ranking positions. The size of the points does not represent anything.\nCleveland also discusses detection, which he qualifies as the most fundamental perception issue, because before executing any graphical perception task, we must be able to detect the graphical element (Cleveland 1985). Lodha’s bump chart does not show overlaps in the dots, which together with color and position is the most important symbol. The jumps in the ranking are well understood. In broad terms, the graphic is very readable, which is not the same as effective.\nReplication in R\nAn almost exact replica was created using ggplot2,\nThe libraries used were as follows:\n\n\n# Import libraries\nlibrary(tidyverse) # for data manipulation\nlibrary(ggplot2) # for data graphics.\nlibrary(ggtext) # provides markdown and HTML text rendering\nlibrary(grid) # for adding the two white lines at the top and bottom\n\n\nThen, the data was imported. As mentioned above, the data is only a PDF, so the values had to be transcribed manually. After that, we made some transformations.\n\n\ndf <- read_csv(\"data.csv\")\nhead(df)\n\n# A tibble: 5 × 15\n  generation  housing healthcare  food trans…¹ cash_…² enter…³ insur…⁴\n  <chr>         <dbl>      <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 silent        16656       7053  5487    5263    4045    2027    1213\n2 boomers       21273       6594  7651    9327    2876    3476    6309\n3 gen_X         26385       5550 10388   13956    2747    4694   11656\n4 millennials   24052       4026  8463   11052    1163    3457    9249\n5 gen_Z         15449       1354  5529    7929     760    1693    3871\n# … with 7 more variables: miscellaneous <dbl>, apparel <dbl>,\n#   personal_care <dbl>, education <dbl>, alcohol <dbl>,\n#   reading <dbl>, smoking <dbl>, and abbreviated variable names\n#   ¹​transportation, ²​cash_contributions, ³​entertainment, ⁴​insurance\n\n\n\n# Pivot longer, add ranks and order chronologically\ndf <- df %>%\n  pivot_longer(-generation, names_to = \"variables\", values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Manually renaming\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \n  \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance and pensions\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n\n\n# Formatting the dollars' column\ndf$dollars <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars <- paste0(\"$\", df$dollars)\n\n\nCharacter vectors were created to 1) sort the generation names chronologically because ggplot2 displayed them in alphabetical order, 2) format them in HTML language that will later be rendered by the ggtext package, and 3) to add as tag the description of the X-axis.\n\n\nx_names_ordered <- c(\"Silent\", \n                     \"Boomers\", \n                     \"Generation X\", \n                     \"Millennials\", \n                     \"Generation Z\")\n\n\n\n\nx_names_full = c(\n  \n  paste(\"<span style='font-size: 9.55pt'>**Silent**<\/span>\",\n        \"1945 or earlier\",\n        \"**$44,683**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\"<span style='font-size: 9.55pt'>**Boomers**<\/span>\",\n        \"1946 to 1964\",\n        \"**$62,203**\",\n        sep = \"<br>\"),\n\n\n  paste(\"<span style='font-size: 9.55pt'>**Generation X**<\/span>\",\n        \"1965 to 1980\",\n        \"**$83,357**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Millennials**<\/span>\",\n    \"1981 to 1996\",\n    \"**$69,061**\",\n    sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Generation Z**<\/span>\",\n    \"1997 or later\",\n    \"**$41,636**\",\n    sep = \"<br>\")\n\n                )\n\n\n\n\nx_lab <- paste(\n  \"<span style='font-size: 10pt'>**Generation**<\/span>\",\n  \"Birth Year Range\",\n  \"**Average Annual Expenditure**\",\n  sep = \"<br>\"\n              )\n\n\nThen the theme was built. We call this theme theme_bump. Before that, we saved as objects the codes of the two main colors: the one of the background and the one of the text.\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nThe textual elements were changed from element_text to element_markdown of the ggtext package. This allows to use markdown or HTML to design text strings.\n\n\ntheme_bump <- function() {\n\n  # Begin construction of the theme\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n}\n\n\nWe then proceeded to build the bump chart. Note that the following chunk must start with {r fig.width = 8.29, fig.height = 6.88} to display the replica in the same proportions as the original.\n\n\nreplica <- ggplot(\n  data = df,\n  aes(x = generation, \n      y = ranking, \n      group = variables)) +\n  # Add the custom theme just designed\n   theme_bump() +\n  # Add the horizontal lines per generation\n     geom_line(aes(color = variables, \n                   alpha = 1, \n                   # Change line thickness accordingly:\n                   linewidth = rev(ranking))) + \n  # Add the points. The white ones are for the border  \n   geom_point(size = 11.85, \n                color = \"white\") +\n     geom_point(aes(color = variables), \n                size = 11.3) +\n     scale_y_reverse(breaks = 1:nrow(df)) +\n  # Order and \n     scale_x_discrete(\n       limits = x_names_ordered,\n       labels = x_names_full,\n       position = \"top\",\n       expand = expansion(mult = c(0.356, 0.1))\n                    ) +\n  # Titles, subtitle, caption and tag \n  labs(\n    title = \"HOW AMERICANS SPEND THEIR MONEY\",\n    subtitle = \"By Age Group | 2021\",\n    caption = \"Author: Preethi Lodha\",\n    tag = x_lab\n  ) +\n  # Add the two horizontal white lines at the top and the bottom\n    coord_cartesian(clip = \"off\") +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(1.11, 1.11), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(-0.05, -0.05), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n  # Add the Y axis text     \n  geom_text(data = df %>% \n                    filter(generation == \"Silent\"), \n                  aes(label = variables, \n                      x = 0.72236), \n                  hjust = \"outward\", \n                  fontface = \"bold\", \n                  color = \"#272727\", \n                  size = 2.4) +\n  # Add the amount money spent.\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.25, \n                fontface = \"bold\") +\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.253, \n                fontface = \"bold\") +\n      geom_text(data = df, aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.257, \n                fontface = \"bold\") +\n  # Add line colors\n      scale_color_manual(values = c(\n        \"#9c6255\",\n        \"#a0d4ee\",\n        \"#9d8379\",\n        \"#8f93b5\",\n        \"#494c4d\",\n        \"#2f634a\",\n        \"#ed444a\",\n        \"#8a8887\",\n        \"#a13b5d\",\n        \"#87a7a0\",\n        \"#af9e2e\",\n        \"#6d1f29\",\n        \"#466f9d\",\n        \"#3896c4\"\n      )) \nreplica\n\n\n\nTo save the plot:\nggsave(\"replica.png\", \nplot = last_plot(), \npath = \"images\", \nwidth = 8.29, \nheight = 6.88, \nunits = \"in\", \ndpi = 120)\nAs can be seen below, only the small icons at the bottom left and the interactive box at the top right were not reproduced. Since these are interactive elements in the original dashboard, we did not consider it necessary.\nOriginal bump chart created by Preethi Lodha.My replica in ggplot2.How can it be improved? Enhancements\nFrom the start, one might question the need to design a graphic to display these data. Tufte (2013) points out that “[t]ables usually outperform graphics in reporting on small data sets of 20 numbers or less” and that “[t]he special power of graphs comes in the display of large data sets.” This case is not a large data set: in fact, the source is a PDF. This peculiarity has pros and cons: on the one hand, to represent expenditure by generation and expenditure category, it is unnecessary to perform many transformations; but on the other hand, it limits the options for alternative graphics.\nIn terms of features, notwithstanding its goodness, it is noted that this bump chart —and indeed, all of them— give readers the feeling that the difference between each category is about the same because the channels used —width of the lines and distance between them— are the same. Although in this case the thickness of the lines has been manipulated to represent each amount of money, its effect in counteracting that feeling is limited.\nUsing labels within the circles to show the money spent per category and per generation could have been a wise move, following the postulates of Tufte (2013), who points that “[c]lear, detailed and thorough labeling should be used to avoid graphic distortion and ambiguity […].” But, in this case, such labels add an extra layer of information and if the bump chart represents jumps in ranking, these were already encoded in the position of the dots and the jumps in the lines. Moreover, there are examples that even though spending in a certain category decreases from one generation to the next, its position in the ranking goes up and vice versa: just look at the jump from Millennials to Generation Z in the category Personal care products and services; and the jump from Boomers to Generation X in the Food category. Tufte himself would call it “a lying graphic” (Tufte 2013).\n\n“A second defense of the lying graphic is that, although the design itself lies, the actual numbers are printed on the graphic for those picky folks who want to know the correct size of the effects displayed. […]” (Tufte 2013)\n\nSo, if the purpose is to represent the spending distribution of Americans, showing rankings can be misleading. For this reason, the main point of improvement would be to represent spending rather than ranking. This implies to change the type of graph to one where the data items are the money spent and the data attributes are the generation and the category of spending. Tufte (2013), in this regard, postulates that “[t]he representation of numbers, as physically measured on the surface of the graph itself, should be directly proportional to the numerical quantities represented” (Tufte 2013). What visual marks would be the most efficient?\nIn order to continue using lines and dots to represent the data, the proposed enhancements are in a line plot:\nA line plot based on Preethi Lodha’s bump chart. This enhancements proposal also has much room for improvement in concept and implementation. Own elaboration.This is not exempt from problems, both in terms of conception and execution. First, the category with the highest expenditure by far is Housing, but the other categories are very close, which caused problems with overlapping labels. That was the driving force behind plotting only the first 6 expenditure categories. Even so, overlapping continued to exist and the ggrepel package, which would help to solve it, did not really avoid them; it only helped to eliminate the labels that were too close at the cost of dislocating others. Another problem is that, according to Healy (2018), lines illustrate “connection and common fate in that the lines joining the shapes tend to be read left-to-right as part of a series” (Healy 2018). He mentions this when explaining Gestalt rules, which are “the strong inferences we make about relationships between visual elements from relatively sparse visual information.” The author emphasizes that line graphs suggest that the underlying variable is continuous and that is not necessarily advantageous for our data, since the X axis contains the generations, but it is not a continuous variable over time.\nThe Gestalt inferences. Extracted from: Data vizualization: a practical introduction, by Kieran Healy. Published by the author in https://socviz.co/One option was to make a Sankey diagram. These visualize flows of quantities through a process and, as an opinion, are more eye-catching. With a Sankey diagram, we would have split the amount spent by each generation in 2021 into 14 categories of data —or fewer, if we also decide to show only the top categories or to group several ones into “Others”—, and each generation would be a breakdown. However, this would give the false sense that the flow of money changes over a period of time and, in stricto sensu, it is not: spending does not change over time: all the data represented is from 2021. What does change is another categorical variable: generation.\nAn example of a Sanky diagram from Wikimedia Commons:\nWikimedia Commons.In addition, in data visualization, clarity should be privileged over the pomposity: Healy (2018) quotes Tufte about graphical excellence, commenting that it “consists of complex ideas communicated with clarity, precision, and efficiency.” Thus, the idea of a Sankey, despite being relatively simple to execute with the ggsankey package, was discarded. A cleaner, clearer and closer option to Lodha’s original graph is the line plot.\nDesigning the enhancements proposal\n\n\n#Libraries, most of them already used in the replica\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel) # To (try to) avoid label overlappings\n\n\nThe following pipes were useful for obtaining a suitable dataframe:\n\n\ndf <- read_csv(\"data.csv\") %>% \n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  #group_by(generation) %>%\n  arrange(desc(dollars))\n\n\nThen, the data was manipulated. Those code chunks will not be showed here as are the same than in the replica (renaming variables using indexing and generating the same character vectors).\nThe theme was a bit edited. This new version is called theme_lines().\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\n\n\ntheme_lines <- function() {\n\n  theme_bw(base_size = 15) +\n\n    # Background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_blank()) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Legend\n    theme(legend.position = \"bottom\") +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_rect(\n      fill = color_background)) +\n    theme(legend.text  = element_markdown(\n      color = color_text, \n      size = 6.5, \n      face = \"bold\")) +\n    theme(legend.title = element_blank()) +\n    theme(legend.direction = \"horizontal\") +\n    theme(legend.spacing.x = unit(0.3, 'cm')) +\n      \n    # Caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_markdown()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n\n}\n\n\nHere, we started the construction of the line plot. Note that each ggplot2 chunk must start with {r fig.width = 8.29, fig.height = 6.88} for it to be displayed with the same proportions of the original bump chart.\n\n\n# Used by the `ggrepel`. Ensures reproducibility of the same labels disposition\nset.seed(78)\n\n#Select only the head categories:\ndf <- \n  subset(df, variables %in% \n           c(head(unique(df$variables)))) \n\nenhan <- df %>% \nggplot() +\n  aes(x = generation, \n      y =dollars, \n      group = variables, \n      color= variables) + \n # Add lines\n   geom_line(\n    alpha = 0.6, \n    linewidth = 1.4) + \n  # Add points and their border:\n  geom_point(size = 4, \n           shape = 20, \n           alpha = 0.6) +\n  geom_point(size = 3, \n             shape = 1, \n             color=\"white\", \n             alpha = 0.7, \n             stroke = 0.7) +\n  # Order the axis x text\n  scale_x_discrete(\n     limits = x_names_ordered,\n     labels = x_names_full,\n     position = \"top\",\n     expand = expansion(mult = c(0.09, 0.1))\n                  ) +\n  scale_y_discrete(\n    expand = expansion(mult = c(0.001, 0.001))\n                  ) +\n  # Title, subtitle and caption. No tag this time.\nlabs(\n  title = \"HOW AMERICANS SPEND THEIR MONEY\",\n  subtitle = \"Top 6 categories by age group | 2021\",\n  caption = \"Author: Preethi Lodha\"\n) +\n\n# Format dollars spent labels\n   geom_text_repel(\n    aes(label = \n          paste0(\"$\", (format(df$dollars, \n                              big.mark=\",\", \n                              trim=TRUE))), \n      segment.square  = TRUE,\n      segment.inflect = TRUE\n    ),\n    # Max labels overlappings allowed:\n    max.overlaps  = 2, \n    size          = 2.5,\n    fontface      = \"bold\",\n    direction     = \"y\"\n    ) +\n  guides(colour = guide_legend(nrow = 1)) +\n  scale_color_manual(values = c(\n                                \"#ab3a6b\",\n                                \"#494c4d\",\n                                \"#3896c4\",\n                                \"#2f634a\", \n                                \"#af9e2e\",\n                                \"#ed444a\")) +\n  # Add the 2 horizontal white lines\n  coord_cartesian(clip = \"off\") +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(1.13, 1.13), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(-0.05, -0.05), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n  # Add the custom theme \n  theme_lines()\n\nenhan\n\n\n\nThere are 9 unlabeled data points, according to the warning message of the ggrepel package. We save the plot with the following code:\n# Save the plot\nggsave(\"enhancements.png\", \n       plot = last_plot(), \n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,\n       units = \"in\", \n       dpi = 120) # Resolution\nAlternative visualization(s)\nAn attempt was made to design an alternative graphic—and an alternative to the alternative. These, although better, still have some flaws.\nThe design of an alternative graph with the same data involved a nonlinear flow. Cleveland explains that data graphing should be an iterative process: “Iteration and experimentation are important for all of data analysis, including graphical data display. Most times when we make a graph it is immediately [sic] clear that some aspect is inadequate and we regraph the data. In many other cases we make a graph, and all is well, but we get an idea for studying the data in a different way with a different graph; one successful graph often suggests another” (Cleveland 1985).\nThe purposes that the new graph should follow were to make the data stand out and eliminate superfluity (Cleveland 1985). Another important point is ease of understanding. Heer and Bostock (2010) replicated previous studies on graphical perception by evaluating charts that encoded data in different ways. Basically, the best way to represent data is with comparison on a common scale —such as grouped bar charts— and the worst is to show it in areas like treemaps do (these performed even worse than pie charts!) (Heer and Bostock 2010). Given this, the theory suggests simplicity, cleanliness and clarity rather than fancy design details and pomposity. In this case, we went for simplicity even in contradiction to Cleveland, who argues that “[t]he important criterion for a graph is not simply how fast we can see a result; rather, it is whether through the use of the graph we can see something that would have been harder to see otherwise […]” (1985). We believe that it is very important that the graphic shows its main idea at first glance, especially in these days when we have so many visual stimuli on the Internet and they all fight for our attention.\nThus, visual cleanliness is a must, but for those intended for publication in websites such as the Visual Capitalist that target a wide and not necessarily expert audience, it is also a challenge. In addition, there are also studies that suggest that visual embellishment has a positive effect on the comprehension and memorability of graphics (Bateman et al. 2010). How to balance aesthetic taste and graphical excellence and integrity? We had to achieve all this without creating a chartjunk, as Tufte would call it, and without losing the purpose of the data, of the original bump chart and its context, and with a data that is only a small table.\nFor these reasons, the safe bet was to develop a grouped bar chart that shows spending categories, generation and amounts in a clear, simple and uncluttered way, but with a custom theme.\nA grouped bar chart, colorblind-friendly. This is the proposed alternative visualization. Own elaboration.The underlying cause why it is flipped is mainly to avoid label overlappings, which were the major problem in all the visualizations we tried with this data. A colorblind-friendly color palette was made. Also, the grid was eliminated according to Tufte: “one of the most sedate graphical elements, the grid, should usually be muted or completely suppressed so that its presence is only implicit—lest it compete with the data […]. Dark grid lines are chartjunk” (Tufte 2013). We do not agree that much with him in that regard, but we must accept that, at least in this case, they are not necessary: that information is already provided by the labels, which Tufte endorses. The choice of font was a personal choice.\nThis graphic has, however, some flaws: we find that the number of bars make it look bloated even though we reduced their number by including several in the “Others” category.\nAlso, the presence of a legend is not bad per sé, but in this case there are still several categories and the audience would have to constantly go back and forth from the legend to the plot to decipher what represents which bar. However, positioning the name of each spending category instead of the name, birth year range and total spent would make it even more bloated.\nAs the display of multiple bars seemed a bit cluttered even if, in our opinion, the plot delivers the correct visualization, a similar visualization was made. We considered that a lollipop plot could be an even better option, and is a close relative of bar plots.\nA grouped lollipop, also colorblind-friendly. Own elaboration.Clarity was the guideline for this lollipop graphic, too. However, some drawbacks arose: the overlapping labels made us decide to remove any geom_text or geom_label from our code and, contravening Tufte, plot a grid as an alternative. Only minor grids are shown and we set a number of grids that we felt was not exaggerated. We also it dashed and used a very subtle color so that it does not overload the plot too much. Still, it exists.\nBoth plots, even if simple, show the expenses per generation more clearly than the bump chart and have visual encodings, according to Heer and Bostock (2010), capable of being better interpreted than stacked bar charts, bubble charts, pie charts and treemaps, the latter being even less effective than pie charts. This last case caught our attention, as treemaps are quite common in all types of publications and are, in our personal opinion, visually appealing. See here an example of a treemap published by Le Monde newspaper.\nSo, we made one, just for comparison (and learning how-to) purposes:\nA treemap just for clarity comparison. Authors argue that it is not a good option due that areas are hard to compare, even more than angles (like the case of pie charts). Own elaboration.As can be seen, the bar plot is simpler and easier to understand than the treemap, as it uses a single visual mark, the bar, to represent the data. That specific visual mark is always of the same width, so the viewer decodes only the height of the bar to interpret the quantity it encodes. For that reason, the proposed bar plot is more effective at conveying the patterns of the data and to compare the values of different categories.\nWhat cannot be denied about the treemap is that it is visually more attractive, at least to our personal taste. Unfortunately, with this one it is more complicated to interpret the differences in the money spent by each generation in a single category. For example, if there were no money spent labels added, it would be difficult to compare Generation X and Generation Z spending on Housing. Besides, it was way more difficult to design. We could have designed one treemap with 5 subgroups —and not 5 invidivual treemaps and then paste them— and the result would have been more or less similar, but without the spaces between each subgroup and with problems to add specific colors for each generation. The code is at the end of this report.\nDesigning the bar plot\n\n\n# Libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel)\nlibrary(ggpubr)\n\n\nWe first computed the rankings just for the selecting the first categories.\n\n\ndf <- \n  read_csv(\"data.csv\") %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Rename categories lower in the ranking as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\n\nThen, the data was manipulated, and variables renamed.\n\n\n# Format the dollar column\n\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nA character vector for ordering the generations:\n\n\ngen_order <- c(\n  \"Generation Z\",\n  \"Millennials\",\n  \"Generation X\",\n  \"Boomers\",\n  \"Silent\"\n      )\n\n\nWe used the same colors:\n\n\n# Theme colours\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nLater, the custom theme was built. This was called theme_bar().\n\n\ntheme_bar <- function() {\n\n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Format the legend\n    theme(legend.position = \"top\") +\n    theme(\n       legend.text = element_markdown(\n        color = color_text,\n        family = \"Consolas\",\n        size = 7.5,\n        face = \"bold\",\n        hjust = 0)) + \n    theme(legend.title = element_blank()) +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_blank()) +\n\n    # Format de caption\n      theme(plot.caption = element_markdown(\n        hjust = 1, \n        family = \"Consolas\",\n        size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5,\n      margin=margin(4,0.2,4,0.2))) +\n    theme(plot.title.position = \"plot\") +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(4,0.2,4,0.2))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.y = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size = 8.5\n    )) +\n    theme(axis.text.x = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    \n    # Plot margins\n      theme(plot.margin = \n              unit(c(0.2, 0.7, 0.2, 0.7), \"cm\")) # top, right, bottom, left\n}\n\n\nThis is the colorblind friendly palette:\n\n\n#Colorblind friendly palette\ncolorblind <- c(\n                \"#5d3686\",\n                \"#c3a939\",\n                \"#6c7ed7\",\n                \"#b95336\",\n                \"#74a344\",\n                \"#a19f9f\",\n                \"#ba496b\",\n                \"#43c9b0\",\n                \"#c26abb\",\n                \"#ae853d\"\n                )\n\n\nThen the bar plot was designed:\n\n\ntag_house <- \"$26,385\"\n\nbar <- ggplot(df, aes(\n                      fill = reorder(variables, \n                                     desc(dollars)), \n                      y    = dollars,\n                      x    = generation)) +\n    geom_bar(position  = \"dodge\", # for groups\n             stat      = \"identity\",\n             linewidth = 0.05,\n             color     = color_background) +\n  # Add dollars' labels\n geom_text(aes(label = dollars2),\n            position      = position_dodge(0.9),\n            color         = color_text,\n            family        = \"Consolas\",\n            #vjust         = 0.5,\n            hjust         = -0.3,\n            size          = 2.5\n            ) +\n  # Order of the x Axis text\n  scale_x_discrete(\n    limits = gen_order,\n    labels = c(\n       \"**Generation Z**<br>1997 or later<br>**$41,636**\",\n       \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n       \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n       \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n      \"**Silent**<br>1945 or earlier<br>**$44,683**\"\n                )\n    ) +\n  # To manipulate the width of the graphic:\n  scale_y_continuous(\n        expand = c(0.005,0), #0.0632\n                    ) +\n  scale_fill_manual(\n    values = colorblind #colorblind-friendly palette\n                    ) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n   # As one of the bars was too large, we added its label manually as a tag\n    tag = tag_house \n       ) +\n  theme_bar() +\n  theme(\n    legend.box.margin = margin(0.2,2,0.2,0.1, unit = \"cm\"),\n    legend.spacing.x = unit(0.4, 'cm'),\n    plot.title.position = \"plot\",\n    plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 7.5,\n      color = color_background),\n    plot.tag.position = c(0.965, 0.332)) + #horizontal, vertical\n  coord_flip() \n  \nbar\n\n\n\nCode for saving the plot:\nggsave(\"alternative_bar.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the lollipop plot\nThe same bar plot theme was used.\n\n\ngen_order <- c(\n        \"Silent\",\n       \"Boomers\",\n       \"Generation X\",\n       \"Millennials\",\n       \"Generation Z\")\n\n\n\n\nlol <-\nggplot(df)+\n    geom_linerange(aes(\n      x = generation,\n      ymin = 0, \n      ymax = dollars, \n      colour = reorder(variables, desc(dollars))), \n      position = position_dodge(0.8))+\n    geom_point(\n      aes(\n        x = generation,\n        y = dollars,\n        colour = reorder(variables, desc(dollars)),\n      ),\n      size = 4,\n      position = position_dodge(0.8)\n    ) +\n    scale_x_discrete(\n    limits = gen_order,\n    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\",\n               \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n               \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n               \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n               \"**Generation Z**<br>1997 or later<br>**$41,636**\")\n               ) +\n  scale_y_continuous(\n        expand = c(0.03,0),\n        n.breaks = 8\n        ) +\n  scale_color_manual(values = colorblind) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\"\n       ) +\n  theme_bar() +\n    theme(\n          legend.box.margin = margin(0.2,1,0.2,0.2, unit = \"cm\"),\n          legend.spacing.x = unit(0.4, 'cm'),\n          axis.text.x = element_markdown(\n                                        color = \"#3b3b3a\", \n                                        family = \"Consolas\", \n                                        size=7.5\n                                      ),\n          plot.title.position = \"plot\",\n          panel.grid.major.y = element_line(color = \"#b0aeae\",\n                                          linewidth = 0.25,\n                                          linetype = \"dashed\"))\nlol\n\n\n\nThe plot was saved with:\nggsave(\"alternative_lol.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the treemap\nFinally, just for learning and comparison purposes, the treemap code is shown below. As said before, authors do not recommend this kind of visualizations because differences in areas are hard to perceive. Besides, when compared with the bar plot or the lollipop, looks way more bloated and less effective.\n\n\n# Import libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(treemapify)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(ggpubr)\n\n\n\n\n# Import data\ndf <- read_csv(\"data.csv\")\n\n# Data wrangling\n\ndf <- df %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products \\n and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n# Categorize observations with a ranking <= 9 as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\n\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\ndf$ranking <- NULL\n\n\n\n\ntheme_tree <- function() {\n  \n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    #theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_markdown(\n      hjust = 1, \n      family = \"Consolas\",\n      size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), \"cm\")) # top, right, bottom, left\n}\n\n\n\n\n# Format the dollars column.\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nDesigning the 5 treemaps:\n\n\nx <- ggplot(df %>% filter(generation==\"Generation X\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#4b4d27\",\n                              \"#a4a671\",\n                              \"#717342\",\n                              \"#717342\"))\n\nmillennials <- ggplot(df %>% filter(generation==\"Millennials\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#805b28\",\n                              \"#e3af6b\",\n                              \"#c49350\",\n                              \"#c49350\"))\n                              \n\nboomers <- ggplot(df %>% filter(generation==\"Boomers\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left        \n    scale_fill_manual(values=c(\"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#96592d\",\n                              \"#e39762\",\n                              \"#be7c4d\",\n                              \"#be7c4d\"))\n                              \n\nsilent <- ggplot(df %>% filter(generation==\"Silent\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n    scale_fill_manual(values=c(\"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#63431d\",\n                              \"#ba9a73\",\n                              \"#9a7447\",\n                              \"#9a7447\"))\n                              \nz <- ggplot(df %>% filter(generation==\"Generation Z\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n      scale_fill_manual(values=c(\"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#61563f\",\n                              \"#baac91\",\n                              \"#897d65\",\n                              \"#897d65\"))\n\n\nThe treemap was, in fact, five glued treemaps. For that reason, the legend could not be displayed properly, so we made a very simple bar plot containing a legend, and the get_leyend function extracted it. Then, we converted it into an ggplot2 element with the as_ggplot function. This procedure allowed us to use the patchwork package and paste the 5 treemaps plus the legend. The ggpubr and cowplot packages were used for these purposes.\n\n\n# Summarize the spendings per generation\ndf_summ <- df %>%\n    group_by(generation) %>%\n    summarise(total_per_generation = sum(dollars))\n\n\n\n\ngen_order <- c(\"Silent\", \n       \"Boomers\", \n       \"Generation X\", \n       \"Millennials\", \n       \"Generation Z\")\n\n\n\n\n# Set custom colors\nbar_colors <- c(\"#9a7447\",\n                          \"#be7c4d\",\n                          \"#717342\",\n                          \"#c49350\",\n                          \"#897d65\"\n)\n\nbar2 <- ggplot(df_summ) +\n  aes(\n    x = generation,\n    fill = generation,\n    weight = total_per_generation) +\n  geom_bar() +\n  scale_fill_manual(breaks=gen_order, \n                    values = bar_colors,\n                    name = \"\",\n                    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\", \n                               \"**Boomers**<br>1946 to 1964<br>$**62,203**\", \n                               \"**Generation X**<br>1965 to 1980<br>**$83,357**\", \n                               \"**Millennials**<br>1981 to 1996<br>**$69,061**\", \n                               \"**Generation Z**<br>1997 or later<br>**$41,636**\")) +\n  scale_x_discrete(\n    limits = gen_order) +\n  theme_minimal() +\n  theme(plot.margin = unit(c(0,0,0,0), \"pt\")) +\n  theme(legend.text = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) + # top, right, bottom, left\n  theme(legend.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) +\n  theme(legend.position = \"bottom\") +\n  theme(legend.spacing.x = unit(0.5, 'cm'))\n\nbar2\n\n\n\n\n\n# Extract the legend\nlegend_extract <- get_legend(bar2) \n\n\n\n\n# Turn the legend into a ggplot2 object\nlegend <- as_ggplot(legend_extract)\n\n\nPaste all graphics:\n\n\ntree <- legend + ((silent / boomers) | (x / millennials) + z) + \n  plot_layout(\n              nrow = 2,\n              ncol = 1,\n              heights = c(0.5, 6)) +\n  plot_annotation(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n    \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n    theme = theme_tree()\n                  )\n\ntree\n\n\n\nSave plot:\nggsave(\"alternative_tree.png\", \n       plot = last_plot(), \n       path = \"images\", \n       width = 8.29, \n       height = 6.88, \n       units = \"in\", \n       dpi = 300)\nNeedless to say, replicating the graphic and proposing new visualizations were very learning exercises. Being able to design better graphics with cleaner and shorter code is still a longer term task.\n\n\n\nBateman, Scott, Regan L. Mandryk, Carl Gutwin, Aaron Genest, David McDine, and Christopher Brooks. 2010. “Useful Junk?: The Effects of Visual Embellishment on Comprehension and Memorability of Charts.” In Proceedings of the 28th International Conference on Human Factors in Computing Systems - CHI ’10, 2573. Atlanta, Georgia, USA: ACM Press. https://doi.org/10.1145/1753326.1753716.\n\n\nBump, Philip. 2021. “America’s Favorite Dog Breeds for the Past Two Decades, Ranked.” Washington Post, November 25, 2021. https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/.\n\n\nCleveland, William S. 1985. The Elements of Graphing Data. Monterey, Calif: Wadsworth Advanced Books and Software.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical Introduction. Princeton, NJ: Princeton University Press.\n\n\nHeer, Jeffrey, and Michael Bostock. 2010. “Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.”\n\n\nLodha, Preethi. 2022. “How Do Americans Spend Their Money, By Generation?” Visual Capitalist. September 25, 2022. https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/.\n\n\nTufte, Edward R. 2013. The visual display of quantitative information. 2nd ed., 8th print. Cheshire, Conn: Graphics Press.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n\n\n\n",
    "preview": "projects/2022/100481925/images/replica.png",
    "last_modified": "2023-01-09T11:25:59+01:00",
    "input_file": {},
    "preview_width": 994,
    "preview_height": 825
  },
  {
    "path": "projects/2022/100483607/",
    "title": "Distribution of state investment by autonomous communities",
    "description": "This following page is a guide, of how to reproduce step by step, the plot of \"El Mundo Gráficos\" done by the student Pablo Arroyo as a final project for the subject.",
    "author": [
      {
        "name": "Pablo Arroyo Rodriguez",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLabs\nLegend\n\nImprovements\nCode\n\nConclusion\n\nThe distribution of state investment by autonomous communities, it is a tricky topic that each year comes to the news. When the State´s budget is published, almost the first thing that each media do is to analyze what are the communities that receive more, and what are the ones that receive less. This could be important, because depending on the needing of support for the governance, more money would go to one community or another.\nThe point here, is in the differences between Madrid and Catalonia. However, as illustrated here, the budget from Catalonia is closer to Andalusia rather than Madrid. We can see notices of this kind in the national press channel “Catalonia and Andalusia lead state investment with almost twice the budget of Madrid and the Valencian Community” or the “El Mundo” from which I took the graph.\nJ.Aguirre | EL MUNDO GRÁFICOS. Figure from elmundo.es.Getting the data\nApparently, the data could be really easy to obtain from an official source, because if you observe this same data from different papers, figures vary a bit. But, as expected with public institutions, the process is really tedious. So, what I did is to obtain the data from the public institution in charge of this figures in Spain, La Intervención General de la Administración del Estado with data from 2009 to 2022.\nFor data about the budget for the next year, 2023, I used another official page which show the information in a visual way, Ministerio de Hacienda, epdata.\nOnce you get the file with the whole datasheet from one specific year, you have to sum the different budget items by communities. It appears spread by different concepts, as a page in an excel book and repeating the process for the four years. Having done that, it is possible to obtain the data in a .cvs file format. So, we will see how our data looks like:\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggsci)\nlibrary(ggforce)\nlibrary(glue)\nlibrary(systemfonts)\nlibrary(cowplot)\n\nsysfonts::font_add_google(\"Be Vietnam Pro\")\nshowtext::showtext_opts(dpi=300)\n\ndata<- read_delim(\"Clean_Data.csv\", delim = \";\", col_types = \"cnnnn\"  )\nglimpse(data)\n\nRows: 19\nColumns: 5\n$ Comunidad <chr> \"Andalucia\", \"Cataluña\", \"Com. de Madrid\", \"C. Val…\n$ `2018`    <dbl> 1379.7, 1312.1, 1117.2, 700.0, 894.8, 962.7, 533.9…\n$ `2021`    <dbl> 2146.16, 2199.30, 1133.90, 1106.90, 792.60, 799.20…\n$ `2022`    <dbl> 2267.07, 2430.74, 1054.90, 1155.60, 1033.50, 935.2…\n$ `2023`    <dbl> 2318.8, 2508.9, 1305.4, 1269.5, 1077.9, 955.8, 600…\n\nIt is impossible to observe the whole datasheet. So, with the previous function glimpse(), we can take a quick view of the general structure, in order to observe more or less how it is. But for observing the main measures of central tendency from our data and its evolution through this for years, it would be nice to include the summary () function.\n\n\nsummary(data)\n\n  Comunidad              2018             2021        \n Length:19          Min.   :  23.5   Min.   :  24.48  \n Class :character   1st Qu.: 195.3   1st Qu.: 216.80  \n Mode  :character   Median : 363.9   Median : 384.10  \n                    Mean   : 504.7   Mean   : 622.11  \n                    3rd Qu.: 797.4   3rd Qu.: 795.90  \n                    Max.   :1379.7   Max.   :2199.30  \n      2022              2023       \n Min.   :  31.85   Min.   :  28.9  \n 1st Qu.: 192.60   1st Qu.: 241.4  \n Median : 439.30   Median : 481.5  \n Mean   : 666.25   Mean   : 718.1  \n 3rd Qu.: 984.35   3rd Qu.:1016.9  \n Max.   :2430.74   Max.   :2508.9  \n\nOnce we have our raw data, it is time to start giving format to our variables, in order that they appear specifically how we want them, not as mere values in a table.\n\n\ndata<-data %>% \n  pivot_longer(c(\"2018\", \"2021\", \"2022\", \"2023\")) %>% \n  mutate(\n    Comunidad=as.factor(Comunidad),\n    name=as.factor(name),\n  )\n\n\nFirst thing to do is to mutate them as a long format, which is more useful for visualization and statistics approaches. Also, it is important to convert the name of the communities and the name of the year, 2023, 2022, 2021, 2018, as factors. That is the way that we have in R to specify the categories in the representation.\nNow, it is possible to say that our data seems to be what it would be expected to start the construction of the graph.\nBuilding the chart\nThe plot was selected because it could seem easy to reproduce, and was the first time dealing with this kind of representation on my own. However, it started to get harder and harder to deal with this grouped bar chart, and the small details were really time consuming. But finally, it was possible to come up with a result as could be seen in the following lines:\nCoordinates and axes\nI will try to reproduce the graph, step by step, before adding the data and obtaining the whole plot.\n\n\np <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\np\n\n\n\nWith this first chunk of code, the baseline of the plot appears. Based on which, we will be adding information and modifying the different characteristic, in order to satisfy the same specification as in the selected one. However, the names of the communities are all together and it is really difficult to understand. It is a pointless point, so it´s worth it to have a vertical disposition instead of a horizontal one, the categories would be more readable.\nAs it could be seen in the example, the graph has certain limits for the values of our data. One of the first points that we have to do, is to fix those values within the specific categories. In this case from 0 to 3000 in steps of 500. I decided to expand the limits a bit more than this 3000, because otherwise the label for this 3000 extended passed the axis and we could not see it.\nThere are also coordinates for the negative part of the graph despite not having negative information for the budgets. That is because we have to extend the lines and add the names of the communities in this part as annotations, otherwise it would be impossible.\nA good point to highlight here, and which was really hard to find, is how to set the y axis on both sides. Although it is a simple line of code, it took me a while to find this specific chunk of code, so if some of you need this in the future pay attention at this point, because the rest is more or less the same as in all plots.\n\n\np <- p + scale_y_continuous(\n    breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000),\n    limits = c(-1500, 3200),\n    sec.axis = dup_axis(),\n    name = NULL,\n    expand = c(0,0)\n  ) +\n  \n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \"Baleares\", \n               \"Cantabria\", \"Canarias\", \"Asturias\", \"Extremadura\", \n               \"Murcia\", \n               \"Aragón\", \"País Vasco\", \"Castilla-La Mancha\", \n               \"Castilla y León\", \"Galicia\", \"C. Valenciana\", \n               \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\np\n\n\n\nA last comment about this previous chunk. The names of the axis have been deleted, because we do not want it to appear in our last graph, but also, we set a specific order for the name of the communities, based on the highest budget for the year 2023.\nTheme\nThe theme for this project is very easy. As it can be seen, the background of the graph is empty, nothing inside, but for, the lines below the name of each community which separate one community from another. A key point here is that we have established the small tick that appears below each break. Maybe, in this position it is hard to identify, but once we apply for coord_flip() it is more easy to observe.\n\n\np <- p + theme_minimal()+\n  \n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n    \np\n\n\n\nWe have an empty graph, with nothing inside which is the case that we are trying to replicate. However, we need to add the guides, and coord_flip() to see something similar to the original one. So, we will do it.\n\n\np <- p +  coord_flip(clip = \"off\", ylim = c(-1500, 3100))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 3100),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\np\n\n\n\nInstead of having a vertical bar chart which is the usual scenario after applying for these changes, we have a horizontal plot, with nothing inside. The graph is starting to seem similar to the original one. However, it is a kind of graph that by its nature, it is much longer than wider, so we have to change the adjustment of our R.Markdown to obtain what we want.\nNotice, that we have changed the specification of the graph, the plot is more or less what we want. Now is the time to add the data and the annotations.\nAnnotations\nApparently, this graph does not have any kind of annotation. However, it is a bit misleading and there was no other way to add the name of the communities rather than as an annotation. To do so, what I did is to extend the dimension of the plot past the axis, and once we have that, adding in the negative part the name corresponding to the different communities as annotations.\n\n\np <- p + annotate(\"text\", x = 19, y = -1400, hjust=0, \n           label = \"Cataluña\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 18, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13, y = -1400, hjust=0,  \n           label = \"Castilla-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\np\n\n\n\nData\nThis graph is based on grouped data by an autonomous community. With the name of the different communities and their budget from four different years, that is why in the previous steps it was important to pivot longer the data, and establish the different year and communities as_factor(). So, it is the type of grouped bar chart.\nNow, we will add the data to the previous coordinates and axis that we have been preparing, but also we will establish the different colors of the bars.\n\n\np <- p + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\np\n\n\n\nThe graph it is closer to our final result. Few things are still left such as a good title, subtitle and caption. But also, we have to establish a good position for the legend which is almost higher than the plot, and this does not make any sense.\nLabs\nA key point that it is still missing in this graph are the labs. If we see the graph until this point, we do not know what the graph is about without an appropriate title, it is mandatory to modify it, and also adding the different subtitles and comments.\n\n\np <- p + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\n\nHowever, when we add all of these things, our plot is completely a mess, because we have added many different things, without the necessary adjustment. So, everything has moved from one place to another and appears to be untidy. Let´s try to solve it! Basically, we will be adjusting almost every position of the element on the plot.\n\n\np <- p + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n     axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, face=\"bold\", \n                              margin=margin(0,0,0,0)),\n     plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                  size=9.5, color= \"black\", \n                                  face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n    ) \np\n\n\n\nLegend\nHowever, we still have the legend in a position that modifies the whole graph, and we have to change that to obtain a real reproduction.\n\n\np<- p +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.285, 1.05), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n    ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\np\n\n\n\nOnce we have done that, the representation is consistent with what we want, because everything is adjusted and aligned, not as in the previous steps, that when you modify something everything changes and you have to start again. But never give up, you will finish doing it!\nIt is time to introduce the annotation near to the name of each community. I tried to do it at the same time in just one chunk of code, but only the names from 3 different communities and the other disappeared. I do not know the reason well. So that is why I decided to do it step by step although it is longer. Sure, there is a better option.\nAnd also we have to add a little more. Notice that at the bottom of the graph there is more information than just a simple caption, so we have to add also this information. The way that I found better to add this information is by using the ggdraw(), which will be included at the end of the next chunk.\n\n\np<- p +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\np <- ggdraw(add_sub(p, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\n\np\n\n\n\nImprovements\nThe plot that I decided to reproduce, was quite complete with almost all the elements that should be included for a good representation, such as: a nice axis with its reference, annotations of different values, a clear legend, nice colors and so on.\nHowever, as a reader of newspapers I miss an interesting point that all graphs should have, something that draws our attention and keeps us reading the notice. This could be done by introducing some interesting point, or maybe some controversial that keeps readers awake, that is why I decided to do the following graph:\nP.Arroyo | MUCSS.Mainly, I decided to do two thing:\nAdding the name of the policy party that is in charge of each community.\nIncluding the evolution of the budget per community with an ascending or descending arrow.\nBy doing that, we include some controversial questions that encourage readers to go deeper in the theme. That is because, as said in the introduction, in Spain it is believed by many people that the budget that each community receives depends on sympathy with the central government.\nWhat, surprised me when I was doing this tutorial, is that also the original author of the previous graph, Javier Aguirre, has introduced some modifications in line with the ones that I was doing. The idea was the same, but his ones were more visual so I decided to continue my path in that way because it was just a few lines of code and the appearance was better. “See news with the final graph” This is a good point to remark, that once you get a nice graph, there is always a way to improve it based on the previous one.\nI have to point out that I don’t like in his definitive graph the inclusion of the top X axis, because there is so much information in the positive part that you will end up missing.\nCode\nI want to comment on the key point that I made to modify the whole graph. Also, I know that a good point of improvement is reducing the code to reproduce exactly the same, by for example using sequences that is something that I would like to do in future steps.\nMain points to highlight:\nExtending the limits of the axis passed the data, from -1500 to 4500, to introduce the different elements as annotations.\nSelecting just one X axis for reference instead of dup_axis(), in order not to overload the plot.\nCompute the percentage variation and add the different elements as annotations in this new axis.\nNevertheless, I include the whole chunk of code, knowing as I said before that there is enough space to do it in fewer lines, but the first step is a nice way of starting.\n\n\n### Coordinates and axes\nt <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\nt <- t + scale_y_continuous(\n  breaks = c(0, 1000, 2000, 3000),\n  #sec.axis = dup_axis(),\n  name = NULL,\n  expand = c(0,0)\n) +\n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \n               \"Baleares\", \"Cantabria\", \"Canarias\", \"Asturias\", \n               \"Extremadura\", \"Murcia\", \"Aragón\", \"País Vasco\", \n               \"Castilla-La Mancha\", \"Castilla y León\", \"Galicia\", \n               \"C. Valenciana\", \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\n### Theme\nt <- t + theme_minimal()+\n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n\nt <- t +  coord_flip(clip = \"off\", ylim = c(-1500, 4500))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 4500),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\n### Annotations for the left name of the communities\nt <- t + annotate(\"text\", x = 19.2, y = -1400, hjust=0, \n                  label = \"Cataluña\", size = 3, \n                  colour = \"#262626\")+\n  annotate(\"text\", x = 18.2, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17.2, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16.2, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15.2, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14.2, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13.2, y = -1400, hjust=0,  \n           label = \"C.-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12.2, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11.2, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10.2, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9.2, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8.2, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7.2, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6.2, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5.2, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4.2, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3.2, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2.2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1.2, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\n##Annotations for adding the different boxes based on the party in charge of each community\nt<- t + annotate(geom = \"rect\", xmin = 19, xmax = 18.75,\n                 ymin = -1400, ymax = -1200, fill = \"#f3af44\", alpha = 1) + #Cataluña\n  annotate(geom = \"rect\", xmin = 18, xmax = 17.75, #Andalucia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 17, xmax = 16.75, #Com.Mad\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 16, xmax = 15.75, #C.Valenciana\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) + \n  annotate(geom = \"rect\", xmin = 15, xmax = 14.75, #Galicia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 14, xmax = 13.75, #CyL\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 13, xmax = 12.75, #C.Mancha\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 12, xmax = 11.75, #País Vasco\n           ymin = -1400, ymax = -1200, fill = \"#22823a\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 11, xmax = 10.75, #Aragon\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 10, xmax = 9.75, #Murcia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 9, xmax = 8.75, #Extremadura\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 8, xmax = 7.75, #Asturias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 7, xmax = 6.75, #Canarias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 6, xmax = 5.75, #Cantabria\n           ymin = -1400, ymax = -1200, fill = \"#81b881\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 5, xmax = 4.75, #Baleares\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 4, xmax = 3.75, #Navarra\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 3, xmax = 2.75, #Rioja\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 2, xmax = 1.75, #Melilla\n           ymin = -1400, ymax = -1200, fill = \"#d9d9d9\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 1, xmax = 0.75, #Ceuta\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1)\n\n###Annotation for the ascendent/descent arrow based on the budget.\nt<- t + geom_segment(\n  x = 18.85, y = 3700,\n  xend = 19.1, yend = 3700,\n  lineend = \"round\", \n  linejoin = \"round\",\n  size = 1, \n  arrow = arrow(length = unit(0.3, \"cm\")),\n  colour = \"#1d1d1b\" \n) +\n  geom_segment(\n    x = 17.85, y = 3700,\n    xend = 18.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 16.85, y = 3700,\n    xend = 17.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 15.85 , y = 3700,\n    xend = 16.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 14.85 , y = 3700,\n    xend = 15.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) + \n  geom_segment(\n    x = 14.1 , y = 3700,\n    xend = 13.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 12.85 , y = 3700,\n    xend = 13.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 11.85 , y = 3700,\n    xend = 12.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.85 , y = 3700,\n    xend = 11.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.1 , y = 3700,\n    xend = 9.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 8.85 , y = 3700,\n    xend = 9.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 7.85 , y = 3700,\n    xend = 8.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 6.85 , y = 3700,\n    xend = 7.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 5.85 , y = 3700,\n    xend = 6.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 4.85 , y = 3700,\n    xend = 5.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 3.85 , y = 3700,\n    xend = 4.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.85 , y = 3700,\n    xend = 3.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.1, y = 3700,\n    xend = 1.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 1.1 , y = 3700,\n    xend = 0.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  )\n\n### Annotation fot the variations in the GDP.\n\nt<- t + annotate(geom = \"text\", x = 18.975, y = 3950,\n                 label = \"3.2\", hjust = 0, size = 3) + #Cataluña\n  annotate(geom = \"text\", x = 17.975, y = 3950,\n           label = \"2.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.975, y = 3950,\n           label = \"13.4\", hjust = 0, size = 3) + #Madrid\n  annotate(geom = \"text\", x = 15.975, y = 3950,\n           label = \"5\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.975, y = 3950,\n           label = \"0.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.975, y = 3950,\n           label = \"-4.2\", hjust = 0, size = 3) + #CyL\n  annotate(geom = \"text\", x = 12.975, y = 3950,\n           label = \"11.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 11.975, y = 3950,\n           label = \"14.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.975, y = 3950,\n           label = \"4.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.975, y = 3950,\n           label = \"-33.4\", hjust = 0, size = 3) + #Murcia\n  annotate(geom = \"text\", x = 8.975, y = 3950,\n           label = \"16.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.975, y = 3950,\n           label = \"7.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.975, y = 3950,\n           label = \"23.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 4.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.975, y = 3950,\n           label = \"34.7\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.975, y = 3950,\n           label = \"12.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.975, y = 3950,\n           label = \"-24.4\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.975, y = 3950,\n           label = \"-9.3\", hjust = 0, size = 3) \n\n\n##Anotation for adding the different text of the party in charge!\n\nt<- t + annotate(geom = \"text\", x = 18.875, y = -1100,\n                 label = \"ERC\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 17.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 15.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 12.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) + \n  annotate(geom = \"text\", x = 11.875, y = -1100,\n           label = \"PNV\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 8.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.875, y = -1100,\n           label = \"PRC\", hjust = 0, size = 3) + ##Cantabria\n  annotate(geom = \"text\", x = 4.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.875, y = -1100,\n           label = \"Indep\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) \n\n\n##Anottation for the tittle of this column\nt<- t + annotate(geom = \"text\", x = 19.68, y = 3200,\n                 label = \"Var. % 2022/23\", hjust = 0, size = 3, fontface = \"bold\")\n\n### Adding the data\nt <- t + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\n### Labs\nt <- t + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\nt <- t + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n    axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, \n                              face=\"bold\", margin=margin(0,0,0,0)),\n    plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                 size=9.5, color= \"black\", \n                                 face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n  ) \n\n###Anotations for the homemade guide about the different policies parties.\n\nt<- t + annotate(geom = \"text\", x = 20.5, y = -1500,\n                 label = \"Presidencias de las CCAA\", hjust = 0, size = 3) +\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -1500, ymax = -1300, fill = \"#e52b43\", alpha = 1) +#Color PSOE\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -500, ymax = -300, fill = \"#0086c5\", alpha = 1) + #Color PP\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 500, ymax = 700, fill = \"#f3af44\", alpha = 1)+ #Color ERC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 1500, ymax = 1700, fill = \"#22823a\", alpha = 1)+ #Color PNV\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 2500, ymax = 2700, fill = \"#81b881\", alpha = 1)+ #Color PRC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 3500, ymax = 3700, fill = \"#d9d9d9\", alpha = 1)+ #Color Indep.\n  annotate(geom = \"text\", x = 20.125, y = -1275,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 20.125, y = -275,\n           label = \"PP\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 725,\n           label = \"ERC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 1725,\n           label = \"PNV\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 2725,\n           label = \"PRC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 3725,\n           label = \"Indep.\", hjust = 0, size = 3)\n\n### Legend\nt<- t +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.295, 1.027), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n  ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\n\nt<- t +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\nt <- ggdraw(add_sub(t, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\nt\n\n\n\nConclusion\nOnce I completed the whole project, I have to say that it is a challenging process. You will be dealing with new tools that we have never seen before although they are really useful.\nYou will realize that after many hours of work, those things that in the first lesson sound like double Dutch to us, little by little everything starts to make sense. So, enjoy the process because this wonderful world of Data Visualization has many things to discover.\n\n\n\n",
    "preview": "projects/2022/100483607/ccaa470.jpg",
    "last_modified": "2023-01-09T11:25:59+01:00",
    "input_file": {}
  },
  {
    "path": "projects/2022/100489635/",
    "title": "GDP Forecasts for China's Cities by 'The Economist': Coastal Areas Have the Highest Growth Potential",
    "description": "A layer-by-layer construction of a map of China containing information on forecasted GDP growth and population for over 100 cities.",
    "author": [
      {
        "name": "Elena Yustres",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original chart\nObtaining and processing the data\nBuilding the plot\n\nEvaluation and potential enhancements\nAlternative visualization\n\nAs both a cause and consequence of China’s rapid economic growth, the proportion of the country’s population living in cities has soared from 20% in 1980 to 60% in 2020. However, China’s Zero-Covid policy has stilted growth significantly. The “China Emerging City Rankings, 2022” Report, launched by the Economist Intelligence Unit (EIU), assesses the growth potential of 108 cities predicted to have a population of more than 1 million by 2025. Scores are calculated using historical data and forecasts on variables including demography, the local economy or the environment.\nThe Economist’s “March of the cities” map. Figure from economist.com.This post will seek to replicate this map, propose incremental enhancements and suggest an alternative visualization that depicts the relationship between growth potential, population and location (or distance to the coastline) taking cities as our units of analysis.\nThe original chart\nObtaining and processing the data\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(showtext)\nlibrary(maps)\nlibrary(maptools)\nlibrary(svglite)\nlibrary(plyr)\n\nsysfonts::font_add_google(\"IBM Plex Sans\", family=\"IBM Plex Sans\")\nshowtext::showtext_auto()\n\n\nDiving into data collection, we obtained the data on the ranking and population of our units of analysis from the EIU (‘Global Geo-Political Trends and Economics’ section) after contacting their office in Asia by email.\n\n\nranking <- read_csv(\"ranking.csv\")\npopulation <- read_csv(\"population.csv\")\n\n\nOnce we have loaded both sets of data, the summaries below show that the ‘ranking’ dataset contains data on scores for 106 cities (ordered from highest, i.e. Ranking = 1, to lowest) while the ‘population’ dataset includes population data for 397 cities in China.\n\n\nglimpse(ranking)\n\nRows: 106\nColumns: 2\n$ City    <chr> \"Hangzhou\", \"Shenzhen\", \"Shanghai\", \"Suzhou\", \"Guang…\n$ Ranking <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\nglimpse(population)\n\nRows: 397\nColumns: 2\n$ City       <chr> \"Shanghai\", \"Beijing\", \"Shenzhen\", \"Guangzhou\", \"…\n$ Population <dbl> 22315474, 18960744, 17494398, 16096724, 13568357,…\n\nIn order to get both attributes (“Ranking” and “Population”) on the same dataset, we used a left_join to merge both datasets by the unit of analysis (“City”). This produced a dataset with both variables for the 106 cities provided by the EIU. Please note that, while the original map in the article by ‘The Economist’ includes 108 cities, the EIU only provided us with data on 106.\n\n\noutput <- ranking %>% left_join(population, by=\"City\")\n\n\nIn order to obtain the “longitude” and “latitude” of each city, we used the world.cities database. This database includes these and other variables for over 40,000 cities in the world. We then filtered the cities in China and selected (as well as renamed) the variables of interest to later on construct my final database.\n\n\ndata <- world.cities %>%\n  filter(country.etc==\"China\") %>%\n  dplyr::select(name, lat, long) %>%\n  dplyr::rename(\"City\"=\"name\", \n         \"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\") \n\n\nWe then merged the location dataset (‘data’) and the dataset with information on ranking and location (‘output’).\n\n\nfulloutput <- output %>% left_join(data, by=\"City\")\n\n\nThe data also required some cleaning and adjustment. First, there were two cities with the same name (i.e. Suzhou) in the EIU ranking. Since they are located in different provinces, we used population and location data to cross check which city corresponded to which score provided by the EIU and renamed one of them to establish the difference. Second, there were several other cities in the ‘data’ dataset with the same name as cities in the ‘output’ one, which led to there being more than one row for each unit of analysis in the ‘fulloutput’ table. We removed the appropriate rows, as well as the rows for which latitude and longitude data were not available (i.e. NAs for those variables). We are left with 104 rows.\n\n\nfulloutputclean <- fulloutput[-c(5, 23, 49, 51, 70, 81, 104, 113),]\nfulloutputclean <- fulloutputclean[!is.na(fulloutputclean$Latitude) \n                                   & !is.na(fulloutputclean$Longitude), ]\nhead(fulloutputclean, 5)\n\n# A tibble: 5 × 5\n  City      Ranking Population Latitude Longitude\n  <chr>       <dbl>      <dbl>    <dbl>     <dbl>\n1 Hangzhou        1    9236032     30.2      120.\n2 Shenzhen        2   17494398     22.5      114.\n3 Shanghai        3   22315474     31.2      121.\n4 Suzhou          4    6715559     31.3      121.\n5 Guangzhou       5   16096724     23.1      113.\n\nThe final step in data processing was obtaining the data to plot the underlying map of China and its provinces. The ggplot2-china-map repository contains such information. We used the readOGR function to read the ‘shapefile’, cleaned the data and fortified into a dataframe. We then instructed that the islands in the South China Sea not be drawn by selecting only observations with “AREA” above 0.005. Finally, again, we renamed variables accordingly.\n\n\nchina <- rgdal::readOGR(dsn=(\"./china_shapefile/\"), layer=\"bou2_4p\", verbose=FALSE)\nchina@data$id<-rownames(china@data)\nchina.points<-fortify(china, region=\"id\")\nchina.df<-join(china.points, china@data, by=\"id\")\nchina<-subset(china.df, AREA>0.005) %>% \n  dplyr::rename(\"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\",\n         \"Grouping\"=\"group\")\n\n\nBuilding the plot\nCoordinates of the map and data points\nUsing the data loaded in ‘china’ in the last step, we use geom_polygon() to draw the underlying map. The aes argument maps the longitude and latitude columns to the x and y coordinates, respectively. This function is also used to specify the fill and the transparency (alpha) level of the map.\nWe then use geom_path() to set the line demarcating the province limits. After indicating the use of the same variables and the same dataset as for the geom_polygon() function, we set the color and size of the border.\nFurther, coord_map() sets the coordinate system for the map by projecting the defined portion of the Earth onto a flat 2D plane.\n\n\np <- ggplot() +\n  geom_polygon(data=china,\n            aes(x=Longitude, y=Latitude, group=Grouping),\n            fill=\"cornsilk3\",\n            alpha=0.3) +\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping),\n            color=\"white\",\n            size=0.2) +\n  coord_map() \np\n\n\n\nNext, we add the data points at the specific locations of the 104 cities (defined by their latitude and longitude) with geom_point(). Thus, on top of the map, we are plotting a scatterplot using data from ‘fulloutputclean’ where each point represents one city. The size of the point (more specifically, its area) represents its population and its fill depicts the relative position of a given city vis-à-vis other cities in the EIU ranking. We then set a black line around the point (shape=21) while specifying the color and thickness (stroke) of the border.\nA title, subtitle and caption are added to replicate the original chart using the labs function.\n\n\np2 <- p + \n  geom_point(data=fulloutputclean, \n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking), \n             shape=21,\n             color=\"black\",\n             stroke=0.03) +\n  labs(title=\"March of the cities\",                                                                   \n       subtitle=\"China, emerging city ranking, 2022\",\n       caption=\"Source: EIU\") \np2\n\n\n\nScales\nNext, the scale_fill_stepsn() and scale_size() functions are used to customize the appearance of the legends for the color and size aesthetics, respectively.\nFor the color legend (or rather, fill legend, given our points have borders defined by the color argument as introduced in the previous section), we first specify its title and title position. We then specify the details relating to the ticks and limits between the different boxes of the legend. We set the values for the 7 breaks in the variable ‘Ranking’ so as to create six categories of rank scores. By means of a drawing tool using the hexadecimal system, we set the colors for each of the six categories. Note that higher-ranked cities are represented with shades of blue and lower-ranked cities are represented with shades of orange or brown, whereby darker shades of both colors represent the ends of the spectrum.\nFor the size legend, we do the same as with the fill legend regarding the title and the breaks, although this time we are specifying 3 breaks. In this case we are also setting the labels for those breaks. This is because, by default, R uses scientific notation for population but the legend title already states that values are provided in millions. Finally, we set the range of the size of the bubbles from 0.04 to 6 mm.\n\n\np3 <- p2 + \n  scale_fill_stepsn(\n      guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE, \n                             show.limits=TRUE, \n                             ticks.colour= \"black\",\n                             ticks.linewidth = 1, \n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1),\n      breaks=c(1, 20, 40, 60, 80, 100, 106), \n      colors=c(\"#1c2c74\", \"#5483b3\", \"#99ccff\", \"#fcdb9b\", \"#fcbc04\", \"#ac6404\"),\n      space=\"Lab\") +\n  scale_size(\n      guide=guide_legend(title=\"Population, 2020, m\", \n                         title.position=\"top\",\n                         order=2),\n      breaks=c(1000000, 10000000, 20000000),\n      labels=c(\"1\", \"10\", \"20\"),\n      range=c(0.04, 6))\np3\n\n\n\nTheme\nDespite there being a special ‘The Economist’ theme, a completely empty theme (without the default background and axis elements) is what we want. Hence we use theme_void(). Under the theme() function, we first specify the (previously loaded) font most closely resembling the one used in the original map. Concerning title, subtitle and caption, we specify their size, as well as their vertical (vjust) and horizontal justification (hjust). Also using the helping function element_text(), we instruct that the title be bold and the caption have the color “gray”. We then set the position, direction and justification of the legend so that it is horizontal and gets centered to the north of China (approximately where Mongolia would be). We then specify that both legends be left-justified and set the font size for both the title and the text inside the legend (as well as the face in the case of the legend title). Finally, we customize the margins around the legend area and set the key width to 8mm, the key height to 2.5mm and the spacing between keys in the size legend to 0.1mm.\n\n\np4 <- p3 +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=22, vjust=-8, hjust=0.05), \n        plot.subtitle=element_text(size=18, vjust=-10, hjust=0.058),\n        plot.caption=element_text(color = \"gray\", size = 17, hjust = 0.05),\n        legend.position=c(0.73, 0.96),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.text=element_text(size=14),\n        legend.margin=margin(1, 1, 1, 1),\n        legend.key.width=unit(8, \"mm\"),\n        legend.key.height=unit(2.5, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'))\np4\n\n\n\nAnnotations\nThe last step to replicate the original map is the annotations, for which we use the annotate() function. While it may appear to be a caption, the text “1=best” is actually inside the plot and hence is introduced as an annotation. For this and the rest of annotations, we specify the type, the coordinates (x, y), the label, the size and the family (as well as the hjust, vjust, fontface and color for some).\nFor the textbox in the lower left corner in the original chart, we create a separate annotation for the title in order to be able to set its fontface to bold and assign it a different color. Further, we separate each of the five cities into different annotations as well because grouping them together under the same one led to there being too large of a vertical space between each of the five lines.\nFor the individual annotations of the eight highest ranked cities on their locations on the map, we simply use the coordinates for each city and adjust them to be able to see which point corresponds to each label. We also added separate annotations with the lines for five cities: Dongguan, Guangzhou, Suzhou, Jiaxing and Hangzhou (type= “segment”). These lines make identifying which label corresponds to each point easier when cities are clustered together.\n\n\np5 <- p4 + \n  annotate(\"text\", x=67, y=51.5, label=\"1=best\", \n           size=5.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=30, label=\"Highest ranked\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\",\n           fontface=\"bold\", color=\"blue4\") +\n  annotate(\"text\", x=65, y=28, label=\"1  Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=26, label=\"2  Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=24, label=\"3  Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=22, label=\"4  Suzhou\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=20, label=\"5  Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=26, label=\"Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=21, label=\"Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=33, label=\"Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114, y=29, label=\"Suzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=102, y=23, label=\"Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=41,label=\"Beijing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=123, y=29, label=\"Jiaxing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=110, y=26, label=\"Dongguan\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=113, y=25.5, \n           xend=113, yend=24) +\n  annotate(\"segment\", x=110, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=117, y=30, \n           xend=120, yend=31.5) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=122, y=27, \n           xend=120, yend=30)\np5\n\n\n\nEvaluation and potential enhancements\nThis section starts with a brief discussion of the positive and negative qualities of both the original chart and its replication. First, there are several limitations with our reproduction of the map. First, we were not able to reproduce the curved segments joining Hangzhou and Suzhou with their respective points or bubbles as the chart did not support geom_curve(). We were also unable to imitate the appearance of the fill legend exactly as the one in the original map contains spaces between the different boxes or ranges of scores.\nNext, an evaluation of the strengths and weaknesses of the original map is also necessary in order to suggest minor improvements.\nOverall, the original map is an effective visualization. The title and subtitle are concise and informative of its purpose and object, i.e. showing how, because of urbanization (“March of the cities”), cities of varying populations on the coast of China have different levels of growth potential as measured by a comprehensive score. The underlying map, which does not encode any information, does not distract from the information being shown as it is given a light color. Moreover, the legends are clear. This is especially important in the case of the size legend, which could be problematic since people perceive areas rather than radii as visual features in circles. In this case, the area of the circle seems to be proportional to population and so it correctly provides a reference point for readers to estimate the population of individual cities. The ‘expressiveness’ criterion is also met, as ordered data (“Ranking”) appears ordered by means of the hue scale. Finally, the annotations help readers focus on a small number of cities (eight for on-the-map annotations and five for the annotation on the bottom left corner), which facilitates the understanding of which cities have highest growth potential as well as of their characteristics (namely population and location).\nTherefore, the mapping of data into visual features communicates (and thus helps us understand) the “story” the author wants to tell in a clear, precise, efficient and truthful way.\nHowever, there may be some areas of potential improvement. The chart below includes several changes so as to enhance the ease of decoding visual information.\n\n\np <- ggplot() +\n  geom_polygon(data=china, \n               aes(x=Longitude, y=Latitude, group=Grouping),\n               fill=\"cornsilk3\",\n               alpha=0.3) +   \n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping), \n            color=\"white\", \n            size=0.2) +\n  coord_map(xlim=c(100, 155), ylim=c(20, 50)) +\n  geom_point(data=fulloutputclean,\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking),\n             shape=21, color=\"black\") +       \n  labs(title=\"March of the cities\",\n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Source: EIU\") +\n  scale_fill_stepsn(\n       guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE,\n                             show.limits=TRUE,\n                             ticks.colour=\"black\",\n                             ticks.linewidth=1,\n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1), \n       colors=c(\"#00008b\", \"#6495ed\", \"#87cefa\", \"#e0ffff\"),\n       breaks=c(1, 30, 60, 90, 106),\n       space=\"Lab\") +\n  scale_size(\n       guide=guide_legend(title=\"Population, 2020, m\",\n                          title.position=\"top\",\n                          order=2), \n       breaks=c(1000000, 10000000, 20000000), \n       labels=c(\"1\", \"10\", \"20\"),\n       range=c(0.04, 6)) +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=20, \n                                vjust=-14, hjust=0), \n        plot.subtitle=element_text(size=13, \n                                   vjust=-21, hjust=0),\n        plot.caption=element_text(color=\"gray\", size=14, \n                                  hjust=0),\n        legend.position=c(1.01, 1.01),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.box.background=element_rect(fill=\"white\"),\n        legend.margin=margin(5, 15, 5, 10),\n        legend.key.width=unit(12, \"mm\"),\n        legend.key.height=unit(3, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'),\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.title.align=0,\n        legend.text=element_text(size=14)) +\n  annotate(\"text\", x=99, y=47.5, label=\"1=best\",\n           size=4.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=121, y=28, label=\"(1) Hangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=115, y=21.5, label=\"(2) Shenzhen\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=32, label=\"(3) Shanghai\",\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114.5, y=28, label=\"(4) Suzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=103, y=23, label=\"(5) Guangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=110.5, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=117.5, y=29, \n           xend=120, yend=31.5) +\n  geom_vline(xintercept=112, linetype=\"dashed\") \np\n\n\n\nAs suggested by the famous author in the field of visualization Edward Tufte, we should seek to maximize the data-ink ratio when displaying data. To that end, we should ask ourselves whether all elements (“ink”) in the chart are necessary to convey our message. Applying this notion to our map, we set limits for the coordinates through the arguments xlim and ylim inside the coord_map() function. This way, as seen in the map above, we “zoom in” to show the relevant data and remove the area west of meridian 100°. If we did this, we would only lose one observation (i.e. one city) and so it may be worth exploring this alternative. Since we have less “unused” space, we also set the legend background fill to “white” in order to establish a clear contrast between the legend and the map.\nMoreover, some changes to the fill legend may increase the ease of decoding visual information on ranking. In order to enhance discriminability on this scale, we reduce the number of categories from six to four. This way, it is easier for readers to figure out the order of cities according to their ranking and relate their scores to location and population without having to distinguish between too many values.\nAdditionally, despite being a small detail, the choice of the color palette may not be the most appropriate to depict this ordering. There does not seem to be an obvious reason for why stronger colors are assigned to the extremes in the ranking spectrum (i.e. highest- and lowest-ranked cities). Allocating different levels of saturation or lightness of the same hue could be an alternative way of visually conveying the ordering of cities according to growth potential. In the code above, we simply replace the colors for the original ‘40-60’ and ‘60-80’ categories with two lighter shades of blue under the scale_fill_stepsn()function.\nFurthermore, the fact that eight cities are annotated on the map and only five are included in the bottom left textbox is not too easy to realize at first and both annotations seem to include redundant information. By removing the textbox and adding the rank numbers directly to the cities annotated on the map, we simplify the visualization without removing essential information.\nFinally, in order to emphasize the idea that cities with the highest growth potential are on the coast, we might want to insert a vertical line (we use geom_vline()) at the (arbitrary) level of longitude 112°. This way we can see that among the 10 cities with the highest growth potential, only Chengdu (i.e. the “dark blue” bubble farthest west) is to the west of this longitude.\nAlternative visualization\nThe final section of this post proposes an alternative visualization to represent the relationship between the population, location and growth potential of cities in China. One possibility is the scatterplot shown below. We plot the ranking on the x-axis and population on the y-axis. We also use the geom_point() function just like in the original map.\nWe change the title and subtitle of the plot. We also add an informative caption and change the axis labels so as to make it even easier to understand what each variable represents and the message being conveyed. We alter the theme to theme_light() so as to increase the contrast between the background and the text and data points.\nThis time, by using the scale_y_continuous() function, we change the default scientific notation so that the axis itself shows population in ‘M’ (million). We then set the specifics for the font, title, subtitle, caption, axis title and axis text under the theme() function.\n\n\np <- ggplot(fulloutputclean) +\n  aes(x=Ranking, y=Population) +\n  geom_point() +\n  labs(title=\"Urbanization and economic growth in China\",      \n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Coastal cities have highest growth potential\",\n       x=\"City Growth Ranking\",\n       y=\"City Population\") +\n  scale_y_continuous(labels=scales::label_number_si()) +\n  theme_light() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=26),                                                            \n        plot.subtitle=element_text(size=20),\n        plot.caption=element_text(size=20, hjust=0),\n        axis.title=element_text(size=15),\n        axis.text=element_text(size=13))\np\n\n\n\nIn general, we can see that higher growth potential (lower value for the variable “City Growth Ranking”) tends to be associated with a larger population, which was perhaps harder to see on the original map. However, we still need to include information about the location (coordinates) of cities. Within the location variable, it seems that longitude is the most important factor: cities closer to the coastline (i.e. farther east, or higher values of x) appear to have higher growth potential. These high-ranking cities seem to be distributed more or less evenly from north to south, hence we disregard the latitude information for simplicity. Therefore, we could encode longitude through the color of the points by highlighting in blue those points representing cities that are located east of the (again, arbitrarily chosen) 112° meridian. We also add a text label (on top of a white rectangle constructed with geom_rect()) to indicate that blue dots represent cities farther east in China.\n\n\nannotation <- dplyr::filter(fulloutputclean, Longitude>112)\np <- p + \n    geom_point(data=annotation, color=\"#6495ED\") +\n    geom_rect(aes(xmin=79, xmax=130, ymin=15000000, ymax=16600000),\n              fill=\"white\",\n              color = \"#6495ED\") +\n    geom_text(aes(x=80, y=15800000, \n                  label=\"Cities to the east of the 112th meridian\"),\n              size=6, hjust=0, vjust=0, color = \"#6495ED\")\np\n\n\n\nFinally, to highlight the top 5 cities from the original map, We construct another annotation and insert it as an argument in the geom_text() function. We adjust the size and horizontal justification of the labels, and make them bold.\n\n\nannotation2 <- dplyr::filter(fulloutputclean, Ranking<=5)\np <- p +\n  geom_text(aes(label=City),\n            annotation2,\n            hjust=-0.2, nudge_x=0.1, size=6,\n            family = \"IBM Plex Sans\",\n            fontface=\"bold\") \np\n\n\n\nWe can see that highly-ranked cities are all near the coast (i.e. all highlighted in blue because they are east of the meridian 112°), but there is a rather wide range of population sizes among the top 5. For instance, both Shanghai and Suzhou have very high growth potential. Yet, the former has more than 3.5 times the population of the latter. This is because many variables are included in the calculation of scores. For instance, Hangzhou tops the ranking due to its nature as a big tech hub. While government regulation targeting tech firms may hamper its medium- and long-term growth, other factors such as its fiscal position, economic diversity or metropolitan development jointly yield a high growth potential for the city.\nAll in all, as the caption suggests, it seems that location (whose effect is hard to separate from other historical, economic and environmental factors) is more important than current population as a predictor of future economic growth.\n\n\n\n",
    "preview": "projects/2022/100489635/economist.png",
    "last_modified": "2023-01-09T11:25:59+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1118
  },
  {
    "path": "projects/gapminder/",
    "title": "Gapminder's World Health Chart",
    "description": "This tutorial reproduces one of the most popular data visualizations ever\nand serves as an example project for this course",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-09-09",
    "categories": [
      "gapminder"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLegend\n\nFinal result\nSingle year\nMultiple years, static\nMultiple years, dynamic\n\n\nHans Rosling was a Swedish professor of International Health at the Karolinska Institute,\nand co-founder of the Gapminder Foundation,\nwhich developed the Trendalyzer software for animated data visualization.\nHis famous 2006 TED Talk,\nDebunking myths about the “third world”,\nhas inspired millions over the world thanks to his celebrated bubble chart\ndepicting the relationship between life expectancy and income.\nGapminder’s World Health Chart. Figure from gapminder.org.The goal of this tutorial is to replicate this famous data visualization step by step.\nGetting the data\nThe data consists of yearly observations of life expectancy values and GDP per capita for a number of countries in the world.\nThis is a very popular dataset.\nWe could download the data directly from the Gapminder homepage,\nbut we will use instead the gapminder package,\nwhich contains ready-to-use data for 142 countries from 1952 to 2007.\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\n\nLet’s take a glimpse of the data:\n\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afgh…\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, As…\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 19…\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nThese are all the variables we need in a tidy format,\nincluding population counts, which will serve to define the size of the bubbles.\nAs we can see, the original visualization includes Oceania into Asia,\nso let’s do the same for our exercise:\n\n\ngapminder <- gapminder %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\"))\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Europe  :360   Median :1980   Median :60.71  \n Angola     :  12   Asia    :420   Mean   :1980   Mean   :59.47  \n Argentina  :  12                  3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nBuilding the chart\nCoordinates and axes\nWe will work with a single year for now.\nThe base panel consists of simple Cartesian coordinates,\nand depicts life expectancy vs. GDP per capita,\nalthough the x label says the more understandable term “Income”.\n\n\np <- ggplot(filter(gapminder, year == 2007)) +\n  aes(gdpPercap, lifeExp) +\n  ylab(\"Life expectancy\") + xlab(\"Income\")\np\n\n\n\nBoth axes have fixed limits across the whole animation.\nAnother thing to note about the axes is that income is in logarithmic scale with very specific breaks.\nAlso, numbers above 10 thousand are labeled as “10k”.\nThe function scales::label_number comes in handy for this.\nNote that we make some space for annotations on top of the chart\nby setting the maximum limit of the y axis to 95.\n\n\nbreaks <- 500*2^c(0:8)\nklabel <- scales::label_number(suffix=\"k\", scale=1e-3)\nlabels <- c(breaks[1:5], klabel(breaks[-(1:5)]))\n\np <- p + scale_y_continuous(limits=c(10, 95), breaks=seq(10, 90, 10)) +\n  scale_x_log10(limits=range(breaks), breaks=breaks, labels=labels)\np\n\n\n\nTheme\nNote that the theme is very similar to theme_classic, but shows the major grid.\nWe also instruct the theme to remove the legend,\nbecause we will add a custom one later on.\n\n\np <- p + theme_classic() +\n  theme(panel.grid.major=element_line(), legend.position=\"none\")\np\n\n\n\nAdditionally, we could continue to tinker with fonts and other parameters.\nAnnotations\nThe base panel depicts three annotations:\nA big background number indicating the year in the middle.\nFour income levels on the top part, whose breaks seem to be 3k, 8k and 24k.\nThe axes’ units on the top left and bottom right corners.\nFor the background number, we could use annotate with a fixed label,\nbut we will use geom_text instead, even if we overplot it many times,\nso that the year is read from the data.\n\n\np <- p + geom_text(aes(8000, 50, label=year), size=65, color=\"lightgray\")\np\n\n\n\nNext, we add the income levels.\nAdditionally, we will take the liberty of adding vertical lines to clearly demarcate the breaks.\n\n\ntlevel <- c(1300, 5000, 14000, 40000)\nblevel <- c(3000, 8000, 24000)\nilevel <- c(\"INCOME LEVEL 1\", \"LEVEL 2\", \"LEVEL 3\", \"LEVEL 4\")\n\np <- p + geom_vline(xintercept=blevel, color=\"darkgray\") +\n  annotate(\"text\", x=tlevel, y=95, color=\"darkgray\", vjust=0, size=3, label=ilevel) +\n  annotate(\"text\", x=blevel, y=95, color=\"darkgray\", vjust=0, size=5, label=\"◆\")\np\n\n\n\nFinally, let’s add the units to the axes.\n\n\np <- p +\n  annotate(\"text\", x=128000, y=10, hjust=0.95, vjust=1, size=3,\n           label=\"per person (GDP/capita, PPP$ inflation-adjusted\") +\n  annotate(\"text\", x=500, y=95, hjust=0.5, vjust=-1.5, size=3, angle=90, label=\"years\")\np\n\n\n\nData\nThe chart is a type of scatterplot, with one point per country, and colored by continent.\nThe novelty here is that every dot is scaled up to represent the population size.\nAlso, we will add some transparency to the points.\n\n\np <- p + geom_point(aes(color=continent, size=pop), alpha=0.7)\np\n\n\n\nWe are close, but a couple of adjustments are required.\nLet’s add a black line around the points (see shape 21),\nand adjust the range of the bubbles a bit.\n\n\np <- p + geom_point(aes(size=pop), color=\"#333333\", shape=21) +\n  scale_size_area(max_size=25)\np\n\n\n\nFinally, let’s replicate the same color scale.\nWe need to provide them in the same order as the factor levels:\n\n\nlevels(gapminder$continent)\n\n[1] \"Africa\"   \"Americas\" \"Europe\"   \"Asia\"    \n\nTherefore, from the web, page we obtain:\nAfrica: Blue rgb(0, 213, 233) -> #00d5e9\nAmericas: Green rgb(127, 235, 0) -> #7feb00\nEurope: Yellow rgb(255, 231, 0) -> #ffe700\nAsia: Red rgb(255, 88, 114) -> #ff5872\n\n\nccolors <- c(\"#00d5e9\", \"#7feb00\", \"#ffe700\", \"#ff5872\")\np <- p + scale_color_manual(values=ccolors)\np\n\n\n\nLegend\nThis chart has an interesting legend:\nit takes advantage from the fact that continents are easily recognizable to use a map as a legend.\nLet’s replicate it separately using data from ggplot2::map_data.\n\n\nworld <- map_data(\"world\")\nglimpse(world)\n\nRows: 99,338\nColumns: 6\n$ long      <dbl> -69.89912, -69.89571, -69.94219, -70.00415, -70.06…\n$ lat       <dbl> 12.45200, 12.42300, 12.43853, 12.50049, 12.54697, …\n$ group     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,…\n$ order     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16,…\n$ region    <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Arub…\n$ subregion <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\nThis data needs to be tweaked a little bit. We need to:\nFilter out the Antarctica region.\nAdd a new column continent with the help of the countrycode package.\nInclude Oceania into Asia.\nDrop any missing values for continent.\n\n\nworld <- world %>%\n  filter(region != \"Antarctica\") %>%\n  mutate(continent = countrycode::countrycode(\n    sourcevar=region, origin=\"country.name\", destination=\"continent\")) %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\")) %>%\n  drop_na(continent)\n\n\nNow, let’s create the map:\n\n\nlegend <- ggplot(world) +\n  aes(long, lat, group=group, map_id=region, fill=continent) +\n  geom_map(map=world) +\n  scale_fill_manual(values=ccolors) +\n  theme_void() + theme(legend.position=\"none\")\nlegend\n\n\n\nFinal result\nSingle year\nIn summary, so far we have\nBuild steps:\nset coordinates and axes, with custom breaks;\nset an appropriate theme and prevent the default legend from appearing;\nadded several annotations, including year, income levels and axis units;\nadded the data points and made several adjustments, including size and color;\ncreated a custom legend based on a simple colored world map.\nThere are several ways we can merge the main plot and the legend.\nIn this case, let’s add it as an inset with the custom annotation function.\nNote that, in contrast to the regular annotation function,\nthis one doesn’t seem to support logarithmic scales very well.\nAs a result, the user needs to provide the transformed values directly.\n\n\np <- p + annotation_custom(\n  ggplotGrob(legend), xmin=log10(16000), ymin=10, ymax=40)\np\n\n\n\nFinally, we can improve this static single-year visualization by adding some context,\ni.e. a title, a subtitle and a caption.\n\n\np + labs(\n  title = \"World Life Expectancy vs. Income in 2007\",\n  subtitle = paste(\n    \"African countries are still lagging behind in terms of general life\",\n    \"expectancy.\\nEuropean and American countries are the healthiest\",\n    \"and richest countries in the world.\"),\n  caption = \"Source: gapminder.org\"\n)\n\n\n\nMultiple years, static\nSo far, we covered the case for a single year.\nHow could we show the evolution, which is the point in this dataset?\nOf course we can define facets to plot all the years.\nIn the following chart,\ngginnards::delete_layers is used to remove the background year;\nwe switch to the whole dataset using the %+% operator;\ndata is faceted in two rows;\naxis labels are slightly rotated to make space for them.\nNote also that we need to manually scale down a bit the range of the bubbles\nto preserve more or less the previous aspect ratio.\n\n\ngginnards::delete_layers(p, match_type=\"GeomText\") %+% gapminder +\n  facet_wrap(\"year\", nrow=2) +\n  scale_size_area(max_size=7) +\n  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))\n\n\n\nMultiple years, dynamic\nAnd we can of course animate it!\nWe can easily convert any ggplot2 chart to plotly using plotly::ggplotly,\nwhich produces interactive web-based charts.\nFurthermore, if we set the frame aesthetic, it is automatically detected,\nand an animation is added based on the corresponding variable.\n\n\nplotly::ggplotly(p %+% gapminder + aes(frame=year))\n\n\n\n\n\n\n",
    "preview": "projects/gapminder/gapminder_files/figure-html5/titled-1.png",
    "last_modified": "2022-10-07T12:58:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  }
]
