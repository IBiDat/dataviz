[
  {
    "path": "projects/2023/100485846/",
    "title": "Seizures of Ammunition and Arms by Country 2017",
    "description": "A brief report based on UNs 2020 Global Study on Firearms Trafficking.",
    "author": [
      {
        "name": "Mecki Hamed-Guerrero",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nWorking with the data\nLibraries and dataset\nData cleaning process\n\nBuilding the graph\nFirst replica\nEdition and color\nFinal graph\nLimitations\n\nImprovements\nFinal Map\nAnalysis and results\nMeso-America and South-America\nMediterrenean Sea\n\nFurther research\n\nIntroduction\nThe illicit trade of weapons is a pervasive issue with far-reaching\nconsequences, intertwining elements of politics, society, and\ninternational relations. The trafficking of arms fuels conflicts,\nexacerbates human suffering, and poses a significant threat to global\nsecurity.\nArms trafficking knows no borders, infiltrating regions plagued by\npolitical instability and social unrest. The consequences are dire, as\nthese weapons often fall into the hands of non-state actors,\nperpetuating violence and hindering efforts for peace. The intertwined\nnature of this problem reflects the complex web of international\nrelations, where the actions of one nation can have ripple effects\nacross the globe.\nTackling the issue of arms trafficking requires a multi-faceted\napproach, involving collaboration between nations, strong regulations\nand a commitment to addressing the root causes of conflict. It also\nrequires information to enable institutions to fully address the issue.\nThis is where data becomes necessary.\nEstablishing a relationship between the different types of arms\ntrafficking that exist and the conflicts that are currently taking place\ncan be very useful in understanding and addressing this phenomenon.\nCreating a model that can explain the dynamics of arms (and components)\ntrafficking at the regional level would provide researchers and\ndecision-makers with a powerful tool to understand and prevent this\nmenace.\nThat is why the intention of this paper will be to plot the ratio of\nammunition seizures in relation to the number of arms seizures on a\nworld map. The motivation for this work lies in the intention to\nidentify regional trafficking dynamics around existing conflicts.\nThe original graph\nThe original graph can be found on page 29 of the UNODC Global Study on\nFirearms Trafficking 2020.\nThe graph to be replicated is Figure 11.\nThe graph shows the relationship between ammunition seizures and weapons\nseizures per country in 2017. The X-axis represents the countries in\nwhich seizures occurred, and the Y-axis represents the ratio of seized\nrounds of ammunition to seized arms (in a logarithmic scale). The graph\nalso has a line at the value 1 for the Y-axis, which indicates the\nboundary between a positive and a negative ratio. Similarly, the graph\nhas a horizontal line above the median value (23), and a space dedicated\nto the common range.\nCountries above the ratio = 1 are those where ammunition trafficking is\nhigher than arms trafficking. This could indicate the presence of arms\nfrom previous conflicts and belonging to already armed groups, which\nrequire more ammunition than arms.\nConversely, where the ratio is < 1, a process of internal rearmament\nmay be taking place. This is probably due to the involvement of third\nstates in the financing of paramilitary or terrorist groups.\nOriginal Source: UNODC Global Study on Firearms Trafficking 2020.Working with the data\nThe database to be used comes from the UNODC (United Nations Office on\nDrugs and Crime) and can be found on the following link: UNODC Firearms\nTrafficking Dataset\nThe dataset contains Categories relating to the ‘Region’, ‘Subregion’\nand ‘Country’. Similarly, the dataset contains information relating to\nthe ‘Source’ that made the seizure and the year in which the seizure was\nmade (2010 to 2020). Also, the dataset contains a specific category,\n‘Indicator’, which gives information about the type of seizure\n(ammunition or arms). Finally, the dataset contains two more important\ncollumns: ‘Dimension’, which explains the reason of the seizured; and\n’Category, which indicates the illegal use of the equipment seized.\nHowever, the dataset lacks the data that the UNODC appears to use to\ndraft the aforementioned Global Study on Firearms Trafficking 2020. For\nthis reason, the scope of the work will be reduced to the information\navailable.\nLibraries and dataset\nThe following libraries will be utilized throughout the entire project,\nencompassing both the replica and subsequent enhancements:\n\n\nlibrary(datapasta)\nlibrary(tibble)\nlibrary(tidyr)\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(rnaturalearth)\nlibrary(rnaturalearthdata)\nlibrary(sf)\nlibrary(RColorBrewer)\n\n\nDue to the fact that the first two columns of the chosen dataset\nprovides no information at all, we will load the .xlsx without them.\n\n\ndata <- read_excel(\"data_iafq_firearms_trafficking.xlsx\", skip=2)\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… other   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… unknown \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Altered…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n6 AGO       Angola  Africa Sub-Saharan A… Individu… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nData cleaning process\nFirst of all:\nThe column “Year” represents the year of the record in the database.\nSince our chart to be replicated relies on data for the year 2017, we\nwill select only records produced in that year.\n\n\ndata <- data[data$Year == 2017, ]\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Ammuniti… Total     Total   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Total   \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… Total   \n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… unknown…\n6 AGO       Angola  Africa Sub-Saharan A… Arms sei… by condi… Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nSecondly:\nThe column “Indicator” indicates whether the data belongs to “Arms\nseized” or “Parts and components seized”. So we must filter the dataset\nso that it contains only these two values:\n\n\ndata <- data |>\n  filter(Indicator %in% c(\"Arms seized\", \"Ammunition seized\"))\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country Region Subregion      Indicator Dimension Category\n  <chr>     <chr>   <chr>  <chr>          <chr>     <chr>     <chr>   \n1 AGO       Angola  Africa Sub-Saharan A… Ammuniti… Total     Total   \n2 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… Total   \n3 AGO       Angola  Africa Sub-Saharan A… Arms sei… by legal… illicit…\n4 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… Total   \n5 AGO       Angola  Africa Sub-Saharan A… Arms sei… by marki… unknown…\n6 AGO       Angola  Africa Sub-Saharan A… Arms sei… by condi… Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nThirdly:\nSince the columns “Dimension” and “Category” segment the total seizures\ninto different subdivisions, we are interested in showing only the sum\ntotal of each of the columns. i.e. those values recorded as ‘Total’, in\nboth columns:\n\n\ndata <- data |>\n  filter(Dimension == \"Total\" & Category == \"Total\")\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country      Region Subregion Indicator Dimension Category\n  <chr>     <chr>        <chr>  <chr>     <chr>     <chr>     <chr>   \n1 AGO       Angola       Africa Sub-Saha… Ammuniti… Total     Total   \n2 AGO       Angola       Africa Sub-Saha… Arms sei… Total     Total   \n3 ALB       Albania      Europe Southern… Arms sei… Total     Total   \n4 ARG       Argentina    Ameri… Latin Am… Ammuniti… Total     Total   \n5 ARG       Argentina    Ameri… Latin Am… Arms sei… Total     Total   \n6 ATG       Antigua and… Ameri… Latin Am… Arms sei… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nFourth:\nWe convert the information in the “VALUE” column (total number of\nseizures) to a numerical value:\n\n\ndata$VALUE <- as.numeric(data$VALUE)\nhead(data)\n\n# A tibble: 6 × 13\n  Iso3_code Country      Region Subregion Indicator Dimension Category\n  <chr>     <chr>        <chr>  <chr>     <chr>     <chr>     <chr>   \n1 AGO       Angola       Africa Sub-Saha… Ammuniti… Total     Total   \n2 AGO       Angola       Africa Sub-Saha… Arms sei… Total     Total   \n3 ALB       Albania      Europe Southern… Arms sei… Total     Total   \n4 ARG       Argentina    Ameri… Latin Am… Ammuniti… Total     Total   \n5 ARG       Argentina    Ameri… Latin Am… Arms sei… Total     Total   \n6 ATG       Antigua and… Ameri… Latin Am… Arms sei… Total     Total   \n# ℹ 6 more variables: Sex <chr>, Age <chr>, Year <dbl>,\n#   `Unit of measurement` <chr>, VALUE <dbl>, Source <chr>\n\nFifthly:\nWe proceed to calculate the ratio of “Ammunition seized” to “Arms\nseized”, under the previously established conditions.\n\n\nratiocalc <- data |>\n  group_by(data$Country) |>\n  reframe(\n    ratio = VALUE[Indicator == \"Ammunition seized\"] / VALUE[Indicator == \"Arms seized\"])\nhead(ratiocalc)\n\n# A tibble: 6 × 2\n  `data$Country`    ratio\n  <chr>             <dbl>\n1 Algeria        189.    \n2 Angola           6.48  \n3 Argentina        0.0310\n4 Australia      187.    \n5 Azerbaijan      20.7   \n6 Brazil          76.6   \n\nBuilding the graph\nFirst replica\nWe proceed to create a first plot with the most basic information.\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\"\n  ) \n\n\n\nWe then proceed to add both the value relative to the median and a\nhorizontal line at the value 1 for the Y-axis, which will allow us to\nbetter differentiate countries above and below the ratio = 1.\nSimilarly, we can calculate the ‘common range’ and plot it on the graph.\n\n\nmediana <- median(ratiocalc$ratio)\n\ncuartil_ratio <- quantile(ratiocalc$ratio, c(0.25, 0.75))\n\nrango_intercuartil_ratio <- cuartil_ratio[2] - cuartil_ratio[1]\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\"\n  ) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\")  +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) \n\n\n\nFrom here we proceed to modify the aesthetic section of the graphic:\nEdition and color\nThe first modification consists of applying ‘theme_minimal()’ to the\ngraph. We will also add a title to it.\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col() +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) \n\n\n\nNext we will change the format of the text displayed on the X and Y\naxes. Similarly, we rotate the names on the X-axis by 90º, in order to\nmake our graphics clearer.\n\n\n  ggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n    geom_col() +\n    scale_y_continuous(labels = function(x) 10^x/100) +\n    labs(x = ' ',\n         y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n    ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n    theme_minimal() +\n    scale_fill_manual(values = c(\"blue\")) +\n    theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n    theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n    geom_hline(yintercept = log10(mediana*100), linetype = \"dashed\", color = \"red\") +\n    geom_hline(yintercept = log10(100), linetype = \"dashed\", color = \"red\") +\n    annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003)  +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))\n\n\n\nNow, we can proceed to the introduction of aesthetic elements related to\ncolour.\nIn this section we are interested in modifying: The background colour,\nthe colour of the bars and the colour of the line relative to the ratio\n= 1.\nIn the same way, we will proceed in framing the graph:\n\n\n  ggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col(width = 0.5, fill = \"#D2691E\", position = \"identity\") +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"blue\")) +\n  theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n  theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"solid\", size = 1, color = \"red\") +\n  geom_hline(yintercept = log10(100), linetype = \"solid\", size = 1, color = \"black\") +\n  annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\")   +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003)  +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  theme(panel.background = element_rect(fill = \"lightgrey\"),\n        plot.background = element_rect(fill = \"white\"))\n\n\n\nNext, we remove the grid from the bottom of the graph, leaving us with\nour final replica.\nFinal graph\n\n\nggplot(ratiocalc, aes(x=reorder(`data$Country` , log10(ratio*1000)), y=log10(ratio*1000))) +\n  geom_col(width = 0.5, fill = \"#D2691E\", position = \"identity\") +\n  scale_y_continuous(labels = function(x) 10^x/100) +\n  labs(x = ' ',\n       y= \"Ratio of seized rounds of ammunition to seized arms\n(logarithmic scale)\") +\n  ggtitle(\"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"blue\")) +\n  theme(axis.text.x = element_text(face = \"bold\", size = 8, vjust = -0.5)) +\n  theme(axis.text.y = element_text(face = \"bold\", size = 14)) +\n  geom_hline(yintercept = log10(mediana*100), linetype = \"solid\", size = 1, color = \"red\") +\n  geom_rect(aes(xmin = -Inf, xmax = Inf, ymin = log10(cuartil_ratio[1]*100), ymax = log10(cuartil_ratio[2]*100)),\n            fill = \"red\", alpha = 0.003) +\n  annotate(\"segment\", x = -0.1, y = log10(100), xend = -0.1, yend = log10(1000), linetype = \"solid\") +\n  geom_hline(yintercept = log10(100), linetype = \"solid\", size = 1, color = \"black\") +\n  annotate(\"segment\", x = 0, y = log10(mediana*100), xend = 0.1, yend = log10(mediana*100), color = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +\n  theme(panel.background = element_rect(fill = \"#EEE9E9\"),\n        plot.background = element_rect(fill = \"white\")) +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank())\n\n\n\nLimitations\nWhile this graph represents an extremely clear identification of those\ncountries that are on either side of the ratio = 1, this information is\nalmost useless for gaining a regional (or global) understanding of the\nrelationships between countries where arms trafficking occurs, their\nneighbours, and the regional circumstances that may cause this (regional\nconflicts, paramilitary groups, etc.).\nIt is for this reason that I consider that the best possible improvement\nto be made to this graph would be to transfer its data to a world map.\nImprovements\nTo convert the information of our dataset we must use the functions\nrelated to the ‘rnaturalearth’ library, creating variables that\nrepresent in R our world map.\nSubsequently, we will establish relationships between the variables\n‘Country’ and the variable ‘Ratio’, since they are the ones we want to\nrepresent.\n\n\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\n\nnames(ratiocalc) <- c(\"Country\", \"ratio\")\n\nmerged_data <- merge(world, ratiocalc, by.x = \"name\", by.y = \"Country\", all.x = TRUE)\n\n\nFinal Map\nFinally, we run the plot that will allow us to visualise our map:\n\n\nggplot(merged_data, aes(fill = log10(ratio*1000))) +\n  geom_sf() +\n  scale_fill_distiller(palette = \"RdYlBu\", direction = 1) +  # Cambia el esquema de colores según tus preferencias\n  labs(fill = \"Ratio\",\n       title = \"Seizures of ammunition in relation to seizures of arms, by country, 2017\") +\n  theme_minimal()\n\n\n\nAnalysis and results\nAlthough it is true that the database lacks the necessary information to\nestablish a global mapping, the extrapolation of the data present in our\ndataset does allow us to visualise more clearly the disposition of\ncertain regional focal points.\nMeso-America and South-America\nIn the Mesoamerica and South America region we have data for: Guatemala,\nEcuador, Peru, Guyana, Brazil and Argentina.\nHere Argentina has the lowest ratio in the region by far. The\ninterpretation of the data leads us to think that, at the regional\nlevel, Argentina has the highest levels with respect to the number of\narms seized per quantity of ammunition seized. In this context, we could\nsituate the dynamics of illegal arms trafficking in Brazil as the most\ndiametrically opposed to those of Argentina. This would indicate that\nmore ammunition has been seized in Brazil than in Argentina. The rest of\nthe region is increasingly closer to a higher level of arms trafficking\nas we move northwards (Peru, Ecuador, Guyana and Guatemala).\nIn the absence of data that could provide information on the behaviour\nof the region as a whole, the overall reading is trivial, although it\nmay be far from reality.\nThe fact that Argentina is the country in the region most specialised in\narms trafficking could be due to its regional status. In this regard,\nArgentina does not have any internal conflicts, so it is to be expected\nthat illegal arms trafficking is aimed at marketing arms to third\ncountries.\nThe violence in the Southern Macrozone in Chile or the narco-terrorist\ninsurgencies in Peru, Paraguay, Colombia and Ecuador can more than\njustify the need to acquire military materiel. Similarly, the fact that\nthe data is so disproportionately in favour of Argentina would support\nthe idea of the latter as a ‘proxy state’ on which a regional network of\nillegal arms trafficking could be built.\nMediterrenean Sea\nRegarding the Mediterranean, we have data from the following countries:\nMorocco, Algeria, Tunisia, Libya and Spain.\nThe data with respect to Spain, which indicates more arms trafficking\nthan ammunition trafficking, could be explained by its geographical\nposition as the ‘gateway to the Mediterranean’ and a maritime exit to\nthe North Atlantic. Further research with data from continental Europe\ncould shed more light on this.\nOn the other side of the Strait of Gibraltar, Libya is the only country\nthat shows similar figures to Spain. The Second Libyan Civil War (2014 -\n) left the country fractured into different centres of power with access\nto different natural resources of vital importance for the functioning\nof the country as a whole. In a state where power is shared between\nlocal militias, terrorist groups, internationally mandated governments\nand unrecognised institutions, armed conflict is already an entrenched\nproblem.\nThis would explain why illegal arms trafficking in Libya has a greater\ntendency towards arms, but maintains a certain level of presence in\nammunition.\nAs for Algeria, the large quantity of seized ammunition could be due to\nthe surplus of military materiel from the colonial era. While Morocco\nunderwent a similar colonial process, the extent to which France armed\nits former colony is greater than that which occurred on Moroccan\nterritory. The high levels of corruption in Morocco could explain a weak\nmilitary chain of command, which sought to take advantage of the\nsurplus. In a context of direct rivalry with Morocco (and with third\nstates involved), it is not at all inconceivable that Algeria would\nconsider selling military surplus to third countries as a means of\nfinancing.\nWith respect to the rest of the regions, the dataset provides\ninsufficient information to make any kind of reading in this regard.\nFurther research\nThe motivation for this work arose from the intention to identify\nregional trafficking dynamics around existing conflicts. The next step\n(once identified) would be to give them a reason.\nI believe that the best way to address the issue of illegal arms\ntrafficking is to situate national contexts in the regional setting.\nThese data (and their visualisation) gave us the opportunity to see\n(through their visualisation) different dynamics taking place in\ndifferent regional settings.\nI believe that this work, accompanied by historical, political and\neconomic contextualisation, would reveal in depth the regional trends of\nillegal arms trafficking and their relationship to the geopolitical\ncontext in which it takes place.\nFrom the numerical and historical analysis of regional trends in illicit\narms trafficking we can expect a clear motivation behind any illegal\ntransaction. The same motivation can give rise to a certain modus\noperandi, refined over time. Identifying such patterns and associating\nthem with patterns would help to map (at a higher level) all the\nelements and actors involved in illegal arms trafficking. This would\nhelp to prevent and eradicate it.\n\n\n\n",
    "preview": "projects/2023/100485846/100485846_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508856/",
    "title": "The Evolution of Working Hours in the World",
    "description": "This project consists in the replicaion and alternative representation of\ngraphs from Our World in Data called \"Working Hours\".",
    "author": [
      {
        "name": "Miao Liao",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nGraph to replicate\n\nFirst two graphs\nMaps\nEvolution path\n\nAlternative representations\nConclusion\n\nIntroduction\nThe graph for this project was inspired by a Working Hours article in Our World in Data, which is about a comparative analysis of average annual hours worked by countries between 1950 and 2019. The first part of the article discusses the average annual working hours of citizens in different countries during this period, depicted through line graphs and maps. We can clearly observe the trends in average annual working hours for each country, identifying which countries have the longest and shortest average annual working hours. Additionally, the variation in colors on the map represents changes in annual working hours. The second part utilizes data on the annual holidays in different countries during this period to depict trends in annual holidays. The third part includes data on population numbers and GDP of various countries, creating different charts to observe the relationships between population numbers, national GDP, and annual working hours in different countries. You can find the full article here.\nGraph to replicate\nThe images I intend to replicate combine line graphs, maps, and bubble charts, each representing different data characteristics. The line graph is used to show the trend of annual working hours over the past 60 years. The maps provide a more macroscopic view of the changes in global working hours. The bubble chart, incorporating population and national GDP, adds complexity to the data and allows for the observation of more information. Finally, an evolutionary path is drawn based on annual working hours and GDP data. The original image depicted the evolutionary paths of all countries over time, dynamically represented across different regional segments. Here is a link to the original graph:\nTime series, 1870-2017Map, 2005First two graphs\nThe first step was to load the libraries, in this case I used these: dplyr, ggplots, ggrepel, tidyr, ggokabeito, tmap and paletteer. The second step was to read the database which was on a csv file.\nThe first image I replicated is a line graph(Figure 1), in which I selected the average annual working hours of over 60 different countries globally from 1950 to 2017. The original was a dynamic trend graph that changed with the slide of time, and I created the final overall line trend graph. However, due to the excessive number of countries, it appeared quite cluttered at first glance. Therefore, in the second image(Figure 2), I chose a few representative countries to make the chart clearer, whereas the original graph was actually an overlay of different countries’ and regions’ trend graphs. Subsequently, there are four map images(Figure 3-6). Each map depicts the state of annual working hours in different regions globally during various years of this period, using shades of color to represent the length of working hours\nThe code for this visual representation can be divided into four parts:\nModify column names after reading the corresponding data table\nSet the X-axis as the year, the Y-axis as the working time, and the colors are differentiated by region\nModify the title to “Annual Working Hours per Country from 1950 to 2017”\nModify the x-axis of the plot\n\n\n# Figure 1\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggrepel)\nlibrary(tidyr)\nlibrary(ggokabeito) # remotes::install_github(\"malcolmbarrett/ggokabeito\")\nlibrary(paletteer)\nworking_hours<-read.csv(file = \"./data/annual-working-hours-per-worker.csv\")\ncolnames(working_hours)<-c(\"Region\",\"Code\",\"Year\",\"working_hours\")\np=ggplot(working_hours, aes(x = Year, y = working_hours, group = Region, color = Region)) +\n   geom_line() +\n    theme_minimal() +\n   labs(title = \"Annual Working Hours per Country from 1950 to 2017\",\n                  x = \"Year\",\n                  y = \"working Hours\",\n                  color = \"Region\") +\n     scale_x_continuous(breaks = seq(1950, 2017, by = 10)) \n \np\n\n\n\n\n\n#Figure 2\n\ndata <- read.csv(file = \"./data/annual-working-hours-per-worker.csv\")\ncolnames(data)[4] <- \"time\"\ndata1 <- dplyr::filter(data, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\np<-ggplot(data1,aes(Year,time,group=Entity,color=Entity))+\n  geom_line(position = position_dodge(0.1),cex=1)+\n  scale_x_continuous(breaks = seq(1870, 2020, 30))+\n  theme_bw()+\n  labs(x=\"Year\",\n       y=\"Hours\",\n       color=\"Country/Region\")+\n  scale_color_manual(values=paletteer_d(\"ggthemes::Classic_20\", n=9))+\n  theme(panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        panel.grid.major.y = element_line(linetype=2),\n        panel.grid.minor.y = element_blank(),\n        axis.text=element_text(size = 13), \n        axis.title =element_text(size = 15),\n        plot.margin=unit(c(3,0,3,0),'cm'),\n        panel.border = element_blank(),\n        axis.line.x= element_line(colour = \"black\"))\np\n\n\n\nMaps\nSelect the data for the corresponding year and select the required column name (entity and time).\nChange the column name and merge data\nModify the Settings of the map: set the title, control the title text size, scale size, map proportion, text color, etc\n\n\n#Figure 3 maps\n\nlibrary(tmap)\ndata(\"World\")\n\n## The map in 1900\n\n## Using ggplot2\n\nlibrary(ggplot2)\nlibrary(sf)\ndata_1900 <- data[data$Year==1900,]  |>  select(\"Entity\",\"time\")\ncolnames(data_1900) <- c(\"sovereignt\",\"Hours\")\nworld_1900 <- left_join(World,data_1900,by=\"sovereignt\")\nggplot(data = world_1900) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1900\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n##Figure 4 \n\n## The map in 1950\n\n## Using ggplot2\ndata_1950 <- data[data$Year==1950,]  |>  select(\"Entity\",\"time\")\ncolnames(data_1950) <- c(\"sovereignt\",\"Hours\")\nworld_1950 <- left_join(World,data_1950,by=\"sovereignt\")\nggplot(data = world_1950) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1950\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n#Figure 5\n## The map in 1997\n\ndata_97 <- data[data$Year==1997,]  |>  select(\"Entity\",\"time\")\ncolnames(data_97) <- c(\"sovereignt\",\"Hours\")\nworld_1997 <- left_join(World,data_97,by=\"sovereignt\")\n\nggplot(data = world_1997) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 1997\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\n\n\n#Figure 6\n\n## The map in 2017\n\ndata_17 <- data[data$Year==2017,]  |>  select(\"Entity\",\"time\")\ncolnames(data_17) <- c(\"sovereignt\",\"Hours\")\nworld_17 <- left_join(World,data_17,by=\"sovereignt\")\nggplot(data = world_17) +\n    geom_sf(aes(fill = Hours)) +\n    scale_fill_viridis_c() +\n    labs(\n        title = \"Annual working hours per worker, 2017\",\n        fill = \"Working Hours\"\n    )+\n  theme_minimal() +\n  theme(\n         plot.title = element_text(size = 14, hjust = 0.5, color = \"orange\"),\n        legend.position = c(0.1, 0.2),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.title = element_text(color = \"#8B1C62\", size = 10),\n        legend.text = element_text(color = \"#008B8B\", size = 8),\n        panel.border = element_rect(color = \"black\", size = 1, fill = NA)\n    )\n\n\n\nEvolution path\nThe original graph is the evolutionary path of the data of different countries superimposed, and then dynamic simulation is carried out. In this part, I select several regions to draw one of them. Here is a link to the original graph\n\n\ndata <- read.csv(file = \"./data/annual-working-hours-vs-gdp-per-capita-pwt.csv\")\n\ncolnames(data)[c(4,5)] <- c(\"work_time\",\"GDP\")\ndata1 <- data[-which(is.na(data$GDP)),]\ndata2 <- data1[-which(is.na(data1$work_time)),]\ndata3 <- dplyr::filter(data2, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\nggplot(data3,aes(GDP,work_time,color=Entity))+\n  geom_point(alpha=0.5)+\n  geom_line(alpha=0.5) +\n  scale_color_okabe_ito(name = \"Country/Region\")+\n  \n  labs(x = 'GDP per capita', y = 'Annual working hours per worker',color=\"Country/Region\") +\n  scale_x_continuous(breaks = c(0,10000,20000,30000,40000,50000,60000,70000))+\n  theme_bw()+\n  theme(axis.text=element_text(size = 7),\n        axis.title.x =element_text(size = 10),\n        axis.title.y =element_text(size = 12))\n\n\n\nAlternative representations\nIn this section, new data has been added, specifically the GDP and population numbers of different countries. Consequently, the next image I replicated is a bubble chart(Figure 7), used to compare the relationship between the average annual working hours, the population size, and the GDP of various countries. Due to the large number of countries, this chart primarily displays a selection of countries and regions, represented in different colors.\nRead file data\nExtract and modify column names\nClean data: Remove blank data\nExtract the country I want to draw\nUse the log10 function to draw the bubble, and use the ggplot2 function to set the x axis, y axis, color, title\n\n\ncolnames(data)[c(4,5)] <- c(\"work_time\",\"GDP\")\ndata1 <- data[-which(is.na(data$GDP)),]\ndata2 <- data1[-which(is.na(data1$work_time)),]\ndata3 <- dplyr::filter(data2, grepl('Brazil|China|France|Germany|Hong Kong|India|\n                                   Singapore|Taiwan|United Kingdom|United States', Entity))\n\ndata3_1 <- data3[data3$Year==2019,]\ndata3_1$Population..historical.estimates. <- log10(data3_1$Population..historical.estimates.)\nrownames(data3_1) <- data3_1$Entity\np<-ggplot(data = data3_1, aes(x = GDP, y = work_time)) +\n  geom_point(aes(size = Population..historical.estimates., fill = Entity), shape = 21, color = 'black', stroke = 1,alpha=0.5) +\n  geom_text(\n    label=rownames(data3_1), \n    nudge_x = 0.25, nudge_y = -10, \n    check_overlap = T\n  )+\n  xlim(0,80000)+\n  labs(x = 'GDP per capita', y = 'Annual working hours per worker') +\n  theme_bw()+\n  labs(fill = \"Country/Region\",\n       size = \"log10(Circles sized by Population)\")+\n  theme(legend.key.size=unit(0.5,\"cm\"))\np\n\n\n\nConclusion\nIn the process of replicating these charts, I encountered two main problems. The first was the excessive number of countries; I attempted to draw them according to different continental plates, but this was unsuccessful. Therefore, I ultimately focused on depicting a selection of typical countries and regions. The second issue was that the original charts dynamically displayed the data from earlier to more recent years, a feature I couldn’t replicate successfully. Thus, I produced a static version of the evolutionary path chart. In further elaboration, I added population data, enriching the information in the charts and allowing for potentially useful conclusions to be drawn through observation of the charts.\n\n\n\n",
    "preview": "projects/2023/100508856/100508856_files/figure-html5/unnamed-chunk-7-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508949/",
    "title": "Water Sanitation Visualization",
    "description": "Graph on the use of water and water sanitisation tools among the various\nregions of the world.",
    "author": [
      {
        "name": "Nadia Napolano",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\nEnhancement\n\nIntroduction\nThe graph was found at Visual Capitalist, it consists of two semicircles facing each other. The data are in percentage form I was able to transcribe them by hand and insert them into the dataset.\nOriginal graph.Replication\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(gridExtra)\n\n\n\n\n\nThe first step in the creation of this graph is the collection of data for the first semicircle: numerical values and information on world regions and water quality values are entered.\nThe second step is to ensure that the values are structured as a percentage, and that their sum is equal to 1.\n\n\ngraph <- ggplot(dati_grafico1_long, aes(x = Region, y = Percentage, fill = Category)) +\n  geom_bar(stat = \"identity\", position = \"stack\", color = \"white\", size = 0.1) +\n  ylim(c(0, 2)) +\n  scale_x_discrete(limits = c(letters[1:9], dati_grafico1$Region)) +\n  coord_polar(theta = \"y\", start = 0, direction = 1) +\n  theme_void() +\n  theme(\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(0, 200, 0, 0),\n    legend.key.size = unit(0.5, \"cm\"),\n    legend.key.width = unit(0.5, \"cm\")\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Safely_Managed\" = \"#7E8EF3\", \"Basic\" = \"#7DCA96\",\n      \"Limited\" = \"#CCC0F1\", \"surface_water\" = \"black\",\n      \"Unimproved\" = \"#CBF8C8\"\n    )\n  ) +\n  annotate(\n    \"segment\",\n    x = 9,\n    xend = 20,\n    y = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    yend = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    colour = \"white\",\n    size = 0.2\n  ) +\n  annotate(\"point\", x = 9, y = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0, yend = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2) +\n  annotate(\"point\", x = 9, y = c(0.8, 0.9, 1), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0.7, yend = c(0.8, 0.9, 1), color = \"black\", size = 0.2) +\n  annotate(\n    \"text\", x = 9, y = 0.65,\n    label = \"Safe\",\n    angle = 70,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +  \n  annotate(\n    \"text\", x = 8.5, y = 0.52,\n    label = \"drinking\",\n    angle = 90,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  )+ \n  annotate(\n    \"text\", x = 8.5, y = 0.37,\n    label = \"water\",\n    angle = 106,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +\n  annotate(\"text\", x = 20, y = 0, label = \"0%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.1, label = \"10%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.2, label = \"20%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.3, label = \"30%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.4, label = \"40%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.5, label = \"50%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.6, label = \"60%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.7, label = \"70%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.8, label = \"80%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.9, label = \"90%\", size = 3) +\n  annotate(\"text\", x = 20, y = 1, label = \"100%\", size = 3) +\n  guides(\n    fill = guide_legend(\n      title = \"         Percentage of\\n      Population Accessing\\n         the Following\",\n      ncol = 3, colour = guide_legend(override.aes = list(shape = 17))\n    )\n  )\n\nprint(graph)\n\n\ntheme_legend_title <- theme(\n  legend.title = element_text(size = 8, face = \"bold\", family = \"Arial Black\")\n)\n\ntheme_legend_text <- theme(\n  legend.text = element_text(size = 5, family = \"Arial\")\n)\ntheme2<- theme( legend.key.size = unit(0.3, \"cm\")\n)\ncombined_graph <- graph + theme_legend_title + theme_legend_text + theme2\nlegend <- get_legend(combined_graph)\ngraph<- graph+ theme(legend.position=\"none\")\nprint(graph)\n\n\n\nThe code opens with the creation of the graph itself using ggplot. The ‘Region’, ‘Percentage’, and ‘Category’ columns play a key role in defining the axes and bars of the graph.\nThe use of geom_bar allows bars representing the different categories to be added to the graph, with the possibility of stacking them for clear representation. Customisation continues with scale_x_discrete, limiting the x-axes to specific categories, and coord_polar, which sets the polar coordinate system for a more dynamic display.\nTo make the graph even more appealing, various style changes were made, such as the use of custom colours with scale_fill_manual and the addition of segments, points and annotated text to highlight particular areas of the graph.\nIn the continuation of the code, we refine the aesthetics of the graph. we create an object called combined_graph, to which we add the title and customise the size of the legend text to make it appropriate for the project. Finally, the original legend is hidden and a new customised legend is inserted that reflects all the changes made, bringing the graph closer to the original image.\n\n\ntheme_legend_title <- theme(\n  legend.title = element_text(size = 8, face = \"bold\", family = \"Arial Black\")\n)\n\ntheme_legend_text <- theme(\n  legend.text = element_text(size = 5, family = \"Arial\")\n)\ntheme2<- theme( legend.key.size = unit(0.3, \"cm\")\n)\ncombined_graph <- graph + theme_legend_title + theme_legend_text + theme2\nlegend <- get_legend(combined_graph)\n\n\ngraph<- graph+ theme(legend.position=\"none\")\nprint(graph)\n\n\n\nIn the code provided, the legend of a polar bar graph is being customised in R. A style was defined for the title of the legend, specifying the text size, bold and font. Next, the text of the legend was customised by setting the desired size and font type. The size of the legend keys was also adjusted.\nAfter combining these customisations with the original graph, a new graph called combined_graph was obtained. Next, the customised legend was extracted using the get_legend method.\nFinally, the original legend was hidden in the original graph and the final result was printed, incorporating the customised legend.\n\n\ndati_graficoper <- data.frame(\n  Region = c(\"South Asia\", \"East Asia and Pacific\", \"West and Central Africa\",\n             \"Eastern and Southern Africa\", \"Latin America and Caribbean\",\n             \"Middle East and North Africa\", \"Eastern Europe and central asia\",\n             \"Western Europe\", \"North America\"),\n  Safely_Managed = c(0, 0.55, 0, 0, 0.22, 0.32, 0.33, 0.87, 0.80),\n  Basic = c(0.46, 0.22, 0.27, 0.30, 0.64, 0.56, 0.60, 0.13, 0.20),\n  Limited = c(0.13, 0.6, 0.23, 0.13, 0.05, 0.07, 0.01, 0, 0),\n  Unimproved = c(0.9, 0.14, 0.25, 0.36, 0.06, 0.03, 0.06, 0, 0),\n  surface_water = c(0.32, 0.03, 0.25, 0.21, 0.03, 0.02, 0, 0 , 0)\n)\n\n\n\n\n\ndati_graficoper_long <- dati_graficoper |> \n  tidyr::pivot_longer(cols = -Region, names_to = \"Category\", values_to = \"Percentage\") |> \n  dplyr::group_by(Region) |> \n  dplyr::mutate(Percentage = Percentage / sum(Percentage))\ngraphper <- ggplot(dati_graficoper_long, aes(x = Region, y = Percentage, fill = Category)) +\n  geom_bar(stat = \"identity\", position = \"stack\",color = \"white\", size = 0.1) +\n  ylim(c(0, 2)) +\n  scale_x_discrete(limits = c(letters[1:9], dati_grafico1$Region)) +\n  coord_polar(theta = \"y\", start = 0, direction = -1) +\n  theme_void() +\n  theme(\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    plot.margin = margin(0, 0, 0, 200)\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"Basic\" = \"#7DCA96\",\n      \"Safely_Managed\" = \"#7E8EF3\",\n      \"Limited\" = \"#CCC0F1\",\n      \"Unimproved\" = \"#CBF8C8\",\n      \"surface_water\" = \"black\"\n    )\n  ) +\n  annotate(\n    \"segment\",\n    x = 9,\n    xend = 20,\n    y = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    yend = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1),\n    colour = \"white\",\n    size = 0.2\n  ) +\n  annotate(\"point\", x = 9, y = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0, yend = c(0.1, 0.2, 0.3), color = \"black\", size = 0.2) +\n  annotate(\"point\", x = 9, y = c(0.8, 0.9, 1), color = \"black\", size = 0.2, shape = 16) +\n  annotate(\"segment\", x = 9, xend = 9, y = 0.7, yend = c(0.8, 0.9, 1), color = \"black\", size = 0.2) +\n  annotate(\n    \"text\", x = 8.7, y = 0.60,\n    label = \"Managed\",\n    angle = 105,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  ) +  \n  annotate(\n    \"text\", x = 8.7, y = 0.40,\n    label = \"sanitation\",\n    angle = 75,\n    hjust = 0.5,\n    vjust = 0.5,\n    color = \"black\",\n    size = 2.2\n  )+\n  annotate(\"text\", x = 20, y = 0, label = \"0%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.1, label = \"10%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.2, label = \"20%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.3, label = \"30%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.4, label = \"40%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.5, label = \"50%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.6, label = \"60%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.7, label = \"70%\", size = 3) +\n  annotate(\"text\", x = 20.8, y = 0.8, label = \"80%\", size = 3) +\n  annotate(\"text\", x = 20, y = 0.9, label = \"90%\", size = 3) +\n  annotate(\"text\", x = 20, y = 1, label = \"100%\", size = 3) +\n  theme(legend.position = \"none\")\n\n\nIn this case we carry out exactly the same procedures for the second data set of information, obtaining a similar result.\n\n\ndoppiografico <- grid.arrange(graphper,legend, graph,  ncol = 3, widths = c(30, 0.01, 30)) \n\n\ndoppiografico2 <- cowplot::ggdraw(doppiografico) + \n  theme(plot.background = element_rect(fill=\"#A6A6E2\"))\nprint(doppiografico2)\n\n\n\nIn this step, three graphic elements are combined using the grid.arrange function of gridExtra: graphper, legend, and graph. The layout is organised in three columns, with specific widths for each element. Next, an additional style is applied to the combined layout using cowplot::ggdraw, setting a plot background with a specific colour (#A6A6E2). Finally, the final result is printed.\nEnhancement\n\n\ndati_grafico1 <- data.frame(\n  Region = c(\"South Asia\", \"East Asia and Pacific\", \"West and Central Africa\",\n             \"Eastern and Southern Africa\", \"Latin America and Caribbean\",\n             \"Middle East and North Africa\", \"Eastern Europe and central asia\",\n             \"Western Europe\", \"North America\"),\n  Safely_Managed = c(0, 0, 0.23, 0.26, 0.65, 0.77, 0.84, 0.96, 0.99),\n  Basic = c(0.88, 0.94, 0.40, 0.28, 0.31, 0.16, 0.11, 0.3, 0),\n  Limited = c(0.4, 0.1, 0.10, 0.18, 0.1, 0.4, 0.2, 0, 0),\n  Unimproved = c(0.7, 0.4, 0.2, 0.16, 0.2, 0.2, 0.2, 0.1, 0.1),\n  surface_water = c(0.1, 0.1, 0.7, 0.12, 0.1, 0.1, 0.1, 0, 0)\n)\n\ndati_grafico1_long <- dati_grafico1 |> \n  tidyr::pivot_longer(cols = -Region, names_to = \"Category\", values_to = \"Percentage\") |> \n  dplyr::group_by(Region) |> \n  dplyr::mutate(Percentage = Percentage / sum(Percentage))\n\ngrafico1_best <- ggplot(dati_grafico1_long, aes(x = Percentage, y = Category, fill = Region)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  xlab(\"Percentage\") +\n  ylab(\"Water Category\") +\n  ggtitle(\"Water Sanitation in Different Regions\") +\n  theme(axis.text.y = element_text(angle = 0, hjust = 0)) +\n  scale_fill_manual(values = c(\n    \"South Asia\" = \"#98F5FF\",\n    \"East Asia and Pacific\" = \"#FFF68F\",\n    \"West and Central Africa\" = \"#FFA07A\",\n    \"Eastern and Southern Africa\" = \"red\",\n    \"Latin America and Caribbean\" = \"black\",\n    \"Middle East and North Africa\" = \"blue\",\n    \"Eastern Europe and central asia\" = \"green\",\n    \"Western Europe\" = \"purple\",\n    \"North America\" = \"orange\"\n  )) +\n  guides(fill = guide_legend(title = \"Region\"))  # Change legend title\n\nprint(grafico1_best)\n\n\n\nI decided to improve this graph by simplifying, a simple bar plot makes the information clearer and less confusing. It conveys all the information without making it difficult for the reader to understand.\nInitially, the dataset data_graph1 is transformed from wide to long format using the function tidyr::pivot_longer. Next, the percentages are normalised for each region, ensuring that the total sum of each region is equal to 1.\nNext, using the ggplot2 library, a bar graph called graph1_best is created, which visually represents the distribution of the water supply categories in the different regions. The categories are positioned on the y-axis, while the percentages are represented on the x-axis. The bars are coloured according to the specific regions.\nThe graph has been customised with titles for the axes and the main title, and the angle of the text on the y-axis has been changed for better readability. The colours of the bars were manually selected to distinctively represent each region. The legend was adapted to include the title ‘Region’.\n\n\ngraficomigliore_per <- ggplot(dati_graficoper_long, aes(x = Percentage, y = Category, fill = Region)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  xlab(\"Percentage\") +\n  ylab(\"Sanitation Category\") +\n  ggtitle(\"Managed Sanitation in Different Regions\") +\n  theme(axis.text.y = element_text(angle = 0, hjust = 0)) +\n  scale_fill_manual(values = c(\n    \"South Asia\" = \"#98F5FF\",\n    \"East Asia and Pacific\" = \"#FFF68F\",\n    \"West and Central Africa\" = \"#FFA07A\",\n    \"Eastern and Southern Africa\" = \"red\",\n    \"Latin America and Caribbean\" = \"black\",\n    \"Middle East and North Africa\" = \"blue\",\n    \"Eastern Europe and central asia\" = \"green\",\n    \"Western Europe\" = \"purple\",\n    \"North America\" = \"orange\"\n  )) +\n  guides(fill = guide_legend(title = \"Region\"))  # Change legend title\n\nprint(graficomigliore_per)\n\n\n\nThe same enhancement have been done for the second data set.\n\n\n\n",
    "preview": "projects/2023/100508949/100508949_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100517341/",
    "title": "Is the World Moving Enough?",
    "description": "A look at the mortality due to low physical activity worldwide.",
    "author": [
      {
        "name": "Mathieu Bietrix",
        "url": {}
      }
    ],
    "date": "2024-01-28",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nOriginal graph\nThe data\nDeaths due to low physical activity\nWorld’s population data\nWorld data\nFinal dataset\n\nMain chart\nCreating the world map\nAdding the text elements\nTheme\nAdding the data\nAdjustments\nInteractive version of the plot\n\nThe line graph\nCoordinate and axes\nTheme and labs\nAdding the data\nAnnotations\n{ggiraph} version of the line plot\nAdjustments\n\nAlternative graphs\nThe data\nAlternative map\nAlternative line graph\n\nProject takeaways and what I learned\n\nOriginal graph\nThe original graph can be found following this link.\nOriginal graphThe data\nDeaths due to low physical activity\n\n\n# Libraries used\n\nlibrary(tidyverse)\nlibrary(arules)\nlibrary(sf) \nlibrary(rnaturalearth)  \nlibrary(ggtext)  \nlibrary(ggiraph)\nlibrary(ggrepel)\nlibrary(kableExtra) \nlibrary(gt)\nlibrary(gtExtras)\nlibrary(ggpp)\n\n\nFortunately, the data used to create this graph was already available on Our Word In Data and can be downloaded in a CSV format. This dataset was originally published by the Institute of Health Metrics and Evaluation, an American research institute in the area of global health statistics. It consists of the number of deaths attributed to low physical activity per country per year. As the data is already available, I will not make use of the {owidR} package that enable to load OWID data in R. Let’s import the dataset.\n\n\ndata <- read_csv(file = \"Final_Project_Dataset.csv\")  \n\n\nThe dataset is already tidy data, and is ready to be used.\nWorld’s population data\nIn order to facilitate the modifications that we would like to do to the original graph later, we need to add a new column to the dataset with the population of the countries. To do so, we need a dataset of the total population of these countries from 1990 to 2019. One can be found one via another chart created by Our World In Data.\nWe need to filter the data to only keep the data from 1990 to 2019. Also, the population dataset contains the total population per continent. These rows are easy to spot, they have missing values as country codes.\n\n\npopulation <- read_csv(file = \"Population_per_country_per_year.csv\")\n\npopulation <- population |>\n    filter(Year >= 1990 & Year <= 2019) |>\n    drop_na(Code)\n\n\nNow that we have the population dataset containing the total population of countries between 1990 and 2019, we can create a new dataset that joins the data tibble and the population tibble and that contains a column with the total population of each country for each year.\n\n\ndata <- \n  inner_join(data, population, \n             by = c('Code'='Code', 'Year'='Year', 'Entity'='Entity')) |>\n# Let's rename the columns for better readability\n  rename(c(\n    Deaths = `Deaths that are from all causes attributed to low physical activity, in both sexes aged all ages`,\n    Population = `Population (historical estimates)`\n           )\n         )\n\n\nWe are almost done. As we can see on the original Our World in Data graph, the color attributed to each country is assigned on the basis of the range of number of deaths due to low activity in the country for a given year. Therefore, we need to discretize this variable in 9 different ranges, as the color scale used by OWID contains 9 ranges. After searching on the Web, I found that such an operation could be performed thanks to the {arules} package, using the discretize() function.\n\n\nlibrary(arules)  \n\n# We define a vector that contains the values of the edges of each range used in the color scale of the original graph.\n\nbreaks_map <- c(0, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000)\ndata <-   \n  data |> \n  mutate(Deaths_disc = discretize(Deaths, method = 'fixed', breaks = breaks_map),\n         .after = Deaths) \n\n\nWorld data\nTo plot a map of the deaths due to low physical activity, we obviously need a map. To build this map, we need data as longitudes and latitudes of the countries worldwide. We will use the {sf} package to represent visally the geographic data (which are polygons) and the {rnaturalearth} to obtain this data.\nFirst, we use the ne_countries() function from the rnaturalearth package. This function contains predownloaded vector maps for the world’s countries. We also want to make our world data a sf object, so that we can use the sf package in the future. The latter can be done by providing the argument returnclass = 'sf' (the default).\n\n\nlibrary(sf) \nlibrary(rnaturalearth)  \n\nworld <- ne_countries()\n\n\nFinal dataset\nWe know need to join the world dataset and the data dataset to create the dataset that will be used to project the world map in ggplot2 and display the number of deaths due to low physical activity at the same time.\n\n\ndata <-\n  world |>\n  left_join(data, by = c('adm0_a3' = 'Code'))\n\n\nFinally, let’s clean up our data dataset a bit so that R may have less difficulty to run the code that we will write to create the graph. Indeed, there are a vast majority of columns that we are not going to be using to display the data of interest with ggplot. The only columns that we need are :\ngeometry, which is used by geom_sf() to plot the shapes of the countries.\nEntity: the name of the country\ncontinent\nsubregion\nYear\nDeaths\nDeaths_disc\nPopulation\n\n\ndata <-\n  data |>\n  select(Entity,\n         continent,         \n         subregion,          \n         Year,          \n         Deaths,          \n         Deaths_disc,          \n         Population,          \n         geometry)  \n\n\nOn a visual standpoint, the OWID graph doesn’t show Antartica, so we can remove the data linked to it in our dataset. Lastly, there are many islands that might pop on our graph. The simplest solution is to clear our data dataset from some of these islands, which seem to be Polynesia.\n\n\ndata <-   \n  data |>   \n  filter(continent != 'Antarctica') |>    \n  filter(subregion != 'Polynesia')\n\n\nMain chart\nCreating the world map\nThe first thing we need to do is to create a projection of the world. As mentioned earlier, we will use the {sf} package, particularly the geom_sf() geom that enables to easily visualize sf objects. One of the advantage of this geom is that it is smart enough to understand the geometry type to draw according to the dataset we provide it.\n\n\np <-    \n  data |>    \n  ggplot() +   \n  geom_sf()  \n\np\n\n\n\nAt this point, we have generated an empty map of the world. One thing we can notice is that the projection (meaning the way a 3D object, the world, is represented in 2D) used by default by geom_sf() is not exactly the same as the one used by Our World In Data. It seems that the latter is a “Robinson” projection. We can use the coord_sf() function to change our projection to a Robinson one.\n\n\np <-    \n  p +   \n  coord_sf(crs = \"+proj=robin\")  \n\np\n\n\n\nAdding the text elements\nLet’s add:\nThe title: “Deaths due to low physical activity, 2019”,\nThe subtitle: “Estimated annual number of deaths attributed to low physical activity”,\nAnd the caption “Data source: IHME, Global Burden of Disease (2019) – Learn more about this data\nOurWorldInData.org/causes-of-death | CC BY”\nAfter going further, it appeared that the caption was more easily handled if we divided it in two parts: a caption and a tag. Note that for the moment, the tag position is clearly not good, as well as the size of its text, which will both be addressed when setting the theme. For convenience until then, let’s comment the tag.\n\n\nplot_title <- \"Deaths due to low physical activity, 2019\" \nplot_subtitle <- \"Estimated annual number of deaths attributed to low physical activity.\"\nplot_caption <- \"Data source: IHME, Global Burden of Disease (2019) - Learn more about this data\" \nplot_tag <- \"OurWorldInData.org/causes-of-death | CC BY\"  \n\n\n\n\np <-   \n  p +  \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption        \n       #tag = plot_tag        \n       )  \n\np\n\n\n\nTheme\nOne thing that we notice is that the OWID graph has a clean white background, without any displayed meridian. As the meridians are already colored in white, adding a theme_classic() should give us the look we are looking for. But we also want to get rid of the longitude axis. Then, the most appropriate theme to use is the theme_void().\n\n\np <- \n  p +\n  theme_void()\n\n\nAlso the caption of the OWID plot has to be moved on the left, the size of the font has to be modified so that the subtitle and caption are smaller, and the title bigger. Finally, the font of the title can be switched to something approximating the Times New Roman font. Unfortunately, we were unable to use the latter font (which remains the biggest mystery of my year 2023 as it’s the most basic font ever), so we needed to get an equivalent from the Google Font, the Merriweather font.\nWe can also de-comment the tag, and set its size and position in the theme(). After unsuccessfully trying several positions for the tag, such as ‘bottom’, and ‘bottomleft’, it appeared that the easiest solution was to manually set its position using plot.tag.position = 'bottom' (which gets the tag under the caption but in the center of the plot), and the margin argument of plot.tag = element_text().\n\n\nsysfonts::font_add_google('Merriweather', family = 'merriweather') \nshowtext::showtext_auto()\n\n\n\n\np <-   \n  data |>   \n  ggplot() +   \n  geom_sf() +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) + # adding the tag   \n  theme_void() +   \n  theme(plot.title = element_text(family = 'merriweather', size = 15),         \n        plot.caption = element_text(hjust = 0),         \n        plot.tag.position = 'bottom',         \n        plot.tag = element_text(size = 10, # customizing tag's size and position\n                                margin = margin(l = -340)))  \n\np\n\n\n\nAdding the data\nSo far, we have a chart that has some common appearance traits shared with the Our World in Data graph. We can now add the information we want to display, focusing on a single year: 2019.\nThe first step is to filter the data to obtain only the data from 2019. Then, we can add an aesthetic to the geom_sf() geom to display the number of Deaths from low physical activity around the world. Since we want to color the map according to this variable, we will use the fill aesthetic.\n\n\np <-    \n  data |>\n  filter(Year == 2019) |> # filtering by year   \n  ggplot() +   \n  geom_sf(aes(fill = Deaths_disc)) +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) +   \n  theme_void() +   \n  theme(plot.title = element_text(family = 'merriweather', size = 15),   \n        plot.caption = element_text(hjust = 0),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(size = 10,    \n                                margin = margin(l = -340)))\n\np\n\n\n\nAdjustments\nOne striking difference with the original plot is the legend. We need to move the legend to the bottom of the chart and change the color palette. We need to change the legend key into a color bar. This can be done by using a “Discretized colourbar guide”: the guide_colorsteps() guide. Within this guide, the “YlorRd” palette seems exactly the one that was used by Our Word In Data for their map.\n\n\np <-    \n  data |>   \n  filter(Year == 2019) |>   \n  ggplot() +   \n  geom_sf(aes(fill = Deaths_disc)) +   \n  coord_sf(crs = '+proj=robin') +   \n  labs(title = plot_title,        \n       subtitle = plot_subtitle,        \n       caption = plot_caption,        \n       tag = plot_tag) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = 'merriweather',\n      size = 15),\n    plot.caption = element_text(\n      hjust = 0),\n    plot.tag.position = 'bottom',         \n    plot.tag = element_text(\n      size = 10,                                  \n      margin = margin(l = -340)),\n    legend.position = 'bottom', # moving the legend around           \n    legend.title = element_blank()) +   \n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps( # Modifying the default legend guide\n                      ticks = TRUE,  \n                      barwidth = 25,  \n                      barheight = 0.5, \n                      frame.colour = 'black',  \n                      frame.linewidth = 0.01,      \n                      ticks.colour = 'black',   \n                      ticks.linewidth = 0.01) \n                    )   \n\np\n\n\n\nOur plot starts looking a bit similar to the OWID one. Let’s move the legend’s labels on top of the legend, and display the limits of the legend. I thought that the first operation could be done by modifying the legend.text in the theme() function, but it seems not possible. Therefore, we can play on the margin argument of the element_text() function in the theme() to move the legend’s label around.\nThe limits are ruled by an argument of the previously used guide_colorsteps(): show.limits.\n\n\np <-    \n  data |>   \n  filter(Year == 2019) |>    \n  ggplot() +  \n  geom_sf(\n    aes(fill = Deaths_disc)) +\n  coord_sf(crs = '+proj=robin') +\n  labs(title = plot_title,\n       subtitle = plot_subtitle,\n       caption = plot_caption,\n       tag = plot_tag) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = 'merriweather',\n      size = 15),\n    plot.caption = element_text(\n      hjust = 0),\n    plot.tag.position = 'bottom',         \n    plot.tag = element_text(\n      size = 10,\n      margin = margin(l = -340)),\n    legend.position = 'bottom',\n    legend.title = element_blank(),\n    legend.text = element_text(           \n      margin = margin(t = -22) # adjusting the position of legend's labels\n      )\n    ) +   \n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps(  \n                      show.limits = TRUE, # adding the scale limits to the legend\n                      ticks = TRUE,      \n                      barwidth = 25,                       \n                      barheight = 0.5,                       \n                      frame.colour = 'black',\n                      frame.linewidth = 0.01,                       \n                      ticks.colour = 'black',\n                      ticks.linewidth = 0.01)\n                    )   \n\np\n\n\n\nNow the caption is slightly overriding the legend. We couldn’t fix it in the theme() by specifying a vjust argument to plot.caption, so rather decided to add a \\n at the beginning of the caption to create an empty line.\n\n\n# We added a newline character at the beginning of the string to create space over the caption\nplot_caption <- \"\\nData source: IHME, Global Burden of Disease (2019) - Learn more about this data\" \n\n\n\n\np \n\n\n\nSome adjustments also need to be done:\nThe borders of the polygons projected by geom_sf() seem to be a bit thicker than on our original OWID graph.\nMany islands remain on the graph, giving it a messier look than the original one.\nThe title, subtitle, caption and tag need to be spaced a bit from the border of the graph.\nFor the first two issues, it seems that the solution could lie in the fact that the resolution/definition of the geometry variable used to project polygons on the graph and thus create a world map, is too high. I tried to use the st_simplify() function from the sf package but wasn’t able to then map my data. However, a much simpler way to do so worked well, by just lowering the scale of the ne_countries() function. This results in less details in the geometry variable, and thus, a less messy visual appearance. Of course, this option is not the optimal one in terms of precision, but it seems that Our World In Data opted for displaying the data for not all countries and island worldwide.\nThe 3rd issue can easily be solved with some little modifications of the theme() by passing a hjust argument to plot.title = element_text() and so on for the subtitle and caption.\nThe look is a lot cleaner, with softer edges. Let’s then try to :\nSpace the title, subtitle, caption, and tag a bit from the left of the plot. This can be achieved by playing on the hjust (margin for the tag) argument of each of these element_text() in the theme().\nGet the title bold, the caption at the same size as the subtitle, the size of the tag a bit lower than the caption. To do so, we will add face and size arguments to element_text() in the theme().\nGet the “Data source” string in the caption bold. For this, we will modify the plot_caption variable, load the {ggtext} library, and set plot.caption to ggtext::element_markdown.\nFinally, the color of the text is not black in the original plot, but this color: #5b5b5b.\n\n\n# Recap of the data processing with the modification on the ne_countries() function\n\ndata <- read_csv(file = \"Final_Project_Dataset.csv\")  \n\npopulation <- read_csv(file = \"Population_per_country_per_year.csv\")  \n\npopulation <- \n  population |>\n  filter(Year >= 1990 & Year <= 2019) |>\n  drop_na(Code)  \n\ndata <-\n  inner_join(\n    data, \n    population, \n    by=c('Code'='Code', 'Year'='Year', 'Entity'='Entity')) |>\n  rename(c(Deaths = `Deaths that are from all causes attributed to low physical activity, in both sexes aged all ages`,\n           Population = `Population (historical estimates)`))\n\nbreaks_map <- c(0, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000, 250000)  \n\ndata <-\n  data |> \n  mutate(Deaths_disc = discretize(\n      Deaths, \n      method = 'fixed', \n      breaks = breaks_map),          \n    .after = Deaths)  \n\nworld <- \n  ne_countries(   \n    scale = 'small', # setting the value of the scale from \"large\" to \"small\"   \n    returnclass = 'sf'\n    )  \n\ndata <-\n  world |>    \n  left_join(data, \n            by = c('adm0_a3' = 'Code'))   \n\ndata <-  \n  data |>\n  select(Entity,          \n         continent,          \n         subregion,          \n         Year,          \n         Deaths,          \n         Deaths_disc,          \n         Population,          \n         geometry)  \n\ndata <-\n  data |>\n  filter(continent != 'Antarctica') |>    \n  filter(subregion != 'Polynesia')\n\n\n\n\n# The plot, with these changes\n\nlibrary(ggtext)  \n\nplot_caption <- \"\\n**Data source**: IHME, Global Burden of Disease (2019) - Learn more about this data\"  \n\np <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf(\n    aes(fill = Deaths_disc)\n    ) +   \n  coord_sf(crs = '+proj=robin') +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    \n    # We add more space to the title, subtitle, caption and tag, using hjust, vjust, and margin. \n    # We also play on the size of these text elements.\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b', # We add the grey color for text elements (modif 1)\n      face = 'bold',\n      size = 23,                                   \n      hjust = 0.08,\n      margin = margin(t = -10)\n      ),\n    \n    plot.subtitle = element_text(\n      color = '#5b5b5b', # grey color added\n      hjust = 0.1,                                     \n      size = 18),\n    \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b', # grey color added\n      hjust = 0.1,\n      size = 18,\n      margin = margin(t = 20)\n      ),       \n    \n    plot.tag.position = 'bottom',     \n    \n    plot.tag = element_text(\n      color = '#5b5b5b', # grey color added\n      size = 16,                                  \n      vjust = -1,\n      margin = margin(l = -280)\n      ),          \n    legend.position = 'bottom',\n    legend.title = element_blank(),         \n    legend.text = element_text(\n      size = 20,         \n      margin = margin(t = -22)\n      )\n    ) +   \n  \n  # No change in the scale\n  scale_fill_brewer(\n    palette = 'YlOrRd',\n    guide = guide_coloursteps(                        \n      show.limits = TRUE,\n      ticks = TRUE,            \n      barwidth = 25,           \n      barheight = 0.5,        \n      frame.colour = 'black', \n      frame.linewidth = 0.01,    \n      ticks.colour = 'black', \n      ticks.linewidth = 0.01)\n    ) \n\np \n\n\n\nInteractive version of the plot\nExactly as in the gapminder project, one of the point of the graph is to get it display an evolution over time. So far, we’ve been plotting the data only for year 2019, but it would be nice to create a more interactive plot, just as the original Our World In Data graph, that enables the user to filter the data by year and continent. Unfortunately for me, the integration of geom_sf() into the plotly library is not optimal, rendering a plot that is dynamic, but looks awful, with quite all of the modifications to the theme() not taken into account.\nA solution that I found was to use the {ggiraph} package to make the plot interactive. The filtering function seems requiring some features to create interfaces that ggplot cannot provide, such as integrating the plot in a Shiny application. Therefore, we will give up this last feature.\nThe ggiraph package is very easy to use and works the following way :\nWe make the geoms interactive by appending the “_interactive” to them.\nWe provide two aesthetics: tooltip, and data_id.tooltip enables to specify which variable needs to be displayed in the tooltip generated by the package.\nOn the other hand, data_id enables to indicate the variables that will be linked to visual effects, that we can define with CSS code paired with the argument options of the girafe() function.\nWe create a new and interactive graph by passing our plot to the girafe() function.\n{ggiraph} version of the map plot\n\n\nlibrary(ggiraph)  \n\np_girafe <-    \n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive( # Switching geom_sf to its ggiraph version       \n    aes(\n      fill = Deaths_disc,        \n      tooltip = sprintf(\"%s: %.3f\", Entity, Deaths)  # Enables to get a tooltip when hovering over the countries with name and percentage of death       \n      )\n    ) +   \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",                                    \n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 15,                                  \n      hjust = 0.1,                                   \n      margin = margin(t = -10)\n      ),\n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.11,                                      \n      size = 11\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.11,\n      size = 11,                                                 \n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 10,                                  \n      vjust = -1,                                 \n      margin = margin(l = -301)\n      ),\n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(           \n      margin = margin(t = -22)          \n      )\n    ) +\n  scale_fill_brewer(\n    palette = \"YlOrRd\",\n    guide = guide_coloursteps(                        \n      show.limits = TRUE,                        \n      ticks = TRUE,                       \n      barwidth = 25,                       \n      barheight = 0.5,                       \n      frame.colour = \"black\",\n      frame.linewidth = 0.01,                       \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.01\n      )\n    )  \n\ngirafe(ggobj = p_girafe)\n\n\nYay it works ! A few things need to be modifed. “A few”.\nAdjustments\nFirst, the position of the plot in the panel is not good. After a few iterations, I noticed that this was just a matter of playing on the margins already existing in our ggplot. Similarly, other theme() elements need to be adjusted.\nHowever, one drawback of the {ggiraph} package is that, without really knowing why:\nIt sizes the theme elements in a differently than the original plot, which requires a lot of micro-adjustment.\nIt seems that its integration to the different types of rendering such as Quarto Presentations or html also requires a lot of these micro-adjustments.\n\n\n# Micro adjustments of size, margin arguments, nothing mindblowing here\np_girafe <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive(\n    aes(        \n      fill = Deaths_disc,        \n      tooltip = sprintf(\"%s: %.0f\", Entity, round(Deaths)) # btw, this was copied from the ggiraph documentation       \n      )\n    ) +    \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,\n    tag = plot_tag\n    ) +   \n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",                                   \n      size = 12,                                   \n      hjust = 0.1,                                   \n      ),          \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                      \n      size = 8),\n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.11,                                                 \n      size = 8,\n      margin = margin(t = 20)\n      ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",                                 \n      size = 7,\n      vjust = -1,\n      margin = margin(l = -261)\n      ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(           \n      hjust = 0.8,           \n      size = 8,           \n      margin = margin(t = -22)         \n      )\n    ) +   \n  scale_fill_brewer(\n    palette = \"YlOrRd\",\n    guide = guide_coloursteps_interactive(\n      show.limits = TRUE,                        \n      ticks = TRUE,                       \n      barwidth = 25,            \n      barheight = 0.5,          \n      frame.colour = \"black\",    \n      frame.linewidth = 0.1,      \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.1)\n    )  \n\ngirafe(ggobj = p_girafe)\n\n\nHere are some improvements that we can still do:\nGive the tooltip a better appearance and make them display the absolute number of deaths due to low physical activity.\nThis interactivity with the plot will be created by adding an options in the girafe() function.\nThis require to create a CSS declarations for the style we want for the elements that are hovered, and pass these declarations to the css argument of the hover_opt() functions and functions related. These functions enable us to tailor the effects of hovering parts of the graph with our mouse. For sake of efficiency and because of my lack of knowledge in CSS, the declarations are generated by AI and adjusted if needed.\nNote: After knitting, I end up with a location of the graph in the panel that is really not good. The aspect of the plot in R Studio is not how it will be rendered. I think I may have used an argument in a way that it is not purposed to, but I couldn’t figure it out.\n\n\n# A \" ' \" symbol for the country \"Cote d'Ivoire\" was producing errors in ggiraph (God Bless French subtleties)  \n\ndata <-\n  data |>\n  mutate(Entity = if_else(Entity == \"Cote d'Ivoire\", \"Cote d Ivoire\", Entity))\n\n# Defining the style of the tooltip  \ntooltip_css <- \"background-color: rgba(245, 245, 245, 1); \n                color: #000000; \n                font-family: 'Arial', sans-serif;\n                font-size: 11px; \n                border-radius: 4px;\n                border: 1px solid #d9d9d9; \n                padding: 8px;\"  \n\np_map_girafe <-\n  data |>\n  filter(Year == 2019) |>    \n  ggplot() +   \n  geom_sf_interactive(\n    aes(        \n      fill = Deaths_disc,        \n      tooltip = paste0(\"<b>\", Entity,\"<\/b>\", \"\\nNumber of Deaths: \", round(Deaths)),\n      data_id = Entity)\n    ) +   \n  coord_sf(crs = \"+proj=robin\") +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,       \n    tag = plot_tag\n    ) +   \n  theme_void() +   \n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 12,                                   \n      hjust = 0.1,  \n      ), \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                      \n      size = 8\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.1,                                                 \n      size = 8,                                                 \n      margin = margin(t = 20)\n      ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 7,\n      vjust = -1,\n      margin = margin(l = -292)\n      ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),         \n    legend.text = element_text(         \n      size = 8,\n      margin = margin(t = -22)          \n      )\n    ) +   \n  scale_fill_brewer(     \n    palette = \"YlOrRd\",     \n    guide = guide_coloursteps(       \n      show.limits = TRUE,        \n      ticks = TRUE,       \n      barwidth = 25,\n      barheight = 0.4,       \n      frame.colour = \"black\",\n      frame.linewidth = 0.1,       \n      ticks.colour = \"black\",    \n      ticks.linewidth = 0.1)\n    )  \n\n# * Lowering the opacity of all the non-hovered elements \n## * Defining borders around the hovered elements\n\ngirafe(ggobj = p_map_girafe,        \n       options = list(          \n         opts_hover_inv(css = \"opacity:0.7;\"), # *          \n         opts_hover(css = \"stroke-width:1.2;stroke:black;\"), # **          \n         opts_tooltip(css = tooltip_css)\n         )\n       )  \n\n\nAt this stage, I think my map is complete.\nThe line graph\nA second graph is joined to the map, in a new tab, that contributes to make this Our World In Data plot so complete. It shows the evolution of the number of deaths due to low physical activity year after year between 1990 and 2019. Since we already have the dataset, we can create a line plot. It has to be noted we are not plotting the entire dataset, as you could access it on the original graph.\nIf fact, one of the cool features that it has is that it provides a filter that enables you to select which countries you want to see on the graph. This greatly facilitates the comparison of evolutions between countries. However, I couldn’t find ways to provide this feature other than placing the graph into a Shiny Application. Since I really don’t know anything about Shiny, I’ll focus on a graph of the 10 countries with most Deaths by year.\nCoordinate and axes\nUnlike the map, this type of graph has axis. These axes have:\nNo label\nIncrementation of 5 years (for x axis) and 5000 deaths (for y axis)\nStarting points at the origin of the coordinate system\nThe plot also has horizontal lines for each 5000 deaths. We had to add also a geom_vline() because without it, the x-axis was disappearing.\n\n\np_line <-    \n  data |>    \n  ggplot(aes\n         (x = Year, \n           y = Deaths)\n         ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),              \n    linetype = 'dashed', \n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019), \n    ylim = c(0, 140000)\n    ) +\n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019), \n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    )  \n\np_line\n\n\n\nTheme and labs\nLet’s now add some elements of theme to the plot, according to the original graph:\nThe y axis is removed, as well as the ticks,\nWe have no titles for both x and y axes,\nThe values displayed along the axes are colored in the same grey as the title, subtitle, caption, and tag of the map,\nThe background is removed, which can be easily done with a theme_classic()\n\n\np_line <-\n  data |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +    \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 20000, to = 140000, by = 20000),        \n             linetype = 'dashed',\n             color = '#dddddd'\n             ) +    \n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"         \n      )\n    )  \n\np_line\n\n\n\nNow, we can add the labs, which are almost the same as on our map.\n\n\np_line <-\n  data |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),              \n    linetype = 'dashed',\n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +\n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  scale_y_continuous(breaks = seq(from = 0, to = 140000, by = 20000),\n                     expand = expansion(mult = c(0, 0.1))\n                     ) +\n  # Copy and paste the labs from our map   \n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"),\n    # Copy paste the theme elements associated to the labs from the map\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b',\n      face = 'bold',\n      size = 15,                                   \n      hjust = -0.18, # Adjusted                                 \n      margin = margin(t = 10) # Adjusted\n      ),         \n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = -0.205, # Adjusted                                       \n      size = 11,\n      margin = margin(t = 5) # Added\n      ), \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = -0.280, # Adjusted\n      size = 11,\n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 10,\n      vjust = -1,                                 \n      margin = margin(b = 10, # Added\n                      l = -320) # Adjusted\n      )          \n    )   \n\np_line\n\n\n\nAdding the data\nThe aesthetic we want to get is color, with each color representing a country, so we map Entity to color. However, since there are more than 150 countries in our data dataset, the best option that we have for the moment is to filter our data with certain countries. For instance, we can get the 10 countries with most deaths in 2019.\nAlso, the original plot has a second geom, that is geom_point() so let’s add it.\n\n\n# Defining a vector of the 10 countries with most Deaths in 2019\ntop10_countries_2019 <-\n  data |> \n  filter(Year == 2019) |> \n  slice_max(order_by = Deaths, n = 10) |> \n  select(Entity) |> \n  st_drop_geometry() |> \n  as_vector()\n\np_line <-\n  data |>  \n  filter(Entity %in% top10_countries_2019) |> # Now, our data is filtered\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +  \n  # Adding the points layer to the plot\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE,\n    size = 0.7\n    ) +   \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dashed',    \n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),         \n    axis.ticks.y = element_blank(),         \n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"\n      ),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 25,\n      hjust = 0,                                    \n      margin = margin(t = 10)\n      ),          \n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 16,\n      margin = margin(t = 5)\n      ),         \n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 16,                                                 \n      margin = margin(t = 20)\n      ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 15,                                  \n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -270)\n      )\n    )   \n\np_line\n\n\n\nAnnotations\nWe can add the annotations thanks to the {ggrepel} package. To be honest, I had a lot of struggle to find the good balance between the size of the annotation, the segments and the alignment of the annotations. At this stage, it was mostly a matter of iterations playing on the arguments of the geom_text_repel() function.\n\n\nlibrary(ggrepel) \n\np_line <-   \n  data |>  \n  filter(Entity %in% top10_countries_2019) |> \n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE,\n    size = 0.7\n    ) +   \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +   \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 20000, to = 140000, by = 20000),  \n             linetype = 'dashed',\n             color = '#dddddd'\n             ) +    \n  coord_cartesian(\n    xlim = c(1990, 2019), \n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.2))\n    ) +   \n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),               \n    expand = expansion(mult = c(0, 0.1))\n    ) +   \n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +   \n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,\n      color = \"#5b5b5b\"\n      ),\n    plot.title = element_text(\n      family = 'merriweather',                                    \n      color = '#5b5b5b',\n      face = 'bold',\n      size = 25,                                   \n      hjust = 0,                                    \n      margin = margin(t = 10)\n      ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 16,\n      margin = margin(t = 5)\n      ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 16,                                                 \n      margin = margin(t = 20)\n      ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 15,                                  \n      vjust = -1,                                 \n      margin = margin(b = 10,\n                      l = -255))\n    ) +\n  \n  # Adding the different annotations       \n  geom_text_repel(aes(\n    label = Entity,                           \n    color = Entity,                           \n    segment.shape = 0\n    ),\n    show.legend = FALSE,\n    data = data |>\n      filter(Year == 2019 & Entity %in% top10_countries_2019),\n    size = 4,                           \n    force = 0.5,                           \n    position = position_nudge_to(x = 2021),\n    direction = \"y\",\n    hjust = 0,\n    segment.curvature = -0.0000001,\n    segment.linetype = 'dotted'\n    )   \n\np_line\n\n\n\nThis is my final line graph.\nNow, let’s try to apply what we learned about {ggiraph} here.\n{ggiraph} version of the line plot\nThe {ggiraph} version follows the same logic as the map we previously created. We’re therefore appending “_interactive” to the geom_line() and to the geom_point() geoms.\n\n\np_line_girafe <-\n  data |>  \n  filter(Entity %in% top10_countries_2019) |>   \n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +   \n  # Making the line interactive   \n  geom_point_interactive(\n    aes(\n      color = Entity,     \n      tooltip = paste0(Year, \" \", Deaths),     \n      data_id = Year\n      ),\n    show.legend = FALSE,     \n    size = 0.7\n    ) +    \n  # Making the points interactive   \n  geom_line_interactive(\n    aes(   \n      color = Entity,     \n      tooltip = Deaths,     \n      data_id = Year\n      ),\n    show.legend = FALSE) +\n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dashed',\n    color = '#dddddd'\n    ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000)\n    ) +   \n  scale_x_continuous(\n    breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n    expand = expansion(mult = c(0, 0.2))\n    ) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),\n    expand = expansion(mult = c(0, 0.1))\n    ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,\n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_classic() +\n  theme(axis.line.y = element_blank(),         \n        axis.ticks.y = element_blank(),\n        axis.title = element_blank(),         \n        axis.text = element_text(           \n          size = 13,   \n          color = \"#5b5b5b\"\n          ),         \n        plot.title = element_text(\n          family = 'merriweather',                                    \n          color = '#5b5b5b',\n          face = 'bold',\n          size = 15,                                   \n          hjust = -0.18,                                    \n          margin = margin(t = 10)\n          ),          \n        plot.subtitle = element_text(\n          color = '#5b5b5b',\n          hjust = -0.205,                                       \n          size = 11,\n          margin = margin(t = 5)\n          ),\n        plot.caption = ggtext::element_markdown(\n          color = '#5b5b5b',\n          hjust = -0.280,                                                  \n          size = 11,\n          margin = margin(t = 20)\n          ),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(\n          color = '#5b5b5b',\n          size = 10,\n          vjust = -1,\n          margin = margin(b = 10,                                           \n                          l = -320))\n        ) +\n  geom_text_repel(\n    aes(\n      label = Entity,\n      color = Entity,                           \n      segment.shape   = 0\n      ),\n    show.legend = FALSE,                       \n    data = data |>                          \n      filter(Year == 2019 & Entity %in% top10_countries_2019),\n    size = 3,\n    force = 0.5, \n    position = position_nudge_to(x = 2021),\n    direction = \"y\",\n    hjust = 0,                          \n    segment.curvature = -0.0000001\n    )   \n\ngirafe(ggobj = p_line_girafe)\n\n\nAdjustments\nWe can notice that the lines are displaying the number of deaths due to low physical activity for year 1990 (which is not what we want), and that even if the points display the year and number of deaths, they are super hard to hover over with the mouse. A cool feature that has been included on the OWID graph is that when you hover your mouse over the graph, a table is displayed with the following information :\nThe year that corresponds to the position of your mouse on the graph,\nThe unit of what is measured (deaths),\nThe legend followed by the number of deaths of each country for this specific year.\nI actually don’t know if I can include the legend, but it seems to me that I read something in the {ggiraph} documentation about possibilty to make tables pop on your graph interactively, so let’s give it a try.\nEdit: I actually found a great tutorial to do so: https://uncharteddata.netlify.app/posts/2022-09-30-interactive-tooltip-tables/\nCreate the table for the tooltip\nWe first need to create a summary table of the pieces of information we want to display in our tooltip. We can do so by extracting the following columns from our data dataset: Entity, Year, Deaths. It is advised to use the {kableExtra} package to do so.\n\n\nlibrary(kableExtra) \n\n# This code chunk is not run, it shows the process followed to build the function\n# that creates these tables for all rows of the dataset.\n\ntooltip_table <-    \n  data |>  \n  filter(Entity %in% top10_countries_2019) |>    \n  select(Entity, Year, Deaths) |> \n  st_drop_geometry() |> \n  kbl(row.names = FALSE)\n\n\nCreating a table for each observation\nIf we pass the newly created table to our tooltip aesthetic in the line graph, each tooltip will show the whole table. To only show the table part that correspond to the Year we are hovering with the mouse, the author of the tutorial suggests to create a new column in data that will contain a sub-table for each Year. To do so, he creates a function that loops trough each row and create the corresponding table.\nNote: I find it genius, especially because I would have never thought about crafting a function to assign a table to each row. Well, I didn’t even know it was possible, but I still wouldn’t have thought about it.\n\n\n#Not run, process\n\nmake_table <- \n  function(year){\n    data |>\n      filter(Entity %in% top10_countries_2019) |>   \n      filter(Year == year) |>    \n      select(Entity, Year, Deaths) |>    \n      st_drop_geometry() |>  # Only way I found to remove the geometry column\n      kbl(row.names = FALSE)  \n  }\n\n\nThis function is intended to create a table from the data dataset according to the specified year parameter. However, expecting that my computer is going to go crazy if we do so with the more than 5000 rows of the dataset, we can apply it to only the top 10 countries used until now in our line graph. To apply this function to each row, we can use the map() function from the {purrr} library. I purposefully don’t run these code chunk because creating a table for every single line in very heavy on my computer and takes forever. I will therefore only run the final function and “tooltip_table” variable.\n\n\ntooltip_table <-    \n  data |>\n  filter(Entity %in% top10_countries_2019) |>\n  mutate(tooltip_table = purrr::map(Year, make_table)) |>\n  select(Entity, Year, Deaths, tooltip_table)\n\n\nCustomizing the table shown by the tooltip\nTo do so, the author advises to modify the style of the table directly in the function that created them, the make_table() function. Also, it seems that a good appearance can be achieved by using the {gt} and {gtExtras} packages. We will start from the styling of the author and try to customize it.\n\n\nmake_table <- \n  function(year){\n    data |>\n      filter(Entity %in% top10_countries_2019) |>\n      filter(Year == year) |>    \n      select(Entity, Deaths) |>    \n      sf::st_drop_geometry() |>\n      gt() |>\n      gt::fmt_number(columns = Deaths, decimals = 0) |>\n      # adjust column widths   \n      gt::cols_width(everything() ~ px(120)) |>\n      # apply the nytimes theme from {gtExtras}   \n      gtExtras::gt_theme_nytimes() |>\n      # add a title and subtitle to the table   \n      # in the original graph, the title is the Year we are hovering with the mouse   \n      gt::tab_header(title = year, subtitle = \"in deaths\") |>\n      # get HTML content of table   \n      gt::as_raw_html() \n  }\n\n\nIT WORKS. Let’s add some new adjustments:\nWe want to make the tables a little smaller, which can be modified in the function make_table() that create the tables.\nLet’s also reproduce the kind of animation that makes the user see the tables that corresponds to the year her mouse is hovering over. I couldn’t find how to reproduce it exactly, so let’s opt for creating vertical reference lines with geom_vline_interactive(), and make them transparent thanks to the alpha argument. We will make these lines sufficiently wide to reproduce the effect of the OWID graph, which is that whenever the user hovers the graph, a table appears.\nAdd an effect that does the following: when hovering over the name of a country, the lines of the other countries get lower opacity, as on the original OWID graph. This can be done by providing a data_id aesthetic to geom_point_interactive, geom_line_interactive and geom_text_repel_interactive, and adding a first a opt_hover() and opts_hover_inv() similar to the one on the map we previously created.\nTweaking the style of our tooltip tables a bit.\n\n\nlibrary(gt)\nlibrary(gtExtras)\n\nmake_table <- function(year){     \n    data |>     \n    slice_max(n = 10, order_by = Deaths, by = Year) |>     \n    filter(Year == year) |>\n    select(Entity, Deaths) |>\n    sf::st_drop_geometry() |>     \n    drop_na() |>\n    gt() |>\n    gt::fmt_number(columns = Deaths, decimals = 0) |>\n    # Adding the Arial font     \n    opt_table_font(font = \"Arial\") |>\n    # making the Deaths column bold     \n    tab_style(       \n      style =  cell_text(weight = \"bold\"),\n      locations = cells_body(columns = Deaths)\n    ) |>\n    # lowering column widths and row height\n    gt::tab_options(data_row.padding = px(4)) |>\n    gt::cols_width(everything() ~ px(100)) |>\n    # Modifying the font size     \n    gt::tab_options(\n      table.font.size = 11,\n      heading.background.color = \"lightgrey\"\n    ) |>\n    gt::tab_header(title = year,                    \n                   subtitle = \"in deaths\"\n    ) |>\n    gt::as_raw_html()   \n}\n\n\n\n\ntooltip_table <-    \n  data |>\n  slice_max(n = 10, order_by = Deaths, by = Year) |>   \n  mutate(table = purrr::map(Year, make_table)) |>\n  select(Entity, Year, Deaths, table)  \n\np_line_girafe <-\n  tooltip_table |>  \n  drop_na() |>\n  ggplot(aes(\n    x = Year, \n    y = Deaths)\n    ) +    \n  geom_point_interactive(aes(      \n    color = Entity,     \n    data_id = Entity),\n    show.legend = FALSE, \n    size = 0.45\n  ) +\n  geom_line_interactive(aes(     \n    color = Entity,     \n    data_id = Entity),\n    show.legend = FALSE,\n    size = 0.3) +   \n  # Adding the vertical reference lines that, when hovered will display the tables with data for the corresponding year.   \n  geom_vline_interactive(aes(\n    xintercept = Year,\n    tooltip = table),\n    alpha = 0,                          \n    size = 4.75) +\n  geom_hline(\n    yintercept = seq(from = 20000, to = 140000, by = 20000),\n    linetype = 'dotted',\n    color = '#dddddd'\n  ) +\n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 140000),\n    clip = 'off'\n  ) +\n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019)) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 140000, by = 20000),                      \n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +\n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 9.5,\n      color = \"#5b5b5b\"\n    ),\n    axis.line = element_line(linewidth = 0.2),\n    plot.margin = \n      margin(r = 60,\n             b = 10\n      ),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 13,                                    \n      hjust = 0,                                    \n      margin = margin(t = 0)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                      \n      size = 9,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 9,                                                  \n      margin = margin(t = 10)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',       \n      size = 8,\n      vjust = -1,\n      margin = margin(l = -173)\n    ) \n  ) +\n  geom_text_repel_interactive(aes(\n      label = Entity,                       \n      color = Entity,                       \n      segment.shape   = 0,\n      data_id = Entity),\n    show.legend = FALSE,\n    data = data |>\n      filter(Year == 2019) |>\n      slice_max(n = 10, order_by = Deaths),\n    size = 2.5,                    \n    force = 0.5,\n    position = position_nudge_to(x = 2022),   \n    direction = \"y\",                  \n    hjust = 0,       \n    segment.curvature = -0.0000001,    \n    segment.size = 0.1,                   \n    xlim = c(NA, Inf)                 \n  )   \n\ngirafe(ggobj = p_line_girafe,        \n       options = list(          \n         opts_hover(css = \"color:;\"),          \n         opts_hover_inv(css = \"opacity:0.15;\")\n       )\n)\n\n\nI know that these elements might not be the core of the Data Viz projects, but I am still super proud of having explored the {ggiraph} package that much, and to have replicated a feature that I thought it would be impossible to make.\nAlternative graphs\nTo be honest, I find that the original Our World In Data graph is very complete, especially because it consists of two graphs that enables us to compare very easily countries between each other thanks to the map, but also take a look at the evolution through the years, and even compare evolutions thanks to the line graph.\nHowever, all the data that is displayed by these graphs are absolute numbers. We now that China is the country with most deaths due to low physical activity in 2019, but China is also the country with the most deaths all causes combined, because China is of course the most populated country in the world. Therefore, it seemed to me that these absolute values failed to convey the information we want to extract from the graphs, which might be something like: “Which country best meet physical activity standards in the world?” for instance.\nTherefore, the alternative graphs proposed are replicates of the original, but showing the data as percentages of the population that died from low physical activity.\nThe data\nThanks to the Population column that we added during the first process of the data to replicate the original graph, we just need to add a Percentage column to the ‘data’ dataset (for sake of clarity, we’ll create a second dataset for the alternative graphs, called data_alt and to discretize the Percentage variable for the alternative map.\nAlso, based on an advice of Iñaki, I chose to multiply by 1000 the percentages since they are very small, to enables a better visualization of the numbers, and to better compare them between each other.\n\n\ndata_alt <-    \n  data |> \n  mutate(\n    Percentage = round((Deaths/Population)*100*1000, digits = 3),\n    .after = Deaths_disc\n    ) |>  # the round() function is used for simpler visualization of the legend later.   \n  mutate(\n    Percentage_disc = discretize(Percentage, method = 'frequency', breaks = 9)\n    )\n\n\nAlternative map\nStatic version\nThe only change is therefore that we are using the data_alt dataset. We also have to modify the subtitle to precise that the numbers are not actual percentages, but thousandths of percentage.\n\n\nplot_subtitle_alt <- \"Estimated annual thousandth of percentage of the populations with deaths attributed to low physical activity.\" \n\n\n\n\np_map_alt <-    \n  # Using data_alt instead of data   \n  data_alt |>   \n  drop_na() |>\n  filter(Year == 2019) |>\n  ggplot() +   \n  # Using the column 'Percentage_disc' instead of 'Deaths\"  \n  geom_sf(aes(fill = Percentage_disc)) +   \n  coord_sf(crs = '+proj=robin') +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_void() +\n  theme(plot.title =\n          element_text(\n            family = 'merriweather',                                    \n            color = '#5b5b5b',\n            face = 'bold',\n            size = 20,\n            hjust = 0.125,                                   \n            margin = margin(t = -10)\n            ),\n        plot.subtitle = \n          element_text(\n            color = '#5b5b5b',\n            hjust = 0.42,\n            size = 16\n            ),         \n        plot.caption = ggtext::element_markdown(\n          color = '#5b5b5b',\n          hjust = 0.2,\n          size = 16,\n          margin = margin(t = 20)\n          ),\n        plot.tag.position = 'bottom',\n        plot.tag = element_text(\n          color = '#5b5b5b',\n          size = 15,\n          vjust = -1,\n          margin = margin(l = -248)\n          ),\n        legend.position = 'bottom',\n        legend.title = element_blank(),\n        legend.text = element_text(           \n          margin = margin(t = -22)\n          )\n        ) +\n  scale_fill_brewer(palette = 'YlOrRd',\n                    guide = guide_coloursteps(                        \n                      show.limits = TRUE,                        \n                      ticks = TRUE,\n                      barwidth = 25,\n                      barheight = 0.5,                       \n                      frame.colour = 'black',\n                      frame.linewidth = 0.01,                       \n                      ticks.colour = 'black',\n                      ticks.linewidth = 0.01)\n                    ) \n\np_map_alt\n\n\nInteractive version\n\n\n# Still a ' symbol for the country \"Cote d'Ivoire\" causing errors in ggiraph \ndata_alt <-\n  data_alt |>\n  mutate(Entity = if_else(Entity == \"Cote d'Ivoire\", \"Cote d Ivoire\", Entity))\n\ntooltip_css <- \"background-color: rgba(245, 245, 245, 1);\n                color: #000000; font-family: 'Arial', sans-serif;\n                font-size: 11px;\n                border-radius: 4px;\n                border: 1px solid #d9d9d9;\n                padding: 8px;\"\n\np_map_alt_girafe <-   \n  data_alt |>\n  filter(Year == 2019) |>\n  ggplot() +   \n  geom_sf_interactive(aes(        \n    fill = Percentage_disc,        \n    tooltip = \n      paste0(sprintf(\"<b>%s<\/b>: %.2f\", Entity, Percentage), \"\\nNumber of Deaths: \", round(Deaths)),\n    data_id = Entity\n  )) +\n  coord_sf(crs = \"+proj=robin\") +\n  labs(title = plot_title,        \n       subtitle = plot_subtitle_alt,        \n       caption = plot_caption,        \n       tag = plot_tag\n  ) +\n  theme_void() +\n  theme(\n    plot.title = element_text(\n      family = \"merriweather\",\n      color = \"#5b5b5b\",\n      face = \"bold\",\n      size = 12,    \n      hjust = 0.12                                   \n    ),\n    #margin modified         \n    plot.subtitle = element_text(\n      color = \"#5b5b5b\",\n      hjust = 0.32,                                      \n      size = 8\n      ),\n    plot.caption = ggtext::element_markdown(\n      color = \"#5b5b5b\",\n      hjust = 0.14,                                                 \n      size = 8,                                                 \n      margin = margin(t = 20)\n    ),\n    plot.tag.position = \"bottom\",\n    plot.tag = element_text(\n      color = \"#5b5b5b\",\n      size = 7,  \n      vjust = -1,\n      margin = margin(l = -278)\n    ),          \n    legend.position = \"bottom\",\n    legend.title = element_blank(),\n    legend.text = element_text(           \n      size = 8,\n      margin = margin(t = -22)\n    )\n  ) +\n  scale_fill_brewer_interactive(\n    palette = \"YlOrRd\",\n    # making the legend interactive\n    guide = guide_coloursteps_interactive(                        \n      show.limits = TRUE,                       \n      ticks = TRUE,\n      barwidth = 25,\n      barheight = 0.4,\n      frame.colour = \"black\",                       \n      frame.linewidth = 0.1,                       \n      ticks.colour = \"black\",\n      ticks.linewidth = 0.1)   \n  ) \n\ngirafe(ggobj = p_map_alt_girafe,        \n       options = list(          \n         opts_hover_inv(css = \"opacity:0.7;\"),          \n         opts_hover(css = \"stroke-width:1.2;stroke:black;\"),          \n         opts_tooltip(css = tooltip_css        \n         )\n       )\n)\n\n\nAlternative line graph\nStatic version\nIn order to stay consistent with the first graph, I decided to plot the same countries as on the first replicate to have a comparison between the absolute numbers and percentage trends.\n\n\n# Countries that have the highest percentage of Deaths in 2019  \n\ncountries_top10 <-\n  data_alt |>\n  filter(Year == 2019) |>    \n  slice_max(n = 10, with_ties = FALSE, order_by = Deaths) |>\n  select(Entity) |>\n  sf::st_drop_geometry() |>\n  as_vector()  \n\np_line_alt <-    \n  # We use the same filtering process to get the same data as on the first line graph  \n  data_alt |>\n  filter(Entity %in% countries_top10) |>  \n  # Switching from the \"Deaths\" column to the \"Percentage\" one\n  ggplot(aes(\n    x = Year,\n    y = Percentage)\n  ) +\n  geom_point(aes(\n    color = Entity),\n    show.legend = FALSE,     \n    size = 0.7\n  ) +\n  geom_line(\n    aes(color = Entity),      \n    show.legend = FALSE\n  ) +   \n  geom_vline(xintercept = 0) +\n    # The reference lines will not be the same. As the max percentages between the countries plotted are around 4 units, let's set a horizontal reference line each 1   \n  geom_hline(\n    yintercept = seq(from = 0, to = 40, by = 10),\n    linetype = 'dashed',            \n    color = '#dddddd'\n  ) +\n  # The ylim will also not be the same   \n  coord_cartesian(\n    xlim = c(1990, 2019),\n    ylim = c(0, 40),\n    clip = 'off'\n  ) +   \n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019)) + # expand removed\n  scale_y_continuous(breaks = seq(from = 0, to = 40, by = 10), # Also Adjusted\n                     expand = expansion(mult = c(0, 0.1)\n                     )\n  ) +\n  labs(\n    title = plot_title,        \n    subtitle = plot_subtitle,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +   \n  theme_classic() +\n  theme(\n    axis.line.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(           \n      size = 13,           \n      color = \"#5b5b5b\"\n    ),\n    plot.margin = margin(r = 60), # Added\n    plot.title = element_text(family = 'merriweather',\n                              color = '#5b5b5b',                                   \n                              face = 'bold',\n                              size = 15,\n                              hjust = 0,                                    \n                              margin = margin(t = 10)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',\n      hjust = 0,                                       \n      size = 11,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 11,\n      margin = margin(t = 20)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',                                \n      size = 10,\n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -320)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = Entity,                       \n      color = Entity,                       \n      segment.shape   = 0\n    ),\n    show.legend = FALSE,                       \n    data = data_alt |>\n      filter(Year == 2019 & Entity %in% countries_top10),\n    #slice_max(n = 10, order_by = Deaths),\n    size = 2.5, # Adjusted\n    force = 0.5,                       \n    position = position_nudge_to(x = 2022),\n    direction = \"y\",\n    hjust = 0,\n    segment.curvature = -0.0000001,                       \n    segment.size = 0.1, # Making segments thiner\n    xlim = c(NA, Inf) # Added to enable labels to past the boundaries of the plot\n  )\n\np_line_alt\n\n\n\nThe line graph is now a bit messier since the values for mortality due to low physical activity are actually quite close between countries. It seems to me that putting all these lines into a Slope chart might be clearer.\nSlope charts\nI still had the problem of having to choose which countries to plot. As I can’t replicate the filter function of the OWID graph, I made compromises. To me, the evolution is what we seek and the reason why we have the data available from 1990. Therefore, I chose to answer both following questions:\nWhat is the evolution of the countries that had the highest deaths-due-to-low-physical-activity rate in the past ?\nOn the other hand, what evolution led the countries that have the highest rates today, to this situation ?\nAnswering this means plotting on the one hand the 10 countries that had the highest percentages in 1990 and on the other hand, those who had the highest rates in 2019.\n\n\ncountries_top_percentage_2019 <-\n  data_alt |>\n  filter(Year == 2019) |>\n  slice_max(n = 10, with_ties = FALSE, order_by = Percentage) |>    \n  select(Entity) |>    \n  sf::st_drop_geometry() |>\n  as_vector()  \n\ncountries_top_percentage_1990 <-\n  data_alt |>\n  filter(Year == 1990) |>    \n  slice_max(n = 10, with_ties = FALSE, order_by = Percentage) |>  \n  select(Entity) |>    \n  sf::st_drop_geometry() |>\n  as_vector()\n\n# Slope graph of the countries which had the highest death rates in 1990.\np_slope_1990 <-    \n  data_alt |>\n  filter(Entity %in% countries_top_percentage_1990, Year == 1990 | Year == 2019) |>\n  ggplot(\n    aes(\n      x = Year, \n      y = Percentage)\n  ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE) +\n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE) +\n  coord_cartesian(\n    xlim = c(1975, 2034),\n    ylim = c(10, 60),\n    clip = 'off'\n  ) +     \n  scale_x_continuous(breaks = c(1990, 2019)) +     \n  scale_y_continuous(\n    breaks = seq(from = 10, to = 60, by = 10),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = \"The 10 countries with most deaths from low physical activity in 1990\",\n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n    ) +\n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),\n    axis.line.x = element_line(\n      linetype = 'dashed',\n      color = '#dddddd'\n    ),\n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(\n      size = 15,\n      color = \"#5b5b5b\"\n    ),         \n    plot.margin = margin(r = 50,\n                         l = 50),\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 18,\n      hjust = 0,                                    \n      margin = margin(t = 20)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',  \n      hjust = 0,\n      size = 14,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 14,                                                 \n      margin = margin(t = 10)\n    ),          \n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 13,\n      vjust = -1,\n      margin = margin(b = 10,                                             \n                      l = -215)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(round(Percentage,1), \" \",Entity),                       \n      color = Entity),\n    data = data_alt |>\n      filter(Year == 2019) |>                        \n      filter(Entity %in% countries_top_percentage_1990),                       \n    show.legend = FALSE,\n    direction = 'y',\n    nudge_x = 5.5,                       \n    size = 5,\n    hjust = 0,\n    segment.alpha = 1,                      \n    segment.linetype = 'dotted'                      \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(Entity, \" \", round(Percentage,1)),\n      color = Entity),\n    data = data_alt |>\n      filter(Year == 1990) |>\n      filter(Entity %in% countries_top_percentage_1990),\n    show.legend = FALSE,                      \n    direction = 'y',\n    nudge_x = -5.5,                       \n    size = 5,\n    hjust = 1,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                     \n  ) +     \n  geom_vline(xintercept = 0) +\n  geom_hline(\n    yintercept = seq(from = 10, to = 60, by = 10),\n    linetype = 'dashed',\n    color = '#dddddd'\n  )\n\n# Slope graph of the countries which had the highest death rates in 2019.\np_slope_2019 <-    \n  data_alt |>      \n  filter(Entity %in% countries_top_percentage_2019, Year == 1990 | Year == 2019) |>  \n  ggplot(aes(\n    x = Year, \n    y = Percentage)\n  ) +\n  geom_point(\n    aes(color = Entity),\n    show.legend = FALSE\n    ) +  \n  geom_line(\n    aes(color = Entity),\n    show.legend = FALSE\n  ) +\n  coord_cartesian(\n    xlim = c(1975, 2034),\n    ylim = c(10, 60),\n    clip = 'off'\n  ) +\n  scale_x_continuous(breaks = c(1990, 2019)) +\n  scale_y_continuous(\n    breaks = seq(from = 0, to = 60, by = 10),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  labs(\n    title = \"The 10 countries with most deaths from low physical activity in 2019\",        \n    subtitle = plot_subtitle_alt,        \n    caption = plot_caption,        \n    tag = plot_tag\n  ) +\n  theme_classic() +   \n  theme(\n    axis.line.y = element_blank(),         \n    axis.line.x = element_line(\n      linetype = 'dashed',\n      color = '#dddddd'\n    ),         \n    axis.ticks.y = element_blank(),\n    axis.title = element_blank(),         \n    axis.text = element_text(           \n      size = 15,\n      color = \"#5b5b5b\"\n    ),\n    plot.margin = margin(r = 50,                              \n                         l = 50), # Adjusted for making the slope plot thinner\n    plot.title = element_text(\n      family = 'merriweather',\n      color = '#5b5b5b',\n      face = 'bold',\n      size = 18,\n      hjust = 0,                                    \n      margin = margin(t = 20)\n    ),\n    plot.subtitle = element_text(\n      color = '#5b5b5b',                                      \n      hjust = 0,                                       \n      size = 14,\n      margin = margin(t = 5)\n    ),\n    plot.caption = ggtext::element_markdown(\n      color = '#5b5b5b',\n      hjust = 0,                                                  \n      size = 14,                                                 \n      margin = margin(t = 10)\n    ),\n    plot.tag.position = 'bottom',\n    plot.tag = element_text(\n      color = '#5b5b5b',\n      size = 13,\n      vjust = -1,\n      margin = margin(b = 10,\n                      l = -215)\n    )         \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(round(Percentage,1), \" \",Entity),\n      color = Entity),\n    data = data_alt |>  \n      filter(Year == 2019) |>\n      filter(Entity %in% countries_top_percentage_2019),                       \n    show.legend = FALSE,                       \n    direction = 'y',\n    nudge_x = 5.5,                       \n    size = 5,\n    hjust = 0,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                      \n  ) +\n  geom_text_repel(\n    aes(\n      label = paste0(Entity, \" \", round(Percentage,1)),\n      color = Entity),\n    data = data_alt |>\n      filter(Year == 1990) |>\n      filter(Entity %in% countries_top_percentage_2019),                       \n    show.legend = FALSE,                      \n    direction = 'y',\n    nudge_x = -5.5,                       \n    size = 5,\n    hjust = 1,\n    segment.alpha = 1,\n    segment.linetype = 'dotted'                     \n  ) +     \n  geom_vline(xintercept = 0) +\n  geom_hline(yintercept = seq(from = 10, to = 60, by = 10),\n             linetype = 'dashed',\n             color = '#dddddd'\n  )   \n\n\nI think this slope chart conveys the evolution of the mortality due to low physical activity a bit better than the line graph. To make it even clearer, I’d like to make the countries which have a downward slope blue and the ones which have an upward slope red. To do this, I’ll define a vector that will contain the color palette and manually add the assign each color to the countries.\nIn the beginning, I wanted to use pivot_wider() to create a column 1990 and a column 2019 that contained the Percentages of each country for these years, then use mutate() to create a new column equals to 2019 - 1990, and then pivot_longer() on both 1990 and 2019 columns to get back tidy data. However, when using the pivot_wider() function on thedata_alt data set, I repetedly got the error message “Object Year can’t be found” and couldn’t get the solution to this issue.\nTherefore, I manually pointed the upward slopes and the downward ones, and crafted the vector in a specific order to align the blue colors with downward slopes and the red ones to the upward ones.\nAn improvement that I could still do: tailor the shade of the color to the slope of the line.\n\n\ncolor_palette_1990 <- \n  c(   \n    '#FF0000',   \n    '#001EE0',\n    '#FF3C00',\n    '#0021F5',\n    '#0A2BFF',   \n    '#1F3DFF',\n    '#334EFF',  \n    '#FF531F',\n    '#4760FF',\n    '#FF6333' \n  )  \n\ncolor_palette_2019 <- \n  c(   \n    '#FF0000',\n    '#FF2800',\n    '#FF3C00',\n    '#FF4F00',\n    '#FF5900',\n    '#FF6300',\n    '#FF7600',\n    '#FF8300',\n    '#FF9000',\n    '#FF9D00' \n  )\n\np_slope_1990 <-   \n  p_slope_1990 +\n  scale_color_manual(\n    breaks = countries_top_percentage_1990,                      \n    values = color_palette_1990,                      \n    labels = countries_top_percentage_1990\n  )  \n\np_slope_2019 <-\n  p_slope_2019 +\n  scale_color_manual(\n    breaks = countries_top_percentage_2019,                      \n    values = color_palette_2019,\n    labels = countries_top_percentage_2019\n  )  \n\np_slope_1990 \n\n\np_slope_2019  \n\n\n\nProject takeaways and what I learned\nThis project was the best of the semester to be honest. It was the best because of how far it required us to push our newly acquired skills in {ggplot}. Actually, I really did not expect it to be that exciting. This excitment of exploring and failing then testing and finally succeeding can be seen with capital “IT WORKS” that I could have included a loooot more often in this article.\nMore seriously, at the end of the day, it might be one of the learning project that I found the most meaningful. Shoutout to Iñaki for enabling us to end the semester with much higher skills in Data.\nMy advices (For what they’re worth)\nDig deep in documentations, everyone say it, teachers say it. Okay now I understand.\nI’m currently learning Python, and having discovered the importance of understanding what’s in a library and how it works it so powerful.\nStart veeeeery soon. Unlike other projects, this one is given on the very first day of class, and that’s a huge chance to take the time to do a cool project that is interesting and valuable in my opinion Word of a dude who started in end of November and made the pull request 30 minutes before the deadline.\nMargins are a nightmare to render. A nightmare. They never end up where I expect them to be. I guess I’m just using them poorly lol\nInclude a pie chart in your project. Be braver than us ahahaha\n\n\n\n",
    "preview": "projects/2023/100517341/100517341_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-30T00:59:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100430897/",
    "title": "Public Trust in Government",
    "description": "Visual representation of the evolution of public trust in the United States\ngovernment by race and ethnicity from 1958 to 2023, as documented in the\nPew Research Paper.",
    "author": [
      {
        "name": "Carlos San-Juan-Baeza",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\nBackground\n\nWorking with the data\nPackgages\nCleaning and getting the data\n\nBuilding the graph\nFirst steps…\nMore aesthetic\nTheme\nOther details and replica\nLimitations\n\nImprovements\nAdd a new variable\nSolving problems\nNew axes\nFinal details\nFinal graph\n\nAnalysis and results\nConclusions and explanations\nPossible future implications\n\n\nIntroduction\nIn recent decades, perceptions of U.S. presidents have experienced a significant change, reaching historically low levels in recent years, which has led to numerous debates and articles discussing this phenomenon. In this paper, however, we will not only analyse the overall trust in presidential leadership, but we will disaggregate this trust by ethnic and racial categories within American society. Our goal is to understand the distinctive variations that emerge in this context and to examine closely how different communities evaluate the effectiveness and integrity of presidents. At the same time, we will be able to explore the impact that different leaders and historical events have had on society’s trust in government.\nIn order to carry out this research, we will rely on the newspaper article provided by Pew Researhc Paper, which analyses this social phenomenon in detail.\nThe original graph\nThe original graph that we are going to take into account for this article can be found on the same page mentioned in the previous section. This graph, as you can see below, presents information on the confidence of United States citizens in the different governments from 1958 to 2023. More specifically, the graph shows information on the most numerous races and ethnicities in the United States, which are Hispanic, Black, White and Asian. In addition, it allows us to see in which periods of time and under which US president there has been a growth or decline in trust, which could be interesting for numerous studies and to understand how social and political evolution has changed.\nOriginal Source: Pew Research Paper.Background\nThe history of ethnic and racial differences in the United States has been a difficult one, marked by diverse experiences and problems over time. From the earliest days of colonization, the presence of different ethnic groups, such as Native Americans, enslaved Africans, Europeans and later immigrants from various regions of the world, has shaped the cultural diversity of the nation. However, they have also faced significant challenges, such as slavery and racial discrimination, showing social inequalities. These experiences have consequently left their mark on society, generating distrust of government, especially when presidents have failed to adequately address these problems.\nHowever, while challenges persist, history also shows progress toward equality, and the relationship between ethnic identity and perceptions of the presidency remains an important theme in U.S. history.\nWorking with the data\nThe data we are going to use throughout the work are collected from numerous sources, such as Pew Research Center, National Election Studies, Gallup, ABC/Washington Post, CBS/New York Times, and CNN Polls. Moreover, the database for race and ethnicity analysis was obtained from searches of the iPOLL Databank provided by the Roper Center for Public Opinion Research. This database was obtained through telephone surveys of random individuals in the United States. More information on the questions that were used can be found here. Although the data is obtained from different sources, the complete database can be downloaded at Pew Researhc Paper\nPackgages\nThe libraries that we are going to use in all the work, both in the replica and in the subsequent improvements, are the following:\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(readr)\n\n\nCleaning and getting the data\nThe database provides information on the trust of citizens of different ethnicities and races on specific dates in the history of the United States. The trust of citizens is represented as a number between 0 and 100, with 0 being no trust and 100 being total trust. First, we have had to transform the “Date” column, which provides the different dates, into a specific format, which will facilitate the handling and analysis of temporal data.\n\n\ndata <- read_csv(\"database.csv\")\ndata.df <- data.frame(data[1:150,1:6])\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\n\nThe second step we have done in order to be able to treat the data correctly and to be able to analyse it, is to convert the data with tidyverse, in order to be able to clean it from NA. The reason for choosing Tidyverse is that it allows us to omit missing values without losing valuable information.\n\n\ndata.df <- data.df |>\n  tidyr::pivot_longer(c(Hispanic, White, Asian, Black)) |> \n  na.omit()\ndata.df\n\n# A tibble: 283 × 4\n   Date       .     name     value\n   <date>     <chr> <chr>    <dbl>\n 1 2023-06-11 PEW   Hispanic    23\n 2 2023-06-11 PEW   White       13\n 3 2023-06-11 PEW   Asian       23\n 4 2023-06-11 PEW   Black       21\n 5 2022-05-01 PEW   Hispanic    29\n 6 2022-05-01 PEW   White       16\n 7 2022-05-01 PEW   Asian       37\n 8 2022-05-01 PEW   Black       24\n 9 2021-04-11 PEW   Hispanic    36\n10 2021-04-11 PEW   White       18\n# ℹ 273 more rows\n\nFinally, before starting to replicate the graph, we have created a series of vectors which will be necessary later on in the elaboration of the graph. Such as the case of “years_to_highlight” which indicates the dates in which the mandate of the different presidents of the U.S. history from Eisenhower to Biden begins. The U.S. presidents we are going to take into account are the following:\nDwight D. Eisenhower (1953-1961) - Republican Party\nJohn F. Kennedy (1961-1963) - Democratic Party\nLyndon B. Johnson (1963-1969) - Democratic Party\nRichard Nixon (1969-1974) - Republican Party\nGerald Ford (1974-1977) - Republican Party\nJimmy Carter (1977-1981) - Democratic Party\nRonald Reagan (1981-1989) - Republican Party\nGeorge H.W. Bush (1989-1993) - Republican Party\nBill Clinton (1993-2001) - Democratic Party\nGeorge W. Bush (2001-2009) - Republican Party\nBarack Obama (2009-2017) - Democratic Party\nDonald Trump (2017-2021) - Republican Party\nJoe Biden (2021-present) - Democratic Party\nIt should be noted that we will only use data from 1958 onwards, i.e. we will not consider Eisenhower’s entire term of office.\n\n\nyears_to_highlight <- c(\n  \"1958-12-01\",  # Dwight D. Eisenhower\n  \"1961-01-20\",  # John F. Kennedy\n  \"1963-11-22\",  # Murder de John F. Kennedy\n  \"1963-11-22\",  # Lyndon B. Johnson assumes the presidency\n  \"1969-01-20\",  # Richard Nixon\n  \"1974-08-09\",  # Resignation of Richard Nixon\n  \"1974-08-09\",  # Gerald Ford takes office\n  \"1977-01-20\",  # Jimmy Carter\n  \"1981-01-20\",  # Ronald Reagan\n  \"1989-01-20\",  # George H.W. Bush\n  \"1993-01-20\",  # Bill Clinton\n  \"2001-01-20\",  # George W. Bush\n  \"2009-01-20\",  # Barack Obama\n  \"2017-01-20\",  # Donald Trump\n  \"2021-01-20\"   # Joe Biden\n)\n\n\nOn the other hand, we also convert into a vector the dates that will later be represented on the x-axis, which is 10 years difference.\n\n\ndesired_dates <- as.Date(c(\n  \"1960-01-01\", \"1970-01-01\", \"1980-01-01\", \"1990-01-01\",\n  \"2000-01-01\", \"2010-01-01\", \"2020-01-01\"\n))\n\n\nFinally we are going to add a function, which will be used to modify the background of the chart. The purpose of this function is to differentiate the background by sections of two different colours, White and “Beige” (being more specific #F0F0E6), which are interspersed. This difference is used to clarify the periods in which different presidents ruled.\nTo do this, we will create a series of vectors, “rect_dates”, which indicates the dates on which the background colours will change, “rec_alpha”, which is used to indicate the transparency of each rectangle that we will use to modify the background and “rect_colors” which indicates the different colours.\nIn short, the fucnion uses “lapply” to generate a list of rectangular layers, each representing a time interval defined by the dates in “rect_dates”. Each rectangle has a specific colour and transparency according to the “rect_colors” and “rect_alpha” vectors. These rectangles can then be added to a chart to highlight and visualize specific time segments. The function is called “rect_layers”.\n\n\nrect_dates <- c(\n  \"1958-12-01\", \"1961-01-20\", \"1963-11-22\", \"1969-01-20\", \"1974-08-09\", \"1977-01-20\",\n  \"1981-01-20\", \"1989-01-20\", \"1993-01-20\", \"2001-01-20\", \"2009-01-20\",\n  \"2017-01-20\", \"2021-01-20\", \"2023-10-12\"\n)\n\n\nrect_colors <- c(\"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\",\n                 \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\", \"white\", \"#F0F0E6\" , \"white\")\n\n\nrect_alpha <- c(0.2,0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2, 0.1, 0.2)\n\n\nrect_layers <- lapply(1:(length(rect_dates) - 1), function(i) {\n  geom_rect(\n    aes(xmin = as.Date(rect_dates[i]), xmax = as.Date(rect_dates[i + 1])),\n    ymin = -Inf, ymax = Inf,\n    fill = rect_colors[i], alpha = rect_alpha[i],\n    inherit.aes = FALSE\n  )\n})\n\n\nBuilding the graph\nFirst steps…\nIn order to analyse the data correctly, we will replicate the original graph developed by Pew Research Paper, which we mentioned earlier. Consequently, the first step to follow is to construct the axis on which our line chart will be developed.\nTo do so, we will use the time variable on the x-axis, which shows the different dates on which respondents were called to obtain the results. While on the y-axis, we have represented “Value” which shows the value of trust that voters placed in the presidents over time.\n\n\nj <- ggplot(data.df)+\n  aes(Date, value, color=name)\nj\n\n\n\nOnce the axis is established, the next step is to modify the background, as we have briefly mentioned before, in which we will use the function called “rect_layers” which we have already explained in previous sections. Its use will allow us to divide the background into two colours, forming different rectangles.\n\n\nj <- j + rect_layers\nj\n\n\n\nOnce the background of the graph has been divided according to the duration of government of the respective presidents, we introduce the data for the respective ethnicities. The different lines show how the trust of the different races and ethnicities has evolved over time in the United States. We have also added the legend in order to distinguish the different lines and know who they correspond to.\n\n\nj <- j + geom_line(linetype=\"solid\", size=1.75, alpha = 1, lineend= \"round\") +\n  scale_color_manual(\n    values = c( \"Asian\" = \"#DE996A\",\"White\" = \"#F2DBCD\",\"Black\" = \"#E7BA9A\",\"Hispanic\" = \"#A55A26\"),\n    name = \"\"\n  )\nj\n\n\n\nOnce the initial phase of the project has been completed, the next step will be to perfect it. So the next step will be to focus on the aesthetic aspect, seeking to enhance and expand its visual qualities, with the aim of making it look as similar as possible to the original graphic.\nMore aesthetic\nIn this part of the code I have focused on improving the title of the graphic, the subtitle, and the caption. At the same time we have added the X and Y axes, adding the corresponding scales to improve the compression of the line chart.\nIn the previous graph, the x-axis was segmented into 20-year sections, and at the same time, it is observed that the x-axis goes beyond the limits of the data, generating empty spaces at the extremes. In other words, the graph starts before the first data, collected in 1958, and ends after the last data in 2023, which can lead to confusion. On the other hand, the y-axis is less well represented, as it only shows information up to 80% confidence. To improve visualization, the x-axis could be adjusted to cover only the range of years available, providing a more accurate representation. Similarly, extending the y-axis to 100% would allow more subtle variations in confidence to be captured, providing a more complete representation of the data.\nConsequently, the function “scale_x_date” has been used in order to define the desired intervals and eliminate the gaps on the x-axis, using the vector previously named “desired_dates”, which organises the dates by decades. By using the format “%Y”, we achieve that only the years on the x-axis are displayed. Simultaneously, we have used the “expand” function to adjust the spacing between the ends of the graph and the y-axis, indicating that we want to remove any unnecessary space, which helps to eliminate gaps without data.\nFor the y-axis, we have applied similar strategies. We used the “breaks” and “limits” functions to set the limits and frequency of occurrence of numbers on the y-axis, extending the limits up to 100%.\n\n\nj <- j +\n  labs(\n    x = NULL,\n    y =NULL,\n    title = expression(paste(bold(\"Trust in government by race and ethnicity\"))),\n    subtitle = \"% who say they trust the government to do what is right just about always/most of time\",\n    color = \"Ethnicity:\",\n    caption = \"Source: PEW RESEARCH CENTER\")  +\n  scale_x_date(\n    breaks = desired_dates,\n    labels = format(desired_dates, \"%Y\"),\n    expand = c(0.00, 0.00) \n  ) +\n  scale_y_continuous(\n    limits = c(0, 100),\n    breaks = seq(0, 100, by = 20),\n    expand = c(0, 0)  \n  ) \n\n\nTheme\nIn this section of the code, we focus on refining the details of the graphic with the goal of making it as close as possible to the original design. To achieve this, we are using the “theme” function, which gives us the ability to adjust a variety of visual and stylistic elements of the graphic.\nSome of the most important adjustments made focus on refining the aesthetics and presentation of the graphic. This process involved customizing several key elements, addressing specific details to achieve a visually coherent and highly readable design. Among the highlights are modifying the size and style of the subtitle to highlight relevant information, specifically selecting the position and appearance of the legend to improve the visual layout, as well as adapting the format and position of the axes for a more accurate and easy-to-understand representation. In addition, the background of the chart is taken care of and margins are added to provide a more polished and professional overall appearance.\n\n\nj <- j + \n  theme_minimal() +\n  theme(\n    plot.subtitle = element_text(size = 10, color = \"grey\", face = \"italic\"),\n    plot.caption = element_text(hjust = -0.1, vjust = -10.0, color = \"black\", size = 10),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\"),\n    legend.text = element_text(size = 10),\n    legend.margin = margin(t = 0, b = -0.2, unit = \"cm\"),  \n    axis.line = element_line(size = 0.5, color = \"black\"),\n    axis.text = element_text(size = 10, color = \"black\"),\n    axis.title = element_text(size = 12, color = \"black\", face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    axis.ticks.x = element_line(size = 0.5),\n    axis.text.x = element_text(angle = 0, hjust = 0.5),  \n    axis.ticks.y = element_line(size = 0.5),\n    axis.text.y = element_text(angle = 0, hjust = 0.5),\n    plot.background = element_rect(fill = \"white\"),\n    plot.margin = margin(1, 1, 1, 1, \"cm\"), \n    legend.key.width = unit(1, \"cm\"),  \n    legend.key.height = unit(1, \"cm\"),  \n    legend.spacing = unit(0.5, \"cm\"),  \n    legend.box.margin = margin(0, 0, 0, 0, \"cm\")  \n  )\nj\n\n\n\nOther details and replica\nIn this final phase of the work, we focused on making the last improvements to obtain the final replica of the chart. We started by using the “guides” function, which plays a crucial role in improving the appearance and clarity of the legend. Through this function, we adjust specific aspects of the legend’s presentation, such as its position, title, and text formatting.\n\n\nj <- j + guides(\n    color = guide_legend(\n      keywidth = 1, keyheight = 0.5,  \n      label.position = \"right\", \n      ncol = 4  \n    )\n  )\n\n\nIn the final phase of replicating the original graph, the names of the presidents have been added above each rectangle to clearly identify the periods of their administrations. In addition, a colour code has been introduced, using red for Republican presidents and blue for Democratic presidents, to indicate the political party they represented in each case. On the other hand, we have marked it as a vector to be used later in a simpler way.\n\n\npresident <- c(\n  geom_text(aes(x = as.Date(\"1958-12-01\"), y = 90), label = \"Eisenhower\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1961-01-20\"), y = 90), label = \"Kennedy\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1963-11-22\"), y = 90), label = \"Johnson\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1969-01-20\"), y = 90), label = \"Nixon\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1974-08-09\"), y = 90), label = \"Ford\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1977-01-20\"), y = 90),\n            label = \"Carter\", vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"1981-01-20\"), y = 90), \n            label = \"Reagan\", vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1989-01-20\"), y = 90), label = \"H.W. Bush\",\n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"1993-01-20\"), y = 90), label = \"Clinton\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"2001-01-20\"), y = 90), label = \"W. Bush\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"2009-01-20\"), y = 90), label = \"Obama\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\"),\n  geom_text(aes(x = as.Date(\"2017-01-20\"), y = 90), label = \"Trump\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#bf3927\"),\n  geom_text(aes(x = as.Date(\"2021-01-20\"), y = 90), label = \"Biden\", \n            vjust = -1, hjust = 0.2, size = 3, angle = -90, color = \"#436983\")\n)\n\n\nj <- j + president\nj\n\n\n\nLimitations\nBefore moving on to the analysis of the graph and exploring the possible impacts that this study could generate, it is necessary to address a number of limitations that affect its clarity and comprehensibility. First of all, there are obvious areas for improvement, for example, the excessive accumulation of lines in the central section, which makes the graph difficult to interpret. Furthermore, the similarity of colours used adds to the difficulty of the aforementioned visual problem. Additionally, when examining the lines corresponding to the Hispanic and Asian ethnic groups, there is a later beginning, especially noticeable in the case of Asia, where they are difficult to see due to the accumulation of lines. Nevertheless, I believe that this graph has a lot of potential for improvement to show the data with more detail and accuracy, as I consider this to be the main problem with the graph.\nFor this reason, before we go into explaining the bugs, we are going to make a number of improvements that could greatly benefit the compression of the line chart.\nImprovements\nAt this stage of the work, we will focus on improving the graph in order to make the analysis more effective and the visualization more understandable.\nAdd a new variable\nOne potential problem that we may encounter in further analysis is the absence of a reference point to assess with greater precision and accuracy the impact on the US presidency. Because of this, we have decided to add a new variable, “Trust.Average”. This variable allows us to measure the average trust of US citizens, which becomes an essential factor in measuring when the trust of different ethnicities is below or above the average trust.\nIt also gives us the ability to examine in more detail the specific times when changes in trust occur. This allows us to identify when the trust of different ethnicities shifts from above to below average, better understanding how different presidents and what time periods have impacted this process of variation in trust.\nTo add this variable, we have used another database provided by Pew Research Paper, which has the same format as our original database, so it is quite easy to add the confidence mean to our database.\n\n\ndata <- read_csv(\"database.csv\")\ndata.df <- data.frame(data[1:150,1:6])\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\ntrust <- read_csv(\"chart-export-cda90f7d-1ac9-45fd-99e1-ec61f808868b.csv\")\ntrust.df <- data.frame(trust[1:150,1:4])\n\ndata.df$Trust.Average <-trust.df$Trust.average\ndata.df$Date <- as.Date(data.df$Date, format = \"%m/%d/%Y\")\n\n\nOnce the variable has been added, we clean the NA data again with tidyverse. In addition, we have also named a new vector, which collects the names of the ethnicities, which we will use and explain later.\n\n\ndata.df <- data.df |>\n  tidyr::pivot_longer(c(Hispanic, White, Asian, Black)) |> \n  na.omit()\ndata.df\n\n# A tibble: 283 × 5\n   Date       .     Trust.Average name     value\n   <date>     <chr>         <dbl> <chr>    <dbl>\n 1 2023-06-11 PEW              16 Hispanic    23\n 2 2023-06-11 PEW              16 White       13\n 3 2023-06-11 PEW              16 Asian       23\n 4 2023-06-11 PEW              16 Black       21\n 5 2022-05-01 PEW              20 Hispanic    29\n 6 2022-05-01 PEW              20 White       16\n 7 2022-05-01 PEW              20 Asian       37\n 8 2022-05-01 PEW              20 Black       24\n 9 2021-04-11 PEW              21 Hispanic    36\n10 2021-04-11 PEW              21 White       18\n# ℹ 273 more rows\n\ndata.df$name <- factor(data.df$name, levels = c(\"White\", \"Black\", \"Hispanic\", \"Asian\"))\n\n\nSolving problems\nFirst of all, we are going to solve one of the main problems with the graph and that was the similarity of colours, which made it difficult to recognize and distinguish the different lines.\n\n\nj <- ggplot(data.df)+\n  aes(Date, value, color=name)+\n  rect_layers+\n  geom_line(linetype=\"solid\", size=1.75, alpha = 1) +\n  scale_color_manual(\n    values = c(\"Asian\" = \"#cdb4db\",  \"White\" = \"#bde0fe\", \"Black\" = \"#ffafcc\", \"Hispanic\" = \"#a7c957\"),\n    name = \"Ethnicity and race: \"\n  )\n\n\nIn the following code we are going to implement the new variable “Trust.Average”, which we have added as “dashed” so that there is no confusion with the colours, being easily visible and comparable with the rest of the variables.\n\n\nj <- j+\n  geom_line(aes(x = Date, y = Trust.Average, linetype = \"Trust.Average\"), color = \"black\") +\n  scale_linetype_manual(name = \"Trust.Average\", values = \"dashed\") \nj\n\n\n\nWe re-create the title and add the same details again.\n\n\nj <- j + \n  labs(\n    x = NULL,\n    y =NULL,\n    title = expression(paste(bold(\"Trust in government by race and ethnicity\"))),\n    subtitle = \"% who say they trust the government to do what is right just about always/most of time\",\n    color = \"Ethnicity:\",\n    caption = \"Source: PEW RESEARCH CENTER\")\n\n\nNew axes\nAnother important improvement we have developed is in the x-axis line, where we have added many more important dates that mark crucial events in US history, with significant impacts on public confidence and perceptions of the government. Here is a brief explanation of each of them:\nMLK. Jr Murdered. - 1968: The assassination of Martin Luther King Jr. was a critical moment in the struggle for civil rights, affecting confidence in equality and social justice.\nEnd of the Vietnam War - 1975: The conclusion of the Vietnam War in 1975 was a historic milestone in ending direct U.S. military involvement, generating profound reflections on foreign policy, social resistance and the reconceptualization of the U.S. role in international conflicts.\nIrangate - 1986: The Irangate scandal revealed the Reagan administration’s secret sale of arms to Iran, with funds destined for Nicaraguan rebels. This generated controversy over government transparency and ethics, impacting on trust in government integrity.\nOklahoma City Bombing - 1995: The terrorist attack in Oklahoma City, which resulted in the deaths of 168 people, left a deep imprint on the national conscience and led to an increase in homeland security.\n9/11 - 2001: The terrorist attacks of September 11 caused the deaths of thousands of people, leading the United States to declare the “War on Terror”. This transformative event altered global politics, national security and the perception of risk in American society.\nFinancial Crisis of 2008: The Financial Crisis, triggered by the collapse of large financial institutions and the housing bubble, resulted in a global recession. The consequences included massive job losses, government intervention in the financial sector and significant economic reforms to prevent future crises.\nSnowden Revelations - 2013: Edward Snowden, a National Security Agency (NSA) contractor, leaked classified documents that revealed massive U.S. government surveillance programs. These revelations generated intense debate about privacy, national security and the ethics of spying, impacting intelligence policies and public perception.\nCOVID-19 - 2020: The COVID-19 pandemic, which began in 2019, had a devastating impact on public health globally, triggering economic crises and undermining confidence in governmental responsiveness\nThis incorporation is essential to our analysis, as it gives us the opportunity to examine in greater detail and precision how each of these historical events impacted on the trust of different ethnicities. This comparison allows us to identify whether these events affected the average trust of individuals, as well as whether any of these events significantly affected one ethnicity or race more than another.\n\n\nj <-  j+ scale_x_date(\n    breaks = c(desired_dates, as.Date(\"2001-09-11\"), as.Date (\"2021-12-20\"), \n               as.Date(\"2008-01-01\"), as.Date(\"2013-02-02\"), as.Date(\"1995-01-01\"), \n               as.Date(\"1975-04-30\"), as.Date(\"1967-04-20\"), as.Date(\"1985-08-20\")),\n    labels = c(format(desired_dates, \"%Y\"), \"9/11\", \"COVID-19\", \"2008 Crisis\",\n               \"Snowden revelations\", \"Oklahoma City Bombing\", \"End of Vietnam War\", \n               \"MLK.Jr Murdered\", \"Irangate\"),\n    expand = c(0.00, 0.00), \n  )+ \n  scale_y_continuous(\n    limits = c(0, 100),\n    breaks = seq(0, 100, by = 20),\n    expand = c(0, 0) \n  )\n\n\nFinal details\nAgain, we reuse the “theme” function in which we have introduced slight improvements to show a neater and more detailed graphic and we add the “president” vector we created earlier, which we have not modified from the original graphic.\n\n\nj <- j + theme_minimal() +\n  theme(\n    plot.subtitle = element_text(size = 10, color = \"grey\", face = \"italic\"),\n    legend.position = \"bottom\",\n    legend.title = element_text(face = \"bold\", size=10),\n    legend.text = element_text(size = 10),\n    legend.margin = margin(t = 0, b = -0.2, unit = \"cm\"),  \n    axis.line = element_line(size = 0.5, color = \"black\"),\n    axis.text = element_text(size = 10, color = \"black\"),\n    axis.title = element_text(size = 12, color = \"black\", face = \"bold\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_blank(),\n    axis.ticks.x = element_line(size = 0.5),\n    axis.ticks.y = element_line(size = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.text.y = element_text(angle = 0, hjust = 0.5),\n    plot.background = element_rect(fill = \"white\"),\n    plot.margin = margin(t=0.45, r= 0.5, b=0, l= 0.5, \"cm\"),\n    legend.key.width = unit(1, \"cm\"), \n    legend.key.height = unit(1, \"cm\"),  \n    legend.spacing = unit(0.5, \"cm\"),  \n    legend.box.margin = margin(0, 0, 1, 0, \"cm\"),\n    plot.caption = element_text(hjust = 0, vjust = 0, color = \"black\", size = 10, \n                                margin = margin(t = 0, b = 0.5, l = 0, r = 0, \"cm\"))\n  ) + president\n\n\nWe add a modification to the legends\n\n\nj <-  j + \n  guides(\n    color = guide_legend(\n      keywidth = 2, keyheight = 0.2,  \n      title.position = \"top\",  \n      label.position = \"bottom\",  \n      ncol = 4  \n    )) + guides(linetype = guide_legend(title = NULL,\n                                 label.position = \"bottom\",  keywidth = 0.2))\n\n\nFinal graph\nDespite improvements, the graph is still quite confusing, as there are many lines that are concentrated at similar points. This accumulation of lines can be confusing, making the interpretation of the graph more complicated. It is therefore necessary to treat data visualisation even more effectively to achieve a clearer and more accessible representation, ensuring that the information is easily assimilated by those viewing the graph.\nConsequently, we have used the function “facet_wrap” to divide the graph by ethnicity, leaving the variable “Trust.Average” as a constant. In this way, the graph is much more understandable, allowing us to take the average as a reference and make comparisons between graphs with greater precision. In addition, we have used the vector “names” mentioned above to display the graphs in the following order:\n\n\nj <- j+\n  facet_wrap(~name, scales = \"free\",nrow=2, ncol=2) \nj\n\n\n\nAnalysis and results\nOnce the improvement has been made, we can see that the graph is much clearer, which will allow us to analyse more precisely how US citizen confidence in the presidency has evolved and what historical factors may have affected these developments.\nFirst of all, it should be mentioned that these facts do not link direct causality, but provide a clearer visual representation of the underlying data. That is, the improved visualisation of the chart focuses on variations and trends, allowing us to identify patterns that might have previously gone unnoticed. However, at no point can we claim that these variations in confidence are due to the facts we mentioned, as well as to the president in question. This is because a large number of factors would have to be taken into account that cannot be predicted, at least not with our data. Therefore, our analysis will be based on observing how the different populations reacted to the different periods and analysing the key moments that have influenced citizens’ perceptions of the presidency.\nConclusions and explanations\nFirst of all, we are going to focus on explaining the 2 main graphs, which are those corresponding to the “White” and “Black” breeds. These are considered the main ones because they provide more data, since they start in 1958, therefore, we can make a more precise study and allow us to analyse a greater number of details.\nIn the graph that represents white people, the first thing that strikes us is the large decrease in trust over the years, as in 1958 trust was around 80% and in 2023 it dropped to just 20%. This shows that regardless of the type of government, the trust of white people has declined enormously. On the other hand, since Johnson’s presidency, the trust of this race plummeted and broke through the median barrier at the end of the Vietnam War along with the beginning of Carter’s presidency. This means that this date seems to be the exact point at which white confidence was below average for the first time in history, declining throughout that president’s term until the arrival of Nixon, where he regained confidence and again surpassed the average.\nHowever, one fact that is quite remarkable about this mandate is the lack of importance or repercussions that Irangate had, because although the average level of trust decreased from that date onwards, the trust of white people remained fairly constant. Subsequently, with the Bush administration, trust was also above average until the arrival of Clinton, when trust was again below average. However, during the eight years of Democratic rule, average trust increased by almost 40% during this period. Moreover, the beginning of this period of trust growth seems to coincide with the Oklahoma bombing. In 2001 there was a change of government from Democrat to Republican, with Bush again as President. However, this year was marked by the attack on the Twin Towers on 11 September 2001 (known as 9/11 or 11S ), which triggered the beginning of a loss of confidence in the government that continues to this day, both on average and in the specific case of white people. Since then, the only time that white people’s trust has been above average was with Trump. In general, we can observe that the trust of white people tends to be above average when political representatives belong to the Republican party. However, the overall average tends to decrease when these candidates are not in government.\nOn the other hand, in the case of Black individuals, we can see how their confidence in the government has also decreased over time, consistently remaining below the average. The trust of Black people in the government has remained relatively constant over time, ranging between 20% and 40%, except during two key events. The first and most notable change occurred with the assassination of Martin Luther King Jr. Following those dates, there was a marked decline in trust, which is understandable considering the impact of this historical event. Martin Luther King was one of the early and prominent advocates for racial equality in the United States. His assassination in 1968 not only represented the tragic loss of an influential leader but also symbolized a significant setback for the civil rights movement and equality. From that moment until the Clinton administration, trust remained below average, but this only lasted for a couple of years until the Oklahoma bombing.\nThe second event that saw a resurgence in the confidence of Black individuals was during the Obama administration. Upon assuming office in 2009, Obama became the first African-American president of the United States. His tenure marked a historic milestone that not only symbolized progress towards inclusion and diversity in the country’s leadership but also had a significant impact on the perception of the African-American community. The cultural connection and identification with a leader who shared their ethnic heritage contributed to strengthening trust in government institutions. Additionally, the policies and programs implemented during his administration to address specific challenges faced by the Black community reinforced the notion of progress and social justice, thus consolidating a tangible improvement in the confidence of this population during that period.\nRegarding the Hispanic ethnicity, for which we only have information from 1990, their confidence also shows a negative trend, although much less abrupt than in the previous cases, consistently remaining above the average. The historical event that most affected their confidence was the 9/11 attacks, similar to the majority of citizens in the country. It is also noted that in 2010, during the Obama administration, there were variations in their confidence, possibly influenced by the revelations of Edward Snowden.\nFinally, regarding Asians, we have very little information to effectively assess the provided data. However, starting from the COVID-19 crisis, there is observed a decrease in their confidence in the government, which could make sense considering that they were the target of attacks and discrimination during the pandemic. The Asian community faced stigmatization and prejudice linked to the origin of the virus, which possibly influenced their perception of the government.\nIn summary, we can affirm that the overall trust of American citizens has decreased over the years, affecting all the ethnicities and races we have observed. However, this decline has not affected all Americans equally. The analysis shows that white individuals have consistently shown a significant increase in trust when representatives from the Republican party are in power, a situation not mirrored in the majority of other cases, where trust tends to decline. The same pattern is observed with specific events, such as the assassination of Martin Luther King Jr., which had a more significant impact on the trust of Black individuals, or the COVID-19 pandemic, which affected the trust of Asian individuals.\nPossible future implications\nThis growing crisis in governmental trust could trigger a number of significant consequences on the stability and effectiveness of the political system, as well as result in increased social polarization, loss of legitimacy of governmental institutions and decreased citizen participation in the democratic process. Therefore, it will be essential to carefully analyze the underlying causes of the decline in trust and to implement effective measures to rebuild the connection between government and society.\nThis could have a wide range of political implications in the future, especially with the aim of reducing such politicization and rebuilding trust in the presidency, because if the necessary measures are not taken, it could lead to the outright rejection of political decisions, ending political support and causing the failure of different governments. Therefore, to avoid more unfavorable scenarios, it will be crucial to undertake significant efforts to rebuild trust through transparency, accountability and commitment to the needs and concerns of the population.\nFinally, understanding the reasons that generate this distrust in the presidency could be essential to address the Sustainable Development Goals (SDGs) of the 2030 Agenda. By identifying the causes and consequences of the lack of trust, more effective strategies can be developed to promote citizen participation and collaboration in the implementation of policies aimed at achieving sustainable goals.\n\n\n\n",
    "preview": "projects/2023/100430897/100430897_files/figure-html5/unnamed-chunk-22-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2880,
    "preview_height": 1872
  },
  {
    "path": "projects/2023/100507468/",
    "title": "Causes of Deaths 2019",
    "description": "Treemap that describe the causes of death before covid pandemic.",
    "author": [
      {
        "name": "Alejandro Saavedra-García",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction and libraries\nOriginal Graph\nReplication of the graph\nAnnotate\n\nFinal Replication\nLimitations\n\nEnhancement\n\nIntroduction and libraries\nIn order to make this chart, we need tidyverse to tidy the data, ggplot2\nto make the graph, and treemapify to helps us to improve our treemap.\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(treemapify)\n\n\nOriginal Graph\nWe found out this plot in the section of Terrorism in Our World in Data\nbut Terrorism and War battle deaths were the most insignificant cause of\ndeaths. This graph was published in Our World in data and the author is\nMax Roser.\nThe data was collected by IHME global Burden of Disease and Global\nTerrorism Database. This database contain data about causes of deaths\nfrom 1970 to 2021. Nevertheless, this graph just represents data\ncollected in 2019, which is the previous year before the covid-19\npandemic. 2020 and 2021 are not a significant year if you want to study\nthe evolution of the causes of deaths because they were significantly\naffected by the pandemic.\nOriginal graphReplication of the graph\n\n\nTree_terror <- read.csv(\"pruebacsv.csv\")\n\n\nAfter running the read.cvs, I had to make the tidy data of this\ndatabase.\nAt first, there were more illnesses than needed so I had to aggregate\nthem all in a new columns with their proper names. For this task, I had\nto search and determine the most suitable column for each illness.\n\n\nQ <- Tree_terror |>\n  drop_na() |> \n  mutate(Digestive_diseases = Digestive.diseases + Cirrhosis.and.other.chronic.liver.diseases,\n         Neurological_deseases = Alzheimer.s.disease.and.other.dementias + Parkinson.s.disease,\n         Other_noncommunicable_diseases = Chronic.kidney.disease + Drug.use.disorders + Alcohol.use.disorders, \n         Nutricional_deficiencies = Nutritional.deficiencies + Protein.energy.malnutrition,\n         Other_infectious_diseases = Meningitis + Acute.hepatitis,\n         Other_accidents = Drowning + Fire..heat..and.hot.substances + Exposure.to.forces.of.nature +Environmental.heat.and.cold.exposure,\n         Homicides = Interpersonal.violence + Poisonings)|> \n  filter(Year == 2019, Entity == \"World\") |> \n  select(-Digestive.diseases, \n        -Cirrhosis.and.other.chronic.liver.diseases, \n        -Alzheimer.s.disease.and.other.dementias, \n        -Parkinson.s.disease,\n        -Chronic.kidney.disease,\n        -Drug.use.disorders,\n        -Alcohol.use.disorders,\n        -Nutritional.deficiencies, \n        -Protein.energy.malnutrition,\n        -Meningitis,\n        -Acute.hepatitis,\n        -Drowning,\n        -Fire..heat..and.hot.substances,\n        -Exposure.to.forces.of.nature ,\n        -Environmental.heat.and.cold.exposure,\n        -Interpersonal.violence,\n        -Poisonings,\n        -Code,\n        -Year,\n        -Entity)  |> \n  pivot_longer(cols = \"Malaria\":\"Homicides\", \n               names_to = \"Causes\", \n               values_to = \"Num_of_deaths\")\n\n\nTo make this a treemap, all illnesses must be within a group. To\naggregate them I decided to create a new column(clasificación) and use a\ncase_when when they were classified as Infectious disease, Suicides and\nso on.\nIn this way, you can create groups(type of illness) and subgroups(which\nare the illnesses themselves).\n\n\nQ <-  Q |> \n    mutate(\n    clasificación = case_when(\n      Causes %in% c(\"Cardiovascular.diseases\", \"Neoplasms\", \"Chronic.respiratory.diseases\", \"Digestive_diseases\", \"Neurological_deseases\", \"Diabetes.mellitus\", \"Other_noncommunicable_diseases\") ~ \"Noncommunicable Diseases\",\n      Causes %in% c(\"Lower.respiratory.infections\", \"Diarrheal.diseases\", \"Tuberculosis\", \"HIV.AIDS\", \"Malaria\", \"Other_infectious_diseases\") ~ \"Infectious Diseases\",\n      Causes %in% c(\"Neonatal.disorders\", \"Maternal.disorders\", \"Nutricional_deficiencies\") ~ \"Maternity Deaths\",\n      Causes %in% c(\"Road.injuries\", \"Other_accidents\") ~ \"Transport Accidents\",\n      Causes %in% c(\"Self.harm\") ~ \"Suicides\",\n      Causes %in% c(\"Homicides\", \"Conflict.and.terrorism\") ~ \"Homicides\",\n      TRUE ~ \"Other\"\n    )\n  )\n\n\nWhen you finish with tidy and create groups and subgroups, now it is\ntime for ggplot(geom_treemap).\n\n\nQ <-ggplot(Q, \n            aes(area = Num_of_deaths, fill = clasificación, subgroup = clasificación, label = Causes)) + \n  geom_treemap() +\n  geom_treemap_subgroup_border() +\n  theme(legend.position = \"none\", plot.title = ggtext::element_markdown(),\n        axis.title = element_blank(), \n        axis.text = element_blank(), \n        axis.ticks = element_blank(), \n        axis.line = element_blank()) +\n  labs(title = \"**What do people die from?** Causes of death globally in 2019\",\n       subtitle = \"The size of the entire visualization represents the total number of deaths in 2019: 55 million.\nEach rectangle within it is proportional to the share of deaths due to a particular cause\",\n       caption = \"Data source: IHME Global Burden of Disease and Global Terrorism Database\") +\n  scale_fill_manual(values = c(\"Noncommunicable Diseases\" = \"#084964\", \n                                \"Infectious Diseases\" = \"#a4184d\", \n                                \"Maternity Deaths\" = \"#b73695\", \n                                \"Transport Accidents\" = \"#0f9d76\", \n                                \"Suicides\" = \"#5b8464\", \n                                \"Homicides\" = \"#008e84\"))\nQ\n\n\n\nAnnotate\nI used annotate to write the name of the principle causes of deaths.\nBut, you have to be cautious because when you use annotate you will\nwrite on the chart, and everything you write it can overlap with other\nboxes. Therefore, the box will remain static even though you because\n\n\n#If you do anotate and the name are too long, it will overlap\n\nQ <- Q +\n   annotate(geom = \"text\", x = 0.0, y = 1, colour = \"white\", label = \"Cancer\") +\n   annotate(geom = \"text\", x = 0.1, y = 0.4, colour = \"white\", label = \"Cardiovascular diseases\") +\n   annotate(geom = \"text\", x = 0.42, y = 0.75, colour = \"white\", label = \"Digestive diseases\") +\n   annotate(geom = \"text\", x = 0.39, y = 1, colour = \"white\", label = \"Neurological\")+\n   annotate(geom = \"text\", x = 0.71, y = 1, colour = \"white\", label = \"Diabetes\") +\n   annotate(geom = \"text\", x = 0.85, y = 1, colour = \"white\", label = \"Suicide\") +\n   annotate(geom = \"text\", x = 0.87, y = 0.87, colour = \"white\", label = \"Road Injuries\")+\n   annotate(geom = \"text\", x = 0.90, y = 0.77, colour = \"white\",size = 3.2, label = \"Neonatal disorders\") +\n   annotate(geom = \"text\", x = 0.84, y = 0.60, colour = \"white\", label = \"Malaria\") +\n   annotate(geom = \"text\", x = 0.87, y = 0.5, colour = \"white\", label = \"Tuberculosis\") +\n   annotate(geom = \"text\", x = 0.85, y = 0.35, colour = \"white\", label = \"Diarrheal\")+\n   annotate(geom = \"text\", x = 0.89, y = 0.13, colour = \"white\", label = \"Lower infections\") +\n   annotate(geom = \"text\", x = 0.1, y = 0.4, colour = \"white\", label = \"Cardiovascular diseases\") +\n   annotate(geom = \"text\", x = 1, y = 1, colour = \"white\", size = 3, label = \"Homicides \") \nQ\n\n\n\nFinal Replication\n\n\nQ\n\n\n\nLimitations\nThere are 2 main limitations in this chart.\nFirst, the shape of this graph was made by r and I cannot change it into\nthe shape I want to replicate.\nSecond, because i cannot replicate the shape of the graph, the names and\nexplanations within the box cannot be replicated because of the length\nand annotation properties.\nEnhancement\nFor the improvement, I have created a geom_col to visualize all deaths\ncauses by violence. This is a better plot to study terrorism and its\nimpact to the total deaths.\nInfections, non-communicable disease, fire and so on, on the whole are\nunintentional causes. But suicide, terrorism and homicide are\nintentional so they have different variables to take into account and\nshould be studied apart from the rest.\nWe can see African, European, Americas, South-east Asia, and western\nPacific region to compare the three different violent causes per capita.\nThus, we can compare per capita the proportion of each cause by their\npopulation.\nTo create this chart, I have just saved the data(regions,number of\npeople that were affected and the population of those regions). Then, we\nhad to adjust the name of the column after the gather function. If we do\nnot do it, we will see in the legend Conflict.and.terrorism instead of\nConflict and terrorism. Finally, we use ggplot for the violent cause per\ncapita.\n\n\ndata <- data.frame(\nRegion = c(\"African Region (WHO)\", \"European Region (WHO)\", \"Region of\nthe Americas (WHO)\", \"South-East Asia Region (WHO)\", \"Western Pacific\nRegion (WHO)\"),\nHomicides = c(98527, 51451, 177179, 61714, 63379),\nConflict.and.terrorism = c(9519, 565, 32, 1880, 421),\nSuicide = c(69367, 137266, 94784, 230453, 184918),\nPopulation = c(1292124691, 342597698, 585172586, 655000000, 1900000000)\n)\n\n\n\ndatos_long <- gather(data, key = \"Causes\", value = \"Cantidad\", -Region,\n-Population)\n\n#We have to adjust the name of the column after the gather function\ndatos_long$Causes <- ifelse(datos_long$Causes == \n                            \"Conflict.and.terrorism\", \"Conflict and terrorism\",    datos_long$Causes)\n\n\nggplot(datos_long, \n       aes(x = Cantidad / Population * 100, y = Region, fill = Causes)) +\n       geom_col(position = \"dodge\") +\n       labs(title = \"Causes of violent death per capita\",\n       x = \"Violent deaths per capita\") +\n       theme_bw() +\n       theme(panel.background = element_rect(fill = \"white\"),\n             axis.text.y = element_text(angle = 0, hjust = 1),\n             axis.title.y = element_blank()) + \n       scale_fill_manual(values = \n                           c(\"Homicides\" = \"green\", \n                             \"Conflict and terrorism\" = \"yellow\", \n                             \"Suicide\" = \"brown\"))\n\n\n\nThe main finding of this plot is that, even thought you just compare\nviolent causes, terrorism is not as important as we might have thought.\nI do not want to undermine the position of the victims that terrorism\nhas caused. I just point out that following this plot, yourself and your\nneighborgs are more dangerous than a terrorist even though terrorism has\na critical impact on social media.\nTo sum up, public policies should take more into account preventing\nsuicide and homicides, at least, as much as they do with terrorism.\n\n\n\n",
    "preview": "projects/2023/100507468/100507468_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100509696/",
    "title": "Changing Sources of Electricity Generation in the United States",
    "description": "This graph describes how the sources of electricity generation in the United\nStates have changed from 2001 to 2017.",
    "author": [
      {
        "name": "Jieun Park",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nPackages and libraries\nOriginal graph\nData Processing\nReplication\nEnhancement\n\nPackages and libraries\n\n\nlibrary(readxl)\nlibrary(tidyverse)\n# remotes::install_github(\"davidsjoberg/ggsankey\")\nlibrary(ggsankey)\n\n\nOriginal graph\n\n\n\nFigure 1: Original graph\n\n\n\nThe presented graphical representation delineates the evolution of electricity generation sources in the United States across the span of 16 years, from 2001 to 2017, encompassing data from all 50 states. You can find the data from this link: https://www.eia.gov/totalenergy/\nTraditionally, over the 16-year period under scrutiny, coal, nuclear, and natural gas have consistently constituted the primary resources for electricity generation in the U.S. A comprehensive analysis, as outlined in the accompanying article, suggests that the relative rankings of these sources have undergone minimal alteration over 17 years for 13 states. Contrarily, in the remaining 37 states, both the proportions of electricity generated and the hierarchical ordering of different sources exhibit discernible changes. Consequently, the points of intersection or crossovers in the graph predominantly stem from the dynamic shifts observed in these 37 states.\nData Processing\n\n\ndata <- read_excel(\"Net_generation_United_States_all_sectors_annual.xls\")\n\n\ndata <- data |> separate(\"Year,petroleum liquids thousand megawatthours,coal thousand megawatthours,natural gas thousand megawatthours,nuclear thousand megawatthours,conventional hydroelectric thousand megawatthours,wind thousand megawatthours,all solar thousand megawatthours,geothermal thousand megawatthours\",\n                         into=c(\"year\", \"Petroleum\", \"Coal\", \"Natural Gas\", \"Nuclear\", \"Hydroelectric\", \"Wind\", \"Solar\", \"Geothermal\"), sep=\",\")\n\ndata <- data[-c(22),]\ndata <- data[-c(1,2,3,4),]\n\ndata$Petroleum <- as.numeric(data$Petroleum)\ndata$Coal <- as.numeric(data$Coal)\ndata$\"Natural Gas\" <- as.numeric(data$\"Natural Gas\")\ndata$Nuclear <- as.numeric(data$Nuclear)\ndata$Hydroelectric <- as.numeric(data$Hydroelectric)\ndata$Wind <- as.numeric(data$Wind)\ndata$Solar <- as.numeric(data$Solar)\ndata$Geothermal <- as.numeric(data$Geothermal)\n\ndata[is.na(data)] <- 0 #to calculate the proportion, NA should be replaced by 0\n\nyear <- rep(2001:2017, by = 1) #creating year variable\nyear <- as.matrix(year)\n\nx <- data |> select(-year)\nx <- as.matrix(x)\nx =  prop.table(x, margin = 1)\nx <- cbind(x, year)\n\nx <- as.data.frame(x) #change the matix to data.frame \nx <- relocate(x, \"V9\", .before = \"Petroleum\")\nx <- x |>  rename(c(year = V9))\nx$year <- sort(x$year, decreasing = TRUE)\n\nk <- pivot_longer(x, !year, names_to = \"energy\", values_to = \"percent\")\nk <- k |> mutate(percentage = percent * 100)\n\n\nThis is the code that I used for the replication of the original graph.\nI’ll explain some challenges that I have been faced using some codes below.\nReplication\n\n\ncolor <- c(\"Coal\" = \"#67614c\", \"Geothermal\" = \"#e2e2e2\", \"Hydroelectric\" = \"#81e3e9\",\n           \"Natural Gas\" = \"#e39424\", \"Nuclear\" = \"#9e71c2\", \"Petroleum\" = \"#d366a8\",\n           \"Solar\" = \"#f7d930\", \"Wind\" = \"#719bc2\")\n\nggplot(k, aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  theme_sankey_bump(base_size = 7)  +\n  labs(x = NULL, y = NULL,\n       title = \"Change of electricity generation sources in the United States\") +\n  scale_x_continuous(breaks = c(2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n                                2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017),\n                     labels = c(\"2001\", \"'02\", \"'03\", \"'04\", \"'05\", \"'06\", \"'07\", \"'08\", \"'09\",\n                                \"'10\", \"'11\", \"'12\", \"'13\", \"'14\", \"'15\", \"'16\", \"2017\")) +\n  scale_y_continuous(labels = NULL) +\n  theme_bw() + coord_cartesian(expand = FALSE) +\n  theme(legend.position = c(0.8,-0.4), legend.title = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.key.size = unit(c(0.35,0.35), \"cm\"),\n        plot.title = element_text(size = 9, face = \"bold\"),\n        legend.background = element_rect(color = \"black\"),\n        legend.text = element_text(face = \"bold\", family = \"Noto Sans KR\", size = 7),\n        plot.margin = unit(c(1,1,4,1), \"cm\"),\n        legend.spacing.x = unit(0.2, 'cm')) +\n  scale_fill_manual(values = color) +\n  guides(fill = guide_legend(nrow = 4)) +\n  annotate(\"text\", x = 2003, y = 75, label = \"Coal\", size = 5, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2006.5, y = 40, label = \"Natural gas\", size = 4, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2007.5, y = 20, label = \"Nuclear\", size = 4, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2003, y = 7, label = \"Hydroelectric\", size = 3, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2015.3, y = 5.3, label = \"WIND\", size = 1.9, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 70, label = \"51%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 40, label = \"21%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 19, label = \"17%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2001.3, y = 6, label = \"6%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 85, label = \"32%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 52, label = \"30%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 28, label = \"20%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 13, label = \"7%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\") +\n  annotate(\"text\", x = 2016.7, y = 6, label = \"6%\", size = 2, color = \"#302d21\", family = \"Source Sans 3\")\n\n\n\nCode below is a fundamental structure of my graph replication.\nI put node, fill, and value to ggplot function and it constructs nodes for different sources of electricity generation and fills it by each color of sources. Moreover, as I put the percentage into the value, the magnitude of node is specified.\nThen, geom_sankey_bump() is used to execute the basic ggplot code into geom_sankey graph format. With this function, I was able to smooth the graph and the type is specified as alluvial.\n\n\nk |> ggplot(aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  scale_fill_manual(values = color)\n\n\n\nBecause in the original graph, there is no background space except for the generated graph, I used theme_sankey_bump() function to adjust the base size of the graph.\n\n\nk |> ggplot(aes(x = year,\n              node = energy,\n              fill = energy,\n              value = percentage)) +\n  geom_sankey_bump(space = 0, type = \"alluvial\", color = \"transparent\", smooth = 13, alpha = 0.93) +\n  theme_sankey_bump(base_size = 7) +\n  scale_fill_manual(values = color)\n\n\n\nEnhancement\n\n\nnew_plot <- k |> \nggplot(aes(x=year, y=energy, fill=percentage)) +\n  geom_tile(col = \"white\") +\n  coord_equal() +\n  scale_fill_gradient(low=\"white\", high=\"blue\") +\n  theme_minimal(base_size = 12) +\n  theme(\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 11, face = \"bold\"),\n    legend.title = element_text(size = 11)\n  ) + labs(\n    x = NULL,\n    y = NULL,\n    title = \"Change of electricity generation sources in the United States\",\n    fill = \"Percentage\"\n  ) + coord_cartesian(expand = FALSE) +\n  scale_x_continuous(breaks = c(2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n                                2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017),\n                     labels = c(\"2001\", \"'02\", \"'03\", \"'04\", \"'05\", \"'06\", \"'07\",\n                                \"'08\", \"'09\", \"'10\", \"'11\", \"'12\", \"'13\", \"'14\",\n                                \"'15\", \"'16\", \"2017\")) \n\nplotly::ggplotly(new_plot)\n\n\n\nIn the pursuit of data visualization enhancement, I employed the ggplot2 package in R, leveraging the versatile geom_tile() function. This particular function facilitates the systematic examination of individual observations arranged by rows and tiles, offering an intuitive approach to data analysis. To further refine the visual representation, the coord_equal() function was utilized, contributing to the generation of tiles that appear more as squares than rectangles. This adjustment enhances the overall visual organization of the graph.\nIn the realm of color aesthetics, the scale_fill_gradient() function played a pivotal role in orchestrating a gradient color scheme. By specifying “white” as the lower end and “blue” as the higher end of the gradient, the color spectrum effectively denotes the range of values within the dataset. The strategic arrangement of colors, transitioning from white for the lowest values to blue for the highest values, imparts a visual cue where darker hues correspond to higher values and lighter hues signify lower values. This gradient color mapping enhances the interpretability of the graph, fostering a more intuitive understanding of the underlying data.\nAs a final touch, the ggplotly() function was employed to impart interactivity to the graph. This transformation elevates the visual experience by allowing users to dynamically explore and interact with the plotted data.\n\n\n\n",
    "preview": "projects/2023/100509696/100509696_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100513795/",
    "title": "American's Top Concerns 2022",
    "description": "Most important issues for Americans, April-October 2022: step-by-step\nreplication graph and a possible alternative.",
    "author": [
      {
        "name": "Mireia Hontanares Belda-Cortés",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nOriginal graph\nGraphic replication\nLoad libraries and read the database\nData cleaning and filtering\nCreation of the plot\nAnnotations\n\nGraphic alternative\n\nIntroduction\nAnticipating the 2022 midterm American elections, FiveThirtyEight\nundertook a survey to unveil the primary concerns of Americans and their\npotential influence on voting decisions.\nThe forthcoming graph encapsulates the central issues articulated by\n2,000 surveyed Americans from April to October 2022. It aims to shed\nlight on the central aspects of the investigation into the factors\ninfluencing American decision-making in the crucial weeks before the\nelections.\nThe principal aim of this project is to accurately replicate the\ninitially mentioned graph. Subsequently, upon completion of the\nreplication, the intention is to propose an alternative representation\nfor the same set of data by creating another graph.\nOriginal graph\nAs mentioned earlier, the original graph depicts the evolution in\nAmericans’ perception of key concerns from April to October 2022. To\nillustrate this, an alluvial chart is created by FiveThirtyEight,\nshowcasing the progression of this perception across the 6 waves, with\ninflation emerging as the primary perceived issue in each of them. For\nthis, they rely on the results obtained from the FiveThirtyEight/Ipsos\npoll, specifically addressing question three of the survey. In this\nquestion, a set of categories- represented in the graph- are proposed,\nand respondents were required to choose three as their primary concerns.\nOriginal graphGraphic replication\nLoad libraries and read the database\nThe initial step in replicating the graph is to load the necessary\nlibraries for its creation.\n\n\nlibrary(tidyverse)\nlibrary(ggalluvial)\nlibrary(shadowtext)\n\ndf <- readxl::read_excel(\"potser.xlsx\")\n\n\nData cleaning and filtering\nIn order to closely replicate the original graph, it is necessary to\nconduct filtering and recodification of certain categories and\nelements.\nInitially, we filter out the categories related to “other” and “none\nof these” to ensure they are not represented.\n\n\nfiltered_data <- df %>%\n  filter(Categoría != \"None of these\" & Categoría != \"Other\")\n\n\nOn the other hand, a recoding process is implemented for the original\nnames of the so-called “waves,” signifying different time periods. These\nnames are abbreviated as follows: W1, W2, W3, W4, W5, and W6. The same\nprocedure is applied to rename certain categories to match those in the\noriginal graph.\n\n\n# Waves\n\nfiltered_data$Waves <- recode(filtered_data$Waves,\n                                \"W1\" = \"WAVE 1\",\n                                \"W2\" = \"WAVE 2\",\n                                \"W3\" = \"WAVE 3\",\n                                \"W4\" = \"WAVE 4\",\n                                \"W5\" = \"WAVE 5\",\n                                \"W6\" = \"WAVE 6\")\n\n# Categories \n\nfiltered_data$Categoría <- recode(filtered_data$Categoría,\n  \"Inflation or increasing costs\" = \"Inflation\",\n  \"Political extremism or polarization\"= \"Political extremism\",\n  \"Government budget and debt\" = \"Government budget/debt\",\n  \"Election security or fraud\" = \"Election security\",\n  \"Opioid or drug addiction\" = \"Drug addiction\",\n  \"COVID-19/ coronavirus\" = \"COVID-19\")\n\n\nFinally, the diverse categories were arranged to ensure that when\ncreating the graph, they appear in the same order as in the original.\n\n\ndesired_order <- c (\"Inflation\", \"Political extremism\", \"Crime or gun violence\",\n                    \"Immigration\", \"Climate change\", \"Government budget/debt\",\n                    \"Abortion\", \"Race and racism\", \"Economic inequality\",\n                    \"Foreign conflicts or terrorism\", \"Healthcare\",\n                    \"Election security\", \"Taxes\", \"Education\", \"Drug addiction\",\n                    \"COVID-19\", \"Unemployment\", \"Natural disasters\")\n\nfiltered_data$Categoría <- factor(filtered_data$Categoría, levels = desired_order)\n\n\nCreation of the plot\nFor the creation of the alluvial diagram, the ggplot2 package and\nits various extensions were utilized.\nThe initial step involved configuring the graph with ggplot, specifying\nthe dataset to be used. The aesthetics (aes) of the graph were defined,\nwith the X-axis representing the different “waves,” the Y-axis\nrepresenting the associated values (Valores), and color and alluvium\n(flows in the graph) being determined by the concern category\n(Categoría).\nThe application of geom_alluvium was employed to generate the\nalluvial layers of the graph, with various attributes such as\ntransparency (alpha), color, and line size separating different\ncategories being specified.\nFurthermore, scale_x_discrete was used to configure the X-axis, and\nscale_fill_manual was applied to assign specific colors, derived\nfrom the original graph, to each concern category.\nUltimately, the title and subtitle of the graph were added, accompanied\nby additional adjustments to customize elements such as axis titles,\ntext, margins, and grid lines. The use of coord_cartesian facilitated\nthe adjustment of X-axis limits to ensure proper data visualization.\n\n\nplot <- ggplot(filtered_data) +\n  aes(x = Waves, y = Valores, fill = Categoría, alluvium = Categoría) +\n  geom_alluvium(decreasing = FALSE, show.legend = FALSE, alpha = 0.95, colour = \"white\", size = 1.9) +\n  scale_x_discrete(position = \"top\") +\n  scale_fill_manual(values = c(\"#1a40af\", \"#743f96\", \"#8f4683\", \"#9e5276\",\n                               \"#b16f63\", \"#a9606b\", \"#e7ea98\", \"#b67f5c\",\n                               \"#bdad53\", \"#ba8f57\", \"#bdbd54\", \"#bdcc59\",\n                               \"#ccf483\", \"#b7d051\", \"#c1e86f\", \"#bc9e54\",\n                               \"#f2f3e0\", \"#f2f3e0\")) +\n  labs(\n    title = \"Americans' top concern is still inflation\",\n    subtitle = \"Share of Americans who said each issue was among the most important facing the\\n country in six waves of a FiveThirtyEight/Ipsos survey, April-October 2022\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.title.x.top = element_blank(),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.text.x.top = element_text(angle = 0, hjust = 0.5, vjust = 0.5, size = 9, family = \"Agency FB\", face= \"bold\"),\n    axis.text.y = element_blank(),\n    axis.ticks.y = element_blank(),\n    plot.margin = unit(c(1, 1, 1, 1), \"lines\"),\n    panel.grid.major.x = element_line(color = \"black\", size = 0.07),\n    panel.grid.minor.x = element_line(color = \"black\", size = 0.07),\n    plot.title = element_text(family = \"Hansplatz Grotesk Bold\", size = 13,\n                              face = \"bold\", hjust = 0, margin = margin(b = 10, unit = \"pt\")), \n    plot.subtitle = element_text(family = \"Hansplatz Grotesk Bold\", size = 9,\n                                 face = \"plain\", hjust = 0,\n                                 margin = margin(t = 0, r = 0, b = 20, l = 0, unit = \"pt\"))\n  ) +\n  coord_cartesian(xlim = c(NA, NA), expand = FALSE)\n\nplot\n\n\n\nAnnotations\nFinally, ggannotate was employed for the annotations of each\ncategory in the graph, utilizing “shadowText” for the shading of each\nannotation. Adjustments were made to the font type, size, color, as well\nas inclination.\n\n\n plot <- plot + annotate (\"shadowText\", x= 5.4, y=250, label= paste(\"INFLATION\"),\n                          family= \"Franklin Gothic Medium\", size= 3.5,\n                          color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot + annotate (geom= \"text\", x= 5.8, y= 236,\n                          label = paste (\"65 percent of survey respondents said inflation was\",\n                                         \"one of the most important issues facing the country,\",\n                                         \"the highest of any wave of this survey\", sep = \"\\n\"),\n                          family = \"Franklin Gothic Medium\", size= 2.7,colour= \"white\", hjust=1)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.03547189834111, y= 191.940039688379,\n                         label= paste (\"CRIME OR GUN VIOLENCE\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+annotate ( \"shadowText\", x= 2.7681052384344, y = 159.126290409273,\n                         label =paste (\"POLITICAL EXTREMISM\"), \n                        family= \"Franklin Gothic Medium\", size= 3.5,\n                        color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+annotate ( \"shadowText\", x=4.49832172596228, y = 139.615412459535,\n                         label = paste (\"CLIMATE CHANGE\"),\n                         family= \"Franklin Gothic Medium\", size=  3.5, \n                         color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+ annotate ( \"shadowText\",x = 4.50788283594673, y = 121.878250687045,\n                          label = paste (\"IMMIGRATION\"),\n                          family= \"Franklin Gothic Medium\", size= 3.5,\n                          color= \"black\", bg.color= \"white\", bg.r= 0.08 )\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 4.77559391551139, y = 103.02794700318,\n                         label = paste (\"GOVERMENT BUDGET/DEBT\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.03040079654389, y = 130.400910778853,\n                         label = paste(\"ABORTION\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 3.40547189834111, y = 80.7433528761925,\n                         label= paste(\"RACE AND RACISM\"),\n                         family= \"Franklin Gothic Medium\", size= 3.5, angle=-6L,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.50466965260073, y = 97.2508436873157,\n                         label= paste(\"FOREIGN\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5,angle= -35L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.42134402562677, y = 90.9367782109428,\n                         label = paste (\"CONFLICT OR \"),\n                         family=\"Franklin Gothic Medium\", size= 3.5, angle= -35L,\n                         vjust = 0.25, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x= 1.35965944508192, y = 87.1183131338777,\n                         label = paste (\"TERRORISM\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5,angle= -35L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x= 3.97289956683296, y = 40.1741646222174,\n                        label = paste (\"COVID-19\"), family= \"Franklin Gothic Medium\",\n                        size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\",x = 3.9202178680187, y = 52.7033197743356,\n                        label = paste(\"HEALTHCARE\"), family= \"Franklin Gothic Medium\",\n                        size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x=  4.46963839600892, y = 64.1996250727836,\n                        label = paste (\"ECONOMIC INEQUALITY\"),\n                        family= \"Franklin Gothic Medium\", size= 3.5, color= \"black\",\n                        bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot<- plot+ annotate (\"shadowText\", x= 1.7800952657120652, y = 27.3196877943721,\n                        label = paste (\"ELECTION SECURITY\"),\n                        family= \"Franklin Gothic Medium\", size= 3.3, angle= -7L,\n                        color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x =5.35770595205863, y = 26.8394405136272,\n                         label = paste (\"DRUG ADDICTION\"),family= \"Franklin Gothic Medium\",\n                         size= 3.5, angle= -5L, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 5.10049440802788, y = 21.6345688058513,\n                         label = paste (\"EDUCATION\"),family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 5.75082486420105, y = 12.8789224437039,\n                         label = paste (\"TAXES\"), family= \"Franklin Gothic Medium\",\n                         size= 3.5, color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n\n plot <- plot+ annotate (\"shadowText\", x = 1.98660111783731, y = 4.08708463768002,\n                         label = paste (\"UNEMPLOYMENT\"),\n                         family = \"Franklin Gothic Medium\", size = 3.3,\n                         color= \"black\",bg.color= \"white\", bg.r= 0.08)\n \n \n plot <- plot+ annotate (\"shadowText\",x= 4.10927846574883, y = 2.98728980567533,\n                         label = paste (\"NATURAL DISASTERS\"),\n                         family= \"Franklin Gothic Medium\", size= 3.3,\n                         color= \"black\", bg.color= \"white\", bg.r= 0.08)\n \n \n plot\n\n\n\nGraphic alternative\nAs an alternative visualization to maintain the objective of depicting\nthe evolution of Americans’ perceptions regarding their top concerns\nacross the six waves, I find the heatmap to be a highly effective\nchoice. This approach facilitates the observation of trend developments\nand patterns, allowing for comparisons between different categories.\nAdditionally, the representation of values through varied color\ngradients enhances the intuitive depiction of intensity for each\ncategory.\nTo accomplish this, the same pre-cleaned database (filtered_data) used\nin replicating the graph was employed. The only modification made was\nchanging the order of the categories.\n\n\norder_heatmap <- filtered_data |>\n  group_by(Categoría) |>\n  summarise(Tendencia = sum(Valores)) |>\n  arrange(Tendencia) |>\n  pull(Categoría)\n\n\nfiltered_data$Categoría <- factor(filtered_data$Categoría, levels = order_heatmap)\n\n\nIn this manner, the ggplot2 library is employed to create a\nheatmap that visualizes the evolution of Americans’ primary concerns\nover six periods (waves) between April and October 2022.\nThe subsequent step revolves around constructing the graph itself.\nUtilizing ggplot, the heatmap is crafted, where waves are positioned on\nthe X-axis, categories (Categoría) on the Y-axis, and values are\nrepresented through colors. Similarly, the heat.colors palette is\nemployed, featuring 10 distinct shades, aiming to accentuate diverse\nchanges and enhance visual perception. To associate warmer colors with\nhigher values, the “rev” function is used, thereby reversing the\norder. Furthermore, the graph’s title is specified, and theme\nadjustments are applied to enhance readability and overall presentation.\nThis approach delivers a clear and effective visual representation of\nthe evolution of Americans’ top concerns over time.\n\n\nheatmap <-ggplot(filtered_data, aes(x = Waves, y = Categoría, fill = Valores)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradientn(colours = rev(heat.colors(10))) +\n  labs(\n    title = \"Americans' top concern's. April-October 2022\",\n    subtitle = \"Share of Americans most important issues perception in six waves, April-October 2022\", \n    fill = NULL\n  ) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 90, vjust = 0.5),\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    legend.title = element_blank(),\n    plot.title = element_text(family= \"Franklin Gothic Medium\",hjust = 1, size = 15,\n                              margin = margin(b = 5, l = 10, unit = \"pt\")), \n    plot.subtitle = element_text(family = \"Hansplatz Grotesk Bold\", size = 9,\n                                 face = \"plain\", hjust = 0.75,\n                                 margin = margin(t = 0, r = 0, b = 20, l = 10, unit = \"pt\")),\n    plot.margin = margin(t = 10, r = 10, b = 10, l = 10, unit = \"pt\") \n    )\n\n heatmap\n\n\n\n\n\n\n",
    "preview": "projects/2023/100513795/100513795_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 960,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100514861/",
    "title": "Gender Pay Gap Graph Replication",
    "description": "Using Eurstat data to reproduce the Gender Pay Gap graph of 2020.",
    "author": [
      {
        "name": "Rianne Nienke Visscher",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGraph replication\nIntroduction\nLibraries\nData cleaning and data transformation\nFonts\nCreating the main plot\nTheme specification\nAnnotations\nGraph text\nExtra panels\nCombining the planes with the main graph\nInserting graphics and final result\n\nGraph improvement\nData cleaning and data transformation\nMap\nFacet plot\nCombining graphs\n\n\nGraph replication\nIntroduction\nThe Gender Pay Gap graph of 2020 as presented below is created by Eurostat which is the European office for statistics by the European Commission. The graph shows a literal gap in the earth with a woman and man standing on top of it. For them, the gap is almost invisible as the smaller gaps are closest to the surface. Eurostat collects data concerning the labour market. The Gender Pay Gap is calculated as “the difference between the average gross hourly earnings of men and women expressed as a percentage of the average gross hourly earnings of men” (Eurostat, 2021), and is used as a proxy for the inequality between men and women.\nOriginal graphLibraries\nThe following libraries are used for the graph replication and the graph improvement\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(ggtext)\nlibrary(cowplot)\n\n\nData cleaning and data transformation\nFirst, the data is cleaned, that is, important NA’s and non-useful variables are deleted and only data for the year 2020 is kept. The variables ‘obs_left ’and ’obs_right’ are created which are needed to later compute the main graph. The variable ‘rank’ is computed to order the countries from the highest to the lowest pat gap.\n\n\ngender_pg <- read_csv(\"gender_pg.csv\")\n  \ndata <- gender_pg |> \n  filter(TIME_PERIOD == 2020) |> \n  filter(!(geo %in% c(\"EA20\", \"EA19\"))) |> \n  drop_na(OBS_VALUE) |> \n  select(-(\"DATAFLOW\":\"nace_r2\")) |> \n  select (-(\"OBS_FLAG\")) |> \n  mutate(obs_left = (OBS_VALUE/2)*-1,\n         obs_right = OBS_VALUE/2) |> \n  arrange(desc(OBS_VALUE)) |> \n  mutate(rank = 1:30) |> \npivot_longer(cols = c(\"obs_left\", \"obs_right\"), \n             names_to = \"left_right\", values_to = \"obs_conv\") |> \n  mutate(obs_left = (OBS_VALUE/2)*-1,\n         obs_right = OBS_VALUE/2) \n\n\nAs the original data only contains the abbreviations of the country names, in this section, a variable with the full country names is added to the data set.\n\n\ndata <- data |> \n  mutate(geo_names = case_when(geo == \"AT\" ~ \"AUSTRIA\",\n                               geo == \"BE\" ~ \"BELGIUM\",\n                               geo == \"BG\" ~ \"BULGARIA\",\n                               geo == \"CH\" ~ \"SWITZERLAND\", \n                               geo == \"CY\" ~ \"CYPRUS\",\n                               geo == \"CZ\" ~ \"CZECHIA\",\n                               geo == \"DE\" ~ \"GERMANY\", \n                               geo == \"DK\" ~ \"DENMARK\",\n                               geo == \"EE\" ~ \"ESTONIA\",\n                               geo == \"ES\" ~ \"SPAIN\",\n                               geo == \"FI\" ~ \"FINLAND\",\n                               geo == \"FR\" ~ \"FRANCE\",\n                               geo == \"HR\" ~ \"CROATIA\",\n                               geo == \"HU\" ~ \"HUNGARY\",\n                               geo == \"IE\" ~ \"IRELAND\",\n                               geo == \"IS\" ~ \"ICELAND\",\n                               geo == \"IT\" ~ \"ITALY\",\n                               geo == \"LT\" ~ \"LITHUANIA\",\n                               geo == \"LU\" ~ \"LUXEMBOURG\",\n                               geo == \"LV\" ~ \"LATVIA\",\n                               geo == \"MT\" ~ \"MALTA\",\n                               geo == \"NL\" ~ \"NETHERLANDS\",\n                               geo == \"NO\" ~ \"NORWAY\",\n                               geo == \"PL\" ~ \"POLAND\",\n                               geo == \"PT\" ~ \"PORTUGAL\",\n                               geo == \"RO\" ~ \"ROMANIA\",\n                               geo == \"SE\" ~ \"SWEDEN\",\n                               geo == \"SI\" ~ \"SLOVENIA\",\n                               geo == \"SK\" ~ \"SlOVAKA\",\n                               geo == \"EU27_2020\" ~ \"EU\")) |> \n  drop_na(geo_names)\n\n\nFonts\nThe fonts used in the original graph were checked using an online font detector. However, the original font was unavailable and ‘Roboto Condensed’ was reported as the most similar free font. The font is found in Google fonts and is uploaded using the ‘sysfonts’ package.\n\n\nsysfonts::font_add_google(\"Roboto Condensed\", family=\"Roboto Condensed\")\n\n\nCreating the main plot\nIn this section the main plot is created. Note that the main plot consist of two different geoms: geom_area with geom_linerange on top. Different rectangular annotations are done to match some of the aesthetics of the original graph. Geom_text is used to annotate the graph with the country names and the values of the gender pay gap per country (obs_value). As in the original graph Iceland, Norway and Switzerland with their corresponding obs_values are coloured grey whereas the rest of the countries and their obs_values is coloured black, these three countries have been excluded form the first geom_text and are later added in another geom_text with the specification of colour set as grey. Also, EU is not included in the first geom_text and is not added in the second geom_text as it asks for a different, more specific annotations and will later be added. The text colours have been generated using an online colour detector. Note that the labels are somewhat different from the original graph. This is due to a mismatch between the obtained data and the original graph. As I am uncertain as to what caused this mismatch, I do not change the data and accept these differences.\n\n\np <- data |>\n  ggplot (aes(x=obs_conv, y=rank))+\n  geom_area(fill = \"#ffeacb\")+  \n  geom_linerange(data = data, aes(y = rank,\n             xmin = obs_left, xmax = obs_right),\n             linewidth =0.3) +\n  annotate(\"rect\", xmin= -11.15, xmax= 11.15,\n           ymin=-3.5, ymax=0, fill = \"#ffeacb\" )+\n  annotate(\"rect\", xmin= -16, xmax= -11.15, \n           ymin=-3.5, ymax=1, fill = \"#f7a600\" )+\n  annotate(\"rect\", xmin= 11.15, xmax= 16, \n           ymin=-3.5, ymax=1, fill = \"#f7a600\" )+\n  annotate(\"rect\", xmin= -0.35, xmax= 0.35, \n           ymin=30.1, ymax= 30.5,fill = \"#ffeacb\" )+\n  geom_text(data=subset(data, OBS_VALUE != 12.9\n                        &OBS_VALUE !=12.2\n                        &OBS_VALUE !=13.4\n                        &OBS_VALUE !=18.4)\n            ,aes(label = OBS_VALUE, \n                 x = obs_right, \n                 family = \"Roboto Condensed\", \n                 fontface = 'bold'),\n                 size = 3.5, \n                 vjust = 0.5, \n                 hjust= -0.5)+\n  geom_text(data=subset(data, geo_names != \"EU\" \n                        & geo_names !=\"ICELAND\" \n                        & geo_names != \"NORWAY\"\n                        & geo_names != \"SWITZERLAND\"),\n            aes(label = geo_names, \n                x = obs_left, \n                family = \"Roboto Condensed\",\n                fontface = 'bold'), \n            size = 3.5, \n            vjust = 0.5,\n            hjust = 1.2)+\n  scale_x_continuous(limits = c(-22,22), expand=expansion(0))+\n   scale_y_continuous(limits = c(-3.5,30.5), expand=expansion(0))\n  \n  data_l<-data |> \n   filter(geo_names ==\"ICELAND\"|\n          geo_names == \"NORWAY\"|\n          geo_names == \"SWITZERLAND\")\n  \n p<-p+ \n   geom_text (data=data_l,aes(label = OBS_VALUE, \n                 x = obs_right, \n                 family = \"Roboto Condensed\", \n                 fontface = 'bold'),\n                 colour = \"#8e6001\",\n                 size = 3.5, \n                 vjust = 0.5, \n                 hjust= -0.5)+\n  geom_text(data=data_l,aes(label = geo_names, \n                x = obs_left, \n                family = \"Roboto Condensed\",\n                fontface = 'bold'), \n            colour = \"#8e6001\",\n            size = 3.5, \n            vjust = 0.5,\n            hjust = 1.2)\n p\n\n\n\nTheme specification\nIn this code piece, the panel grid and all themes is relation to the axes are set to element_blank to remove any of these specifications. The colour of the graph is set using the panel.background command.\n\n\np<-p+\n  theme(\n    plot.margin = margin(0,0, 0, 0),\n    panel.background = element_rect(fill = \"#f7a600\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    axis.line = element_blank())\n\np\n\n\n\nAnnotations\nIn order to add the pink labels for EU, two data sets were generated only containing the values needed to plot the labels. Hereafter, geom_label is used to put the labels on top of the plot. The pink bar is computed using the annotate (“rect”) function.\n\n\nlabel_EU <- data |> \n  filter(geo_names ==\"EU\" & left_right== \"obs_left\") \n\nlabel_OBS_VALUE <- data |> \n  filter(left_right== \"obs_right\" & OBS_VALUE == 12.9) \n  \n\nlabel_EU\n\n# A tibble: 1 × 9\n  geo       TIME_PERIOD OBS_VALUE  rank left_right obs_conv obs_left\n  <chr>           <dbl>     <dbl> <int> <chr>         <dbl>    <dbl>\n1 EU27_2020        2020      12.9    15 obs_left      -6.45    -6.45\n# ℹ 2 more variables: obs_right <dbl>, geo_names <chr>\n\np<- p+\n  annotate(\"rect\",ymin=15, ymax= 15, \n           xmin = -6.45, xmax=6.45,\n           fill = NA, color=\"#a71c6d\", linewidth =1)+\n  geom_label(data = label_EU, aes(label = geo_names), \n             family = \"Roboto Condensed\",  fontface = 'bold', size = 3.5, \n             color = \"white\",fill = \"#a71c6d\",\n             label.size = 0, label.r = unit(0, \"lines\"),\n             label.padding = unit(0.05, \"lines\"),\n             vjust = 0.5, hjust = 1.3)+\n  geom_label(data = label_OBS_VALUE, aes(label = OBS_VALUE), \n             family = \"Roboto Condensed\",  fontface = 'bold', size = 3.5,  \n             color = \"white\",fill = \"#a71c6d\", \n             label.size = 0, label.r = unit(0, \"lines\"),\n             label.padding = unit(0.05, \"lines\"),\n             vjust = 0.5, hjust= -0.5)\n  p\n\n\n\nIn this section, the text annotations are computed and are added to the main plot using annotate (‘text’)\n\n\nmiddle_string <- \"For all countries except Czechia and Iceland: data for enterprises \\n employing 10 or more employees. Czechia and Iceland: data \\n for enterprises employing 1 or more employees \"\n\nleft_string <- \"Iceland, Norway, Switzerland: \\n non_EU countries\"\n\nright_string <- \"Ireland, Greece: data not \\n available\"\n\np<-p+ \n  annotate(\"text\", x=0, y=-1, label = middle_string, family = \"Roboto Condensed\", size = 2.5, fontface = 'italic')+\n  annotate(\"text\", x=-12, y=-2, label = left_string, family = \"Roboto Condensed\", size = 2.5,  hjust ='right')+\n  annotate(\"text\", x=12, y=-2, label = left_string, family = \"Roboto Condensed\", size = 2.5, hjust ='left')\n\np\n\n\n\nGraph text\nIn this section the text that annoate the graph is generated for the upper part of the graph. The panels for the upper and lower part of the graph is computed in the next section.\n\n\nsubtitle_string <- \"How much less \\n do women earn \\n than men?\"\n\nsubtitle_string_short <- strwrap(subtitle_string, width = 15)\n\ntag_string <- \"Difference between average gross \\n hourly earnings of male and female \\n employees as % of male gross \\n earnings, 2020\"\n\ntag_string_short <- strwrap(tag_string, width = 35)\n\n\nExtra panels\nIn this section, the extra panels that are at the top and bottom of the graph are computed. The panels contain many different pieces of text. In order to locate them precisely to match the original graph, annotate (‘text’) is used. Later these panels will be added to the main graph using the library ‘patchwork’.\n\n\np1.df<- data_frame(x=c(-20,20), y= c(10,10))\n\np1<- p1.df |> ggplot (aes(x=x, y=y))+\n  geom_area(fill = \"#ffeacb\")\n\np1<-p1+\n  theme(aspect.ratio = 0.4,\n         axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank(),\n         plot.margin = margin (20,0, 0, 0))+\n  scale_x_continuous(expand=expansion(0),limits = c(-20,20)) +\n  scale_y_continuous(expand=expansion(0))+\n  annotate(\"text\", x=0, y=8, label = \"Gender pay gap\",\n           family = \"Roboto Condensed\", size = 12, fontface = 'bold')+\n  annotate(\"text\", x=-7, y=4, label =  paste(subtitle_string_short, collapse = \"\\n\"),\n           family = \"Roboto Condensed\", size = 7.5, fontface = 'bold',\n           lineheight = 0.8, hjust ='right')+\n  annotate(\"text\", x=6, y=4, label =  paste(tag_string_short, collapse = \"\\n\"),\n           family = \"Roboto Condensed\", size = 3.75, fontface = 'italic', \n           hjust = 'left')\n\np1\n\n\np2.df<- data_frame(x=c(-20,20), y= c(10,10))\n\np2<- p2.df |> ggplot (aes(x=x, y=y))+\n  geom_area(fill = \"white\")\n\np2<-p2+\n  theme(aspect.ratio = 0.05,\n         axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank())+\n  scale_x_continuous(limits = c(-20,20), expand=expansion(0)) +\n  scale_y_continuous(expand=expansion(0))+\n  annotate(\"text\", x=-5, y=6, label = \"#InternationalWomensDay\", \n           family = \"Roboto Condensed\", size = 5, fontface = 'bold',\n           color = \"#7a7b7f\", hjust=1)+\n  annotate(\"text\", x=6, y=6, label = \"ec.europa.eu/\", \n           family = \"Roboto Condensed\", size = 5, color = \"#7a7b7f\", hjust=0)+\n  annotate(\"text\", x=12.5, y=6, label = \"eurostat\", \n           family = \"Roboto Condensed\", size = 5, color = \"#7a7b7f\", hjust=0, fontface = 'bold')\n\np2\n\n\n\nCombining the planes with the main graph\nThis section adds to two extra plains to the main graph using the library (‘patchwork’)\n\n\np3<-p1+p+p2+\n  plot_layout(ncol=1)&\n  theme(plot.background = element_rect(fill =\"#ffeacb\"),\n        plot.margin = margin(0,0,0,0))\np3\n\n\n\nInserting graphics and final result\nThis piece of code adds the graphics of the woman and the man in the upper part of the graph as well as the EU sign in the lower part of the graph. The function ggdraw from the ‘cowplot’ package is used to do so.\n\n\np3<-ggdraw(p3) +      \n  draw_image(\"images/female.png\", y = 0.315, x=-0.07, scale = 0.170)\n\np3<-ggdraw(p3)+\n  draw_image(\"images/male.png\", y = 0.315, x=0.06, scale = 0.170)\n\np3<-ggdraw(p3)+\n  draw_image(\"images/eu.png\", y = -0.48, x=0.445, scale = 0.05)\n\np3\n\n\n\nGraph improvement\nIn my opinion, the original graph should not be changed as I think that the graph is clear and concise. It is able to transfer the message that the pay gap exists in all European countries and that the gap is fairly wide in many of them. Moreover, the graph is aesthetically pleasing and easy to interpret. However, a small shortcoming of this graph is that it only shows data for 2020 whereas the evolution of the pay gap over time can show us whether the gap is decreasing or not, that is, whether Europe is heading in the right direction. Therefore, I developed a new graph that is able to express this evolution over time. The graph consists of two sub graphs: a map showing the percentage increase or decrease between 2010 and 2021 and a facet graph showing a line graph of the evolution of the gender pay gap between 2010 and 2021. I have chosen to include the map graph as it is able to summarise the trends shown in the facet graph which are rather hard to compare among themselves due to the large amount of information in the graph.\nData cleaning and data transformation\nThe first step in building both graphs is transforming the data. For both graphs, only data from 2010 onward was selected. For the facet graph, the full country names were computed and a sub data frame only excluding the variable geom_names was created which is needed for specifying part of the graph. For the map graph, two new variables had to be created: the gender pay gap (obs_value) of 2010 (y2010) and the gender pay gap of 2021 (y2021) in order to subtract them from one another and create a variable that expresses the difference between 2010 and 2021. The following was done by making two new data sets with a column just specifying the pay gap in 2010 and 2021 and then merging these new data sets with the main data set. Hereafter, y2010 was subtracted from y2010 and this continuous variable was transformed into a factor variable by classifying the continuous variables into factors of 2 percentage points.\n\n\ngender_pg <- read_csv(\"gender_pg.csv\")\n\n#Data frame used for the facet graph\ndata2<- gender_pg |> \n  filter(TIME_PERIOD > 2009)\n\n#Gnereating the full country names for the facet graph\ndata2 <- data2 |> \n  mutate(geo_names = case_when(geo == \"AT\" ~ \"AUSTRIA\",\n                               geo == \"BE\" ~ \"BELGIUM\",\n                               geo == \"BG\" ~ \"BULGARIA\",\n                               geo == \"CH\" ~ \"SWITZERLAND\", \n                               geo == \"CY\" ~ \"CYPRUS\",\n                               geo == \"CZ\" ~ \"CZECHIA\",\n                               geo == \"DE\" ~ \"GERMANY\", \n                               geo == \"DK\" ~ \"DENMARK\",\n                               geo == \"EE\" ~ \"ESTONIA\",\n                               geo == \"ES\" ~ \"SPAIN\",\n                               geo == \"FI\" ~ \"FINLAND\",\n                               geo == \"FR\" ~ \"FRANCE\",\n                               geo == \"HR\" ~ \"CROATIA\",\n                               geo == \"HU\" ~ \"HUNGARY\",\n                               geo == \"IE\" ~ \"IRELAND\",\n                               geo == \"IS\" ~ \"ICELAND\",\n                               geo == \"IT\" ~ \"ITALY\",\n                               geo == \"LT\" ~ \"LITHUANIA\",\n                               geo == \"LU\" ~ \"LUXEMBOURG\",\n                               geo == \"LV\" ~ \"LATVIA\",\n                               geo == \"MT\" ~ \"MALTA\",\n                               geo == \"NL\" ~ \"NETHERLANDS\",\n                               geo == \"NO\" ~ \"NORWAY\",\n                               geo == \"PL\" ~ \"POLAND\",\n                               geo == \"PT\" ~ \"PORTUGAL\",\n                               geo == \"RO\" ~ \"ROMANIA\",\n                               geo == \"SE\" ~ \"SWEDEN\",\n                               geo == \"SI\" ~ \"SLOVENIA\",\n                               geo == \"SK\" ~ \"SlOVAKA\",\n                               geo == \"EU27_2020\" ~ \"EU\")) |> \n  drop_na(geo_names)\n\n#Deleting the variable geo_names for the facet graph\ndata2a<- dplyr::select(data2, -geo_names)\n\n#Creating data frame for the map graph\n#Creating variable y2021\ndata4<- data2 |> \nfilter(TIME_PERIOD==2021) |>\nmutate(y2021 = OBS_VALUE)\n\n#Creating variable y2010\ndata5<- data2 |> \nfilter(TIME_PERIOD==2010) |>\nmutate(y2010 = OBS_VALUE) \n\n#Merging variable y2021 into the main dataset\ndata3<- data2 |> \n  left_join(data4, by = c(\"geo\" = \"geo\"))\n\n#Merging the variable y2010 into the main data set\ndata3<- data3 |> \n  left_join(data5, by = c(\"geo\" = \"geo\"))\n\n#Selecting only the necessary variables\ndata3<- data3 |> \n  select(geo, TIME_PERIOD, OBS_VALUE, geo_names, y2021, y2010) |> \n  mutate(TIME_PERIOD = as.integer(TIME_PERIOD))\n\n#Creating the continuous variable of the dfference between 2010 and 2021 and transforming this into a categorical varaible\ndata3<- data3 |> \n  mutate(diff_10_21 = y2021-y2010) |>\n  mutate(diff_10_21_fact = ifelse(between(diff_10_21, -8, -6), \"-8 to -6\",\n                           ifelse(between(diff_10_21, -5.99, -4), \"-6 to -4\",\n                           ifelse(between(diff_10_21, -3.99, -2), \"-4 to -2\",\n                           ifelse(between(diff_10_21, -1.99, 0), \"-2 to 0\",\n                           ifelse(between(diff_10_21, 0.01, 2), \"0 to 2\",\n                           ifelse(between(diff_10_21, 2.01, 4), \"2 to 4\",\n                           ifelse(between(diff_10_21, 4.01, 6), \"4 to 6\",\n                           ifelse(between(diff_10_21, 6.01, 8), \"6 to 8\", \"NA\")))))))))\n\n#Uploading the map data from the 'giscoR' package and joing this data with the main dataset\neurope<-giscoR::gisco_get_countries(resolution = \"60\",\n    region=\"Europe\") |> \n  select(CNTR_ID, geometry) |> \n  left_join(data3, by = c(\"CNTR_ID\" = \"geo\"))\n\n\nMap\nThe map is created using geom_sf. Europe is selected by setting the coordinates in the coord_sf command. Also, the title and the legend title are created.\n\n\np1021<- ggplot(europe)+\n  geom_sf(aes(fill = reorder(diff_10_21_fact, diff_10_21)), size = 1)+\n  coord_sf(xlim=c(-20, 50),\n           ylim=c(35, 70))+\n  labs(title = \"Difference in Gender Pay Gap between 2010 and 2021\",\n       fill = \"Percentage change\")\n  \n\np1021\n\n\n\nTheme specification\nIn this section, the aesthetics of the graph are specified. All elements concerning the axis and the panel are set to element_blank to reduce noise in the graph. Also, the colour scale is set manually based on an existing colour palette. The colours are high in contrast to grasp the attention of the viewer and enhances understanding of decreasing or increasing percentages, that is, positive or negative trends. Hjust in the plot title is used to align the title with the scale which will become visible in the final plot.\n\n\np1021<-p1021+\n  theme(axis.title = element_blank(),\n         axis.text = element_blank(),\n         axis.ticks = element_blank(),\n         axis.line = element_blank(),\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(colour =  \"#33201F\", family = \"Roboto Condensed\", face = \"bold\", hjust = 1),\n    plot.subtitle = element_text(family = \"Roboto Condensed\",colour =  \"#33201F\" ),\n    legend.title = element_text(family = \"Roboto Condensed\",colour =  \"#33201F\" ),\n    legend.position = \"left\",\n    plot.margin = margin(10,10,10,10))+\n  scale_fill_manual(values = c( \"-8 to -6\" = \"#008C89\",\n                                  \"-6 to -4\" = \"#00AD7C\",\n                                  \"-4 to -2\" = \"#72CA5C\",\n                                  \"-2 to 0\" =\"#D2DE32\",\n                                  \"0 to 2\"=\"#E36588\",\n                                  \"2 to 4\"=\"#9D224E\",\n                                  \"4 to 6\"=\"#7B0033\",\n                                  \"6 to 8\"= \"#59001B\"))\n\np1021\n\n\n\nFacet plot\nIn this section the base plot for the facet plot is generated. Each facet shows the line from all countries in the back in light pink. This is to allow the viewer to make comparisons between the trend of a certain country with the rest of the countries.\n\n\nfacet <-ggplot(data2, aes(TIME_PERIOD, OBS_VALUE)) + \n  geom_line(data = data2a, aes(TIME_PERIOD, OBS_VALUE, group= geo), colour =\"#FFD2F2\") +\n  geom_line() + \n  facet_wrap(~geo_names)\n\nfacet\n\n\n\nPlot text\nIn this piece of code the axes labels and the title is added to the graph.\n\n\nfacet<-facet +\n  labs(\n    x = \"Year\",\n    y = \"Gender Pay Gap\",\n    title = \"Evolution of the Gender Pay Gap between 2010 and 2021\"\n  )\n\nfacet\n\n\n\nTheme specification\nIn this section the theme specification is performed for the facet graph. The colours used are taken from the same colour scale used for the map graph to make them aesthetically compatible. The ticks on the x axis have been rotated with an angle of 45 degrees to avoid overlap of the labels.\n\n\nfacet <-facet+\n  theme( panel.background = element_rect(\"#FFFFDD\"),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title = element_text(family = \"Roboto Condensed\", colour = \"#016A70\"),\n    axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1, margin = margin(10,0,10,0)),\n    title = element_text(family = \"Roboto Condensed\", colour = \"#33201F\",  face = \"bold\", margin = margin(10,0,10,0)),\n    strip.background=element_rect(fill=\"#D2DE32\"),\n    strip.text = element_text(family = \"Roboto Condensed\", colour = \"#33201F\"),\n    plot.margin = margin(10,10,10,10) )\nfacet\n\n\n\nCombining graphs\nIn this section the map graph and the facet graph are combined using the package ‘patchwork’. Also, the widths of the plots are adjusted to give the facet plot more space.\n\n\np4<-p1021+facet\np4<-p4+plot_layout(widths = c(5,7))\n\n\nGraph text\nThis piece of code adds the title, subtitle and caption to the graph. It also includes theme specification of the combined graph. The graph shown below is the final version of the graph improvement.\n\n\np4<-p4+\n  plot_annotation(\n    title= \"The Gender Pay Gap between 2010 and 2021\",\n    subtitle = \"Difference between average gross hourly earnings of male and female employees as % of male gross earnings\",\n    caption = \"Iceland, Norway, Switzerland: non_EU countries and Ireland, Greece: data not available\",\n    theme= theme(plot.title =  element_text(\n      family = \"Roboto Condensed\", colour = \"#016A70\", face = \"bold\", size = 20, hjust = 0.14),\n        plot.title.position = \"plot\",\n        plot.subtitle = element_text(family = \"Roboto Condensed\", colour = \"#33201F\",margin=margin(0,0,30,0), hjust = 0.19),\n        plot.caption =  element_text(family = \"Roboto Condensed\", colour = \"#33201F\"),\n      plot.margin =margin(10,0,10,0)))\n\np4\n\n\n\n\n\n\n",
    "preview": "projects/2023/100514861/100514861_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1872
  },
  {
    "path": "projects/2023/100517886/",
    "title": "The Growth of the Oil Industry",
    "description": "Replication of a graph from El Orden Mundial which aims to represent the\nevolution of oil production since 1910.",
    "author": [
      {
        "name": "Sara Cristina Herranz-Amado",
        "url": {}
      }
    ],
    "date": "2024-01-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReflecting on the original visualization\nCleaning the data\nGraph replication\nAddressing some issues\n\n\nAlternative visualizations\n\nIntroduction\nOn September 28, 2023, El Orden Mundial, a digital independent media focused on high-quality and in-depth international analysis, published the article ¿Cerca del peak oil? Así ha crecido la producción de petróleo en el último siglo, which would translate as Approaching Peak Oil? This is how oil production has grown in the last century. The author of the visualization and the article is Álvaro Merino.\nThis report aims to discuss this graphic considering some issues, such as the information it intends to show, the general characteristics and strengths of this type of graphic, the necessary steps to built a replica using R and some points of improvements, proposing a couple of graph alternatives.\nReflecting on the original visualization\nA stream graph is a type of stacked area chart. It represents the evolution of a numeric variable (Y axis) following another numeric value (X axis), for several groups with different colors. Areas are usually displayed around a central axis, and edges are rounded to give a flowing and organic shape. These graphs are good to study the relative proportions of the whole, but they are bad to study the evolution of each individual group.\nFor the current case, and as the title of the visualization suggests, the author was interested in analyzing the overall distribution of the different countries within the whole context of oil producer countries, rather than the detailed changes of each specific country. However, although this can be seen in the original plot below, it becomes way more clear when analyzing the replication process replication. We will delve further into this in the corresponding section.\nFinally, we would like to highlight some positive and negative aspects of the original plot. Regarding the positives, the chosen format is quite striking and appropriate for representing the intended information. The color grouping, not only by country but also changing the shade by region, facilitates the assimilation of the data.\nHowever, concerning the areas for improvement that we took into account when selecting this graph for the final project, we primarily emphasize the amount of text that appeared, as it hindered the readability of the graph. Likewise, the reservoir map was too small and could have appeared as a separate graph to complement it, as it also lacks a country-wise division for easier interpretation. This graph was not included in the replication because we did not have the data for it and we were not able to find it. Finally, the percentages at the end of the represented streams were not very clear regarding what they represented (whether they referred to the total for that year or the overall total).\nOriginal graph\n\n# Loading libraries\nlibrary(readxl)\nlibrary(tidyverse)\nlibrary(ggstream)\n\n\nCleaning the data\nThe article collected data from the Statistical Review of World Energy from the Energy Institute. Specifically, the data used for the replication was that published in XSLX panel format in Consolidated Dataset - Panel Format. Therefore, we started by uploading the data base, deleting unnecessary columns and NAs from the main variable (oilprod_kbd):\n\n\ndata <-  read_xlsx(path = \"Panel format.xlsx\", sheet = 1, range = \"A1:M7212\")\n\ndata <- data |>\n  select(-c(OPEC:CIS))\n\npanel <- data |> \n  filter(!is.na(oilprod_kbd)) \n\n\nThen, we organized the countries. First, a vector including the countries that needed to appear explicitly in our graph was created, which was also used to create a new data frame where all these countries appeared. We then filtered the original database to select the undesired countries and aggregated them by region. This approach allowed us to assign the name of the region to the aggregated data. Finally, we merged the two data frames into a new one, panel_c.\n\n\ncountries <- c(\"Australia\", \"China\", \"Indonesia\", \"Norway\", \"Russian Federation\", \n               \"USSR\", \"United Kingdom\", \"Brazil\", \"Venezuela\", \"Mexico\", \n               \"Canada\", \"US\", \"Saudi Arabia\", \"Iran\", \"Kuwait\", \"Iraq\", \"Libya\", \n               \"United Arab Emirates\", \"Nigeria\", \"Other Africa\", \n               \"Other Asia Pacific\", \"Other CIS\", \"Other Caribbean\", \n               \"Other Eastern Africa\", \"Other Europe\", \"Other Middle Africa\", \n               \"Other Middle East\", \"Other Northern Africa\", \n               \"Other S. & Cent. America\", \"Other South America\", \n               \"Other Western Africa\")\n\n# Filtering data by country of interest\npanel_a <-  panel |>\n  group_by(Region, Country) |> \n  filter(Country %in% countries) |> \n  mutate(Region = if_else(Country == \"Australia\", \"Oceania\", Region)) |> \n  select(-c(pop, ISO3166_alpha3, ISO3166_numeric, SubRegion, oilprod_mt)) \n\n  \n# Filtering data by countries that are not of our interest and aggregating them \npanel_b <- panel |> \n  filter(!Country %in% countries) |> \n  group_by(Year, Region) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop') |> \n  mutate(Country = Region) |> \n  select(Country, everything()) |>\n  filter(!is.na(Region)) |> \n  arrange(Country) \n\n# Combining both data frames into a new one\npanel_c <- bind_rows(panel_a, panel_b)\n\n\nOnce panel_c was generated, we moved on to refining the regional variables. To achieve this, we first named six different vectors after the main regions, which included the countries from panel_b (it is worth remembering that these countries were labeled according to the region they belonged to, rather than their individual country names). Next, we created individual data frames for each region. In these, we aggregated the oil production by year, presenting them as “Other -said continent-” in the resulting data frame. Finally, a new data frame, panel_d, was formed by merging all the individual region data frames.\n\n\n# Vectors for main regions\nasia <- c(\"Asia Pacific\", \"Other Asia Pacific\")\nafrica <-  c(\"Africa\", \"Other Africa\", \"Other Eastern Africa\", \"Other Middle Africa\", \n             \"Other Northern Africa\", \"Other Western Africa\")\nmiddle_east <-  c(\"Middle East\", \"Other Middle East\")\neurope <- c(\"Europe\", \"Other Europe\")\namerica <- c(\"Other Caribbean\", \"Other S. & Cent. America\", \"Other South America\", \n             \"S. and Cent. America\")\ncis <- c(\"CIS\", \"Other CIS\")\n\n\n# Data frame for each region\nasia <- panel_c |>\n  filter(Country %in% asia) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% asia, \"Other Asia\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\nafrica <- panel_c |>\n  filter(Country %in% africa) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% africa, \"Other Africa\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\nmiddle_east <- panel_c |>\n  filter(Country %in% middle_east) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% middle_east, \"Other Middle East\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\neurope <- panel_c |>\n  filter(Country %in% europe) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% europe, \"Other Europe\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\namerica <- panel_c |>\n  filter(Country %in% america) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% america, \"Other South America\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\ncis <- panel_c |>\n  filter(Country %in% cis) |> \n  group_by(Year, Country) |> \n  mutate(Country = if_else(Country %in% cis, \"Other CIS\", Country)) |> \n  arrange(Year) |> \n  summarise(oilprod_kbd = sum(oilprod_kbd), .groups = 'drop')\n\n# Data frame merging the region ones \npanel_d <-  bind_rows(asia, africa, middle_east, europe, america, cis)\n\npanel_d <- panel_d |> \n  mutate(Region = Country) |> \n  select(Country, Year, Region, everything())\n\n\nThe final data frame was formed by combining panel_d and panel_a. Some name adjustments were implemented to streamline the existing data, and the variables Region and Country were organized in the order observed in the original graph.\n\n\n# Final data frame \npanel_f <- bind_rows(panel_d, panel_a)\n\npanel_f <- panel_f |> \n  filter(!is.na(Region)) |> \n  mutate(Region = if_else(Region == \"Other Europe\", \"Europe\", Region)) |> \n  mutate(Region = if_else(Region == \"Other Asia\", \"Asia\", Region)) |> \n  mutate(Region = if_else(Region == \"Asia Pacific\", \"Asia\", Region)) |> \n  mutate(Region = if_else(Region == \"Other Middle East\", \"Middle East\",\n                          Region)) |> \n  mutate(Region = if_else(Region == \"Other Africa\", \"Africa\", Region)) |> \n  mutate(Region = if_else(Region == \"Other South America\", \"S. & Cent. America\",\n                          Region)) |>   \n  mutate(Region = if_else(Region == \"Other CIS\", \"CIS\", Region)) |> \n  arrange(Region, Country) \n\n# To determine the desired order of appearance for the regions in the graph\npanel_f$Region <- factor(panel_f$Region, levels = c(\"Oceania\", \"Asia\", \"Europe\", \n                                                    \"CIS\", \"S. & Cent. America\",\n                                                    \"North America\", \"Middle East\",\n                                                    \"Africa\"))\n\npanel_f$Country <- factor(panel_f$Country, levels = c(\"Australia\", \"Indonesia\", \n                                                      \"China\", \"Other Asia\", \n                                                      \"United Kingdom\", \"Norway\", \n                                                      \"Other Europe\", \"USSR\", \n                                                      \"Russian Federation\", \n                                                      \"Other CIS\", \"Brazil\", \n                                                      \"Venezuela\",\n                                                      \"Other South America\", \n                                                      \"Mexico\", \"Canada\", \"US\",\n                                                      \"Saudi Arabia\", \"Iran\",\n                                                      \"Kuwait\", \"Iraq\", \n                                                      \"United Arab Emirates\", \n                                                      \"Other Middle East\", \"Libya\", \n                                                      \"Nigeria\", \"Other Africa\"))\n\npanel_f <- \n  panel_f |> \n  arrange(Country, Region)\n\n\nPanel_f was the data frame ultimately used for creating a replica of the graph. However, we encountered certain challenges with the data, such as dealing with missing data from 1900 to 1965 and the distribution peculiarities of Russia, which consisted of two distinct observation groups (USSR and Russian Federation). These impacted the representation of the data. In section “Addressing some issues”, after presenting the definitive graph replication, we discuss the proposed adjustments and the reasons they were ultimately discarded.\nGraph replication\nWe began by defining certain aesthetic aspects and later combined them all using ggplot. First, we proceeded to define those related to colors, scales, axes, background, key and other lines in the graph.\n\n\n# Colors\nmycolors <-  c(\"#08e7a7\",\"#33a4a1\", \"#2bb8b9\", \"#6ad3d0\", \"#d86a6f\", \"#be3e44\", \n               \"#a60400\", \"#e78b71\", \"#ca664a\", \"#b1583f\", \"#e9daa1\", \"#e6cc75\",\n               \"#dab330\", \"#9263e1\", \"#7546be\", \"#4f2991\", \"#e997e8\", \"#e079db\",\n               \"#d168c7\",  \"#c453b0\", \"#ad358d\", \"#9a2366\", \"#89c257\", \"#68a03f\", \n               \"#59882c\") \n\ncolors <- scale_fill_manual(values = mycolors)\n\n# Scales\nscale <- c(scale_x_continuous(name = NULL, limits = c(1961, 2022), \n                              breaks = seq(from = 1970, to = 2020, by = 10), \n                              expand = expansion(0)), \n           scale_y_continuous(name = NULL, labels = NULL, position = \"right\",\n                              expand = expansion(add = c(5000, 5500)))) \n\n# Axes \naxes <- theme(axis.line.y = element_blank(), axis.ticks.y = element_blank()) \n\nticks <- theme(axis.ticks.x = element_line(color = \"gray40\"), \n               axis.ticks.length.x = unit(0.15, \"cm\"))\n\n# Background and key\ntheme <- theme(panel.grid.major = element_blank(), \n               panel.grid.minor = element_blank(),\n               legend.position = \"none\", \n               plot.caption = element_text(hjust = 0, color = \"gray20\"))\n\n# Arrows and lines\narrows <- c(geom_curve(aes(x = 2013, y = 52000, xend = 2019, yend = 52000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 1994, y = 44000, xend = 1997, yend = 38000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2003, y = -48500, xend = 2008, yend = -46000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01), \n            geom_curve(aes(x = 1973, y = -46000, xend = 1977, yend = -43000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_segment(aes(x = 1973, y = 38500, xend = 1973, yend = 36000),\n                         color = \"#08e7a7\", \n                         linewidth = 0.2),\n            geom_segment(aes(x = 1990, y = 19500, xend = 1990, yend = 24200),\n                         color = \"#a60400\", \n                         linewidth = 0.3),\n            geom_segment(aes(x = 1987, y = -28200, xend = 1987, yend = -39700),\n                         color = \"#9a2366\", \n                         linewidth = 0.2),\n            geom_vline(xintercept = c(1979, 2019), \n                      linetype = \"dashed\",\n                      color = \"white\", \n                      linewidth = 0.2))\n\n\nThen, we worked with the aesthetics involving text, such as annotation, labels, titles and subtitles.\n\n\n# Text font\nsysfonts::font_add_google(\"Fira Sans Condensed\")\nsysfonts::font_add_google(\"Fira Sans\")\n\n# Labels\nsubtitle <- expression(paste(bold(\"Producción histórica de petróleo hasta 2022\"), \n                             \" (barriles diarios)\"))\n\nlabels <-  labs(title = \"El crecimiento de la industria petrolera\", \n                subtitle = subtitle,\n                caption = \"\\n \\n Autora: Sara Herranz (2023). Fuente: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme <- theme(plot.title = element_text(family = \"Fira Sans Condensed\", \n                                               size = 14, \n                                               face = \"bold\"),\n                     plot.subtitle = element_text(family = \"Fira Sans Condensed\", \n                                                  size = 9.5, \n                                                  color = \"gray10\", face = \"bold\"), \n                     plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\n# Percentage annotations\n  # First, we compute the percentages\npanel_per <- panel_f |> \n  filter(Year == \"2022\") |> \n  mutate(percent = round((oilprod_kbd/(sum(oilprod_kbd)))*100)) |> \n  filter(percent > 2) |> \n  arrange(Country, Region) \n\n  # Second, we create the annotations\npercent_annotations <- \n  c(annotate(\"text\", x = 2020, y = 46500, size = 3,  label = paste(\"4%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 28000, size = 3,  label = paste(\"12%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 17500, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 14000, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = 6000, size = 3,  label = paste(\"6%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -4000, size = 3,  label = paste(\"19%\"), \n             color = \"grey2\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -17500, size = 3,  label = paste(\"13%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -25000, size = 3,  label = paste(\"4%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -28400, size = 3,  label = paste(\"3%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -32000, size = 3,  label = paste(\"5%\"), \n             color = \"grey20\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -36000, size = 3,  label = paste(\"4%\"), \n             color = \"grey6\",  family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -39500, size = 3,  label = paste(\"3%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2020, y = -47500, size = 3,  label = paste(\"5%\"), \n             color = \"grey6\", family = \"Fira Sans\", fontface = \"italic\"))\n\n# Text annotations\ntext_annotations <-  \n  c(annotate(\"text\", x = 2012, y = 51000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"En 2019, justo antes de la pandemia,\\n se alcanzó una producción récord\\n (95 millones)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1993, y = 44000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis financiera\\nasiática de 1997\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1972, y = -45000,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis del petróleo\\nde los 70 (guerra de\\nYom Kipur, 1973,\\nRev. iraní, 1979)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1979, y = 45000,  hjust = 0.5, vjust = 0.5, size = 2.5, \n             label = paste(\"1979:\\n 66 millones\"), \n             color = \"grey40\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 2002, y = -48500,  hjust = 1, vjust = 0.5, size = 3, \n             label = paste(\"Crisis financiera global de 2008\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1))\n\n# Country labels\ncountry_annotations <- \n  c(annotate(\"text\", x = 1971, y = 40000, size = 3, label = paste(\"Oceanía\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2011, y = 42000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2000, y = 35500, size = 3, label = paste(\"Indonesia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 38000, size = 3, label = paste(\"Resto Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 10, fontface = \"italic\"), \n    annotate(\"text\", x = 1995, y = 27300, size = 3, label = paste(\"R. Unido\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1995, y = 24500, size = 3, label = paste(\"Noruega\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 18000, size = 3, label = paste(\"Resto Europa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1974, y = 17000, size = 3, label = paste(\"URSS\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 23000, size = 3, label = paste(\"Rusia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2008, y = 13000, size = 3, label = paste(\"Resto CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2011, y = 10700, size = 3, label = paste(\"Brasil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\", srt = 15),\n    annotate(\"text\", x = 2005, y = 8100, size = 3, label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 4900, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = 1500, size = 3, label = paste(\"Canadá\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1996, y = -3300, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -13500, size = 3, label = paste(\"Arabia Saudi\"), \n             color = \"#9a2366\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1999, y = -19000, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -25000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", srt = -10, fontface = \"italic\"),\n    annotate(\"text\", x = 1988, y = -24300, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -29300, size = 3, label = paste(\"EAU\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 1990, y = -41000, size = 3, label = paste(\"Resto O. Próximo\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1993, y = -30400, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = -34400, size = 3, label = paste(\"Libia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = -40800, size = 3, label = paste(\"Resto África\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"))\n\n\nThe next version of the plot included these aesthetics. As mentioned earlier, what it represents is how the different proportions of each country relate to each other, rather than examining the specific changes of each group. Thus, the sense of flowing, curvy appearance and smooth transition is evident in this visualization.\nIt is also important to note that some changes were made to the data because we considered them essential. Firstly, ‘Other CIS’ was added to the data, and Libya was repositioned. In the original graph, Libya was included among the countries in the Middle East region, but we deemed it more appropriate to relocate it to Africa, as it is geographically situated there. On the other hand, ‘Other South America’ is not represented, even though it has sufficient data to be included.\n\n\nplot <- ggplot(data = panel_f) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_stream(type = \"mirror\", \n              bw = 0.56, \n              true_range = \"max_x\") + \n  colors + scale + axes + theme_minimal() + ticks +\n  labels + labelstheme + percent_annotations + \n  text_annotations + country_annotations + theme + arrows \n\nplot\n\n\n\nAddressing some issues\nAs seen in the previous graph and mentioned before, we encountered certain challenges with the data, such as handling missing data from 1900 to 1965 and addressing the distribution peculiarities of Russia, which consisted of two distinct observation groups (USSR and Russian Federation).\nDealing with missing data\nRegarding the first issue, Professor Iñaki suggested to include a 0 in the oilprod_kbd variable for the year 1910 in each country However, we managed to define a function that progressively reduced the value of the variable oilprod_kbd from its value in 1965 for each country until 0 in 1910. We opted for 15 instead of 0, as in the original idea, because, in reality, the distribution in the original graph tends toward zero but does not appear to reach that value.\nOn the other hand, after implementing this improvement, we recognized that its main flaw was that the data added to the variable ‘oilprod_kbd’ for each country did not adhere to the same distribution as the available oilprod_kbd data for each country. We attempted to devise a function that considered this existing distribution for each country between the years 1965-2022 (1975-2022 for Norway and 1985-2022 for the USSR and Other CIS) aiming for the newly generated values for the period 1910-1965 to follow the same distribution. Said function worked by applying the ecdf (Empirical Cumulative Distribution Function) to the data distribution. Unfortunately, despite several attempts, we couldn’t make it work. Given that the complexity of the mentioned function surpasses the requirements of this course, we decided to adhere to the solution depicted below, even though it does not entirely align with the original graph.\n\n\n# Adding the necessary rows (from 1910 to 1964)\nrows <- tibble(Country = rep(c(\"Australia\", \"Indonesia\", \"China\", \"Other Asia\", \n                  \"United Kingdom\", \"Norway\", \"Other Europe\", \"USSR\",\n                  \"Russian Federation\", \"Other CIS\",  \"Brazil\", \n                  \"Venezuela\", \"Other South America\", \"Mexico\", \"Canada\", \n                  \"US\", \"Saudi Arabia\", \"Iran\", \"Kuwait\", \"Iraq\", \n                  \"United Arab Emirates\", \"Other Middle East\", \"Libya\", \n                  \"Nigeria\", \"Other Africa\"), each = 55),\n               Year = rep(seq(1910, 1964), length.out = 1375),\n               Region = rep(c(\"Oceania\", \"Asia\", \"Asia\", \"Asia\", \"Europe\", \"Europe\",\n                 \"Europe\", \"CIS\", \"CIS\", \"CIS\", \"S. & Cent. America\", \n                 \"S. & Cent. America\", \"S. & Cent. America\", \n                 \"North America\", \"North America\", \"North America\",\n                 \"Middle East\", \"Middle East\", \"Middle East\",\n                 \"Middle East\", \"Middle East\", \"Middle East\", \"Africa\", \n                 \"Africa\", \"Africa\"), each = 55), \n               oilprod_kbd = 15)\n\nnorway_rows <- tibble(Country = rep(\"Norway\", each = 6),\n                      Year = seq(1965, 1970),\n                      Region = rep(\"Europe\", each = 6),\n                      oilprod_kbd = 15)\n\nrf_rows <- tibble(Country = rep(\"Russian Federation\", each = 20),\n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 15)\n\noc_rows <- tibble(Country = rep(\"Other CIS\", each = 20), \n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 15)\n\n# Merging the new data together and then binding it to the original one\nrows <- bind_rows(rows, norway_rows, rf_rows, oc_rows)\n\npanel_g <- rbind(panel_f, rows) \n\npanel_g <- panel_g |> \n  arrange(Country, Year) |> \n  mutate(Year = as.numeric(Year))\n\n# Function to interpolate oilprod_kbd\ninterp_values <- function(country_df) {\n  approx(\n    x = c(1965, 1910), \n    y = c(country_df$oilprod_kbd[country_df$Year == 1965], 15),\n    xout = country_df$Year\n  )$y\n}\n\n# Applying the function to each country\ndf_interp <- panel_g |> \n  group_by(Country) |> \n  nest() |> \n  mutate(oilprod_kbd_interp = map(data, interp_values)) |> \n  unnest(cols = c(data, oilprod_kbd_interp))\n\n# Merging the interpolated data and the original data \nalternative <- full_join(panel_g, df_interp, by = c(\"Year\", \"Country\"))\n\n# Arranging and filtering the data \nalternative_f <- alternative |> \n  arrange(Country, Year) |> \n  select(-c(oilprod_kbd.x, Region.x)) |> \n  mutate(oilprod_kbd.y = case_when(\n    Country == \"Norway\" & Year > 1975 ~ oilprod_kbd.y,\n    (Country == \"Russian Federation\" | Country == \"CIS\") & Year > 1985 ~ oilprod_kbd.y,\n    Country != \"Norway\" & Country != \"Russian Federation\" \n    & Country != \"CIS\" & Year > 1965 ~ oilprod_kbd.y,\n    TRUE ~ oilprod_kbd_interp))\n\n\nOnce the new data frame was set, we defined some adjustments to fit the new data.\n\n\n# Adjusting the scale to fit the new data\nscale1 <- c(scale_x_continuous(name = NULL, limits = c(1910, 2022), \n                              breaks = seq(from = 1920, to = 2020, by = 10), \n                              expand = expansion(0)),\n            scale_y_continuous(name = NULL, labels = NULL,\n                               expand = expansion(add = c(5000, 5500)))) \n\n# Text annotations\nlabels1 <-  labs(caption = \"\\nAutora: Sara Herranz (2023). Fuente: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme1 <- theme(plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\ntext_annotations1 <- c(\n    annotate(\"text\", x = 1910, y = 51000,  hjust = 0, vjust = 0.5, size = 3.8, \n             label = paste(\"Producción histórica de petróleo hasta 2022\"), \n             color = \"grey20\", family = \"Fira Sans\"), #subtitle\n    annotate(\"text\", x = 1959, y = 51000,  hjust = 0, vjust = 0.5, size = 3.6, \n             label = paste(\" (barriles diarios)\"), \n             color = \"grey30\", family = \"Fira Sans\"), #subtitle\n    annotate(\"text\", x = 1910, y = 55000,  hjust = 0, vjust = 0.5, size = 5, \n             label = paste(\"El crecimiento de la industria petrolera\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"bold\"), #title\n    annotate(\"text\", x = 2011, y = 51000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"En 2019, justo antes de la pandemia,\\n se alcanzó una producción récord\\n (95 millones)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1993, y = 42000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis financiera\\nasiática de 1997\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1967, y = -40000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis del petróleo de los 70\\n (guerra de Yom Kipur, 1973,\\nRev. iraní, 1979)\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1950, y = -25000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Irán, Irak, Kuwait, Arabia Saudí y\\nVenezuela fundan la Organización\\nde Países Exportadores de\\nPetróleo (OPEP) en 1960\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1933, y = 19000,  hjust = 0.5, vjust = 0.5, size = 2.8, \n             label = paste(\"El automóvil y la bombilla eléctrica\\nimpulsaron la industria del petróleo a\\nprincipios del siglo XX, hasta\\nentonces limitada al queroseno\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 1979, y = -37000,  hjust = 0.5, vjust = 0.5, size = 2.3, \n             label = paste(\"1979:\\n 66 millones\"), \n             color = \"grey40\", family = \"Fira Sans\", lineheight = 1),\n    annotate(\"text\", x = 2002, y = -50000,  hjust = 1, vjust = 0.5, size = 2.8, \n             label = paste(\"Crisis financiera global de 2008\"), \n             color = \"grey20\", family = \"Fira Sans\", lineheight = 1))\n\n# Arrows and lines\narrows1 <- c(geom_curve(aes(x = 1951, y = -23000, xend = 1960, yend = -18000), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2012, y = 52000, xend = 2019, yend = 48500), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 1994, y = 42000, xend = 1997, yend = 36500), \n                       colour = \"grey40\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2003, y = -50000, xend = 2008, yend = -43000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01), \n            geom_curve(aes(x = 1968, y = -40000, xend = 1973, yend = -31000), \n                       colour = \"grey40\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = 0.3, linewidth = 0.01),\n            geom_segment(aes(x = 1973, y = 36000, xend = 1973, yend = 29000),\n                         color = \"#08e7a7\", \n                         linewidth = 0.2),\n            geom_segment(aes(x = 1990, y = 21800, xend = 1990, yend = 19300),\n                         color = \"#a60400\", \n                         linewidth = 0.3),\n            #geom_segment(aes(x = 1987, y = -28200, xend = 1987, yend = -39700),\n                         #color = \"#9a2366\", \n                         #linewidth = 0.2),\n            geom_vline(xintercept = c(1979, 2019), \n                      linetype = \"dashed\",\n                      color = \"white\", \n                      linewidth = 0.2))\n\n\n\n\n# Country labels\ncountry_annotations1 <- \n  c(annotate(\"text\", x = 1971, y = 38000, size = 3, label = paste(\"Oceanía\"), \n             color = \"grey10\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2009, y = 39000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 1994, y = 32100, size = 3, label = paste(\"Indonesia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 35500, size = 3, label = paste(\"Resto Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 13, fontface = \"italic\"), \n    annotate(\"text\", x = 1995, y = 26400, size = 3, label = paste(\"R. Unido\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1995, y = 23500, size = 3, label = paste(\"Noruega\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 16000, size = 3, label =paste(\"Resto\\nEuropa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1974, y = 17000, size = 3, label = paste(\"URSS\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = 23000, size = 3, label = paste(\"Rusia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2010, y = 15370, size = 3, label = paste(\"Resto CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", srt=15),\n    annotate(\"text\", x = 2011, y = 13500, size = 3, label = paste(\"Brasil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface=\"italic\", srt=15),\n    annotate(\"text\", x = 2005, y = 10000, size = 3, label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 7000, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = 3800, size = 3, label = paste(\"Canadá\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1996, y = -3300, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1960, y = -1000, size = 3, label = paste(\"EE.UU.\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2005, y = -12500, size = 3, label = paste(\"Arabia Saudi\"), \n             color = \"#9a2366\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2004, y = -19000, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1975, y = -15800, size = 3, label = paste(\"Irán\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -23000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1966, y = -12500, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = -29000, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1976, y = -22700, size = 3, label = paste(\"Irak\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2007, y = -27500, size = 3, label = paste(\"EAU\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 2006, y = -29600, size = 3, label=paste(\"Resto O.Próximo\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", srt = -10),\n    annotate(\"text\", x = 1992, y = -27400, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2008, y = -34600, size = 3, label = paste(\"Libia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2010, y = -38800, size = 3, label = paste(\"Resto\\nÁfrica\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\", \n             lineheight = 1))\n\n\n\n\nplot2 <- ggplot(data = alternative_f) +\n  aes(x = Year, y = oilprod_kbd.y, fill = Country) +\n  geom_stream(type = \"mirror\", \n              bw = 0.56,\n              true_range = \"max_x\")  +\n  colors + scale1 + axes + theme_minimal() + ticks +\n  labels1 + labelstheme1  + \n  text_annotations1 + country_annotations1 + theme + arrows1 \n\nplot2\n\n\n\nWhile we couldn’t replicate the exact shape and distribution of the missing values from the original plot, we believe this serves as a commendable alternative to our initial visualization attempt. Furthermore, as mentioned earlier, geom_stream is useful for studying the relative proportion of the whole. This is evident in the updated graph, where the representation of the available data appears more accurate compared to the original plot.\nIt also should be noted that certain aesthetic aspects implemented in this replica could not be preserved due to the alteration in the data distribution. This is evident in the percentages at the end; by modifying the joint data distribution, the values of the dependent variable in the last year decrease, leaving little room to include these labels as they appear in the original graph.\nUSSR and Russian Federation\nThe USSR and Russian Federation observations concerned us for two reasons. Firstly, despite having data only until 1984 for the USSR, the characteristics of geom_stream extended the data in the opposite direction to the existing data, distorting the data distribution. On the other hand, we wanted to compare the number of barrels produced (oilprod_kbd) for the US and USSR/Russian Federation in different years, given that in the original graph, the thickness of these streams appeared similar. Upon filtering the data, we were able to verify that the data distributions were similar, despite the graphical representation showing significant differences.\nThus, concerning the data from the USSR and the Russian Federation, we aimed to combine the observations of both countries into a single entity to examine how it influenced the data or whether the distribution resembled that of the original graph. Therefore, we recoded the observations of the USSR so that all of them appeared as the Russian Federation.\n\n\n# Running some tests to compare USSR and US\ntest <- panel_f |> \n  filter(Country == c(\"USSR\", \"US\")) |> \n  group_by(Year) \n\n\n# Merging USSR and Russian Federation into one observation\npanel_h <- \n  panel_f |> \n  arrange(Country, Region) |> \n  mutate(Country = if_else(Country == \"USSR\", \"Russian Federation\", Country))\n\n\nAfter establishing the new data frame, we implemented several adjustments to align with the updated data. Some aesthetics are missing as we solely aimed to observe how the data was distributed. However, as illustrated in the graph below, the distribution of the resulting data deviates from the anticipated outcome. Consequently, we made the decision to discard it.\n\n\nmycolors2 <-  c(\"#08e7a7\",\"#33a4a1\", \"#2bb8b9\", \"#6ad3d0\", \"#d86a6f\", \"#be3e44\", \n                \"#a60400\", \"#e78b71\", \"#b1583f\", \"#e9daa1\", \"#e6cc75\", \"#dab330\",\n                \"#9263e1\", \"#7546be\", \"#4f2991\", \"#e997e8\", \"#e079db\", \"#d168c7\",\n                \"#c453b0\", \"#ad358d\", \"#9a2366\", \"#89c257\", \"#68a03f\", \"#59882c\") \n\ncolors2 <- scale_fill_manual(values = mycolors2)\n\n\nplot3 <- ggplot(data = panel_h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_stream(type = \"mirror\", \n    bw = 0.56, \n    true_range = \"max_x\") + \n  colors2 + labels + scale + axes +\n  theme_minimal() +  theme + labelstheme + ticks \n\nplot3\n\n\n\n\nAlternative visualizations\nTo carry out the proposal for alternative visualizations, we took into consideration the original author’s objective, which was to depict the historical evolution of oil production for the entire oil industry. However, we also aimed to shift the focus to clearly visualize the regional and country-specific contributions. Both aspects were more apparent in the original stream graph. However, they were not as evident in the replication we conducted because the stream graph is useful for gaining a general understanding of the whole structure without getting bogged down by intricate details of each part’s evolution, but not so much for depicting the individual contributions.\nTherefore, in order to keep the intention of the original author, we decided to make an alternative representation using a stacked area chart, and also to combine it with faceting techniques. On one hand, faceting generates small multiples each showing a different subset of the data. It is a powerful tool for exploratory data analysis: one can rapidly compare patterns in different parts of the data and see whether they are the same or different.\nOn the other hand, similarly to the stream graph, a stacked area chart displays the evolution of the value of several groups on the same graphic. The values of each group are displayed on top of each other, allowing to check the evolution of both the total of a numeric variable and the importance of each group. Thus, as it can be seen in the graph below, it is easier to observe variations in the contribution of each category. Additionally, the mentioned appearance resembles better the original graph, although it does not have the mirror aesthetic, since the original visualization not only displays the evolution of all the countries, but also the changes in the individual categories.\nReturning to the features of the faceting employed, we have provided two complementary visualizations alongside the stream graph. The first faceting allows us to observe the contribution of each region to the total barrel production of oil. Additionally, it utilizes the same scale for the dependent variable (oilprod_kbd), enabling visual comparisons between regions. However, in the second faceting, we employ “scales =”free_y”“, which allows for representing different scales for each of the plots, thereby enabling the visualization of the individual evolution of oil production for each region.\nIt was necessary to make some considerations regarding the data used for the following graphs. Firstly, we employed the information available in the original database (after cleaning it to meet our requirements, of course), and we discarded the database that we created afterwards, which included information for oilprod_kbd in the period 1910-1964. The main reason for this decision was our desire to work with accurate and reliable data. Additionally, since the distribution of the new data created by the function we had defined did not align with the distribution of the existing data, it did not seem appropriate to use them for the alternative visualization. Furthermore, given that the data in the original database included separate observations for the USSR and the Russian Federation, we retained the same data frame for this enhancement. Consequently, due to the nature of the graph, which stacks areas on top of the previous ones, there is a gap in the representation of both observations in 1985. In order to adsress this we added 0 to the oilprod_kbd variable for the not available years of USSR and Other CIS (1985-2022) and Russian Federation (1965-1984). This worked perfectly fine. As a side note, we attempted to make the same adjustment in the visualizations that utilized geom_stream. However, due to the characteristics of the streamgraph, the differences were negligible.\nOn the other hand, we also modified some aesthetics, for instance, reducing the amount of text displayed to avoid overloading the graph.\n\n\n# Adding the necessary rows to Russian Federation, Other CIS and USSR\np1 <- tibble(Country = rep(\"Russian Federation\", each = 20),\n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 0)\n\np2 <- tibble(Country = rep(\"Other CIS\", each = 20), \n                  Year = seq(1965, 1984),\n                  Region = rep(\"Other CIS\", each = 20),\n                  oilprod_kbd = 0)\n\np3 <- tibble(Country = rep(\"USSR\", each = 38), \n                  Year = seq(1985, 2022),\n                  Region = rep(\"Other CIS\", each = 38),\n                  oilprod_kbd = 0)\n\n# Merging the new data together and then binding it to the original one\npreb <- bind_rows(p1, p2, p3)\n\nenhan1 <- rbind(panel_f, preb) \n\n\n\n\n# Labels\nsubtitle2 <- expression(paste(bold(\"Historical oil production up to 2022 \"), \n                             \"(barrels per day)\"))\n\nlabels2 <-  labs(title = \"The growth of the oil industry\", subtitle = subtitle2,\n                caption = \"\\n \\n Author: Sara Herranz (2023). Reference: Energy Institute Statistical Review of World Energy (2023)\") \n\nlabelstheme2 <- theme(plot.title = element_text(family = \"Fira Sans Condensed\", \n                                               size = 15, \n                                               face = \"bold\"),\n                     plot.subtitle = element_text(family = \"Fira Sans Condensed\", \n                                                  size = 11, \n                                                  color = \"gray10\", face = \"bold\"), \n                     plot.caption = element_text(family = \"Fira Sans Condensed\"))\n\n# Scale\nscale2 <- c(scale_x_continuous(name = NULL, limits = c(1965, 2022), \n                              breaks = seq(from = 1970, to = 2020, by = 10), \n                              expand = expansion(0)), \n           scale_y_continuous(name = NULL, labels = NULL, position = \"right\",\n                              expand = expansion(add = c(5000, 5500)))) \n\n# Text_annotations\ntext_annotations2 <-  \n  c(annotate(\"text\", x = 2018, y = 98300,  hjust = 0.5, vjust = 0.5, size = 3, \n             label = paste(\"2019:\\n record production\\n (95 million)\"), \n             color = \"grey40\", family = \"Fira Sans\"),\n      annotate(\"text\", x = 1979, y = 68200,  hjust = 0.5, vjust = 0.5, size = 3, \n             label = paste(\"1979:\\n 66 millions\"), \n             color = \"grey40\", family = \"Fira Sans\"))\n\n# Country labels\ncountry_annotations2 <- \n  c(annotate(\"text\", x = 1971, y = 60000, size = 3, label = paste(\"Oceania\"), \n             color = \"#08e7a7\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 77000, size = 3, label = paste(\"China\"), \n            color = \"white\", family = \"Fira Sans\", srt = 3, fontface = \"italic\"), \n    annotate(\"text\", x = 2006, y = 83000, size = 3, label = paste(\"Indonesia\"), \n             color = \"#33a4a1\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 74000, size = 3, label = paste(\"Other Asia\"), \n             color = \"white\", family = \"Fira Sans\", srt = 7, fontface = \"italic\"), \n    annotate(\"text\", x = 2001, y = 63300, size = 3, label = paste(\"UK\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2001, y = 60800, size = 3, label = paste(\"Norway\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1999, y = 53000, size = 3, label = paste(\"Other Europe\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1977, y = 48000, size = 3, label = paste(\"USSR\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1990, y = 46000, size = 3, label = paste(\"Russia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"), \n    annotate(\"text\", x = 2010, y = 65000, size = 3, label = paste(\"Other CIS\"),\n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2006, y = 54000, size = 3, label = paste(\"Brazil\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\", srt = 9),\n    annotate(\"text\", x = 2006, y = 51000, size = 3, srt = 9, \n             label = paste(\"Venezuela\"), \n             color = \"#6f4e37\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 30500, size = 3, label = paste(\"México\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 28000, size = 3, label = paste(\"Canada\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1984, y = 23000, size = 3, label = paste(\"US\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2015, y = 31000, size = 3, label = paste(\"Saudi Arabia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 24800, size = 3, label = paste(\"Iran\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 21000, size = 3, label = paste(\"Kuwait\"), \n             color = \"white\", family = \"Fira Sans\", srt = 5, fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 17000, size = 3, label = paste(\"Iraq\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2016, y = 13000, size = 3, label = paste(\"UAE\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),  \n    annotate(\"text\", x = 2016, y = 9800, size = 3, label = paste(\"Other M. East\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 1998, y = 7100, size = 3, label = paste(\"Nigeria\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2001, y = 5500, size = 3, label = paste(\"Lybia\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"),\n    annotate(\"text\", x = 2000, y = 2300, size = 3, label = paste(\"Other Africa\"), \n             color = \"white\", family = \"Fira Sans\", fontface = \"italic\"))\n\narrows2 <- c(geom_curve(aes(x = 1974, y = 55000, xend = 1971, yend = 58000), \n                       colour = \"#08e7a7\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2004, y = 77000, xend = 2004, yend = 81000), \n                       colour = \"#33a4a1\",\n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2002, y = 58700, xend = 2001, yend = 55100), \n                       colour = \"#a60400\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01),\n            geom_curve(aes(x = 2012, y = 60000, xend = 2010, yend = 63500), \n                       colour = \"#b1583f\", \n                       arrow = arrow(length = unit(0.01, \"npc\"), type = \"open\"),\n                       curvature = -0.3, linewidth = 0.01))\n\n\n\n\n# Geom_area: \nalt_plot <- ggplot(data = enhan1) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area() +\n  geom_vline(xintercept = c(1979, 2019), \n    linetype = \"dashed\", \n    color = \"white\", \n    linewidth = 0.2) + \n  colors + labels2 + scale2 + axes +\n  theme_minimal() +  theme + labelstheme2 + ticks +\n  text_annotations2 + country_annotations2 + arrows2\n\nalt_plot\n\n\n\nFor the faceting, we opted for facet_wrap paired with an area chart, since it is useful when dealing with a single variable having many levels and there is a desire to arrange the plots more efficiently in terms of space. To adjust the data, we computed the total production by region to arrange the facets accordingly. Following that, we made some adjustments to the scales and then proceeded to plot the graphs.\n\n\n# Creating new data frame ordering the data by the total oil production per region, \n  # in an ascending order\nh <- enhan1 |> \n  group_by(Region) |> \n  mutate(toil = sum(oilprod_kbd), \n         Region = case_when(\n           Country %in% c(\"Russian Federation\", \"Other CIS\") & Year < 1985 ~ \"CIS\",\n           Country == \"USSR\" & Year > 1984 ~ \"CIS\",\n           TRUE ~ Region)) |> # dealing with some NAs\n  ungroup() |> \n  arrange(toil)\n\nh$Region <- factor(h$Region, levels = c(\"Oceania\", \"Europe\", \"S. & Cent. America\", \n                                        \"Asia\", \"Africa\", \"CIS\", \"North America\",\n                                        \"Middle East\"))\n\n# Adjusting the scale of the plot\nscale3 <- c(scale_x_continuous(name = NULL, limits = c(1965, 2022), \n                               breaks = seq(from = 1975, to = 2020, by = 15), \n                               expand = expansion(0), position = \"bottom\"),\n            scale_y_continuous(name = NULL, \n                               position = \"left\")) \n\n\n\n\n# Facet 1. Plotting the data\nalt_plot2 <- ggplot(data = h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area(show.legend = FALSE) +\n  facet_wrap(facets = h$Region,\n             nrow = 5,\n             ncol = 2) + \n  colors + scale3 + axes + \n  theme_minimal() + labels2 + labelstheme2 + ticks + theme +\n  theme(panel.spacing.y = unit(2, \"lines\")) \n\nalt_plot2\n\n\n\n\n\n# Facet 2. Plotting the data\nalt_plot3 <- ggplot(data = h) +\n  aes(x = Year, y = oilprod_kbd, fill = Country) +\n  geom_area(show.legend = FALSE) +\n  facet_wrap(facets = h$Region,\n             nrow = 4,\n             ncol = 2,\n             scales = \"free_y\") + \n  colors + scale3 + axes + \n  theme_minimal() + labels2 + labelstheme + ticks + theme +\n  theme(panel.spacing.y = unit(2, \"lines\"))\n\nalt_plot3\n\n\n\n\n\n\n",
    "preview": "projects/2023/100517886/100517886_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1248
  },
  {
    "path": "projects/2023/100061715/",
    "title": "Unveiling Birth Clinical Practice in Spain: Mapping the Cesarian Sections and Birth Dynamics",
    "description": "Exploring the nuances of maternal healthcare in Spain through an augmented map,\nshowcasing original cesarean section rates alongside additional insights such\nas total births per autonomous community and cesarean rates adjusted for the\naverage maternal age.",
    "author": [
      {
        "name": "Celia Muñoz",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nBackground\nFirst steps\nAlternative visualisation\n\nBackground\nOver the past two decades, the global rate of caesarean sections (C-sections) has experienced a notable increase. While C-sections are a life-saving intervention when medically necessary, inappropriate procedures pose potential risks for both mothers and newborns.\nIn Spain, caesarean deliveries rank among the most prevalent surgical procedures, accounting for 22% of all deliveries in 2019. The aggressive nature of caesarean sections becomes particularly concerning when performed without medical justification, as such instances may be regarded as obstetric violence and contribute to gender discrimination.\nThe chart to replicate is found on the Ministry of Health’s website, as part of the indicators from the Minimum Basic Data Set (CMBD). This set comprises a record of all hospital admissions documented over the course of a year (2019 in this case) on a patient-level basis. For each patient, fundamental sociodemographic variables are gathered, and the hospital episode is encoded using international standards for the classification of diseases and procedures.\nC-section rate in Spain (2019), the original graphTo reproduce our graph, the original data on cesarean section rate can be downloaded from the same website. The dataset includes information for all autonomous communities regarding the total number of births in Spain, the age of the mother, the total number of births with a cesarean section, and the average age of mothers who underwent a cesarean section.\nFirst steps\nThe first step is to load the basic libraries and those specific for merging our data, generating maps, etc. Next, we load our original data and perform data cleaning to construct the cesarean section rate variable, which will be essential throughout the development.\n\n\n# Loading packages\nlibrary(tidyverse)\nlibrary(mapSpain)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(stringdist)\nlibrary(fuzzyjoin)\nlibrary(ggtext)\n\n\n\n\n# Adjusting locale settings\nmy_locale <- locale(decimal_mark = \",\", grouping_mark = \".\")\n\n\n# Reading data\nc_section <- read_delim(\"tasa_cesareas.csv\", \n                 skip = 10, \n                 delim = \";\",\n                 col_names = c(\"ccaa\", \"n_births\", \"births_hosp_stay\", \n                               \"birth_age\", \"n_c_section\", \"c_section_age\", \n                               \"c_section_hosp_stay\", \"c_section_rate\"),\n                 locale = my_locale)\n\n# Cleaning data and generating a new cesarea rate\nc_section <- c_section %>% \n  na.omit() %>% \n  filter(ccaa != \"Total Altas\") %>% \n  mutate(c_section_rate = (n_c_section / n_births) * 100)\n\nccaa <- c_section %>% \n  select(ccaa)\n\n\nNow that we have the data loaded and cleaned, we begin constructing our chart. In this case, as it is a map of Spain, we will use the mapSpain library, which allows us to visualize different geographical levels. In this case, we need the data at the level of autonomous communities.\nThere are several libraries for creating map-based graphics; however, most of them place the Canary Islands in their original location. This can be problematic when representing territories that are geographically distant from the general country area. Fortunately, mapSpain comes with the default fictitious location for the Canary Islands, commonly used in such cases.\n\n\n# Loading map data\nspain <- esp_get_ccaa()\n\n# Ploting the basic map\nggplot(spain) +\n  geom_sf()\n\n\n\n\n\n# Verifying that the names of the CCAA match to enhance the join.\nc_section <- c_section %>% \n  stringdist_join(\n    spain,\n    by = c(\"ccaa\" = \"ine.ccaa.name\"),\n    method = \"jaccard\",\n    mode = \"left\",\n    max_dist = 0.3\n  ) %>% \n  mutate(\n    ine.ccaa.name = if_else(ccaa == \"Rioja (La)\", \"Rioja, La\", ine.ccaa.name)) \n\n# Keeping the main variables\nc_section <- c_section %>% \nselect(ccaa, ine.ccaa.name, n_births, birth_age, c_section_rate, c_section_age) \n\n# Joining map data and cesarean data\nc_section <- spain %>% \n  left_join(\n    c_section,\n    by = \"ine.ccaa.name\"\n  )  \n\nstr(c_section)\n\nClasses 'sf' and 'data.frame':  19 obs. of  27 variables:\n $ codauto          : chr  \"01\" \"02\" \"03\" \"04\" ...\n $ iso2.ccaa.code   : chr  \"ES-AN\" \"ES-AR\" \"ES-AS\" \"ES-IB\" ...\n $ nuts1.code       : chr  \"ES6\" \"ES2\" \"ES1\" \"ES5\" ...\n $ nuts2.code       : chr  \"ES61\" \"ES24\" \"ES12\" \"ES53\" ...\n $ ine.ccaa.name    : chr  \"Andalucía\" \"Aragón\" \"Asturias, Principado de\" \"Balears, Illes\" ...\n $ iso2.ccaa.name.es: chr  \"Andalucía\" \"Aragón\" \"Asturias, Principado de\" \"Islas Baleares\" ...\n $ iso2.ccaa.name.ca: chr  NA NA NA \"Illes Balears\" ...\n $ iso2.ccaa.name.gl: chr  NA NA NA NA ...\n $ iso2.ccaa.name.eu: chr  NA NA NA NA ...\n $ nuts2.name       : chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Illes Balears\" ...\n $ cldr.ccaa.name.en: chr  \"Andalusia\" \"Aragon\" \"Asturias\" \"Balearic Islands\" ...\n $ cldr.ccaa.name.es: chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Islas Baleares\" ...\n $ cldr.ccaa.name.ca: chr  \"Andalusia\" \"Aragó\" \"Astúries\" \"Illes Balears\" ...\n $ cldr.ccaa.name.ga: chr  \"Andalucía\" \"Aragón\" \"Principado de Asturias\" \"Illas Baleares - Illes Balears\" ...\n $ cldr.ccaa.name.eu: chr  \"Andaluzia\" \"Aragoi\" \"Asturiesko Printzerria\" \"Balear Uharteak\" ...\n $ ccaa.shortname.en: chr  \"Andalusia\" \"Aragon\" \"Asturias\" \"Balearic Islands\" ...\n $ ccaa.shortname.es: chr  \"Andalucía\" \"Aragón\" \"Asturias\" \"Baleares\" ...\n $ ccaa.shortname.ca: chr  \"Andalusia\" \"Aragó\" \"Astúries\" \"Illes Balears\" ...\n $ ccaa.shortname.ga: chr  \"Andalucía\" \"Aragón\" \"Asturias\" \"Illas Baleares\" ...\n $ ccaa.shortname.eu: chr  \"Andaluzia\" \"Aragoi\" \"Asturias\" \"Balear Uharteak\" ...\n $ nuts1.name       : chr  \"SUR\" \"NORESTE\" \"NOROESTE\" \"ESTE\" ...\n $ ccaa             : chr  \"Andalucía\" \"Aragón\" \"Asturias (Principado de)\" \"Balears (Illes)\" ...\n $ n_births         : num  54561 7715 3802 6245 11392 ...\n $ birth_age        : num  31.4 32.4 33.1 31.7 31.6 ...\n $ c_section_rate   : num  23.8 18.3 17.4 17.5 17.8 ...\n $ c_section_age    : num  32.5 33.2 34.1 33.4 33.1 ...\n $ geometry         :sfc_GEOMETRY of length 19; first list element: List of 6\n  ..$ :List of 1\n  .. ..$ : num [1:1259, 1:2] -4.27 -4.27 -4.28 -4.28 -4.27 ...\n  ..$ :List of 1\n  .. ..$ : num [1:6, 1:2] -5.61 -5.61 -5.61 -5.61 -5.61 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -3.03 -3.03 -3.04 -3.03 -3.03 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -6.31 -6.32 -6.32 -6.32 -6.31 ...\n  ..$ :List of 1\n  .. ..$ : num [1:6, 1:2] -6.27 -6.27 -6.28 -6.28 -6.27 ...\n  ..$ :List of 1\n  .. ..$ : num [1:5, 1:2] -6.47 -6.47 -6.47 -6.47 -6.47 ...\n  ..- attr(*, \"class\")= chr [1:3] \"XY\" \"MULTIPOLYGON\" \"sfg\"\n - attr(*, \"sf_column\")= chr \"geometry\"\n - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ...\n  ..- attr(*, \"names\")= chr [1:26] \"codauto\" \"iso2.ccaa.code\" \"nuts1.code\" \"nuts2.code\" ...\n\nThe next task is to use our cesarean section rate variable to fill the different autonomous communities with varying color intensities according to their values.\n\n\n# Filling the map with cesarean rate data\nc_section_map <- ggplot(c_section) +\n  geom_sf(aes(fill = c_section_rate), color = \"white\", linewidth = 0.2)\n\nc_section_map\n\n\n\nOur original map uses various shades of bluish-green to represent the cesarean section rate. The color darkens with a higher cesarean section rate. These color specifications are determined based on specific values. We use the “colors,” “breaks,” and “limits” adjustments in the scale_fill_stepsn function to indicate these specifications.\n\n\n# Setting the specific colors and breaks\nc_section_map <- c_section_map +\n  scale_fill_stepsn(\n    colors = c(\"#5EAABB\", \"#478B9C\", \"#2f6b7d\", \"#184c5d\", \"#002c3e\"),\n    breaks = c(13.57, 16.83, 20.10, 23.36, 26.63, 29.89),\n    limits = c(13.57, 29.89)) # Setting the limits\n\n\nc_section_map\n\n\n\nOnce we have the colors set for our chart, we slightly adjust the coordinates for a better framing of the graph.\n\n\n# Setting the coordinates so we can have space for the legend\nc_section_map <- c_section_map +\n    coord_sf(xlim=c(-14, 5),\n           ylim=c(34.6, 45.5)) \n\nc_section_map\n\n\n\nOne of the challenges in our chart is the legend. It is placed at the top and in a horizontal position. In addition, the guiding numbers are aligned centrally with the points where the colour changes. This is true for all except the first data point, which is aligned to the left with the beginning of the legend.\n\n\n# Tunning the fonts\nsysfonts::font_add_google(\"Open Sans\", family=\"Open Sans\")\n\n# Tunning the legend\nc_section_map <- c_section_map +\n  theme_void() +\n  theme(\n    legend.position = c(0.2,0.9),\n    legend.direction = \"horizontal\",\n    legend.key.width = unit(12, \"mm\"),\n    legend.key.height = unit(5, \"mm\"),\n    legend.background = element_blank(),\n    legend.title = element_blank())\n\n# Adjusting alignment of the legend\nc_section_map <- c_section_map + \n  theme(text = element_text(size = 10, \n                            color = \"#6d6d6d\",\n                            family=\"Open Sans\"),\n        legend.text.align = c(0, 0.5, 0.5, 0.5, 0.5, 0.5))\n\nc_section_map\n\n\n\nAlternative visualisation\nOne of the factors that may explain for the number of caesarean sections is the age of the pregnant woman.\nThe Ministry of Health website provides information on the average age of women at delivery in each autonomous community, but it is not used in the visualisation.\nInformation on the number of births per autonomous community is also provided.\nIt is necessary to use all the provided information, including the average age of women at delivery and the number of births per autonomous community, to compose a new map depicting the age-adjusted caesarean section rate, while also considering the total number of births. This enhanced visualisation aims to provide insights into the correlation between maternal age and the prevalence of caesarean sections across different autonomous communities.\n\n\n# Enhancement\n# Obtaining the standarised cesarean rate\nmodel <- lm(c_section_rate ~ c_section_age, data = c_section)\ncoefs <- coef(model)\n\nc_section <- c_section %>% \n  mutate(c_section_age = c_section_rate - coefs['c_section_age'] * (c_section_age - mean(c_section_age)))\n\n# Lets take a look at the adjusted cesarean rate\nsummary(c_section$c_section_age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  15.38   18.14   21.95   21.38   23.53   28.93 \n\n\n\nc_section_centroid <- st_centroid(c_section, of_largest_polygon = TRUE)\n\n\nTo show the total number of births in a community we will use bubbles that vary in size according to the number of births. We visualise the age-adjusted caesarean section rate using colour.\n\n\n# Visualising a bubble map\nbubble_map <- ggplot() +\n  geom_sf(data = spain,\n          linewidth = 0.1,\n          alpha = 0.5) +\n  geom_sf(\n    data = c_section_centroid,\n    pch = 21,\n    aes(size = n_births, \n        fill = c_section_age),\n    stroke = 0.1) +\n  coord_sf(xlim=c(-17, 3.5),\n           ylim=c(34, 45))\n  \nbubble_map\n\n\n\nAs this is a continuous variable, instead of using a static colour palette with shades very similar to each other, I will use a colour gradient. We set a gradient where the midpoint of the colour coincides with the average adjusted caesarean section rate.\n\n\n# Adjusting guides\nbubble_map <- bubble_map +\n  scale_fill_gradient2(\n    low = \"#4CAF50\",\n    mid = \"#FFC107\",\n    high = \"#FF5722\",\n    midpoint = mean(c_section$c_section_age),\n    guide = guide_colorbar(\n      title = \"Cesarean section rate (%)\",\n      title.position = \"top\"\n    )) +\n  scale_size(\n    breaks = c(20000, 40000),\n    labels = c(\"20\", \"40\"),\n    range = c(1, 14),\n    guide = guide_legend(title=\"Number of births (K)\", \n                         title.position=\"top\",\n                         order=2)) \n\nbubble_map\n\n\n\nNow we are using two visualisation elements (bubble size and colour), we will have one more legend than in the original chart. We adjust them so that they are placed on the left margin.\n\n\n# A few more tweaks \nbubble_map <- bubble_map + \n  theme_void() +\n  theme(\n    legend.position = c(0.12,0.7),\n    legend.direction = \"horizontal\",\n    legend.key.width = unit(8, \"mm\"),\n    legend.key.height = unit(5, \"mm\"),\n    legend.background = element_blank(),\n    legend.title=element_text(face=\"bold\", size=8),\n    legend.text=element_text(size=6))  \n\nbubble_map\n\n\n\nSince we are visualising an adjusted rate, it is useful to add annotations to improve the understanding of the graph.\n\n\n# Including annotations\nbubble_map <- bubble_map +\n  annotate(\"richtext\", x = -8.5, y = 44.3, \n           label = paste0(\n    \"<span style='color: #e75c93;'>#1 <\/span><b>Galicia<\/b> becomes a higher rate<br>\n    than would be expected:\n    <b>25.05%<\/b><\/span>\"),\n    size = 3,\n    hjust = 0,\n    fill = NA,\n    label.color = NA) +\n  annotate(\"richtext\", x = -7.5, y = 38.5, \n           label = paste0(\n    \"<span style='color: #e75c93;'>#2 <\/span><b>Extremadura<\/b><br>\",\n    \"has around 7K births per year<br>\n    with the highest age-adjusted c-section rate<br>\n    <b>28.93%<\/b><\/span>\"),\n    size = 3,\n    hjust = 1,\n    fill = NA,\n    label.color = NA)\n\nbubble_map\n\n\n\nFinally we add the title and subtitle. Here is the alternative graph showing the number of births in Spain during 2019 and the age-adjusted caesarean section rate, so we can see that the communities in red have high rates and could be having an excess of non-recommendable clinical practices in all cases.\n\n\n# Adding title and subtitle\nbubble_map <- bubble_map + \n  labs(title = \"**Regional disparities in childbirth clinical practice**\",\n       subtitle = \"**Number of births** and _age-adjusted caesarean rates_ across autonomous communities\") +\n  theme(plot.title = element_text(hjust = 0.5,\n                                  size = 14),\n        plot.subtitle = element_text(hjust = 0.5,\n                                     size = 9)) +\n  theme(plot.title = element_markdown(),\n        plot.subtitle = element_markdown())\n\nbubble_map\n\n\n\n\n\n\n",
    "preview": "projects/2023/100061715/100061715_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100407543/",
    "title": "The Demography of the World Population from 1950 to 2100",
    "description": "Visualizing how global demography has changed and what we can expect for the\n21st - century Our World in Data.",
    "author": [
      {
        "name": "Daniel Pérez-Gutiérrez",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nReplication work\nPackages\nGetting the data\nPreparing the data\nBuilding the graph\n\nAlternative graph\nConstructing the new interest variable\nTime series evolution of the difference between the number of men and women\nDoing the graph interactive\n\n\nIntroduction\nIn 1950, the world population was 2.5 billion people. Since then, it has experienced significant growth, currently exceeding 8 billion. According to United Nations projections, the global population is expected to reach approximately 10.4 billion by the end of the century. This visualization of the population pyramid provides a clearer view of how the demographic composition has evolved and will continue to evolve in the coming decades, as it allows us to observe the age and gender distribution, highlighting changes over time.\nThe original graph\n\n\n\nFigure 1: The original graph\n\n\n\nThe selected graph is available in Our World in data. Elements to note about the graph and the composition of the world population are as follows:\nThe width represents the size of the population of a given age; females on the right and males on the left. The bottom layer represents the number of newborns and, above it, are the numbers of the older cohorts.\nIn darker blue, the pyramid representing the structure of the world population in 1950 can be seen. Particularly noteworthy is the increase in the number of births, which widened the base of the pyramid, and the high lifetime risk of death, which is evident because the pyramid narrows toward the top. There were many newborns relative to the number of people at older ages.\nThrough shades of blue and green, the same visualization shows the population structure over the last decades up to 2018. It can be seen that in each subsequent decade, the population pyramid widened, i.e. in each decade the total number of people of all ages increased.\nReplication work\nPackages\n\n\nlibrary(tidyverse)\nlibrary(cowplot)\n\n\nGetting the data\n\n\ndata <- readxl::read_excel(\"data.xlsx\")\n\n\nPreparing the data\nWe are faced with a dataset where information on the ages of individuals is presented in a scattered manner, with each age group located in a separate column. This structure can be challenging for efficient analysis and visualization of the information. To address this situation, the pivot_longer() function of the tidyverse package is used. This operation allows the data to be rearranged so that the ages, originally represented as separate columns, are stacked into a single column called “Age”.\nOnce the data is in the desired format, I make sure that there are no NA\n\n\ndata2 <- data |> \n  pivot_longer(cols = c(2:102),\n               names_to = \"Age\",\n               values_to = \"population\")\n\nif (any(!complete.cases(data2))) {\n  print(\"There are any NA.\")\n} else {\n  print(\"There are not any NA\")\n}\n\n[1] \"There are not any NA\"\n\n\n\n\nSince to replicate the original graph I have to make two separate graphs (one for the male population and one for the female population) I filter the dataframe according to gender, and create a different data set for each gender.\n\n\ndata_male <- data2 |> \n  filter(sex == \"Male\")\n\ndata_female <- data2 |> \n  filter(sex == \"Female\")\n\n\nBuilding the graph\nFirst, I create a vector containing the years that the authors of the original chart highlight with thicker lines and dashed lines.\nSubsequently, this vector will allow me to create 3 layers:\nThe first one for all years from 1950 to 2100.\nThe second for selected years that are actual observations (1950, 1960, 1970, 1980, 1990 and 2018) which have a thicker line.\nThe third one, for the selected years that are projections (2050, 2075 and 2100) with lines of the same thickness as the years of the second layer, but with a dashed line.\nThen, after numerous attempts, the ingenious solution to apply the exact color to the area between the lines delineating the profiles of each year in the population pyramid was to create a vector in which the sequence of each element corresponds directly and precisely to the years (once the color palette was inverted). By establishing a 1:1 correspondence between each color and the area between the lines that draw the profile of each year, I can assign a color to each of the 150 areas to be colored.\n\n\nselected_years <- c(1950, 1960, 1970, 1980, 1990, 2018, 2050, 2075, 2100)\n\ncolor_paleta <- c(\n  \"#3E5189\",                  \n  rep(\"#3371B7\", times = 10),  \n  rep(\"#3B86B7\", times = 10),  \n  rep(\"#48A0AA\", times = 10),  \n  rep(\"#52B6A3\", times = 10),  \n  rep(\"#57C09F\", times = 28),  \n  rep(\"#E6F07C\", times = 32),  \n  rep(\"#E2DB56\", times = 25),  \n  rep(\"#EFDD56\", times = 25)   \n)\ncolor_paleta_invertido <- rev(color_paleta)\n\n\nFemale population\nI use geom_area to display stacked areas representing the distribution of the female population over time. geom_line adds lines with specific settings to highlight selected observations and additional projections. The coord_flip function inverts the x and y axes to enhance the display of the area plot. In addition, geom_text is used to manually add labels and the values of both axes.\n\n\nplot_female <- ggplot(data_female, aes(x = Age, y = population, fill = forcats::fct_rev(Year))) +\n  geom_area(position = \"identity\", alpha = 0.7) +\n  geom_line(aes(color = \"NotSelected\", linetype = \"NotSelected\"),\n            alpha = 0.1, size = 0.1) +\n  geom_line(data = subset(data_female, Year %in% c(1950, 1960, 1970, 1980, 1990, 2018)),\n            aes(color = \"Selected\", linetype = \"Selected\"),\n            alpha = 1, size = 0.3, linetype = \"solid\") +\n  geom_line(data = subset(data_female, Year %in% c(2050, 2075, 2100)),\n            aes(color = \"AdditionalSelected\", linetype = \"AdditionalSelected\"),\n            alpha = 1, size = 0.3, linetype = \"dashed\") +\n  coord_flip() +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5, size = 19, face = \"bold\"),\n        axis.text.y = element_blank(), axis.title.y = element_blank(), axis.text.x = element_blank()) +\n  scale_x_continuous(breaks = seq(0, 100, by = 10), limits = c(-10, 102)) +\n  scale_fill_manual(values = color_paleta_invertido) +\n  scale_color_manual(values = c(\"NotSelected\" = \"#686351\", \"Selected\" = \"#686351\", \"AdditionalSelected\" =\"#686351\")) +\n  scale_linetype_manual(values = c(\"NotSelected\" = \"solid\", \"Selected\" = \"solid\", \"AdditionalSelected\" = \"dashed\")) +\n  geom_text(data = data.frame(x = 9.94307173536714, y = 28511.2785548616, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.3, vjust = 1L,color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 18.0412115460575, y = 26490.5928372464, label = \"1960\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 29.1943328380169, y = 25480.2499784388 , label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.4, vjust = 1L, color = \"#686351\",inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 39.238472992214, y = 25143.4690255029, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label), \n            size = 2, angle = -14L, vjust = 1L,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 49.6413296030791, y = 23571.8245784689, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, hjust = 0.35, vjust = 1L, color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 57.6527237837525, y = 40000, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2,angle = -14L, hjust = 1L, vjust = 0.35, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 75.5416978407678, y = 37941.145237066, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -12L, hjust = 0.45, vjust = 0.65, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 82.5215256568887, y = 38165.6658723566, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -13L, hjust = 0.25, vjust = 0.8,color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 87.3963251911341, y = 39400.5293664547, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = -14L, vjust = 1L,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 40000, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n             size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3E5189\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y =45500, label = \"1960\"),\n            mapping = aes(x = 0, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3371B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 57567.0830381612, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#48A0AA\",inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0, y = 55560.22486, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#3B86B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 65296.5630636051, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#52B6A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 65900.4237224363, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#E6F07C\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 61007, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#E2DB56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 54350.0899600451, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#EFDD56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = 66861.9360283455, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = -90L, hjust = 0, vjust = 0.8, color = \"#57C09F\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x =0 , y = 29857.4288547544, label = \"Women\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 4, hjust =1L, vjust = 1L, color = \"#4B4B4B\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 25 , y = 65700, label = \"Median Age in 1950:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n geom_text(data = data.frame(x = 23.6 , y = 65700, label = \"23.6 years\"),\n          mapping = aes(x = x, y = y, label = label),\n          size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 31.4  , y = 65700, label = \"Median Age in 2018:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 30 , y = 65700, label = \"30 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 37.5  , y = 65700, label = \"Median Age in 2050:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 36.1 , y = 65700, label = \"36.1 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 40.4  , y = 65700, label = \"Median Age in 2075:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 39 , y = 65700, label = \"39 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 44.4  , y = 65700, label = \"Median Age in 2100:\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 43 , y = 65700, label = \"41.6 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.2, hjust = 0L, vjust = 0.75, color = \"#A3A3A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 102, y = 10000, label = \"10 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 20000, label = \"20 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 30000, label = \"30 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 40000, label = \"40 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 50000, label = \"50 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 60000, label = \"60 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = 70000, label = \"70 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n\n  labs(title = \"\", x = \"\", y = \"\", fill = \"Año\", color = \"Línea destacada\", linetype = \"Discontinuity\")\n\nprint(plot_female)\n\n\n\nMale population\nThe procedure to make this graph is the same as the one used to make the graph with the female data\n\n\nplot_male <- ggplot(data_male, aes(x = Age, y = -population, fill = forcats::fct_rev(Year))) +\n  geom_area(position = \"identity\", alpha = 0.7) +\n  geom_line(aes(color = \"NotSelected\", linetype = \"NotSelected\"),\n            alpha = 0.1, size = 0.1) +\n  geom_line(data = subset(data_male, Year %in% c(1950, 1960, 1970, 1980, 1990, 2018)),\n            aes(color = \"Selected\", linetype = \"Selected\"),\n            alpha = 1, size = 0.3, linetype = \"solid\") +\n  geom_line(data = subset(data_male, Year %in% c(2050, 2075, 2100)),\n            aes(color = \"AdditionalSelected\", linetype = \"AdditionalSelected\"),\n            alpha = 1, size = 0.3, linetype = \"dashed\") +\n  coord_flip() +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", plot.title = element_text(hjust = 0.5, size = 19, face = \"bold\"),\n        axis.text.y = element_blank(), axis.title.y = element_blank(), axis.text.x = element_blank()) +\n  scale_x_continuous(breaks = seq(0, 100, by = 10), limits = c(-10, 102)) +\n  scale_y_continuous(limits = c(-75000, 0)) +\n  scale_fill_manual(values = color_paleta_invertido) +\n  scale_color_manual(values = c(\"NotSelected\" = \"#686351\", \"Selected\" = \"#686351\", \"AdditionalSelected\" = \"#686351\")) +\n  scale_linetype_manual(values = c(\"NotSelected\" = \"solid\", \"Selected\" = \"solid\", \"AdditionalSelected\" = \"dashed\")) +\n  geom_text(data = data.frame(x = 6.18998544147173, y = -30320.5198591813, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.55, vjust = 0.6, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 14.2745633982306, y = -31880.6425658543, label = \"1960\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.2, vjust = 0.45, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 23.7762261259231, y = -31368.3552619391, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2,angle = 24L, hjust = 0.4,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 33.7651553067948, y = -31496.4270879179, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size =2, angle = 24L, vjust = 0.8,color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 41.8050242512531, y = -31624.4989138967, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 24L, hjust = 0.40, vjust = 0.35, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 58.8592950465282, y = -35210.5100413027, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size= 2, angle = 27L, hjust = 0.5, vjust = 0.6, color = \"#686351\",inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 72.8681580025912, y = -36107.0128231542, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 25L, hjust = 0.35, vjust = 0.15, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 80.7862113793117, y = -35978.9409971755, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 18L, color = \"#686351\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 85.6268864011455, y = -36812.4166584925, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, angle = 20L, hjust = 0.4, vjust = 0.9, color = \"#686351\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0.0540647418287934, y = -41737.516021589, label = \"1950\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#3E5189\", inherit.aes = FALSE) +\n\n  geom_text(data = data.frame(x = 0, y =-47403, label = \"1960\"),\n            mapping = aes(x = 0, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#3371B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -60601, label = \"1980\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#48A0AA\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 0, y = -58589, label = \"1970\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#3B86B7\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -69485, label = \"1990\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#52B6A3\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -68360, label = \"2050\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#E6F07C\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -63507, label = \"2075\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#E2DB56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -56524, label = \"2100\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L, color = \"#EFDD56\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 0, y = -70891, label = \"2018\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 1.6, angle = 90L, hjust = 1L,color = \"#57C09F\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x =0 , y = -20000,  label = \"Men\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 4, hjust =1L, vjust = 1L, color = \"#4B4B4B\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 102, y = -10000, label = \"10 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -20000, label = \"20 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -30000, label = \"30 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -40000, label = \"40 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -50000, label = \"50 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -60000, label = \"60 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 102, y = -70000, label = \"70 Million\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 10, y = -73400, label = \"10 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 20, y = -73400, label = \"20 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 30, y = -73400, label = \"30 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 40, y = -73400, label = \"40 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 50, y = -73400, label = \"50 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 60, y = -73400, label = \"60 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 70, y = -73400, label = \"70 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 80, y = -73400, label = \"80 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n  geom_text(data = data.frame(x = 90, y = -73400, label = \"90 years\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"#949494\", inherit.aes = FALSE)+\n \n  labs(title = \"\", x = \"\", y = \"\", fill = \"Año\", color = \"Línea destacada\", linetype = \"Discontinuity\")\n\n\n\nprint(plot_male)\n\n\n\nCombined\nOnce both graphs have been made, I proceed to join them. Using the draw_plot and draw_text function of ggdraw I manually adjust the position of each plot and manually include the title, subtitle and the source of the data.\n\n\ncombined_plot <- ggdraw() +\n  draw_plot(\n    plot_male + theme(panel.grid = element_blank()) +\n      geom_hline(yintercept = 0, color = \"black\", size = 0.2, linetype = \"solid\", alpha = 0.2),\n    x = 0.04, y = 0, width = 0.5, height = 1\n  ) +\n  draw_plot(\n    plot_female + theme(axis.text.y = element_blank(), panel.grid = element_blank()) +\n      geom_hline(yintercept = 0, color = \"black\", size = 0.2, linetype = \"solid\", alpha = 0.2),\n    x = 0.46, y = 0, width = 0.5, height = 1\n  ) +\n  draw_text(\n    \"The Demography of the World Population from 1950 to 2100\",\n    x = 0.5, y = 0.96, size = 12, vjust = 0, hjust = 0.5, color = \"#474747\",\n    family = \"Times New Roman\"\n  ) +\n  draw_text(\n    \"Shown is the age distribution of the world population - by sex - from 1950 to 2018 and the UN Population Division's projection until 2100.\",\n    x = 0.5, y = 0.93, size = 5, vjust = 0, hjust = 0.5, color = \"#585858\",\n    fontface = \"italic\"\n  ) +\n  draw_text(\n    \"Data source: United Nations Population, Division - World Population Prospects 2017; Medium Variant.\nThe data visualization is available at OurWorldinData.org. where you find more research on how the world is changing and why.\",\n    x = 0.3, y = 0.02, size = 6, vjust = 0, hjust = 0.5, color = \"#C9C9C9\"\n  )\nprint(combined_plot)\n\n\n\nAlternative graph\nGiven that the original graph is comprehensive and aesthetically appealing, improving both its visual and informational quality proves challenging. Therefore, a viable alternative is to explore the inclusion of an additional graph that provides complementary information on the evolution of the world population.\nIn this way, incorporating the evolution of the population difference between men and women in demographic analysis offers a detailed and specific perspective, enriching the understanding of how the demographic composition has changed over time. This approach allows for the identification of specific patterns in the population difference between genders over the decades, enabling us to observe how demographic dynamics have evolved in relation to gender.\n\n\n\nConstructing the new interest variable\nI calculate for each age group and each year, the difference between the total number of men and women.\nThus, if the difference is positive, the result indicates that the number of males is greater, and if the result is negative, the number of females is greater than the number of males.\n\n\ndf_diff <- data_mejora |> \n    group_by(Year, Age) |> \n    summarise(population_diff = sum(ifelse(sex == \"Male\", population, -population)))\n\n\nTime series evolution of the difference between the number of men and women\n\n\n plot_diff <- ggplot(df_diff, aes(x = Age, y = population_diff, color = as.factor(Year))) +\n    geom_line(size = 0.8) +\n    labs(title = \"Differences between men and women (1950-2100)\",\n         x = \"Age\",\n         y = \"Men population - Women Population\",\n         color = \"Age\") +\n    scale_color_manual(values = c(\"1950\" = \"#3E5189\", \"1980\" = \"#48A0AA\", \n                                  \"2018\" = \"#57C09F\", \"2050\" = \"#E6F07C\",\n                                  \"2075\" = \"#E2DB56\", \"2100\"= \"#EFDD56\" )) +\n    theme_minimal()\n \nplot_diff <- plot_diff + annotate(\"segment\", x = 50, xend = 50, y = 250, yend= 4000)\nplot_diff<- plot_diff + geom_text(data = data.frame(x = 50, y = 4600, label = \"Male population > Female population\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"black\", inherit.aes = FALSE)\n\n\nplot_diff <- plot_diff + annotate(\"segment\", x = 50, xend = 50, y = -250, yend= -4000)\nplot_diff<- plot_diff + geom_text(data = data.frame(x = 50, y = -4600, label = \"Female population > Male population\"),\n            mapping = aes(x = x, y = y, label = label),\n            size = 2, color = \"black\", inherit.aes = FALSE)\nprint(plot_diff)\n\n\n\nDoing the graph interactive\nUsing the ggplotly function of the plotly library, we allow the graph to be interactive and give us the exact value of the difference between the number of men and women for a given age if we place the computer cursor over the year in which we are interested.\n\n\nplotly::ggplotly(plot_diff)\n\n\n\n\n\n\n",
    "preview": "projects/2023/100407543/100407543_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100408925/",
    "title": "How Britain Voted in the E.U. Referendum",
    "description": "Britons voted on Thursday to leave the European Union. The Leave side led with\n17.4 million votes, or 52 percent, versus the Remain side’s 16.1 million, or\n48 percent, with a turnout of around 72 percent.",
    "author": [
      {
        "name": "Laura Martinez",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nGetting the data right\nPackages\nLoading and fixing the data\n\nReplication\nCreating two scales\nSetting fonts for the map\nCreating tags for the map\nCreating the base plot (map)\nAdding tags to the map\nLondon close-up\nRemain-Leave bar plot\nLondon zoom-up lines\nPutting everything together\nFinal annotations\nLimitations\n\nIs there an alternative way?\n\nIntroduction\nThe article from The New York Times, published on June 25, 2016, delves into the aftermath of the Brexit referendum, portraying it as a momentous and uncertain chapter in Britain’s storied history. The piece captures the prevailing sentiments of shock and uncertainty following the unexpected decision to leave the European Union, as the country grapples with the potential economic, political, and social consequences.\nIt reflects on the intricate challenges ahead, including the renegotiation of trade agreements, potential shifts in global influence, and the implications for the European Union itself. Through interviews with citizens, politicians, and analysts, the article captures the diverse reactions and apprehensions within the UK and abroad, emphasizing the profound impact of the referendum on the nation’s trajectory and its place in the broader European context.\nLink to article\nThe original graph\nThe original graph can be found on the New York Times graph repository and uses maps and charts to illustrate the voting patterns across various regions, highlighting stark divisions between areas that voted to remain in the European Union and those that opted to leave and providing a detailed breakdown of the results of the Brexit referendum in the United Kingdom.\nOriginal graph, source: NYTGetting the data right\nPackages\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(scales)\nlibrary(sf)\nlibrary(ggforce)\nlibrary(patchwork)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(maps)\nlibrary(ggnewscale)\nlibrary(ggtext)\nlibrary(RColorBrewer)\nlibrary(mapproj)\n\n\nWe should also set here our own working directory\nLoading and fixing the data\nThe data is not precisely easily accessible (or at least not all of it) so I recommend downloading it from Github.\n\n\n# csv data for the UK\nreferendum <- read_csv(\"EU-referendum-result-data.csv\")\n\n# shapefiles\nuk_shp <- read_sf(\"maps/uk_constituencies_2016.shp\")\nireland_shp <- read_sf(\"maps/IRL_adm1.shp\")\n\n# check the geometries to how many divisions they have\nlength(st_geometry(uk_shp))\nlength(st_geometry(ireland_shp))\n\n\nAfter loading the data many variables that were meaningless for creating the graph were eliminated. Once that was done, certain variables were renamed so that the area name and area code were the same in both shapefiles for the UK and Ireland, aligned their coordinate systems so that they matched (at EPSG:4326) and merged the shapefiles altogether and also with the main dataset with all the information.\n\n\n# eliminate meaningless columns of the shp: \nuk_shp$ID <- NULL\nireland_shp$ID_0 <- NULL\nireland_shp$ISO <- NULL\nireland_shp$NAME_0 <- NULL\nireland_shp$TYPE_1 <- NULL\nireland_shp$ENGTYPE_1 <- NULL\nireland_shp$NL_NAME_1 <- NULL\nireland_shp$VARNAME_1 <- NULL\n\n# rename variables\nnames(ireland_shp)[names(ireland_shp) == \"NAME_1\"] <- \"area_name\"\nnames(ireland_shp)[names(ireland_shp) == \"ID_1\"] <- \"area_code\"\n\nreferendum <- referendum |> \n  rename(area_code = Area_Code)\n\n# transform and align the coordinate systems\nuk_shp <- st_transform(uk_shp, crs = st_crs(\"EPSG:4326\"))\nireland_shp <- st_transform(ireland_shp, crs = st_crs(\"EPSG:4326\"))\n\n#check their coordinates systems\nprint(st_crs(uk_shp))\nprint(st_crs(ireland_shp))\n\n#Merge shapefiles\nuk_shp1 <- rbind(uk_shp, ireland_shp)\n\n#Merge with dataset\nbrexit_data <- left_join(uk_shp1, referendum, by = \"area_code\")\n\n\nAlso, I manually filled the referendum data (remain, leave and turnout percentages) for the districts of Northern Ireland with the information made available by the BBC.\n\n\n#West Tyrone\nbrexit_data$Pct_Turnout[18] <- 61.8\nbrexit_data$Remain[18] <- 26765\nbrexit_data$Leave[18] <- 13274\nbrexit_data$Pct_Remain[18] <- 66.8\nbrexit_data$Pct_Leave[18] <- 33.2\n\n#Upper Bann\nbrexit_data$Pct_Turnout[17] <- 63.8\nbrexit_data$Remain[17] <- 24550\nbrexit_data$Leave[17] <- 27262\nbrexit_data$Pct_Remain[17] <- 47.4\nbrexit_data$Pct_Leave[17] <- 52.6\n\n#Strangford\nbrexit_data$Pct_Turnout[16] <- 64.5\nbrexit_data$Remain[16] <- 18727\nbrexit_data$Leave[16] <- 23383\nbrexit_data$Pct_Remain[16] <- 44.5\nbrexit_data$Pct_Leave[16] <- 55.5\n\n#South Down\nbrexit_data$Pct_Turnout[15] <- 62.4\nbrexit_data$Remain[15] <- 32076\nbrexit_data$Leave[15] <- 15625\nbrexit_data$Pct_Remain[15] <- 67.2\nbrexit_data$Pct_Leave[15] <- 32.8\n\n#South Antrim\nbrexit_data$Pct_Turnout[14] <- 63.4\nbrexit_data$Remain[14] <- 21498\nbrexit_data$Leave[14] <- 22055\nbrexit_data$Pct_Remain[14] <- 49.4\nbrexit_data$Pct_Leave[14] <- 50.6\n\n#North Down\nbrexit_data$Pct_Turnout[13] <- 67.7\nbrexit_data$Remain[13] <- 23131\nbrexit_data$Leave[13] <- 21046\nbrexit_data$Pct_Remain[13] <- 52.4\nbrexit_data$Pct_Leave[13] <- 47.6\n\n#North Antrim\nbrexit_data$Pct_Turnout[12] <- 64.9\nbrexit_data$Remain[12] <- 18782\nbrexit_data$Leave[12] <- 30938\nbrexit_data$Pct_Remain[12] <- 37.8\nbrexit_data$Pct_Leave[12] <- 62.2\n\n#Newry and Armagh\nbrexit_data$Pct_Turnout[11] <- 63.7\nbrexit_data$Remain[11] <- 31963\nbrexit_data$Leave[11] <- 18659\nbrexit_data$Pct_Remain[11] <- 62.9\nbrexit_data$Pct_Leave[11] <- 37.1\n\n#Mid Ulster\nbrexit_data$Pct_Turnout[10] <- 61.7\nbrexit_data$Remain[10] <- 25612\nbrexit_data$Leave[10] <- 16799\nbrexit_data$Pct_Remain[10] <- 60.4\nbrexit_data$Pct_Leave[10] <- 39.6\n\n#Lagan Valley\nbrexit_data$Pct_Turnout[9] <- 66.6\nbrexit_data$Remain[9] <- 22710\nbrexit_data$Leave[9] <- 25704\nbrexit_data$Pct_Remain[9] <- 46.9\nbrexit_data$Pct_Leave[9] <- 53.1\n\n#Foyle\nbrexit_data$Pct_Turnout[8] <- 57.4\nbrexit_data$Remain[8] <- 32064\nbrexit_data$Leave[8] <- 8905\nbrexit_data$Pct_Remain[8] <- 78.3\nbrexit_data$Pct_Leave[8] <- 21.7\n\n#Fermanagh and South Tyrone\nbrexit_data$Pct_Turnout[7] <- 67.9\nbrexit_data$Remain[7] <- 28200\nbrexit_data$Leave[7] <- 19958\nbrexit_data$Pct_Remain[7] <- 58.6\nbrexit_data$Pct_Leave[7] <- 41.4\n\n#East Londonderry\nbrexit_data$Pct_Turnout[6] <- 69.9\nbrexit_data$Remain[6] <- 21098\nbrexit_data$Leave[6] <- 19455\nbrexit_data$Pct_Remain[6] <- 52.0\nbrexit_data$Pct_Leave[6] <- 48.0\n\n#East Antrim\nbrexit_data$Pct_Turnout[5] <- 65.2\nbrexit_data$Remain[5] <- 18616\nbrexit_data$Leave[5] <- 22929\nbrexit_data$Pct_Remain[5] <- 44.8\nbrexit_data$Pct_Leave[5] <- 55.2\n\n#Belfast West\nbrexit_data$Pct_Turnout[4] <- 48.9\nbrexit_data$Remain[4] <- 23099\nbrexit_data$Leave[4] <- 8092\nbrexit_data$Pct_Remain[4] <- 74.1\nbrexit_data$Pct_Leave[4] <- 25.9\n\n#Belfast South\nbrexit_data$Pct_Turnout[3] <- 67.6\nbrexit_data$Remain[3] <- 30960\nbrexit_data$Leave[3] <- 13596\nbrexit_data$Pct_Remain[3] <- 69.5\nbrexit_data$Pct_Leave[3] <- 30.5\n\n#Belfast North\nbrexit_data$Pct_Turnout[2] <- 57.5\nbrexit_data$Remain[2] <- 20128\nbrexit_data$Leave[2] <- 19844\nbrexit_data$Pct_Remain[2] <- 50.4\nbrexit_data$Pct_Leave[2] <- 49.6\n\n#Belfast East\nbrexit_data$Pct_Turnout[1] <- 66.5\nbrexit_data$Remain[1] <- 20728\nbrexit_data$Leave[1] <- 21918\nbrexit_data$Pct_Remain[1] <- 48.6\nbrexit_data$Pct_Leave[1] <- 51.4\n\nbrexit_data$Region_Code <- NULL\nbrexit_data$Region <- NULL\nbrexit_data$id <- NULL\nbrexit_data$Area <- NULL\n\n\nReplication\nCreating two scales\nSince our map is based on two scales (Leave and Remain) with their own legends and positive graduated systems (percentage vote ranging from 1 to 100), we need to separate our dataset into two datasets.\nIn order to do so first we have to classify our data according to which option won (got majority) in each district. For that we need to create a column that classifies each observation as “Leave” or “Remain”. Then create the different datasets given the classifier just created.\n\n\n# Making a winner column\nbrexit_data <- mutate(brexit_data, winner = if_else(Pct_Remain > Pct_Leave, \"Remain\", \"Leave\"))\n\n#Add ireland as Pct_leave to plot it gray \nbrexit_data$winner[399:424] <- \"Leave\"\n\n# Creating two different data frames\nleave_df <- brexit_data[brexit_data$winner == \"Leave\",]\nremain_df <- brexit_data[brexit_data$winner == \"Remain\",]\n\n\nOn top of that, in the code all of the observations of Ireland were classified as “Leave”. This is just to later be able to plot Ireland as a gray area so that the whole Island is displayed for geographical reference. As a result this displays the whole island of Ireland, the part corresponding to Northern Ireland with the corresponding colours for Leave and Remain in each district and the rest of the island in gray.\nSetting fonts for the map\nFollowing this, it sets the base graphics parameter par(family = \"Times\") to specify the “Times” font family. The script proceeds to add fonts from Google Fonts using the font_add_google function from both the “Lora” and “DM Serif Display” font families. These are the fonts that will be used in the final map (I decided to choose those fonts instead of the ones in the original map as I liked better these).\nFinally, it activates font rendering with the showtext_auto() function from the “showtext” package, allowing the specified fonts to be used in subsequent graphical output. Overall, these lines of code ensure that the desired fonts are installed, imported, and configured for use in R graphics.\n\n\n#Add fonts\nsysfonts::font_add_google(\"Lora\", family=\"Lora\")\nsysfonts::font_add_google(\"DM Serif Display\", family=\"DM Serif Display\")\nshowtext::showtext_auto()\n\n\nCreating tags for the map\nBefore plotting the map it is also necessary to prepare some of the tags that will be displayed on the map (or at least the ones that are attached geographically to it).\nIn this part of the code, two data frames related to the Brexit referendum leave_df and remain_df are manipulated together with a newly created data frame named country_tag that has the exact coordinates of where each of the tag is to be placed.\nFor both leave_df and remain_df, it is added a new column named country based on a conditional logic using the case_when function. This logic assigns country names (“England,” “Northern Ireland,” “Wales,” or “Scotland”) to each row in the data frames based on the first letter of the area_code column.\nAdditionally, the code reorders the columns to have the newly created country column as the first column. The final section of the code creates a new data frame, country_tag, containing information about the latitude and longitude of specific countries. In simpler terms, this chunk prepares and organizes data by assigning countries to rows based on their area codes and creates a separate data frame with geographical information.\n\n\nleave_df <- leave_df |> \n  mutate(country = case_when(\n    substr(area_code, 1, 1) == \"E\" ~ \"England\",\n    substr(area_code, 1, 1) == \"N\" ~ \"Northern Ireland\",\n    substr(area_code, 1, 1) == \"W\" ~ \"Wales\",\n    substr(area_code, 1, 1) == \"S\" ~ \"Scotland\",\n    TRUE ~ NA_character_\n  )) \nleave_df <- leave_df |> \n  select(country, everything())\n\nremain_df <- remain_df |> \n  mutate(country = case_when(\n    substr(area_code, 1, 1) == \"E\" ~ \"England\",\n    substr(area_code, 1, 1) == \"N\" ~ \"Northern Ireland\",\n    substr(area_code, 1, 1) == \"W\" ~ \"Wales\",\n    substr(area_code, 1, 1) == \"S\" ~ \"Scotland\",\n    TRUE ~ NA_character_\n  )) \nremain_df <- remain_df |> \n  select(country, everything())\n\n#Dataframe of tags (locations on the map)\ncountry_tag <- data.frame(\n  country = c(\"Scotland\", \"England\", \"Wales\", \"Nothern \\nIreland\"),\nlatitude = c(56.999651, 54.383331, 52.000, 55.360043), \nlongitude = c(-4.809075, -1.866667, -4.933, -7.707558)\n)\n\n\nCreating the base plot (map)\nThe following R code constructs a thematic map using the ggplot2 package in R. The map visualizes the results of the E.U. Referendum in Britain, specifically focusing on the percentage of votes for remaining (“Remain”) and leaving (“Leave”) the European Union across different regions. Here’s a detailed breakdown of the code:\nBase Plot Setup: The ggplot() function initializes the plot, and two separate layers are added for the “Remain” and “Leave” data frames using geom_sf. This function is specifically designed for creating visualizations with spatial data, where each observation in the dataset represents a geographic feature such as a point, line, or polygon. The aes argument within it specifies the variables (Pct_Remain or Pct_Leave respectively) to map to the fill color aesthetic. Remain is plotted with a blue scale and Leave with a scale of reds.\nColor Scales: scale_fill_stepsn is used to define color scales for “Remain” and “Leave” percentages. Colors are specified, breaks are set (starting at 50 and ending at 80, which covers the variability of the tunover data), and labels are assigned. The color gradients represent different levels of support, and breaks indicate specific percentage points. Also inside this command the legends are customised for each scale.\nLegend customization: the guide_colorsteps() function is utilized to customize the appearance of the legend associated with data. The configuration ensures even steps in the color scale (uniform distribution of colors across the scale), includes ticks on the legend with specified color and width, orients the legend horizontally, and provides a clear title (“Remain”). Additionally, lines are drawn at the lower and upper limits of the color scale, and the frame of the legend is set to black. The size of text labels within the legend is adjusted to 8 for optimal readability.\nAdding a New Fill Scale: The new_scale_fill() command is introduced to reset the fill scale specifically for the subsequent geom_sf layer that deals with “Leave” data. This is done to separate the color scales for “Remain” and “Leave,” allowing independent customization of color gradients, breaks, labels, and other scale-related properties.\nText Annotations: geom_text is employed to add labels to the map. The country_tag data frame provides coordinates (longitude and latitude) for text placement, and labels are drawn using the specified font (“Lora”). Country names are bold and sized appropriately.\nThemes and Formatting: The appearance of the map is controlled through various theme options. theme_minimal() provides a clean background, and additional adjustments are made for titles, legends, axis labels, grid lines, and font styles. The adjustments include setting the size of the legend title to 9, positioning the plot title to the left with a vertical justification of 0.5, and making the title bold. The legend is positioned at coordinates (0.15, 0.85) within the plot. The text across the plot is set to a specified font family (“DM Serif Display”) and a size of 15. Various elements such as axis text, titles, ticks, and grid lines are removed for a cleaner and more minimalistic design. The legend is oriented horizontally, placed in a vertical box on the right, and justified to the right. The key size of the legend is set to a unit of 0.4 cm, and text within the legend is adjusted to a size of 6. The spacing between legend items along the y-axis is set to zero.\nFinal Plot Object: The final plot object is stored in the variable map.\nThe map effectively visualizes the voting patterns in the E.U. Referendum, distinguishing between regions that voted to remain or leave. The use of color gradients, text annotations, and a clear legend enhances the interpretability of the map.\n\n\nmap <- ggplot() +\n  geom_sf(data = remain_df,\n          aes(fill = Pct_Remain),\n          colour = \"white\",\n          lwd = 0.1) +\n  scale_fill_stepsn(\n    colors = c(\"lightskyblue1\", \"steelblue1\", \"dodgerblue\", \"dodgerblue4\"),\n    breaks = c(50, 60, 70, 80),\n    labels = c(\"\", \"\", \"\", \"\"),\n    limits = c(50, 90),\n    name = \"Remain\", \n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 0.5,\n      direction = \"horizontal\",\n      title = \"Remain\",\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  new_scale_fill() +\n  geom_sf(data = leave_df,\n          aes(fill = Pct_Leave),\n          colour = \"white\",\n          lwd = 0.1) +\n  scale_fill_stepsn(\n    colors = c(\"bisque\", \"lightsalmon\", \"orangered\", \"red3\"),\n    breaks = c(50, 60, 70, 80),\n    labels = c(\"50%\", \"\", \"\", \"80%\"),\n    limits = c(50, 90),\n    name = \"Leave\",\n    na.value = \"gray87\", \n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 0.5,\n      direction = \"horizontal\",\n      title = \"Leave\",\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  geom_text(data = country_tag,\n            aes(x = longitude, y = latitude, label = country),\n            color = \"black\",\n            size = 2.5, fontface = \"bold\",\n            family = \"Lora\") +\n  theme_minimal() +\n  labs(title =                           \"How Britain Voted in the E.U. Referendum\",\n       x = NULL, \n       y = NULL, \n       fill = \"Should Britain remain in the European Union?\") +\n  theme(legend.title = element_text(size = 9),\n        plot.title = element_text(hjust = 0, vjust = 0.5, face = \"bold\"),\n        legend.position = c(0.15, 0.85),\n        text = element_text(family = \"DM Serif Display\",  size = 15),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.box.just = \"right\",\n        legend.key.size = unit(0.4, \"cm\"), \n        legend.text = element_text(size = 6),\n        legend.spacing.y = unit(0, \"cm\"))\nmap\n\n\n\nAs an extra point the coordinates of the map are expanded so that other plots can be added later in the design of the final plot\n\n\n# Expand coordinates of map\n\nexpanded_xmin <- -11.653038\nexpanded_xmax <- 4.382762\nexpanded_ymin <- 49.41625\nexpanded_ymax <- 61.529979\n\n# Modify coord_sf() to include expanded limits\nmap <- map +\n  coord_sf(xlim = c(expanded_xmin, expanded_xmax),\n           ylim = c(expanded_ymin, expanded_ymax))\n\nprint(map)\n\n\n\nAdding tags to the map\nThe code below seeks to generate a map visual using ggplot2, with additional annotations for selected cities. The cities data frame specifies the names, latitudes, and longitudes of several cities in the United Kingdom. Then, the “new” map (updated version of the previous one) is created by adding circles representing cities to the existing map (map). Each circle has a radius of 0.2 units, outlined in gray, and the city names are displayed at specified positions around their respective circles. The geom_text function is used to add city labels, adjusting the vertical and horizontal justification as well as font style and color for each city.\n\n\n#Cities annotations & coordinates\ncities <- data.frame(\n  city = c(\"London\", \"Manchester\", \"Cardiff\", \"Birmingham\", \"Edinburgh\", \"Liverpool\", \"Oxford\", \"Belfast\"),\n  latitude = c(51.509865, 53.4794, 51.4861, 52.479876, 55.9410, 53.3549, 51.750051, 54.5930),\n  longitude = c(-0.118092, -2.2437, -3.1801, -1.9058, -3.29181, -3.0104, -1.25386, -5.9381))\n\n#MAP + tags/circles\nmap1 <- map+\n  geom_circle(data = cities,\n              aes(x0 = longitude, y0 = latitude, r=0.2),  \n              stat= \"circle\",color = \"gray48\" , fill = NA, \n              size = 0.2)+ \n  geom_text(data = cities[c(2, 3, 4, 7), ], aes(x = longitude, y = latitude, label = city),\n            vjust = -2.5, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[c(1, 5), ], aes(x = longitude, y = latitude, label = city),\n            vjust = 3.6 , size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[6,], aes(x = longitude, y = latitude, label = city),\n            hjust = 1.3, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  geom_text(data = cities[8,], aes(x = longitude, y = latitude, label = city),\n            hjust = -0.5, size = 1.5, fontface = \"bold\", color = \"gray24\") +\n  theme(aspect.ratio = 1.15)\nmap1\n\n\n\nThe resulting map (map1) provides a visual representation of the geographical locations of these cities, enhancing the overall information conveyed by the map. Additionally, the theme function adjusts the aspect ratio of the map for better visual aesthetics.\nLondon close-up\nIn this chunk a zoomed-in version of a map is created using ggplot2. The locations data frame contains geographical coordinates (longitude and latitude) defining bounding boxes for several cities. The location variable specifies the city for which the user wants to generate a zoomed map. In the code, it’s set to “London,” but users can change it to other cities from the list. The code then extracts the longitude and latitude ranges (xlim and ylim) for the specified city from the locations data frame.\n\n\n# Locations dataframe with coordenates \nlocations <- data.frame(\n  rbind(\n    c(\"London\", -0.58913, 0.3520155, 51.2318741, 51.7167602),\n    c(\"Manchester\", -2.4034, -2.0937, 53.3794, 53.5501),\n    c(\"Cardiff\", -3.3124, -3.0971, 51.4461, 51.5521),\n    c(\"Birmingham\", -2.0450, -1.6958, 52.3538, 52.5578),\n    c(\"Edinburgh\", -3.3278, -3.0481, 55.8910, 55.9880),\n    c(\"Liverpool\", -3.0917, -2.8125, 53.3321, 53.4586),\n    c(\"Oxford\", -1.2994, -1.1280, 51.7149, 51.7984),\n    c(\"Belfast\", -5.9959, -5.8481, 54.6430, 51.5400)\n  ),stringsAsFactors = F)\n\nlocation <- \"London\" # Change the location as needed\n\n# Extract xlim and ylim values directly from the locations data frame\nxlim <- as.numeric(locations[locations[, 1] == location, c(2, 3)])\nylim <- as.numeric(locations[locations[, 1] == location, c(4, 5)])\n\n\nWith this now the extraction of the map is plotted and stored:\n\n\nzoomed_map1 <- map +\n  theme(legend.position = \"none\", plot.title = element_blank(),\n        panel.border = element_rect(color = \"black\", fill = NA, size = 1)) +\n  coord_sf(xlim = c(xlim[1], xlim[2]), ylim = c(ylim[1], ylim[2]), crs = 4326) +\n  theme(aspect.ratio = 1)\nzoomed_map1\n\n\n\nThe resulting zoomed_map1 is generated by adjusting the original map (map) with additional themes and coordinates. The adjustments include removing the legend, hiding the plot title, adding a black border to the map, and setting the aspect ratio to maintain the correct proportions. The coord_sf function is used to set the limits for the x and y axes based on the extracted ranges for the chosen city. The resulting map (zoomed_map1) provides a closer look at the specified city by zooming in on its geographical coordinates.\nRemain-Leave bar plot\nAfter having ready the base map we need to start creating the adjacent plots. This code generates a bar plot using ggplot2 in R to visualize the results of the Brexit referendum in different regions of the United Kingdom. The data frame df contains information about the population, “Remain” votes, and “Leave” votes for regions such as Britain, England, London, Scotland, Wales, and Northern Ireland. The factor levels of the “Region” variable are reordered for better visualization.\n\n\n# Create new data frame with the data\ndf <- data.frame(Region = c(\"Britain\", \"England\", \"London\", \"Scotland\", \"Wales\", \"N. Ireland\", \" \"),\n                 Pop_M = c(64.1, 53.0, 8.5, 5.3, 3.0, 1.8, NA),\n                 Remain = c(48, 47, 60, 62, 47, 56, NA),\n                 Leave = c(52, 53, 40, 38, 53, 44, NA))\n\n# Reorder levels of factor\ndf$Region <- factor(df$Region, levels = c(\"London\", \"N. Ireland\", \"Wales\", \"Scotland\", \"England\", \"Britain\", \" \"), ordered = is.ordered(df$Region))\n\n\nAgain, once the data is ready, it just needs to be plotted. The bar_plot is created by reshaping the data using the gather function to represent the “Remain” and “Leave” votes as separate bars for each region. The resulting plot shows a stacked bar chart where each region is divided into “Remain” and “Leave” segments. The code also includes text annotations for specific regions, emphasizing the vote percentages in key areas such as Northern Ireland, Scotland, and London.\nThe plot is then flipped horizontally (coord_flip()) for simulating the one in the reference graph (which is a horizontal plot), and custom themes and color scales are applied to enhance the visual representation. The plot includes two sets of text annotations within the stacked bars, highlighting regions like “N. Ireland,” “Scotland,” and “London” with specific vertical adjustments. Additional annotations label “REMAIN” and “LEAVE,” while the plot is customized with a minimal theme, flipped coordinates, color-filled bars for “Remain” and “Leave,” removal of grid lines, and a dashed horizontal line at 50% for reference, indicating the threshold between “Remain” and “Leave” outcomes.\n\n\n#plot bar plot\nbar_plot <- df |> \n  select(Region, Remain, Leave)  |> \n  tidyr::gather(key, VoteCount, -Region) |> \n  ggplot(aes(x = Region, y = VoteCount, fill = key)) +\n  geom_bar(stat = \"identity\") +\n  geom_text(aes(label = ifelse(Region %in% c(\"N. Ireland\", \"Scotland\", \"London\"), paste0(VoteCount, \"%\"), \"\")),\n            position = position_stack(vjust = c(0.4, 0.47)),\n            color = \"white\", fontface = \"bold\", size = 2) +\n  geom_text(aes(label = ifelse(Region %in% c(\"England\", \"Wales\", \"Britain\"), paste0(VoteCount, \"%\"), \"\")),\n            position = position_stack(vjust = c(0.5, 0.6)),\n            color = \"white\", fontface = \"bold\", size = 2) +\n  annotate(\"text\", x=6.7, y= 12, label = \"REMAIN\",  size = 2)+\n  annotate(\"text\", x=6.7, y= 90, label = \"LEAVE\", size = 2)+\n  labs(title = \"\",\n       x = \"\", y = \"\") +\n  theme_minimal() +\n  coord_flip() +\n  scale_fill_manual(values = c(\"Remain\" = \"dodgerblue4\", \"Leave\" = \"red3\"))+\n  theme(legend.position = \"none\",\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_text(face = \"bold\", color = \"black\", size = 6, hjust = 0, family = \"Lora\"))+\n  geom_hline(yintercept = 50, linetype = \"dashed\", color = \"white\", size=0.2)\nbar_plot\n\n\n\nLondon zoom-up lines\nTo make this plot closer to the reference plot dashed lines need to be added and connected to the zoomed-up map. he coordinates for the starting and ending points of each line are specified in the origin1, end1, origin2, and end2 vectors. They were manually chosen using a web that displays the coordenates of any point you might choose on a map.\nTwo data frames, line1 and line2, were then created to represent the coordinates of each line. The code builds on an existing map (map1) and uses the geom_segment function to add two dashed line segments to the map. The aesthetics define the starting and ending points of each segment using the x and y coordinates from the respective data frames. The color is set to “grey38,” the linetype to “dashed,” and the size to 0.13, resulting in two visually distinct dashed lines representing the specified segments.\n\n\n#LINE 1\norigin1 <- c(-0.090525, 51.757161)\nend1 <- c(1.904604, 52.578733)\n\n#LINE2\norigin2 <- c(-0.100525, 51.240399)\nend2 <- c(1.904604, 50.999038)\n\nline1 <- data.frame(x = c(origin1[1], end1[1]), y = c(origin1[2], end1[2]))\nline2 <- data.frame(x = c(origin2[1], end2[1]), y = c(origin2[2], end2[2]))\n\nmap2 <- map1 +\n  geom_segment(data = line1,\n               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),\n               color = \"grey38\", linetype = \"dashed\", size = 0.13) +\n  geom_segment(data = line2,\n               aes(x = x[1], y = y[1], xend = x[2], yend = y[2]),\n               color = \"grey38\", linetype = \"dashed\", size = 0.13)\nmap2\n\n\n\nThe resulting map, map2, displays the original map with the added line segments.\nPutting everything together\nIn order to put everything together the coordinates (xmin, xmax, ymin, ymax) are specified to determine the placement of the zoomed map within the combined plot, focusing on a specific region. Similarly, coordinates (xmin1, xmax1, ymin1, ymax1) are specified for the placement of the bar plot. The annotation_custom function is then used to add each individual plot as a custom annotation to the main map (map2).\n\n\n# Specify coordinates for the zoomed map\nxmin <- 1.5\nxmax <- 4.5\nymin <- 50.5\nymax <- 53\n\n#specify coordinates for the bar plot\nxmin1 <- -2\nxmax1 <- 5.5\nymin1 <- 55.5\nymax1 <- 60.5\n\n\nThe first annotation_custom call adds the zoomed map (zoomed_map1) to the specified region of the main map (map2). The second annotation_custom call adds the bar plot (bar_plot) to another specified region. The resulting plot, plot_w_addins, displays both the zoomed map and the bar plot in a single composite view. This approach allows for the juxtaposition of different visualizations within the same plot, providing a comprehensive overview of spatial and categorical information.\n\n\n# Combine the maps into one\ncombined_map <- annotation_custom(grob = ggplotGrob(zoomed_map1), \n                                xmin = xmin, xmax = xmax, \n                                ymin = ymin, ymax = ymax)\n\ncombined_bar <- annotation_custom(grob = ggplotGrob(bar_plot), \n                                  xmin = xmin1, xmax = xmax1, \n                                  ymin = ymin1, ymax = ymax1)\n\n\n# Create combination of all plots\nplot_w_addins <- map2 + combined_map + combined_bar\nplot_w_addins\n\n\n\nFinal annotations\nFinally, the big text annotations need to be added on top of everything else.\nFirst, geographical points and annotation texts related to specific regions are defined. Each set of points represents a geographic area (e.g., Scotland, London, Ireland, Wales), and the associated annotation_text provides information or context about that region in relation to the Brexit referendum\n\n\n#Scotland\npoint1 <- c(-0.666206, 55.598766)\npoint2 <- c(-2.456146, 56.080442)\npoint3 <- c(-0.59, 55.152745)\nannotation_text1 <- \"The Scottish first minister has said that a leave\\nvote could trigger a referendum vote in\\nScotland to leave Britain. Scots rejected\\nindependence in a referendum in September\\n2014 by 55 percent to 45 percent.\"\n\n#London\n\npoint4 <- c(1.930838, 53.06749)\nannotation_text2 <- \"London, along with Scotland,\\nled the vote to remain in the\\nEuropean Union, though the\\neast side of the city voted to\\nleave.\"\n\n#Ireland\npoint5 <- c(-7.84579, 55.970628)\npoint6 <- c(-6.506151, 55.300913)\npoint7 <- c(-11.220845, 56.260588)\nannotation_text3 <- \"Northern Ireland shares a\\ncompletely porous border with\\nIreland, which is in the\\nEuropean Union. Trade issues\\ncould arise between the two.\"\n\n#Wales\npoint8 <- c(-5.517893, 50.843996)\npoint9 <- c(-4.524143, 51.599867)\npoint10 <- c(-9.527097, 50.85646)\nannotation_text4 <- \"The majority of Wales voted\\nstrongly to leave, except for the\\nlargest city Cardiff, which voted to\\nremain by 60 percent.\"\n\n\nOverall, this code helps position annotations on a map to provide additional information about key regions and their stances during the Brexit referendum.\nAt last the final plot with the annotations:\nThe code uses geom_curve to draw curved arrows between specific points, creating visual connections on the map. The arrows are labeled with text annotations, conveying additional information about each region’s significance in the context of the Brexit referendum.\nThe annotations are positioned strategically using annotate(\"text\") along with specified coordinates for clarity. Additionally, the overall appearance of the plot is fine-tuned by adjusting the theme to minimize unnecessary elements, such as axis ticks and grid lines, and enhancing the overall aesthetics.\n\n\n#final plot\nplot_w_addins+\n  geom_curve(aes(x = point1[1], y = point1[2], xend = point2[1], yend = point2[2]),\n             curvature = 0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  geom_curve(aes(x = point5[1], y = point5[2], xend = point6[1], yend = point6[2]),\n             curvature = -0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  geom_curve(aes(x = point8[1], y = point8[2], xend = point9[1], yend = point9[2]),\n             curvature = 0.3,  # Adjust curvature as needed\n             arrow = arrow(length = unit(0.05, \"cm\")),  # Add an arrow at the end\n             color = \"gray51\") +\n  annotate(\"text\", x = point3[1], y = point3[2],\n           label = annotation_text1, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point4[1], y = point4[2],\n           label = annotation_text2, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point7[1], y = point7[2],\n           label = annotation_text3, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  annotate(\"text\", x = point10[1], y = point10[2],\n           label = annotation_text4, size = 1.7, color = \"black\", family = \"Lora\", hjust = 0) +\n  theme_minimal()+\n  theme(legend.title = element_text(size = 9),\n        plot.title = element_text(hjust = 0, vjust = 0.5, face = \"bold\"),\n        legend.position = c(0.15, 0.85),\n        text = element_text(family = \"DM Serif Display\",  size = 15),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        axis.ticks = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.direction = \"horizontal\",\n        legend.box = \"vertical\",\n        legend.box.just = \"right\",\n        legend.key.size = unit(0.4, \"cm\"), \n        legend.text = element_text(size = 6),\n        legend.spacing.y = unit(0, \"cm\"))\n\n\n\nThe legend.position parameter determines the location of the legend, placing it slightly to the right and towards the top of the plot. The text parameter specifies the font family as “DM Serif Display” with a font size of 15, ensuring a consistent and aesthetically pleasing text style throughout the plot. Additionally, various elements such as axis labels, titles, ticks, and grid lines are removed using element_blank(), contributing to a clean and uncluttered layout.\nThe legend is configured to be horizontal (legend.direction), and its box is styled to be vertical with justification to the right (legend.box and legend.box.just). Further customization includes adjusting the size of legend keys (legend.key.size), text size within the legend (legend.text), and eliminating vertical spacing between legend items (legend.spacing.y). Collectively, these theme settings enhance the plot’s readability, maintain a coherent design, and prioritize the display of essential information.\nLimitations\nSome key limitations of this graph are the legend and the zoomed-up map. In the original map the legend was created with another program and with R this is the closest I could manage to get after making a few adjustments. Regarding the zoomed up map I tried different methods like buffer or ggmapinset, but given the structure of my data and layers I was not able to make the zoomed-up map round.\nIs there an alternative way?\nThe remaining library that would be needed:\n\n\nlibrary(htmltools)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(sp)\n\n\nThe data should be loaded again and the data for Northern Ireland should be manually loaded again just like for the previous map:\n\n\n#csv\nreferendum <- read_csv(\"EU-referendum-result-data.csv\")\n#UK shapefile\nuk_shp <- read_sf(\"maps/uk_constituencies_2016.shp\")\n\n#modifications for merging\nreferendum <- referendum |> \n  rename(area_code = Area_Code)\n\n#merge\nbrexit_data <- left_join(uk_shp, referendum, by = \"area_code\")\n\n#West Tyrone ...\n#brexit_data$Pct_Turnout[18] <- 61.8\n#brexit_data$Remain[18] <- 26765\n#...\n\n\nThen the cleaned data should be reprojected into WGS84\n\n\n#Reproject data to WGS84\nbrexit_data <- st_transform(brexit_data, 4326)\n\n\nSubsequently, the brexit_data dataframe is being modified with a new variable called margin. This variable is calculated as the absolute difference between the columns Pct_Remain and Pct_Leave. The mutate function from the dplyr package is used to create this new column.\nThen, the range function is applied to the margin variable within the brexit_data dataframe. The range function returns the minimum and maximum values of a numeric vector. In this context, it calculates the minimum and maximum values of the margin variable. The na.rm = TRUE argument is included to exclude any missing values (NA) when determining the range.\n\n\n#min_max values\nbrexit_data <- mutate(brexit_data, margin = abs(Pct_Remain - Pct_Leave))\nmin_max_values <- range(brexit_data$margin, na.rm = TRUE)\n\n\nAfter that is done a colour palette for the plotted map must be created. This colour palette will take the lightest colour for the smallest number of the margin between votes.\n\n\n#colour palette \n\nleave_palette <- colorNumeric(palette = \"Reds\", domain=c(min_max_values[1], min_max_values[2]))\nremain_palette <- colorNumeric(palette = \"Blues\", \n                               domain=c(min_max_values[1], min_max_values[[2]]))\n\n\nThis code is creating two color palettes, leave_palette and remain_palette, for visualizing the margin between “Pct_Remain” and “Pct_Leave” in a graphical representation. The colorNumeric function is used from the leaflet package, and it allows for the creation of a color palette based on a numeric range.\nThe palette argument specifies the color scheme, with “Reds” for leave_palette and “Blues” for remain_palette. The domain argument sets the range of values for which colors will be assigned. In this case, the range is determined by min_max_values[1] (minimum) and min_max_values[2] (maximum), which were calculated in the previous code block as the minimum and maximum values of the absolute margin between “Pct_Remain” and “Pct_Leave”. The color palettes will be used later for mapping and visualizing the data, with lighter colors representing smaller margins and darker colors representing larger margins.\nFor this visualization, two different dataframes are needed, so they are created in the same way as in the previous plot:\n\n\n# Making a winner column\nbrexit_data <- mutate(brexit_data, winner = if_else(Pct_Remain > Pct_Leave, \"Remain\", \"Leave\"))\n\n#Creating two different data frames\nleave_df <- brexit_data[brexit_data$winner == \"Leave\",]\nremain_df <- brexit_data[brexit_data$winner == \"Remain\",]\n\n\nAlso, in order to have popups for each district to be used in conjunction with the leaflet map, they have to be previously set:\nThis chunk is creating HTML-formatted popups for map markers in a geographic visualization. The popups provide information about the voting results for different areas, particularly focusing on the “Leave” and “Remain” campaigns in the context of the Brexit referendum.\n\n\n#Create a popup\n\nleave_popup <- glue(\"<strong>{leave_df$area_name} AREA<\/strong><br />\n                    <strong>winner: Leave<\/strong><br />\n                    Leave: {scales::comma(leave_df$Pct_Leave, accuracy = 1)}<br />\n                    Remain: {scales::comma(leave_df$Pct_Remain, accuracy = 1)}<br />\n                    Margin: {scales::comma(leave_df$margin, accuracy = 1)}\")  %>%   \n  lapply(htmltools::HTML)\nremain_popup <- glue(\"<strong>{remain_df$area_name} AREA<\/strong><br />\n                      <strong>winner: Remain<\/strong><br />\n                      Remain: {scales::comma(remain_df$Remain, accuracy = 1)}<br />\n                      Leave: {scales::comma(remain_df$Leave, accuracy = 1)}<br />\n                      Margin: {scales::comma(remain_df$margin, accuracy = 1)}\")  %>%   \n  lapply(htmltools::HTML)\n\n\nFor the “leave_popup,” the information includes the area name, the winning campaign (“Leave”), the percentage of votes for “Leave,” the percentage of votes for “Remain,” and the margin between the two. The glue function is used to dynamically insert values from the leave_df dataframe into an HTML template. The lapply function is then applied to convert the resulting string into an HTML object.\nSimilarly, for the “remain_popup,” the information includes the area name, the winning campaign (“Remain”), the percentage of votes for “Remain,” the percentage of votes for “Leave,” and the margin between the two. The glue function is again utilized to create an HTML-formatted string, and lapply converts it into an HTML object.\nLastly, the background for the map is set and the map is plotted:\n\n\n#Set the background of the map\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\")\n\n\n\nThis code above uses the leaflet R package to create an interactive map, and it sets the background map tiles to be provided by CartoDB with a Positron theme. The leaflet() function initializes a new leaflet map, and addProviderTiles(\"CartoDB.Positron\") adds the specified map tiles from CartoDB’s Positron theme as the background to the leaflet map. This provides a clean and visually appealing base map for further layers and data visualization on the leaflet map.\n\n\n#Then we overlay the data\n\nleaflet() %>%\n  addProviderTiles(\"CartoDB.Positron\") %>%\n  addPolygons(\n    data = leave_df,\n    fillColor = ~leave_palette(leave_df$margin),\n    label = leave_popup,\n    stroke = TRUE,\n    smoothFactor = 0.2,\n    fillOpacity = 0.8,\n    color = \"#666\",\n    weight = 1\n  ) %>%\n  addPolygons(\n    data = remain_df,\n    fillColor = ~remain_palette(remain_df$margin),\n    label = remain_popup,\n    stroke = TRUE,\n    smoothFactor = 0.2,\n    fillOpacity = 0.8,\n    color = \"#666\",\n    weight = 1\n  )\n\n\n\nThe previous code just overlays a map on a cartographic base layer using CartoDB’s Positron tiles.\nThe addPolygons function is then used to overlay polygons on the map, representing geographical areas. Two sets of polygons are added to the map, corresponding to the leave_df and remain_df datasets, each with specific styling. The fillColor parameter is set dynamically using color palettes (leave_palette and remain_palette) based on the margin values in each dataset. This creates a choropleth map where different shades of color represent different margins between Leave and Remain votes in each geographic area.\nAdditionally, the label parameter is used to create pop-up labels for each polygon, displaying relevant information such as the area name, the winning side (Leave or Remain), individual vote percentages, and the margin. The map is designed to be interactive, allowing users to explore the data by hovering over each area and viewing the associated information. The stroke, smoothFactor, fillOpacity, color, and weight parameters are set to control the appearance of the polygons, ensuring a visually informative and aesthetically pleasing map.\nAnd with this we have an alternative interactive map to visualize the data!!\n\n\n\n",
    "preview": "projects/2023/100408925/100408925_files/figure-html5/unnamed-chunk-19-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1435
  },
  {
    "path": "projects/2023/100481838/",
    "title": "We Feel It Already. How About We Visualize It?",
    "description": "Summer temperatures are getting hotter and this plot does a pretty good job at showing that.",
    "author": [
      {
        "name": "Mikaela DeSmedt",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe plot in question: the story and how it’s told\nVisual encoding\nOther elements\n\nReplication\nOriginal and tidy data\nBase plot\nAnnotations\nBreaking it by periods\nReference area\nAnimation\n\nEnhancement\nEnhancement 1: Ridgelines\nEnhancement 2: Facets\n\n\nIntroduction\nResearchers have found that summer temperatures have shifted drastically since the mid-20th century. An eerie discovery that points to the frightening reality that temperatures in the warmer season of the year are now hot or extremely hot in comparison what they were 40 years ago.\nOriginal chart from NYT websiteThe aim of this tutorial is to analyze the visual encoding and replicate this chart. The final section also proposes additional improvements.\nThe plot in question: the story and how it’s told\nThe following chart uses data from retired NASA climate scientist James Hansen to show how summer temperatures have shifted toward more extreme heat over the past several decades.\nThis representation uses bell curves to compare the distribution in the frequency of occurrence of temperature anomalies (y-axis) divided by local standard deviation for the 1951-1980 period (x-axis) obtained by binning all local results for the indicated region and 11-year period into 0.05 frequency intervals. Additionally, this chart is presented along an animation which shows the transition of all recorded periods.\nIn essence, what this chart aims to communicate is the shift in the distribution of temperatures towards a higher occurrence of hotter temperatures. So, lets take a look at visual encoding it uses to do so…\nREMINDER: Visual encoding is the way in which data items and their attributes are mapped to visual structures such as marks and channels. Taking them From data items (observations, rows) to visual marks and from data attributes (variables, columns) to visual channels\nVisual encoding\nOur raw data consists on rows representing anomalies in recorded temperatures ranging from -6 to +6 in 0.05 intervals. The attributes of these data include the frequency of occurrence of these anomalies and the period in which they were recorded. The visual elements used to map the data are as follow\nVisual mark: area - the shape of the distribution of occurrence in temperature anomalies\nVisual channel (identity): color - determining which anomalies are to be regarded as extremely cold, cold, normal, hot or extremely hot along the X-axis.\nOther elements\nIn order to further the expressive capabilities of these chart, the original authors included further explanatory elements such as tittle and subtitle, text labels and a legend, as well as reference elements such as a reference area that allows comparison with the baseline period and reference lines which emphasize the limits of each temperature group.\nOriginal chart from NYT website marked-up to list additional elements and annotationsReplication\nOriginal and tidy data\nThe authors behind the publication that inspired this chart post data and visualizations of their own in this website http://www.columbia.edu/~mhs119/PerceptionsAndDice/\nFrom here, we download the ‘shifted data’ table named Data: N.H. Land, Jun-Jul-Aug. Which when imported to R is visualized as follows:\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\nccdata<- tibble(read.table(\n  file = \"http://www.columbia.edu/~mhs119/PerceptionsAndDice/NH.JJA.11yrs.txt\", \n  header = TRUE,\n  skip = 1))\n\nwrite.csv(ccdata, \"ccdata.csv\", row.names = FALSE)\n\nhead(ccdata)\n\n# A tibble: 6 × 5\n  anoms.S X1980.1990 X1991.2001 X2002.2012 X2013.2023\n    <dbl>      <dbl>      <dbl>      <dbl>      <dbl>\n1   -6             0          0          0          0\n2   -5.95          0          0          0          0\n3   -5.9           0          0          0          0\n4   -5.85          0          0          0          0\n5   -5.8           0          0          0          0\n6   -5.75          0          0          0          0\n\nIn the author’s website they also make available a visualization of the data which tells the same story as the chart in the NYT post, but dispensing of animation or other aesthetics. This serves us to ‘reverse engineer’ our way into understanding the structure our data must follow for us to be able to replicate it using Ggplot.\nFigures in Warm/Cool Dice Colors [for Northern Hemisphere Land]Note: The data published in the author’s site has been updated since the publication of the NYT article. Hence, the data used to replicate this chart is slightly different to the original.\nFrom looking at the first few rows of ‘ccdata’ we can already tell the first step will be to ‘tidy’ this dataset. The second step then, will be to categorize our anomalies into the four groups seen in the NYT post. Our data has temperature anomalies ranging from -6 to +6. we need to create a categorical variable that labels these anomalies from extremely cold to extremely hot. Following these two steps will yield a ‘tidy’ dataset with all the attributes we need our data to have.\n\n\nccdata <- ccdata |> \n  drop_na(anoms.S)\n\n#tidy up dataset \nlongdata <- ccdata |> \n  pivot_longer(cols = \n                 c(X1980.1990, \n                   X1991.2001, \n                   X2002.2012, \n                   X2013.2023), \n               names_to = \"period\") |> \n  mutate(\"period\" = str_sub(period, 2)) |> \n  \n#create temperature type variable\n  mutate(\"temptype\" = case_when(\n         anoms.S < -3 ~ \"Extremely cold\",\n         anoms.S >= -3 & anoms.S < -0.5 ~ \"Cold\",\n         anoms.S >= -0.5 & anoms.S <= 0.5 ~ \"Normal\",\n         anoms.S > 0.5 & anoms.S <= 3 ~ \"Hot\",\n         anoms.S > 3 ~ \"Extremely hot\"))\n\nhead(longdata)\n\n# A tibble: 6 × 4\n  anoms.S period    value temptype      \n    <dbl> <chr>     <dbl> <chr>         \n1   -6    1980.1990     0 Extremely cold\n2   -6    1991.2001     0 Extremely cold\n3   -6    2002.2012     0 Extremely cold\n4   -6    2013.2023     0 Extremely cold\n5   -5.95 1980.1990     0 Extremely cold\n6   -5.95 1991.2001     0 Extremely cold\n\nNow with the data as we want it, we can head on and start with our graph.\nBase plot\nI have broken down the code of my base plot in four steps\nAs a first step we degine our ggplot() function. This sets up the basic structure of the plot function. It specifies the data (longdata) and aesthetic mappings for the x-axis (anoms.S), y-axis (value), and fill color (temptype). But up to this line, we are left only with an x and a y axis and no markings within it.\nSecondly, we must define our geom, which is this case is geom_area(). This adds an area plot to the ggplot with options specifying that the data is in identity form, the stacking position, the number of bins. Note here that the legend argument has been set to false this is because we wish to add it later on as a separate item.\nThird, we style our plot. using scale_fill_manual() we set the fill colors for different levels of the ‘temptype’ variable using their codes in hexadecimal format.\nIn this step we determine the size of our X-axis using xlim() and we use theme_void() to set the theme of the plot to a blank/void , essentially removing any axes, labels, or background elements.\n\n\nbaseplot<- \n  longdata |> \n  ggplot(aes(x = anoms.S, \n             y = value, \n             fill = temptype)) + \n#2. Adding the geom which will map our data \n  geom_area(stat = \"identity\", \n                 position = \"stack\", \n                 bins = 30,\n                 show.legend = FALSE) \n\n#3. Custom colors\n##saving custom colors to save space later down the road\ncustomcolors <- c(\"Extremely cold\"=\"#085b84\", \n                                 \"Cold\" = \"#54a5ba\",\n                                 \"Normal\" = \"#dfdfdf\", \n                                 \"Hot\" = \"#eb8550\",\n                                 \"Extremely hot\" = \"#cc2821\")\n\nbaseplot<- baseplot +\n  scale_fill_manual(values = customcolors) +\n  \n#4. Axis limits and theme\n  xlim(c(-6, 6))+\n  theme_void()\n\nbaseplot\n\n\n\nAt this point, out plot has the general shape we want it to have. But it still needs additional elements to help us understand what is going on.\nAnnotations\nTo our baseplot we need to add all the explanatory elements such as labels, tittles, legend and others. So lets take a look at the code for that.\nTittle and subtitle\nThis element was added using the labs function which sets these elements for the plot.\n\n\nbaseplot <- \nbaseplot +\n#Tittle and subtittle + the color we want it to have\n  labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\"),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015))\n\n\nLegend and period lable\nWe will add our legend using the annotate function which essentially allows us to add text annotation freely along the plot. For example, consider the line\nannotate(\"text\", x=0, y=-0.04, label= \"Normal\", color = \"#999999\", fontface = 2)\nThis annotates the plot with the text “Normal” at coordinates (0, -0.04) with a gray color and bold fontface. We have done this for all temperature types.\nSimilarly, using this same function, we will add a label for the corresponding period of the plot. As this baseplot is set to consider all our data the period it corresponds to is from 1980 to 2023.\n\n\n#Leged by annotations\n  \nbaseplot +\n  annotate(\"text\", \n           x=0, \n           y=-0.04, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.04, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.04, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.04, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=5, \n           y=-0.04, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2)+\n    annotate(\"text\", \n           x=4, \n           y= 1, \n           label= \"1980-2023\", \n           color = \"black\",\n           size = 10,\n           fontface = 10)\n\n\n\nReference lines\nWe also have reference lines showing the limits of each temp type in the baseline period. We have added these using geom_vline() and setting the places where we want it to intercept the x axis in xintercept, the line type and the color we want it to be.\n\n\nbaseplot<- \n  baseplot +\n  geom_vline(xintercept = c(-3, -0.5, 0.5, 3), \n             linetype = \"dashed\", \n             color = \"gray\")\n\nbaseplot\n\n\n\nNow our chart has almost all the elements it needs. But it still not quite as we want it to be because it doesn’t yet tell the story.\nBreaking it by periods\nOur baseplot is good for showing all the elements that go into the making of our chart. However, we still need this to be made for each of the period we have data for. We can easily do this by filtering our data using the filter function before our ggplot() fucntion as follows\nplot1980.1990<- longdata |> filter(period == \"1980.1990\") |> ggplot(...\nNote: Creating these plots also needs us to adjust the coordinates in the labels. I’m also setting a ylim() argument to make this standard through all plots.\nThe following chunk shows this example for the period of 1980 to 1990.\n\n\nplot1980.1990<-\nlongdata |> \n  filter(period == \"1980.1990\") |> \n  ggplot(aes(x = anoms.S, \n               y = value, \n               fill = temptype)) + \n    geom_area(stat = \"identity\", \n                   position = \"stack\", \n                   bins = 30,\n                   show.legend = FALSE)+\n  scale_fill_manual(values = customcolors)+\n  xlim(c(-6, 6))+    \n    theme_void()+\n  annotate(\"text\", \n           x=3, \n           y= 0.35, \n           label= \"1980-1990\", \n           color = \"black\",\n           size = 10,\n           fontface = 10)\n\n\nOnce that is done, we can add a few more annotations are needed. Namely those that are placed together with an arrow or another visual element. For this we use the function geom_segment and indicate its positioning with x y coordinates as we have done for text annotations.\n\n\n#We save the new lables as a function in order to reuse\nperiod_annotations <- function(plot){\n  plot + \n  #chart aesthetics\n    scale_fill_manual(values = customcolors)+\n    xlim(c(-6, 6))+    \n    theme_void()+\n  #title and subtitle \n    labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n    theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\"),\n          plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015))+\n  #Reference lines\n    geom_vline(xintercept = c(-3, -0.5, 0.5, 3), \n             linetype = \"dashed\", \n             color = \"gray\")+ \n   #Legend\n     annotate(\"text\", \n           x=0, \n           y=-0.02, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.02, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.02, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.02, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2)+\n  annotate(\"text\", \n           x=5, \n           y=-0.02, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2)+\n  #Other annotatins\n    geom_segment(\n    x = -4.2, \n    y = 0.05,          \n    xend = -4.2, \n    yend = 0.1,\n    color = \"#999999\",\n    arrow = arrow(length = unit(0.2, \"cm\"), \n                  ends = \"last\", \n                  type = \"closed\"))+\n  annotate(\"text\", \n           x= -4.2, \n           y= 0.03, \n           label= \"More frequent\", \n           color = \"#999999\")\n}\n\n#We apply the function to the plot to save the layers\nplot1980.1990<- period_annotations(plot1980.1990) \n\nplot1980.1990\n\n\n\nOnce we have that down, we can do it for all the other periods.\n\n\n\nIn these 4 plots we can already see the shift tha the original plot communicates. But again a key element will help show that better.\nReference area\nAlong the animaion, the original plot maintains a reference area filled by a lined pattern in order to show the difference in the distribution of the baseline period and all those which follow. For this, we need to create another layer on our plots.\nFirst, I’m creating a data frame with data for the shadow along using the filter function.\n\n\ndf.shadow<-\n  longdata |> \n  filter(period == \"1980.1990\")\n\n\nThe code for the shadow is as follows. Here I’m applying it over the plot1991.2001 object so we can see the reference area. Here, it now makes sense to include one annotation I had previously disregarded as it points to the reference area.\n\n\nreferenceshadow<- function(plot){\n  plot +\n  ggpattern::geom_area_pattern(data = df.shadow,\n                               stat = \"identity\", \n                 position = \"stack\", \n                 show.legend = FALSE,\n                 pattern = \"stripe\",\n                 pattern_density = 0.2,\n                 pattern_fill = \"#999999\",\n                 pattern_colour = \"#999999\",\n                 alpha = 0.09,\n                 pattern_size = 0.01,\n                 pattern_spacing = 0.01,\n                 pattern_linetype = 1)+\n  #'base period' annotation\n   geom_segment(\n    x = -1.6, \n    y = 0.11,          \n    xend = -2.1, \n    yend = 0.11,\n    color = \"#999999\")+\n  annotate(\"text\", \n           x= -3, \n           y= 0.12, \n           label= \"1980-1990\",\n           size = 3,\n           color = \"#999999\")+\n  annotate(\"text\", \n           x= -3, \n           y= 0.1, \n           label= \"Base period\",\n           size = 2.6,\n           color = \"#999999\")\n}\n\nreferenceshadow(plot1991.2001)\n\n\n\nHere is how it looks when applied to all plots.\n\n\n\nAnimation\nI redefined our baseplot to have a ylim that would be suiting to all time periods and have the lables and fons sizes adjusted accordingly. This new plot I named thewholething as it includes all the elements previously discussed in this post.\nUsing the function transition_states from the gganimate(). For the animation it’s actually not necessary to make an individual plot for each time period. Rather, we can define that we want our variable period to be what determines our transition states. The result is as follows\n\n\nlibrary(gganimate)\nlibrary(gifski)\n\n\n# Animate the plots\nanim <- thewholething + \n  transition_states(longdata$period,\n                    transition_length = 2,\n                    state_length = 1)\n\n\nanimate(anim)\n\n\n\nEnhancement\nThe main thing I’d like to improve in this plot is being able to tell the same story but without having to rely on the animation. I would like for this plot to be able to tell us that temperatures are getting hotter every decade from the first look.\nSo I have proposed 2 enhacements.\nEnhancement 1: Ridgelines\nThe first one involve changing the geom we use to geom_ridgeline_gradient.\n\n\nlibrary(ggridges)\n\n#enhancement1<-\n  longdata |> \n   ggplot(aes(y=value, \n               x=anoms.S,\n              height = value,\n              group = period,\n              fill = temptype)) +\n    geom_ridgeline_gradient(show.legend = FALSE)+\n    scale_fill_manual(values = c(\"Extremely cold\"=\"#085b84\", \n                               \"Cold\" = \"#54a5ba\",\n                               \"Normal\" = \"#dfdfdf\", \n                               \"Hot\" = \"#eb8550\",\n                               \"Extremely hot\" = \"#cc2821\"))+\n  theme_void()+\n  xlim(-8,8)+\n  annotate(\"text\", \n           x=0, \n           y=-0.04, \n           label= \"Normal\", \n           color = \"#999999\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=-5, \n           y=-0.04, \n           label= \"Extremely Cold\", \n           color = \"#085b84\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=-1.8, \n           y=-0.04, \n           label= \"Cold\", \n           color = \"#54a5ba\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=1.8, \n           y=-0.04, \n           label= \"Hot\", \n           color = \"#eb8550\",\n           fontface = 2,\n           size = 6)+\n  annotate(\"text\", \n           x=5, \n           y=-0.04, \n           label= \"Extremely Hot\", \n           color = \"#cc2821\",\n           fontface = 2,\n           size = 6)+\n    geom_segment(\n        x = -4.2, \n        y = 0.12,          \n        xend = -4.2, \n        yend = 0.3,\n        color = \"#999999\",\n        arrow = arrow(length = unit(0.2, \"cm\"), \n                      ends = \"last\", \n                      type = \"closed\"))+\n  annotate(\"text\", \n           x= -4.2, \n           y= 0.09, \n           label= \"More frequent\", \n           color = \"#999999\",\n           size = 4)+\n    labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\",\n                                  size = 20),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015,\n                                     size = 15))\n\n\n\nWith this alternative plot we are able to visualize the shift in the distribution of temperatures without relying on the animation. However, having all the data clustered up in the same space might not be the most efficient way of showing the shift with as much emphasis as we would like.\nEnhancement 2: Facets\nFor the second enhacement, I consider the use of facets.\n\n\nenhancement2<- \n  longdata |> \n  ggplot(aes(x = anoms.S, \n             y = value, \n             fill = temptype)) + \n#2. Adding the geom which will map our data \n  geom_area(stat = \"identity\", \n                 position = \"stack\", \n                 bins = 30) +\n#3. \n  scale_fill_manual(values = c(\"Extremely cold\"=\"#085b84\", \n                               \"Cold\" = \"#54a5ba\",\n                               \"Normal\" = \"#dfdfdf\", \n                               \"Hot\" = \"#eb8550\",\n                               \"Extremely hot\" = \"#cc2821\"),\n                    breaks = c(\"Extremely cold\", \n                               \"Cold\", \"Normal\", \n                               \"Hot\", \n                               \"Extremely hot\"),\n                    name = NULL) +\n#4. Axis limits and theme\n  xlim(c(-6, 6))+\n  ylim(c(-0.15,0.4))+\n  theme_void()+\n#Tittle and subtittle + the color we want it to have\n  labs(title = \"Summer temperatures\",\n       subtitle = \"in the Northern Hemisphere\") +\n  theme(plot.title = element_text(color = \"black\",\n                                  hjust = 0.015,\n                                  face = \"bold\",\n                                  size = 20),\n        plot.subtitle = element_text(color = \"gray\",\n                                     hjust = 0.015,\n                                     size = 15),\n        strip.text = element_text(hjust = 0.09, \n                                  vjust = 0,\n                                  size = 15),\n         legend.position = \"bottom\")+\n  facet_wrap(~ period, \n             nrow = 4, \n             ncol = 1,\n             scales = \"free_x\")\n  \n  \nenhancement2\n\n\n\nIn this alternative plot, each period is allocated on their ‘own’ X-axis and distributed vertically. This allows for the visual comparison of the distribution to be faster for our readers.\n\n\n\n",
    "preview": "projects/2023/100481838/100481838_files/figure-html5/first_plot_with_shadow-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100483064/",
    "title": "The Evolution of the US Military Deployment",
    "description": "Visualising data on the evolution of the US military presence around the world\nfrom 1950 to 2020.",
    "author": [
      {
        "name": "Clara Fernanda Martín-Villaescusa",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nReplication process\nGetting and cleaning data\n\nBuilding the graph\nTheme\nGraph\nAnnotations and replicated graph\n\nAlternative visualization\nLimitation of stacked areas\nPreparing data\nCreating the alternative graph\n\n\nIntroduction\nThe original graph\nThe international analysis media El Orden Mundial published this graph in order to visualise “la evolución de la presencia militar de Estados Unidos en el mundo desde 1950”. This graph was made possible thanks to research data from the scientific journal Conflict Management and Peace Science. It highlights the most critical points of the US military deployment:\nBetween 1950 and 1990, the United States never had fewer than 400,000 troops outside its borders, with the Korean and Vietnam Wars marking particularly critical points in this process.\nAfter the fall of the Berlin Wall and the collapse of the USSR, military deployment dropped to 200,000.\nFollowing the 9/11 attacks, Washington attacked Afghanistan (20019 and Iraq (2003), where it is estimated that at least 2.3 million US troops have served in both countries since they were invaded.\nIn addition, the graph shows the continued presence of US troops around the world. The countries where most US troops are concentrated are Japan, where there are still more than 53,000 troops, Germany and South Korea, where there are around 34,000 and 26,400, respectively. Puerto Rico and the United Kingdom are other states where there are more bases and soldiers. These countries are not in close conflict but are fully aligned with US interests at the international level because they are protected by the United States.\nThe aim of this tutorial is to reproduce the graph and propose an alternative visualization using the same dataset.\nLa evolución del despliegue militar de EE.UU. Fuente: El Orden Mundial\n\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(troopdata)\nlibrary(dplyr)\n\nsysfonts::font_add_google(\"Outfit\", family=\"outfit\")\nshowtext::showtext_auto()\n\n\nReplication process\nGetting and cleaning data\nThe database is quite complete, in it we can see both the number of military bases and the number of US soldiers in each country and region from 1950 to 2020. First we have organised the database, putting the same identification code for the Republic of Vietnam and Vietnam, among other details. In addition to translating the name of the regions into Spanish.\n\n\ntroopdata <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(ccode = ifelse(ccode == 260, 255, ccode),\n         ccode = ifelse(countryname == \"Republic of Vietnam\", 816, ccode),\n         iso3c = ifelse(countryname == \"Republic of Vietnam\", \"VNM\", iso3c),\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\",\n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\"))\n\n\nIf you look at the graph, there are countries that are highlighted in other colours than those of their region, because in these countries the presence of US soldiers was much higher than in other countries. For instance, Germany, Vietnam or Japan.\nI will make a database without these countries, so that they are not counted twice afterwards.\n\n\ndelete <- c(\"Germany\", \n              \"West Germany\", \n              \"German Democratic Republic\", \n              \"Vietnam\", \n              \"Japan\", \n              \"South Korea\", \n              \"Iraq\")\n\nno_countries <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\", \n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\")) |> \n  filter(!(countryname %in% delete))\n\n\nSo, now we have two databases: one with regions and highlighted countries, and another without the highlighted countries. With these, we will proceed to form the necessary data frame for replicating the graph.\nRegion data\nI do the region data with troopdata without the highlighted countries.\n\n\nregional.data <- no_countries |> \n  group_by(region, year) |>  \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |>  \n  filter(region != 'Afloat') |> \n  filter(region != 'North America') \n\n\nregional.data <- subset(regional.data, year <= 2020)\n\nregional.data$region <- factor(regional.data$region , \n                               levels= c(\"Europa y Asia Central\", \n                                         \"África Subsahariana\", \n                                         \"Asia Oriental y Oceanía\", \n                                         \"Latinoamérica y Caribe\", \n                                         \"Asia Meridional\", \n                                         \"Oriente Próximo y Magreb\"))\n\n\nCountry data\nHere are only the highlighted countries. Germany is recategorised because there are several germanies in the database.\n\n\ncountry.data <- troopdata |>\n  filter((grepl(\"Vietnam\", countryname)) | \n           grepl('Germany', countryname) | \n           grepl (\"South Korea\", countryname) | \n           grepl (\"Japan\", countryname) | \n           grepl (\"Iraq\", countryname)) |>\n  mutate(countryname = ifelse(countryname == \"Republic of Vietnam\", \"Vietnam\", countryname),\n            countryname = ifelse(countryname == \"West Germany\", \"Germany\", countryname),\n         countryname = ifelse(countryname == \"German Democratic Republic\", \"Germany\", countryname))|>\n  group_by(countryname, year) |>  \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |>\n  mutate(countryname = factor(countryname, \n                              levels = c(\"Iraq\", \"Japan\", \n                                         \"South Korea\", \"Vietnam\",\n                                         \"Germany\", \n                                         setdiff(unique(countryname),\n                                                 c(\"Iraq\", \"Japan\",\n                                                   \"South Korea\",\n                                                   \"Vietnam\",\n                                                   \"Germany\")))))\n\ncountry.data$countryname <- factor(country.data$countryname , \n                                   levels=rev(c(\"Germany\",\n                                                \"Vietnam\",\n                                                \"Japan\",\n                                                \"South Korea\",\n                                                \"Iraq\")))\n\n\nCombination of region and country\nOnce we have both data frames (with and without the highlighted countries), we put them together in order to manipulate the data for the highlighted countries and the regions without the featured countries.\n\n\ncombined_data <- bind_rows(\n  mutate(regional.data, data_type = \"region\"),\n  mutate(country.data, data_type = \"country\"))\n\ncombined_data <- bind_rows(regional.data, country.data)\n\ncombined_data <- combined_data |> \n  pivot_longer(cols = c(region, countryname), names_to = \"tipo\", values_to = \"region_country\")\n\n\nWe order the categories so that the areas are stacked correctly on the graph.\n\n\ncombined_data$region_country <- factor(combined_data$region_country , \n                                       levels = c(\"Latinoamérica y Caribe\", \n                                                  \"África Subsahariana\",\n                                                  \"Iraq\", \n                                                  \"Oriente Próximo y Magreb\", \n                                                  \"Asia Meridional\",\n                                                  \"South Korea\",\n                                                  \"Japan\",\n                                                  \"Vietnam\",\n                                                  \"Asia Oriental y Oceanía\", \n                                                  \"Germany\",\n                                                  \"Europa y Asia Central\"))\n\n\nBuilding the graph\nTheme\nAn important part to replicate this graph, in the THEME, as it is the skeleton of any graph. For this, I created my own theme. Where first we adjust everything related to the texts that appear in the graphic (Title, Subtitle, Caption), then everything related to the axes, and the background of the graphic itself and finally the style of the legend.\n\n\ntheme_ok <- theme(text = element_text(family=\"outfit\", \n                                      size = 25),\n  plot.title = element_text(face = \"bold\", \n                            size = 45),\n  plot.subtitle = element_text(face = \"bold\", \n                               color = \"gray38\",\n                               size = 34),\n  plot.title.position = \"plot\",\n  plot.caption = ggtext::element_markdown(\n    size = rel(1.2),\n    hjust = 0,\n    margin = margin(0, 0, 0, 0),\n    lineheight = 0.2),\n  plot.caption.position = \"plot\",\n  strip.background = element_rect(fill = \"gray80\", \n                                  color = \"black\"),\n  panel.background = element_rect(fill = \"white\"),\n  strip.text = element_text(color = \"black\", \n                            face = \"bold\"),\n  panel.grid.major.y = element_line(color = \"lightgrey\"),\n  panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(),\n  axis.line = element_line(color = \"black\",\n                           size = 1),\n  axis.text.x = element_text(angle = 45, \n                             hjust = 1),\n  legend.position = \"top\",\n  legend.direction = \"horizontal\",\n  legend.title = element_blank(),  \n  legend.text = element_text(size = 22, \n                             hjust = 0, \n                             face = \"plain\", \n                             color = \"gray40\"),\n  legend.background = element_blank(),  \n  legend.box = \"none\",  \n   legend.justification = \"left\", \n  legend.margin = margin(t = 3, r = 0, b = 3, l = -70),\n  legend.key = element_blank(),\n  legend.key.size = unit(0.6, \"cm\"),\n  legend.key.width = unit(0.7, \"cm\"),\n  legend.key.height = unit(0.5, \"cm\"))\n\n\nHere, I create a vector to give the specific colour to each region and country.\n\n\ncolors <- c(\"Europa y Asia Central\" = \"#676B90\", \n            \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n            \"Asia Meridional\" = \"#70B3B5\", \n            \"Oriente Próximo y Magreb\" = \"#8BA629\", \n            \"África Subsahariana\" = \"#9E65A6\", \n            \"Latinoamérica y Caribe\" = \"#F2BE5C\", \n            \"Iraq\" = \"#AACE7B\", \n            \"Japan\" = \"#DEA281\", \n            \"South Korea\" = \"#E5C5B1\", \n            \"Vietnam\" = \"#DF8756\", \n            \"Germany\" = \"#7185B5\")\n\ncolors2 <- c(\"Europa y Asia Central\" = \"#676B90\", \n             \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n             \"Asia Meridional\" = \"#70B3B5\", \n             \"Oriente Próximo y Magreb\" = \"#8BA629\", \n             \"África Subsahariana\" = \"#9E65A6\", \n             \"Latinoamérica y Caribe\" = \"#F2BE5C\", \n             \"Iraq\" = \"#8BA629\", \"Japan\" = \"#DEA281\", \n             \"South Korea\" = \"#DE5A3C\", \n             \"Vietnam\" = \"#DF8756\", \n             \"Germany\" = \"#676B90\")\n\n\nGraph\nRegion graph\nTo understand what I have done above with the database, I have first created a graph with the regions, without the countries highlighted.\n\n\nregional.time <- ggplot(regional.data, \n                        aes(x = year, \n                            y = troopsum, \n                            fill = region)) +\n  geom_area() +\n  scale_x_continuous(\n    limits = c(1950, 2020),\n    breaks = seq(1950, 2020, 10),\n    expand = expansion(add = c(1.5, 0))) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), \n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0)) +\n  scale_fill_manual(values = colors) +\n  theme_ok +\n  labs(x = \"\",\n       y = \"Soldados\",\n       color = \"Region\",\n       linetype = \"Region\",\n       title = \"La evolución del despligue militar de EE.UU.\",\n       subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\") \n\nprint(regional.time)\n\n\n\nCountry graph\nIn the following graph we see the countries highlighted without the regions, clearly these countries are the ones that had/have the largest US military presence.\n\n\ncountry.time <- ggplot(country.data, aes(x = year, \n                                         y = troopsum, \n                                         fill = countryname)) +\n  geom_area() +\n  scale_x_continuous(limits = c(1950, 2020), \n                     breaks = seq(1950, 2020, 10), \n                     expand = expansion(0.02)) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), \n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0))  +\n  scale_fill_manual(values = colors) +\n  theme_ok + \n  labs(x = \"\",\n       y = \"Soldados\",\n       color = \"Region\",\n       linetype = \"Region\",\n       title = \"La evolución del despligue militar de EE.UU.\",\n       subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\")  \n\ncountry.time\n\n\n\nCombined graph\nI then created the chart with the data frame combining the regions and countries highlighted. To replicate the original graph, geom_area is used, where the position of the areas is \"stacked\", that is, the areas of the regions and the highlighted countries are stacked on top of each other, that is why the categories of both variables were previously ordered.\nWith scale_fill_manual I am creating what I want to appear inside the legend (regions only). And with scale_color_manual I am colouring the areas, indicating that I want them to be coloured with the colours of the vector colours2, and the categories of my data frame variable combinated_data.\n\n\ncombined.time <- ggplot() +\n  geom_area(data = combined_data |>  \n              filter(!is.na(region_country)), \n            mapping = aes(x = year, \n                          y = troopsum, \n                          fill = region_country, \n                          color = region_country), \n            position = \"stack\", size = 1.3) +  \n  scale_x_continuous(\n    limits = c(1950, 2020),\n    breaks = seq(1950, 2020, 5),\n    expand = expansion(add = c(0.5, 0)))+\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1),\n                     limits = c(0, 1200000),\n                     breaks = seq(0, 1200000, 200000),\n                     expand = expansion(0)) +\n   scale_fill_manual(name = \"Leyenda\", \n                     values = colors, \n                     breaks = c(\"Europa y Asia Central\", \n                                \"África Subsahariana\", \n                                \"Asia Oriental y Oceanía\", \n                                \"Latinoamérica y Caribe\", \n                                \"Asia Meridional\", \n                                \"Oriente Próximo y Magreb\")) +\n  scale_color_manual(values = colors2, \n                     breaks = unique(combined_data$region_country), \n                     guide = FALSE) +\n  theme_ok +\n  labs(\n    x = \"\",\n    y = \"\",\n    color = \"Data Type\",\n    fill = \"Data Type\",\n    title = \"La evolución del despliegue militar de EE.UU.\",\n    subtitle = \"Presencia de tropas por regiones y países más destacados (1950-2020)\",  \n    caption = \"**Gráfico:** \\nÁlvaro Merino (2021) \\n\\n**Fuente:**\n    Michael A. Allen, Michael E. Flynn y Carla Martínez Machain, Us global military deployments, 1950-2020 (2021)\" ) \n\ncombined.time\n\n\n\nAnnotations and replicated graph\nWith annotate, I have added all the labels that appear on the graph, so that the person viewing the graph can better place the data historically in his or her head. For instance, the highest peak of the graph is indicated with an arrow to indicate that it was due to the Vietnam War.\nAlso, another small detail I got with annotate, is the title of the Y-axis, where the original graph indicates that the Y-axis is about the number of soldiers by putting “Soldados” under the last figure that is displayed. I achieved it with coord_cartesian, setting clip=\"off\", to be able to place an annotation outside the graph axes.\n\n\ncombined.timeA <- combined.time + \n  annotate(\"text\",\n  label = \"Alemania\",\n  x = 1980, y = 150000, hjust = 0.3, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") + \n  annotate(\"text\",\n  label = \"Vietnam\",\n  x = 1968, y = 450000, hjust = 0.4, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Irak\",\n  x = 2006, y = 300000, hjust = 0.6, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Japón\",\n  x = 1955, y = 520000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"white\", family=\"outfit\") +\n   annotate(\"text\",\n  label = \"11S\",\n  x = 2001, y = 440000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Colapso de la URSS\",\n  x = 1992, y = 540000, hjust = 0.09, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"text\",\n  label = \"Caída del Muro \\nde Berlín\",\n  x = 1990, y = 700000, hjust = 0.5, vjust = -0.4, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"segment\", \n           x = 1990, xend = 1990, y = 0, yend = 700000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 1992, xend = 1992, y = 0, yend = 520000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 2001, xend = 2001, y = 0, yend = 420000, \n           color = \"gray50\", linetype = \"aa\") +\n  annotate(\"segment\", \n           x = 2012, xend = 2014, y = 200000, yend = 330000, \n           color = \"gray30\", linetype = \"solid\") +\n  annotate(\"text\",\n  label = \"Afganistán\", \n  x = 2014, y = 330000, hjust = 0.3, vjust = -0.5, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"segment\", \n           x = 1953, xend = 1957, y = 700000, yend = 840000, \n           color = \"gray30\", linetype = \"solid\") +\n  annotate(\"text\",\n  label = \"Corea \\ndel Sur\",\n  x = 1958, y = 800000, hjust = 0.2, vjust = -0.2, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"curve\", \n           x = 2010, y = 210000 , xend = 2011, yend = 640000, \n           color = \"gray30\", curvature = 0.06, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 2006, y = 350000 , xend = 2007, yend = 640000, \n           color = \"gray30\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra contra \\nel terror\",\n  x = 2009, y = 660000, hjust = 0.5, vjust = 0, size = 9, \n  color = \"gray30\", family=\"outfit\", lineheight = 0.6) +\n  annotate(\"curve\", \n           x = 1968, y = 850000 , xend = 1975, yend = 920000, \n           color = \"gray30\", curvature = -0.2, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam\",\n  x = 1975, y = 920000, hjust = -0.05, vjust = 0.3, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  annotate(\"curve\", \n           x = 1953, y = 880000 , xend = 1957, yend = 1100300, \n           color = \"gray30\", curvature = -0.3, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Corea\",\n  x = 1957, y = 1100300, hjust = -0.05, vjust = -0.3, size = 9, \n  color = \"gray30\", family=\"outfit\") +\n  coord_cartesian(xlim=c(1950, 2020), clip=\"off\") +\n  annotate(\"text\",\n           label=\"Soldados\", \n           x=1950, y=1150000, hjust = 1.3, size = 7, \n           color = \"gray30\", family=\"outfit\")\n\n\ncombined.timeA\n\n\n\nAlternative visualization\nLimitation of stacked areas\nStacking is a process in which a chart is broken down into multiple categorical variables that constitute the whole set. Each element of the categorical variable is represented by a shaded area, and these areas are stacked on top of each other.\nStacked charts are useful for studying the evolution and relative proportions of each group as a whole. In fact, the top of the areas allows for visualizing the overall behavior, similar to a classic area chart. However, they are not suitable for studying the evolution of each individual group, and this is due to two main reasons. Firstly, all groups, except those with a baseline, are challenging to read in terms of their values at each tile level.\nTherefore, as an alternative means of visualizing this dataset, I have opted to generate a line graph. This approach simplifies the information, facilitating a clearer observation of the individual evolution within each region.\nPreparing data\n\n\ntroopdata1 <- troopdata::troopdata |>  \n  filter(ccode != 2 & year >= 1950) |> \n  mutate(ccode = ifelse(ccode == 260, 255, ccode),\n         ccode = ifelse(countryname == \"Republic of Vietnam\", 816, ccode),\n         iso3c = ifelse(countryname == \"Republic of Vietnam\", \"VNM\", iso3c),\n         region = countrycode::countrycode(iso3c, \"iso3c\", \"region\"),\n         region = case_when(\n           ccode == 1003 ~ \"Afloat\",\n           ccode == 70 ~ \"North America\",\n           region == \"Latin America & Caribbean\" ~ \"Central & South America & Caribbean\", \n           TRUE ~ region), \n         region = recode(region, \n                         \"Central & South America & Caribbean\" = \"Latinoamérica y Caribe\", \n                         \"Europe & Central Asia\" = \"Europa y Asia Central\", \n                         \"Middle East & North Africa\" = \"Oriente Próximo y Magreb\", \n                         \"Sub-Saharan Africa\" = \"África Subsahariana\", \n                         \"South Asia\" = \"Asia Meridional\", \n                         \"East Asia & Pacific\" = \"Asia Oriental y Oceanía\"))\n\n\nRegarding the data frame, I have chosen to solely utilize the regional data. Including the highlighted countries as well would have resulted in an excessive amount of information. Additionally, with the aid of subsequent annotations, we can provide the viewer with specific details about the country and historical period being represented.\n\n\nregional.data1 <- troopdata1 |> \n  group_by(region, year) |> \n  dplyr::summarise(troopsum = sum(troops, na.rm = TRUE)) |> \n  filter(region != 'Afloat') |>\n  filter(region != 'North America')\nregional.data1$region <- factor(regional.data1$region , \n                                levels= c(\"Asia Oriental y Oceanía\", \n                                          \"Europa y Asia Central\", \n                                          \"Oriente Próximo y Magreb\", \n                                          \"Asia Meridional\", \n                                          \"Latinoamérica y Caribe\", \n                                          \"África Subsahariana\"))\n\n\nAdapting the theme\nThe changes made to the theme are minor, such as altering the font style. The most significant modification has been the repositioning of the legend. When designing a line graph, it is most appropriate to place the legend on the left margin. This ensures that the viewer, after reading the line (from right to left), encounters the corresponding color for that line.\n\n\nsysfonts::font_add_google(\"Merriweather\", family=\"Merriweather\")\nshowtext::showtext_auto()\n\ntheme_ok1 <- theme(text = element_text(family=\"Merriweather\", \n                                       size = 22),\n  plot.title = element_text(face = \"bold\", \n                            size = 40),\n  plot.subtitle = element_text(face = \"bold\", \n                               color = \"gray30\" ,\n                               size = 28),\n  plot.title.position = \"plot\",\n  plot.caption = ggtext::element_markdown(size = rel(1), \n                                          lineheight = 0.9, \n                                          hjust = 0, \n                                          margin = margin(0, 0, 0, 0)),\n  plot.caption.position = \"plot\",\n  plot.margin = margin(t = 30, r = -150, b = 0, l = 2), \n  strip.background = element_rect(fill = \"gray80\", \n                                  color = \"black\"),\n  panel.background = element_rect(fill = \"white\"),\n  strip.text = element_text(color = \"black\", \n                            face = \"bold\"),\n  panel.grid.major = element_blank(),\n  panel.grid.minor = element_blank(),\n  axis.line = element_line(color = \"black\",size = 0.9),\n  axis.title.y = element_text(size = 14, \n                              color = \"gray30\", \n                              angle = 90, \n                              hjust = 0.5),\n  axis.text.x = element_text(angle = 45, hjust = 1),\n  legend.position = \"right\",\n  legend.direction = \"vertical\",\n  legend.title = element_blank(),  \n  legend.text = element_text(size = 20, \n                             color = \"gray20\", \n                             hjust = 0),\n  legend.background = element_blank(),  \n  legend.box = \"none\",  \n  legend.justification = c(-0.2, 0),  \n  legend.margin = margin(t = 0, r = 150, b = 5, l = -5),\n  legend.spacing.y = unit(0.5, \"cm\"),\n  legend.key = element_blank(),\n  legend.key.size = unit(0.6, \"cm\"), \n  legend.key.height = unit(0.7, \"cm\"))\n\n\nCreating the alternative graph\nAs mentioned earlier, the design of the graph will feature solid lines to facilitate the visualization of each region’s evolution. Simple and clean.\n\n\nregional.time1 <- ggplot() +\n  geom_line(data = regional.data1, \n            mapping = aes(x = year, \n                          y = troopsum, \n                          color = region, \n                          linetype = region), \n            linetype = \"solid\", \n            size = 0.8) +  \n  scale_x_continuous(limits = c(1950, 2020), \n                     breaks = seq(1950, 2020, 5), \n                     expand = expansion(add = c(1.5, 0))) +\n  scale_y_continuous(labels = scales::number_format(big.mark = \".\", \n                                                    decimal.mark = \",\", \n                                                    accuracy = 1), breaks = seq(0, \n                                                                                1000000, \n                                                                                100000)) +\n  scale_color_manual(name = NULL, \n                     values = c(\"Europa y Asia Central\" = \"#676B90\", \n                                \"Asia Oriental y Oceanía\" = \"#DE5A3C\", \n                                \"Asia Meridional\" = \"#70B3B5\", \n                                \"Oriente Próximo y Magreb\" = \"#8BA629\", \n                                \"África Subsahariana\" = \"#9E65A6\", \n                                \"Latinoamérica y Caribe\" = \"#F2BE5C\")) +\n  theme_ok1  +\n  labs(\n    x = \"\",\n    y = \"Soldados\",\n    title = \"La evolución del despliegue militar de EE.UU.\",\n    subtitle = \"Presencia de tropas por regiones (1950-2020)\", \n    caption = \n      paste(\"Fuente: Michael A. Allen, Michael E. Flynn y Carla Martínez Machain, Us global military deployments, 1950-2020 (2021)\"))\n\n\nregional.time1\n\n\n\nAnnotations and alternative graph\nAnd finally, the annotations on the graph will assist us in overcoming the challenge of distinguishing the highlighted countries. Furthermore, these annotations provide a deeper understanding of the evolution of each country, especially with this line graph. We can observe, as mentioned at the beginning of this article, how the presence of U.S. military is sustained despite the conclusion of the conflict for which the U.S. troops were initially deployed.\n\n\nregional.time1 <- regional.time1 + annotate(\"text\",\n  label = \"11S\",\n  x = 2001, y = 250000, hjust = 0.5, vjust = 0.6, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"text\",\n  label = \"Colapso de la URSS\",\n  x = 1992, y = 360000, hjust = 0.05, vjust = -1, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"text\",\n  label = \"Caída del Muro de Berlín\",\n  x = 1990, y = 470000, hjust = 0.5, vjust = 0, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n  annotate(\"segment\", \n           x = 1990, xend = 1990, y = 0, yend = 450000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"segment\", \n           x = 1992, xend = 1992, y = 0, yend = 365000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"segment\", \n           x = 2001, xend = 2001, y = 0, yend = 220000, \n           color = \"gray50\", linetype = \"aa\", size = 0.4) +\n  annotate(\"text\",\n  label = \"Guerra contra \\nel terror\",\n  x = 2013, y = 230000, hjust = 0.7, vjust = -0.7, size = 8, \n  color = \"gray30\", lineheight = 0.4, family=\"Merriweather\") +\n  annotate(\"curve\", \n           x = 2012, y = 50000 , xend = 2013, yend = 230000, \n           color = \"#70B3B5\", curvature = 0.06, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 2007, y = 150000 , xend = 2010, yend = 240000, \n           color = \"#8BA629\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"curve\", \n           x = 1968, y = 650000 , xend = 1971, yend = 710000, \n           color = \"#DE5A3C\", curvature = -0.1, \n           arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam\",\n  x = 1972, y = 720000, hjust = 0, vjust = 0, size = 8, \n  color = \"gray30\", family=\"Merriweather\") +\n   annotate(\"curve\", \n            x = 1951, y = 500000 , xend = 1953, yend = 600000, \n            color = \"#DE5A3C\", curvature = -0.1, \n            arrow = arrow(length = unit(0.02, \"npc\"), angle = 20, type = \"closed\")) +\n  annotate(\"text\",\n  label = \"Guerra de Vietnam \\ny \\nOcupación de Japón\",\n  x = 1956, y = 680099, hjust = 0.5, vjust = 0.5, size = 6, \n  color = \"gray30\", lineheight = 0.4,family=\"Merriweather\") \n\nregional.time1\n\n\n\n\n\n\n",
    "preview": "projects/2023/100483064/100483064_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2112,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100508665/",
    "title": "Sex Gap in Life Expectancy in Spain",
    "description": "How many more years do Spanish women live compared to men? This project\nreplicates and enhaces a World in Data graph showing the evolution of the sex\ngap in life expectancy from 1908 to 2018 in Spain.",
    "author": [
      {
        "name": "Alicia Talavera-Marcos",
        "url": {}
      }
    ],
    "date": "2024-01-21",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGetting the data ready\nWorking on the legend positioning of the plot\n\nCreating the plot\nInitial form and axis\nTheme, title and labels\nBackground lines\nStacked areas\nLegend\nFinal replicated plot\n\nPlot enhacement\nOriginal graph pros & cons\nFirst enhacement graph\nSecond enhacement graph\nFinal enhacement\n\n\nIt is known that women usually have a higher life expectancy and live longer than men. However, this life expectancy gap isn’t homogeneous and it varies significantly through different age groups. The original graph I replicated and enhances for this project shows how each age group contributes to the overall sex gap in life expectancy in Spain, from years 1908 to 2018.\nSource: https://ourworldindata.org/why-do-women-live-longer-than-menThese are the packages I used for this project.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\nGetting the data ready\nFirst, I had to import the data. It was available for download on the source website and it was very easy to find. The data were complete and it was the same used for the original graph.\n\n\nlifex <- read.csv(\"lifeexpectancy.csv\")\n\n\nThen I had to tidy up the data in order to be able to use it. I had to rename the age group columns to make it shorter and more manageable, as well as pivoting them. The database included date for many countries, so I had to filter it to work only with the data from Spain.\n\n\n#Rename columns\n\nlifex_r <-\n  lifex |> \n  rename(\n    \"Age 0 (infancy)\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..0,\n    \n    \"Ages 1-14\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..1.14,\n    \n    \"Ages 15-39\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..15.39, \n    \n    \"Ages 40-59\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..40.59,\n    \n    \"Ages 60-79\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..60.79,\n    \n    \"Ages 80+\" = Contribution.to.sex.gap.in.life.expectancy..years....Age_group..80.) \n\n#Tidy the data\n\ntidy_lifex_r <- \n  lifex_r |>\n  pivot_longer(cols = \"Ages 80+\":last_col(),\n               names_to = \"Age_group\",\n               values_to = \"Contribution_to_gap\")\n\n#Spain data\n\nspain <- \n  tidy_lifex_r |> \n  filter(Entity == \"Spain\" & Contribution_to_gap >= 0) |> \n  mutate(Age_group = fct_rev(Age_group)) #Change order of groups to replicate the original\n\n\nWorking on the legend positioning of the plot\nBefore getting to work with the visualization, I created some variables regarding the positioning of the legend labels. I wanted to calculate the middle point of the areas to make each label appear just in the middle, even if then I had to make some adjustments.\n\n\nylegend_80 <- \n  spain |> \n  filter(Age_group == \"Ages 80+\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_60 <- \n  spain |> \n  filter(Age_group == \"Ages 60-79\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_40 <- \n  spain |> \n  filter(Age_group == \"Ages 40-59\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_15 <- \n  spain |> \n  filter(Age_group == \"Ages 15-39\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_1 <- \n  spain |> \n  filter(Age_group == \"Ages 1-14\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_0 <- \n  spain |> \n  filter(Age_group == \"Age 0 (infancy)\", Year == 2018) |> \n  pull(Contribution_to_gap)\n\nylegend_0_final <- ylegend_0/2\nylegend_1_final <- ylegend_1/2 + ylegend_0\nylegend_15_final <- ylegend_15/2 + ylegend_0 + ylegend_1\nylegend_40_final <- ylegend_40/2 + ylegend_0 + ylegend_1 + ylegend_15\nylegend_60_final <- ylegend_60/2 + ylegend_0 + ylegend_1 + ylegend_15 + ylegend_40\nylegend_80_final <- ylegend_80/2 + ylegend_0 + ylegend_1 + ylegend_15 + ylegend_40 + ylegend_60\n\n\nCreating the plot\nInitial form and axis\nTo begin, we define the x and y axis data by using the Year and Contribution to gap columns. As for the scales, we establish the limits for both axes and set the breaks accordingly. On the y-axis, we introduce breaks every two years of contribution to the gender gap in life expectancy. On the x-axis, we set a maximum limit extending beyond 2018, the last year of available data, reaching up to 2045. This provides additional space on the right side for including the legend. Lastly, using the coord_cartesian(expand = FALSE) function and its corresponding argument we manage to start the plot directly at the axis, eliminating a small margin.\n\n\n#Basic form\n\np <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 9.5), breaks=c(0, 2, 4, 6, 8)) +\n  scale_x_continuous(limits=c(1908, 2045), breaks=c(1908, 1920, 1940, 1960, 1980, 2000, 2018), \n                     labels=c(1908, 1920, 1940, 1960, 1980, 2000, 2018)) +\n  coord_cartesian(expand = FALSE)\n\np\n\n\n\nTheme, title and labels\nThe theme needs to resemble closer the original graph, so we use theme_classic and adjust the font size. Now it’s the time to edit the color of the axis lines as well as the ticks, their length and the family font of the text and its color.\nWe also create the text for the title and subtitle, adjust its font, color and position.\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair_display\")\n\n p <- p +\n\n#Colors of axis, axis text, title\n  theme_classic(base_size=14) +\n  theme(\n    legend.position=\"none\", #remove legend\n    axis.line = element_blank(), #axis lines, colors\n      axis.ticks.x = element_line(color = \"darkgray\"), \n      axis.ticks.length = unit(0.15, \"cm\"),\n      axis.ticks.y = element_blank(),\n      axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\")) + \n    labs(x = \"\", y= \"\", \n        \n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n         \n         subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n  \n    theme(\n        axis.title.y = element_text(size = 11, family = \"playfair_display\", color = \"#5B5B5B\", margin = margin(r=10)),\n\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      \n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\"),\n      \n      plot.title.position = \"plot\",\n      \n      plot.margin = margin(10, 0, 0, 10))\n\np\n\n\n\nBackground lines\nNow to finish setting up the plot by adding the background lines present on the original graph that help read the y values of the data. We use geom_segment and use the same values as the ones for the breaks in the y-axis. We adjust the type and color of the lines.\n\n\np <- p +\n  \n#Background lines\n    geom_segment(data = data.frame(y = c(0, 2, 4, 6, 8), yend = c(0, 2, 4, 6, 8), x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") \n\np\n\n\n\nStacked areas\nFinally we can represent our data using geom_area to create stacked areas of each age group’s contribution to the sex gap. We specify that we want the areas color to be defined by the different age group categories. We manually define the colors for each area and stablish details like a bit of transparency with alpha and the width of the exterior line of the areas.\n\n\np <- p +\n\n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#82A954\", \n                               \"Ages 15-39\" = \"#49A892\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\"))\np\n\n\n\nEven though whis is looking quite good, the exterior lines don’t match exactly the color they should have. To fix that we create a new scale_color_manual function in which we define a very similar although different color for the exterior lines of the areas.\n\n\n p <- p +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                              \"Ages 40-59\" = \"#8AAD61\", \n                               \"Ages 15-39\" = \"#62A685\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\"))\np\n\n\n\nLegend\nNow we will create the text for the legend. Instead of using any legend function in ggplot2, we create it manually using annotate since it should have a very specific position and characteristics. We add text for each age group and use our previously created legend position variables to place it. We have to adjust the placement manually to make it perfect, as well as editing the font and color for each label.\n\n\np <- p +\n\n#Legend \n   annotate(\"text\", x = 2026, y = (ylegend_80_final-0.15), hjust = 0, vjust = 0,\n            label = \"Ages 80+\", family = \"playfair_display\", size = 3, color = \"#B26257\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_60_final-0.15), hjust = 0, vjust = 0,\n           label = \"Ages 60-79\", family = \"playfair_display\", size = 3, color = \"#BE9053\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_40_final+0.9), hjust = 0, vjust = 0,\n           label = \"Ages 40-59\", family = \"playfair_display\", size = 3, color = \"#8AAD61\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_15_final+1), hjust = 0, vjust = 0,\n           label = \"Ages 15_39\", family = \"playfair_display\", size = 3, color = \"#62A685\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_1_final+0.6), hjust = 0, vjust = 0,\n           label = \"Ages 1-14\", family = \"playfair_display\", size = 3, color = \"#657EAD\") +\n  \n  annotate(\"text\", x = 2026, y = (ylegend_0_final+0.1), hjust = 0, vjust = 0,\n           label = \"Age 0 (infancy)\", family = \"playfair_display\", size = 3, color = \"#5F5D75\") \n\np\n\n\n\nLastly, we have to replicate the lines connecting the legend labels with the areas. To achieve this we use geom_segment, the previously crafted position variables, and adjust their length and color. For the last age group labels we have to create three different lines that connect to each other given the reduced space left due to their small area size that don’t allow use to use just a straight line.\n\n\np <- p +\n  \n#Lines of the legend\n  #Red line\n  geom_segment(data = data.frame(y = ylegend_80_final, yend = ylegend_80_final, x = 2019, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Orange line\n  geom_segment(data = data.frame(y = ylegend_60_final, yend = ylegend_60_final, x = 2019, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\n  #Green line\n    geom_segment(data = data.frame(y = ylegend_40_final, yend = ylegend_40_final, x = 2019, xend = 2021),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_40_final+1, yend = ylegend_40_final+1, x = 2021, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_40_final, yend = ylegend_40_final+1, x = 2021, xend = 2021),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\n  #Teal line\n    geom_segment(data = data.frame(y = ylegend_15_final, yend = ylegend_15_final, x = 2019, xend = 2022),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_15_final+1.1, yend = ylegend_15_final+1.1, x = 2022, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_15_final, yend = ylegend_15_final+1.1, x = 2022, xend = 2022),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Blue line\n      geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final, x = 2019, xend = 2023),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_1_final+0.7, yend = ylegend_1_final+0.7, x = 2023, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final+0.7, x = 2023, xend = 2023),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n  #Violet line\n      geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final, x = 2019, xend = 2024),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n\ngeom_segment(data = data.frame(y = ylegend_1_final+0.2, yend = ylegend_1_final+0.2, x = 2024, xend = 2025),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\") +\n  \n    geom_segment(data = data.frame(y = ylegend_1_final, yend = ylegend_1_final+0.2, x = 2024, xend = 2024),\n    aes(x = x, xend = xend, y = y, yend = yend), color = \"darkgray\")\n\n\nFinal replicated plot\n\n\np\n\n\n\nPlot enhacement\nOriginal graph pros & cons\nThe original graph is quite good, being simple enough to communicate data withouth being too confusing. It’s visually well depurated, with harmonized colors, fonts and object and place placement. However, even if it’s easy to see the big picture, the main issue is that the age groups information gets lost and it’s harder to understand.\nFirst enhacement graph\nFor this first enhacement I decided to change a few things:\nAdding a yellow color in the areas to avoid having three different blue hues\nAdding a title to the y-axis to make it more understandable\nChanging the legend to make it more visible\nAdding important historical event marks to add context to the data\n\n\n#Improvements\np <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 11), breaks=c(0, 2, 4, 6, 8)) +\n  scale_x_continuous(limits=c(1908, 2018), breaks=c(1908, 1920, 1940, 1960, 1980, 2000, 2018), \n                     labels=c(1908, 1920, 1940, 1960, 1980, 2000, 2018)) +\n  coord_cartesian(expand = FALSE) +\n  \n#Colors of axis, axis text, title\n  #ENHACEMENT - NEW LEGEND\n  theme_classic(base_size=14) +\n  theme(\n    legend.position=\"right\", \n    legend.title = element_blank(),\n    legend.text = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\"),\n    legend.key.size = unit(0.4, \"cm\"), \n    legend.key.width = unit(0.5, 'cm'),\n    axis.line = element_blank(), #axis lines, colors\n      axis.ticks.x = element_line(color = \"darkgray\"), \n      axis.ticks.length = unit(0.15, \"cm\"),\n      axis.ticks.y = element_blank(),\n      axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n      axis.title.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\", size = 12, margin = margin(r = 10))) +\n    labs(x = \"\", y= \"Sex gap years\", #ENHACEMENT - Y-AXIS TITLE\n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n         \n         subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n    theme(\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\", hjust= 0),\n      plot.title.position = \"plot\") +\n  \n#Background lines\n    geom_segment(data = data.frame(y = c(0, 2, 4, 6, 8), yend = c(0, 2, 4, 6, 8), x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") +\n  \n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", #ENHACEMENT - YELLOW COLOR\n                               \"Ages 15-39\" = \"#82A954\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\")) +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#8AAD61\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\")) +\n\n#ENHACEMENT - EVENT MARKS\n    geom_segment(aes(x = 1936, xend=1936, y=0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1936, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"CIVIL WAR\") +\n  annotate(\"text\", x=1936, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\") +\n       geom_segment(aes(x = 1918, xend = 1918, y = 0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1918, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"SPANISH FLU\") +\n    annotate(\"text\", x=1918, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\") +\n       geom_segment(aes(x = 1981, xend = 1981, y = 0, yend = 10), color = \"#5B5B5B\", linetype = \"dotted\") +\n  annotate(\"text\", x=1981, y=10.5, color=\"#5B5B5B\", vjust=0, size=3, label=\"AIDS CRISIS\") +\n    annotate(\"text\", x=1981, y=10.10, color=\"#5B5B5B\", vjust=0, size=3, label=\"◆\")\n\np\n\n\n\nThis graph now looks better and is easier to read. However, it doesn’t solve the main issue we stated earlier, since it’s still hard to read the contribution per each age group.\nSecond enhacement graph\nLooking to solve this issue, I decided to make facets emphasizing the information of the age groups. I decided to fix the scale to see each facet proportionally to the total. I kept the event marks to keep this historical context.\n\n\nfacets <- ggplot(spain) +\n    aes(Year, Contribution_to_gap) +\n    facet_wrap(Age_group ~ .) + #ENHACEMENT - FACETS\n  \n#Scales and size\n  scale_y_continuous(limits=c(0, 4.5), breaks=(4)) +\n  scale_x_continuous(limits=c(1908, 2018), breaks=c(1908, 1930, 1960, 1990, 2018), \n                     labels=c(1908, 1930, 1960, 1990, 2018)) +\n  coord_cartesian(expand = FALSE) +\n\n#Colors of axis, axis text, title\n  theme_classic(base_size=11) +\n  theme(\n    strip.text = element_text(size = 10, family = \"playfair_display\", color=\"#5B5B5B\", face= \"bold\"),\n    strip.background = element_blank(),\n    legend.position = \"null\", \n    axis.line = element_line(color = \"gray\"),\n    axis.ticks.x = element_line(color = \"darkgray\"), \n    axis.ticks.length = unit(0.15, \"cm\"),\n    axis.ticks.y = element_blank(),\n    axis.text.x = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n    axis.text.y = element_text(color = \"#6C6C6C\", family = \"playfair_display\"),\n    panel.spacing.x = unit(2, \"lines\")) + \n    labs(x = \"\", y= \"\", \n          title = \"How do death rates in each age group contribute to the overall sex gap in life\\nexpectancy? Spain\", \n          subtitle = \"The height of the curve shows the gap in life expectancy in years (female minus male). Positive values indicate higher\\nlife expectancy in females. The stacked areas show how the gap arises from sex differences in death rates in each age\\ngroup.\") +\n    theme(\n      plot.title = element_text(size = 14, family = \"playfair_display\", color = \"#5B5B5B\"),\n      plot.subtitle = element_text(size = 9, family = \"playfair_display\", color = \"#5B5B5B\", hjust= 0),\n      plot.title.position = \"plot\",\n      plot.margin = margin(0.5, 1, 0, 0.5, \"cm\")) +\n\n#Background lines\n    geom_segment(data = data.frame(y = 4, yend = 4, x = 1908, xend = 2018),\n    aes(x = x, xend = xend, y = y, yend = yend),\n    linetype = \"dashed\", color = \"lightgray\") +\n\n#Areas\n  geom_area(aes(fill = Age_group, color = Age_group), alpha = 0.8, linewidth = 0.3) +\n  scale_fill_manual(values = c(\"Ages 80+\" = \"#B26257\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#82A954\", \n                               \"Ages 1-14\" = \"#6281BC\", \n                               \"Age 0 (infancy)\" = \"#58495D\")) +\n  \n    scale_color_manual(values = c(\"Ages 80+\" = \"#BF6B60\", \n                               \"Ages 60-79\" = \"#BE9053\", \n                               \"Ages 40-59\" = \"#BEBA54\", \n                               \"Ages 15-39\" = \"#8AAD61\", \n                               \"Ages 1-14\" = \"#657EAD\", \n                               \"Age 0 (infancy)\" = \"#5F5D75\")) +\n  \n      geom_segment(aes(x = 1936, xend=1936, y=0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") +\n       geom_segment(aes(x = 1918, xend = 1918, y = 0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") +\n       geom_segment(aes(x = 1981, xend = 1981, y = 0, yend = 4.5), color = \"darkgrey\", linetype = \"dotted\") \n\nfacets\n\n\n\nThis make the information of the age groups very easy to read and understand its different tendencies. However, this plot now loses the information of the big picture.\nFinal enhacement\nTo solve this, I decided to combine both plots using the R package patchwork. I merged both of them together and made a few adjustment until I got the final enhaced graph. This solves the issue of not being able to clearly distinguish trends within each age group, in addition to providing a clearer picture with the combined chart, observing the overall evolution of the life expectancy sex gap. Furthermore, the issue of the legend is resolved by having facets that allow us to understand the meaning of each color in the areas.\n\n\n\n\n\np2/facets2\n\n\n\nThanks for reading!\n\n\n\n",
    "preview": "projects/2023/100508665/100508665_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100407986/",
    "title": "Change in Abortion after Dobbs",
    "description": "Visualization of the change in abortion data after the Dobbs decision, which \ngave power of legislation over abortion to the different states of the U.S.",
    "author": [
      {
        "name": "Clara Espinosa-Acevedo",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nContext\nPreparing the data\nReplication\nColors and legend\nText\nAnnotations\n\nEnhancement\nBase\nSquares\nText\nAnnotations\nLegends\n\n\nContext\nThe right to have an abortion was protected in the U.S. after the Roe v. Wade(1973)\ndecision, taken by the U.S. Supreme Court. This decision ruled that the Constitution\nprotected the right to have an abortion. In 2022, the Supreme Court took another\ndecision (Dobbs v. Jackson Women’s Health Organization, popularly known as Dobbs),\nwhich overruled Roe v. Wade.\nThis decision gave the power to the states to decide individually about the regulation\nof the right to have an abortion. This caused a drop in abortion in Republican states\nin which abortion became fully, or almost fully illegal.\nThis project replicates a graph from FiveThirtyEight which shows the changes in\nabortion data after Dobbs:\nOriginal graph form FiveThirtyEightAfter this replication, we try to add information about the public opinion\non Roe v. Wade for the different states. This way we can see if the decisions of\nthe different governments pair with the opinion of the population.\nPreparing the data\nFirst, we prepare a data frame in which we mark the position of each state,\nthe name abreviation and the corresponding value of change in abortions.\n\n\ndf <- data.frame(\n  x = c(1, 8, 6, 3, 2, 4, 11, 11, 11, 10, 9, 1, 6, 3, 6, 7, 5, 7, 5, 11, 10, \n        12, 8, 6, 6, 7, 4, 10, 5, 5, 12, 10, 4, 3, 10, 8, 4, 2, 9, 12, 9, \n        5, 8, 5, 3, 9, 11, 2, 7, 8, 4),\n  y = c(8, 2, 2, 3, 4, 4, 5, 3, 4, 1, 2, 2, 5, 6, 4, 4, 3, 3, 2, 6, 4, 8, \n        6, 6, 3, 2, 6, 3, 6, 4, 7, 5, 3, 4, 6, 5, 2, 5, 5, 6, 3, 5, 3, 1, 5, \n        4, 7, 6, 5, 4, 5),\n  state = c(\"AK\", \"AL\", \"AR\", \"AZ\", \"CA\", \"CO\", \"CT\", \"DC\", \"DE\", \"FL\", \"GA\", \n            \"HI\", \"IA\", \"ID\", \"IL\", \"IN\", \"KS\", \"KY\", \"LA\", \"MA\", \"MD\", \"ME\", \n            \"MI\", \"MN\", \"MO\", \"MS\", \"MT\", \"NC\", \"ND\", \"NE\", \"NH\", \"NJ\", \"NM\", \n            \"NV\", \"NY\", \"OH\", \"OK\", \"OR\", \"PA\", \"RI\", \"SC\", \"SD\", \"TN\", \"TX\", \n            \"UT\", \"VA\", \"VT\", \"WA\", \"WI\", \"WV\", \"WY\"),\n  state.color = c(\"black\", \"#BE8DB7\", \"#BE8DB7\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"black\", \"black\", \"#BE8DB7\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"white\",\n                  \"#BE8DB7\", \"black\", \"black\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"white\", \"#BE8DB7\", \"black\", \"black\", \"black\",\n                  \"black\", \"#BE8DB7\", \"white\", \"#BE8DB7\", \"black\",\n                  \"black\", \"black\", \"black\",\"#BE8DB7\", \"black\", \"black\"),\n  value = c(2, -100, -100, -53, 1, 33, -1, 0, 24, 10, -57, 4, -27, -48, 28,\n           15, 36, -100, -100, -3, 1, 18, 8, 14, -83, -100, 30, 37, -100, 30,\n           -6, 7, 12, 21, 12, -65, -100, 18, 6, -7, -56, -100, -78, -100, -3,\n           -4, 16, 5, -100, -8, -5))\n\n\nReplication\nColors and legend\nFirst, we create a base for the graph, using geom_tile to draw the states. We also\ntry the PRGn palette, since it looked similar to the color palette used by\nFiveThirtyEight.\n\n\nlibrary(ggplot2)\nggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"white\", linewidth=2) +\n  geom_text(aes(label=state, color=state.color), size=6) +\n  coord_fixed() +\n  scale_fill_distiller(type=\"div\", palette=\"PRGn\") +\n  scale_color_identity() +\n  theme_void()\n\n\n\nWe realised that the color pallete didn’t followed a normal “distribution”. In\norder to perfectly match the colors, we took certain values, and assign them to\nthe colors showed in the original graph for those states.\n\n\nq <- ggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"white\", linewidth=2) +\n  geom_text(aes(label=state, color=state.color), size=5) +\n  coord_fixed() +\n  scale_fill_gradientn(colors = c(\"#4A0B35\",\"#7D3F62\", \"#92597A\",\n                                  \"#AB7D99\", \"#CBA8C2\", \"#E8D0E9\",\n                                  \"#F0F0F0\", \"#DBF2D5\", \"#C1DCB8\", \n                                  \"#B4D2AB\", \"#A9C89E\", \"#9CBD8F\",\n                                  \"#7EA370\", \"#2B5F1D\"),\n                       breaks = c(-100, -78, -65, -48, -27, -8, 0, 5, 18, \n                                  24, 30, 37, 50, 100),\n                       limits = c(-100, 100)) +\n  scale_color_identity() + \n  theme_void()\nq\n\n\n\nWe change the position and direction of the legend, which consits on a color bar.\n\n\nq <- q + guides(fill = guide_colorbar(title = \"PERCENT CHANGE\",\n                                 title.position = \"top\",\n                                 title.theme = element_text(size = 10,\n                                                            family = \"Helvetica\"),\n                                 #title.hjust = 0.5,\n                                 #title.vjust = 0.5,\n                                 label = FALSE,\n                                 barheight = 0.7,\n                                 barwidth = 9,\n                                 #nbin = 100,\n                                 ticks = FALSE,\n                                 direction = \"horizontal\")) +\n  theme(legend.position = c(0.13, 1))\nq\n\n\n\nText\nWe add the title, subtitle and caption of the graph.\n\n\nq <- q + labs(\n  title = \"Several states saw a complete drop in abortions after Dobbs\",\n  subtitle = \"Percentage change in number of abortions from April to August 2022, by state\",\n  caption = paste0(\"Percent change in abortions is calculated from #WeCount's unrounded data.\", \n                  \"\\nLess-populated states might see larger\",\n                  \"percentage shifts because the raw number of abortions in\", \n                  \"those states tend to be smaller.\")\n) +\n  theme(plot.title = element_text(size = 18, color = \"#222222\", face = \"bold\", \n                                  family = \"Helvetica\", hjust = 0.1, vjust = 3)) +\n  theme(plot.subtitle = element_text(size = 14, color = \"#222222\", face = NULL, \n                                     family = \"Helvetica\", hjust = 0.1, vjust = 3)) +\n  theme(plot.caption = element_text(size = 10, color = \"#999999\", face = NULL, \n                                    family = \"Helvetica\", hjust = 0, vjust = 0.1)) +\n  ylim(0, 9) +\n  theme(legend.position = c(0.13, 0.97))\n\nq\n\n\n\nAnnotations\nWe begin with the square annotations, which surround some states.\n\n\n# Base\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 8.65, ymax = 9.65, \n                  alpha = 0, color = \"#D8726F\") + ylim(0, 10)\n\n# SD\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# WI\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# OH\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 4.5, ymax = 5.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# KY\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# MO\nq <- q + annotate(\"rect\", xmin = 5.5, xmax = 6.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# TN\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# SC\nq <- q + annotate(\"rect\", xmin = 8.5, xmax = 9.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AZ\nq <- q + annotate(\"rect\", xmin = 2.5, xmax = 3.5, ymin = 2.5, ymax = 3.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# OK\nq <- q + annotate(\"rect\", xmin = 3.5, xmax = 4.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# LA\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AR\nq <- q + annotate(\"rect\", xmin = 5.5, xmax = 6.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# MS\nq <- q + annotate(\"rect\", xmin = 6.5, xmax = 7.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# AL\nq <- q + annotate(\"rect\", xmin = 7.5, xmax = 8.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# GA\nq <- q + annotate(\"rect\", xmin = 8.5, xmax = 9.5, ymin = 1.5, ymax = 2.5, \n                  alpha = 0, color = \"#D8726F\")\n\n# TX\nq <- q + annotate(\"rect\", xmin = 4.5, xmax = 5.5, ymin = 0.5, ymax = 1.5, \n                  alpha = 0, color = \"#D8726F\")\n\nq\n\n\n\nNext, line annotations which point out information about some states.\n\n\n## Lines ##\n# CA\nq <- q + annotate(\"segment\", x = 2, xend = 2, y = 3.5, yend = 1, color = \"black\")\n\n# AZ\nq <- q + annotate(\"segment\", x = 3, xend = 3, y = 2.5, yend = 2, color = \"black\")\n\n# CA&AZ\nq <- q + annotate(\"segment\", x = 2, xend = 3, y = 2, yend = 2, color = \"black\")\n\n# ND\nq <- q + annotate(\"segment\", x = 5.3, xend = 5.3, y = 6.5, yend = 7.1, color = \"black\")\n\n# AR\n# AR1\nq <- q + annotate(\"segment\", x = 6, xend = 6, y = 1.5, yend = -0.2, color = \"black\") + ylim(-0.5, 10)\n# AR2\nq <- q + annotate(\"segment\", x = 6, xend = 6.3, y = -0.2, yend = -0.2, color = \"black\")\n\nq\n\n\n\nLastly, we will do text annotations, which are “on the other side” of the line\nannotations. We also add the values for the legend.\n\n\n# Base square\nlibrary(ggtext)\n\nq <- q + annotate(geom = \"richtext\", x = 7.5, y = 9.15, \n                  label = \"Outlines indicate that abortion was **fully**\n                  <br>**illegal** or **illegal after about six weeks** for\n                  <br>at least half of the two months after Dobbs\", \n                  size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n                  family = \"Helvetica\")\n\n# ND\n\nq <- q + annotate(geom = \"richtext\", x = 2.6, y = 7.7,\n             label = \"The only abortion clinic in \n             <span style = 'color:#480A34'>**North Dakota**<\/span>\n             <br> moved to <span style = 'color:#567F4D'>**Minnesota**<\/span>, \n             where the number<br>of abortions rose by \n             <span style = 'color:#567F4D'>**14%**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\")\n\n# CA & AZ\n\nq <- q + annotate(geom = \"richtext\", x = 0.5, y = 0.25,\n             label = \"Abortions in <span style = 'color:#567F4D'>**California**<\/span>\n             <br>rose by only <span style = 'color:#567F4D'>**1%**<\/span>, although\n             <br>they declined by <span style = 'color:#99607E'>**53%**<\/span> in\n             <br>neighboring <span style = 'color:#99607E'>**Arizona**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\")\n\n# AR\n\nq <- q + annotate(geom = \"richtext\", x = 6.4, y = -0.4,\n             label = \"Many Southern states saw a<\n             br><span style = 'color:#480A34'>**100% decline**<\/span> in the number\n             <br>of abortions as a result of<br>post-Dobbs legislation\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, color = \"#555555\", \n             family = \"Helvetica\") +\n  xlim(-0.5, 13.5) + ylim(-0.7, 9.7)\n\n# Legend\nq <- q + annotate(geom = \"richtext\", x = -0.25, y = 9.6,\n             label = \"-100%\",\n             size = 3, fill = NA, label.color = NA, hjust = 0) \n\nq <- q + annotate(geom = \"richtext\", x = 0.35, y = 9.6,\n             label = \"No change\",\n             size = 3, fill = NA, label.color = NA, hjust = 0)\n\nq <- q + annotate(geom = \"richtext\", x = 1.3, y = 9.6,\n             label = \"+100%\",\n             size = 3, fill = NA, label.color = NA, hjust = 0) \n\nq\n\n\n\nEnhancement\nWe create a new dataframe, which contains new positions for the states. We do this\nto separate them, so they don’t share the lines outside the states. This way we will\nbe able to add the information.\n\n\ndf <- data.frame(\n  x = c(1, 10.1, 7.5, 3.6, 2.3, 4.9, 14, 14, 14, 12.7, 11.4, \n        1, 7.5, 3.6, 7.5, 8.8, 6.2, 8.8, 6.2, 14, 12.7, 15.3, \n        10.1, 7.5, 7.5, 8.8, 4.9, 12.7, 6.2, 6.2, 15.3, 12.7, 4.9, \n        3.6, 12.7, 10.1, 4.9, 2.3, 11.4, 15.3, 11.4, 6.2, 10.1, 6.2, \n        3.6, 11.4, 14, 2.3, 8.8, 10.1, 4.9),\n  y = c(10.1, 2.3, 2.3, 3.6, 4.9, 4.9, 6.2, 3.6, 4.9, 1, 2.3, \n        2.3, 6.2, 7.5, 4.9, 4.9, 3.6, 3.6, 2.3, 7.5, 4.9, 10.1, \n        7.5, 7.5, 3.6, 2.3, 7.5, 3.6, 7.5, 4.9, 8.8, 6.2, 3.6, \n        4.9, 7.5, 6.2, 2.3, 6.2, 6.2, 7.5, 3.6, 6.2, 3.6, 1, \n        6.2, 4.9, 8.8, 7.5, 6.2, 4.9, 6.2),\n  state = c(\"AK\", \"AL\", \"AR\", \"AZ\", \"CA\", \"CO\", \"CT\", \"DC\", \"DE\", \"FL\", \"GA\", \n            \"HI\", \"IA\", \"ID\", \"IL\", \"IN\", \"KS\", \"KY\", \"LA\", \"MA\", \"MD\", \"ME\", \n            \"MI\", \"MN\", \"MO\", \"MS\", \"MT\", \"NC\", \"ND\", \"NE\", \"NH\", \"NJ\", \"NM\", \n            \"NV\", \"NY\", \"OH\", \"OK\", \"OR\", \"PA\", \"RI\", \"SC\", \"SD\", \"TN\", \"TX\", \n            \"UT\", \"VA\", \"VT\", \"WA\", \"WI\", \"WV\", \"WY\"),\n  state.color = c(\"black\", \"white\", \"white\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\", \n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"black\", \"black\", \"white\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"white\",\n                  \"white\", \"black\", \"black\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\", \"black\", \"black\",\n                  \"white\", \"white\", \"black\", \"black\", \"black\",\n                  \"black\", \"white\", \"white\", \"white\", \"black\",\n                  \"black\", \"black\", \"black\",\"white\", \"black\", \"black\"),\n  value = c(2, -100, -100, -53, 1, 33, -1, 0, 24, 10, -57, 4, -27, -48, 28,\n           15, 36, -100, -100, -3, 1, 18, 8, 14, -83, -100, 30, 37, -100, 30,\n           -6, 7, 12, 21, 12, -65, -100, 18, 6, -7, -56, -100, -78, -100, -3,\n           -4, 16, 5, -100, -8, -5))\n\n\nBase\nWe create a new base, with a black background. We do this because if we do an\n“honest” color gradient, a lot of the states will be close to white. We also add a\nnew color pallete.\n\n\nlibrary(ggdark)\nq <- ggplot(df) +\n  aes(x, y, fill=value) +\n  geom_tile(color=\"black\", linewidth=6) +\n  geom_text(aes(label=state, color=state.color), size=6) +\n  coord_fixed() +\n  scale_fill_gradientn(colors = c(\"#9b2226\",\"#F0F0F0\", \"#3a5a40\"),\n                       breaks = c(-100, 0, 100),\n                       limits = c(-100, 100)) +\n  scale_color_identity() +\n  theme_void() +\n  dark_theme_minimal() +\n  theme(axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.background = element_blank(),\n        panel.grid = element_blank())\n  \n\nq\n\n\n\nSquares\nWe begin with the squares that will sorround each state. This way, we can give to each\nof them an alpha value which represent the support of the population to overturning\nRoe v. Wade.\n\n\n# AK\n\nq <- q + \n  annotate(\"segment\", x = 0.43, xend = 0.43, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 9.53, yend = 9.53, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 1.57, xend = 1.57, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 10.67, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# HI\n\nq <- q + \n  annotate(\"segment\", x = 0.43, xend = 0.43, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 1.57, xend = 1.57, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 0.43, xend = 1.57, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# WA\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# OR\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# CA\n\nq <- q + \n  annotate(\"segment\", x = 1.73, xend = 1.73, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 2.87, xend = 2.87, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 1.73, xend = 2.87, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261)\n\n# ID\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565)\n\n# UT\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# NV\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# AZ\n\nq <- q + \n  annotate(\"segment\", x = 3.03, xend = 3.03, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.17, xend = 4.17, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 3.03, xend = 4.17, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# MT\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.565)\n\n# WY\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.870)\n\n# CO\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 4.33, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 4.33, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 5.46, yend = 5.46, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# NM\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# OK\n\nq <- q + \n  annotate(\"segment\", x = 4.33, xend = 4.33, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.46, xend = 5.46, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 4.33, xend = 5.46, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783)\n\n# ND\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# SD\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391)\n\n# NE\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.783)\n\n# KS\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# LA\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696)\n\n# TX\n\nq <- q + \n  annotate(\"segment\", x = 5.63, xend = 5.63, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 0.43, yend = 0.43, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.77, xend = 6.77, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 5.63, xend = 6.77, y = 1.57, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609)\n\n# MN\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# IA\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 5.63, yend = 6.77,\n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.261)\n\n# IL\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.07, xend = 8.07, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 6.93, xend = 8.07, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# MO\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 8.06, xend = 8.06, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.609)\n\n# AR\n\nq <- q + \n  annotate(\"segment\", x = 6.93, xend = 6.93, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 8.06, xend = 8.06, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1) +\n  annotate(\"segment\", x = 6.93, xend = 8.06, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 1)\n\n# WI\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# IN\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.696)\n\n# KY\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# MS\n\nq <- q + \n  annotate(\"segment\", x = 8.23, xend = 8.23, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.37, xend = 9.37, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 8.23, xend = 9.37, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652)\n\n# MI\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# OH\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n# WV\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.739)\n\n# TN\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.652)\n\n# AL\n\nq <- q + \n  annotate(\"segment\", x = 9.53, xend = 9.53, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 10.67, xend = 10.67, y = 1.73, yend = 2.87,\n           color = \"#7DB4DE\", size = 1, alpha = 0.522) +\n  annotate(\"segment\", x = 9.53, xend = 10.67, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.522)\n\n# PA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# VA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.130)\n\n# SC\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.435)\n\n\n# GA\n\nq <- q + \n  annotate(\"segment\", x = 10.83, xend = 10.83, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 1.73, yend = 1.73, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 11.97, xend = 11.97, y = 1.73, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478) +\n  annotate(\"segment\", x = 10.83, xend = 11.97, y = 2.87, yend = 2.87, \n           color = \"#7DB4DE\", size = 1, alpha = 0.478)\n\n# NY\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# NJ\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.174)\n\n# MD\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# NC\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0.348)\n\n# FL\n\nq <- q + \n  annotate(\"segment\", x = 12.13, xend = 12.13, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 0.43, yend = 0.43, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 13.27, xend = 13.27, y = 0.43, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391) +\n  annotate(\"segment\", x = 12.13, xend = 13.27, y = 1.57, yend = 1.57, \n           color = \"#7DB4DE\", size = 1, alpha = 0.391)\n\n# VT\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 8.23, yend = 8.23, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 9.37, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217)\n\n# MA\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# CT\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 5.63, yend = 5.63, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 5.63, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 6.77, yend = 6.77, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# DE\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 4.33, yend = 4.33, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 4.33, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 5.47, yend = 5.47, \n           color = \"#7DB4DE\", size = 1, alpha = 0.087)\n\n# DC\n\nq <- q + \n  annotate(\"segment\", x = 13.43, xend = 13.43, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 3.03, yend = 3.03, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 14.57, xend = 14.57, y = 3.03, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0) +\n  annotate(\"segment\", x = 13.43, xend = 14.57, y = 4.17, yend = 4.17, \n           color = \"#7DB4DE\", size = 1, alpha = 0)\n\n# ME\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 9.53, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 9.53, yend = 9.53, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 9.53, yend = 10.67,\n           color = \"#7DB4DE\", size = 1, alpha = 0.043) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 10.67, yend = 10.67, \n           color = \"#7DB4DE\", size = 1, alpha = 0.043)\n\n# NH\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 8.23, yend = 8.23, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 8.23, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 9.37, yend = 9.37, \n           color = \"#7DB4DE\", size = 1, alpha = 0.304)\n\n# RI\n\nq <- q + \n  annotate(\"segment\", x = 14.73, xend = 14.73, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 6.93, yend = 6.93, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 15.87, xend = 15.87, y = 6.93, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217) +\n  annotate(\"segment\", x = 14.73, xend = 15.87, y = 8.07, yend = 8.07, \n           color = \"#7DB4DE\", size = 1, alpha = 0.217)\n\nq\n\n\n\nText\nWe add a new title and complete the caption with information about the new data.\n\n\nq <- q + labs(\n  title = \"Relation between the drop in abortion after Dobbs and the public opinion\",\n  caption = paste0(\"Percent change in abortions is calculated from #WeCount's unrounded data.\",\n                  \"\\nData on opinion about overturning Roe v. Wade extracted from the \",\n                  \"PRRI American Values Atlas.\")\n) +\n  theme(plot.title = element_text(size = 15, color = \"white\", face = \"bold\", \n                                  family = \"Helvetica\", hjust = 0.1, vjust = 0)) +\n  theme(plot.subtitle = element_text(size = 14, color = \"white\", face = NULL, \n                                     family = \"Helvetica\", hjust = 0.8, vjust = 0)) +\n  theme(plot.caption = element_text(size = 10, color = \"white\", face = NULL, \n                                    family = \"Helvetica\", hjust = 0, vjust = 2))\n\nq\n\n\n\nAnnotations\nWe add the line and text annotations with information about the states and the\npublic opinion of each state\n\n\n# ANNOTATION 1: ND AND MN\n\n# ND\nq <- q + annotate(\"segment\", x = 6.5, xend = 6.5, y = 8.07, yend = 9, \n                  color = \"white\")\n\nq <- q + annotate(geom = \"richtext\", x = 3.8, y = 9.7,\n                  label = \"The only abortion clinic in \n                  <span style = 'color:#9B2226'>**North Dakota**<\/span>\n                  <br> moved to <span style = 'color:#D5DAD5'>**Minnesota**<\/span>, \n                  where the number<br>of abortions rose by \n                  <span style = 'color:#D5DAD5'>**14%**\",\n                  size = 5, fill = NA, label.color = NA, hjust = 0, \n                  color = \"white\")\n\n# ANNOTATION 2: CA AND AZ\n\n# TX\nq <- q + annotate(\"segment\", x = 3.6, xend = 5.6, y = 1, yend = 1, \n                  color = \"white\")\n\n# OK Vrt\nq <- q + annotate(\"segment\", x = 3.6, xend = 3.6, y = 2.3, yend = 0.2, \n                  color = \"white\")\n\n# OK Hzt\nq <- q + annotate(\"segment\", x = 3.6, xend = 4.3, y = 2.3, yend = 2.3, \n                  color = \"white\")\n\n# TX&OK\n\nq <- q + annotate(geom = \"richtext\", x = 1.5, y = -0.6,\n             label = \"The states in which abortion \n             <br> dropped to <span style = 'color:#9B2226'>**0**<\/span> also showed \n             <br> the strongest support to <br> overturning \n             <span style = 'color:#7DB4DE'>**Roe v. Wade**\",\n             size = 5, fill = NA, label.color = NA, hjust = 0, \n             color = \"white\") \n\n# ANNOTATION 3: AR\n\n# AR\n# AR1\nq <- q + annotate(\"segment\", x = 7.5, xend = 7.5, \n                  y = 1.65, yend = -0.5)\n# AR2\nq <- q + annotate(\"segment\", x = 7.5, xend = 7.9, \n                  y = -0.5, yend = -0.5)\n\n# AR\n\nq <- q + annotate(geom = \"richtext\", x = 8, y = -0.7,\n                  label = \"<span style = 'color:#9B2226'>**Arkansas**<\/span> \n                  is the state in which<br>more people are in favor of\n                  <br>overturning Roe v. Wade:<span style = 'color:#7DB4DE'> **48%**\",\n                  size = 5, fill = NA, label.color = NA, hjust = 0,\n                  color = \"white\") \nq\n\n\n\nLegends\nWe start withe the first legend, which represent the colors for the filling of the\nstates.\n\n\nq <- q + guides(fill = guide_colorbar(#title = \"PERCENT CHANGE\",\n                                      #title.position = \"top\",\n                                      #title.theme = element_text(size = 10,\n                                                                 #family = \"Helvetica\"),\n                                      #title.hjust = 0.5,\n                                      #title.vjust = 0.5,\n                                      label = FALSE,\n                                      barheight = 0.7,\n                                      barwidth = 11,\n                                      #nbin = 100,\n                                      ticks = FALSE,\n                                      direction = \"horizontal\", )) +\n  theme(legend.position = c(0.28, 0.915),\n        legend.title = element_blank()) + ylim(-1.3, 12) +\n  annotate(geom = \"richtext\", x = 2.8, y = 12, \n                  label = \"Percent change in abortions <br> from April to August of 2022\", \n                  size = 4, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 2.8, y = 11.1, \n                  label = \"-100%\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 3.9, y = 11.1, \n                  label = \"No change\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 5.4, y = 11.1, \n                  label = \"+100%\", \n                  size = 3, fill = NA, label.color = NA, hjust = 0, \n                  family = \"Helvetica\", color = \"white\") \nq\n\n\n\nThe second legend explains the squares that sorround the states.\n\n\nq <- q + \n annotate(geom = \"richtext\", x = 9.5, y = 12, \n                  label = \"Percent of population who \n                  <br>would like Roe v. Wade overturned\", \n                  size = 4, fill = NA, label.color = NA, hjust = 0, \n          family = \"Helvetica\", color = \"white\") +\n  annotate(\"rect\", xmin = 9.55, xmax = 9.85, ymin = 11.3, \n           ymax = 11.6, alpha = 0, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 9.86, xmax = 10.16, ymin = 11.3, \n           ymax = 11.6, alpha = 0.1, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.17, xmax = 10.47, ymin = 11.3, \n           ymax = 11.6, alpha = 0.2, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.48, xmax = 10.78, ymin = 11.3, \n           ymax = 11.6, alpha = 0.3, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 10.79, xmax = 11.09, ymin = 11.3, \n           ymax = 11.6, alpha = 0.4, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.10, xmax = 11.40, ymin = 11.3, \n           ymax = 11.6, alpha = 0.5, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.41, xmax = 11.71, ymin = 11.3, \n           ymax = 11.6, alpha = 0.6, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 11.72, xmax = 12.02, ymin = 11.3, \n           ymax = 11.6, alpha = 0.7, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.03, xmax = 12.33, ymin = 11.3, \n           ymax = 11.6, alpha = 0.8, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.34, xmax = 12.64, ymin = 11.3, \n           ymax = 11.6, alpha = 0.9, fill = \"#7DB4DE\") +\n  annotate(\"rect\", xmin = 12.65, xmax = 12.95, ymin = 11.3, \n           ymax = 11.6, alpha = 1, fill = \"#7DB4DE\") +\n  annotate(geom = \"richtext\", x = 9.5, y = 11.1, \n                  label = \"25%\", \n                  size = 3, fill = NA, label.color = NA, \n           hjust = 0, family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 11.07, y = 11.1, \n                  label = \"36%\", \n                  size = 3, fill = NA, label.color = NA, \n           hjust = 0, family = \"Helvetica\", color = \"white\") +\n  annotate(geom = \"richtext\", x = 12.64, y = 11.1, \n                  label = \"48%\", \n                  size = 3, fill = NA, label.color = NA, \n            hjust = 0, family = \"Helvetica\", color = \"white\")\n  \nq\n\n\n\n\n\n\n",
    "preview": "projects/2023/100407986/100407986_files/figure-html5/unnamed-chunk-15-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2304,
    "preview_height": 2112
  },
  {
    "path": "projects/2023/100507500/",
    "title": "Post-COVID Wallet Woes: The High Cost of Living",
    "description": "COVID-19 had a major impact on the economy and effectively affected the\nconsumption patterns of European households.",
    "author": [
      {
        "name": "Phong Duong",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nCollecting and processing data\nLoading packages\nGetting the data\nTransforming data\n\nReplicating the plot\nBuilding the basic elements\nBuilding icon graph (second graph)\nPatching things up…\n\nAlternative graph\nLoading libraries\nFont\nLoad and transform data\nBuilding the graph\nSecond plot\nFinal result\n\n\nIntroduction\nEurostat provided comprehensive statistical indicators and data visualisations on key figures on the overall economic situation of the Europe Union in 2023 in the sixth edition of Key figures on Europe. One interesting graph was about the household consumption spending in which the author demonstrated the difference in choices in spending of European households between 2022 and 2023. The author also detailed the changes in spending behaviours since the pandemic of COVID-19 in 2020.\nEurostat also provides the source of the data and we will use it to replicate the graph in this project. Later, an alternative graph will be presented as a suggestion for improving the original graph.\nHere is the original graph:\nHousehold consumption expenditure by EurostatCollecting and processing data\nLoading packages\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(extrafont)\nlibrary(sysfonts)\nlibrary(showtext)\nlibrary(ggimage)\nlibrary(patchwork)\n\n\nGetting the data\nLike previously said, Eurostat includes a link in the graph to find the source data. It is possible to include more data from other years as well as from specific countries.\n\n\ndata <- read_csv(\"EU_data.csv.gz\")\n\n\nThe data file only included coded names for the categories so we will need to create a new column with the names similarly to the graph. The guidelines for the names according to the coded names are also provided by Eurostat (link. We will also add a percent column for more ease to work with as the original data column (OBS_VALUE) is on the scale of 1000. Finally, we only need the data from year 2022 and 2023 so we will filter the data accordingly and select the necessary columns to build the graph.\nTransforming data\n\n\ndataset <- data %>% \n  select(coicop, TIME_PERIOD, OBS_VALUE) %>% \n  mutate(coicop_name = case_when(\n    coicop == \"CP00\" ~ \"All-items HICP\",\n    coicop == \"CP01\" ~ \"Food and non-alcoholic beverages\",\n    coicop == \"CP02\" ~ \"Alcoholic beverages, tobacco and narcotics\",\n    coicop == \"CP03\" ~ \"Clothing and footwear\",\n    coicop == \"CP04\" ~ \"Housing, water and energy\", #change to fit the graph\n    coicop == \"CP05\" ~ \"Household equipment and maintenance\", #Change to fit the graph\n    coicop == \"CP06\" ~ \"Health\",\n    coicop == \"CP07\" ~ \"Transport\",\n    coicop == \"CP08\" ~ \"Communications\",\n    coicop == \"CP09\" ~ \"Recreation and culture\",\n    coicop == \"CP10\" ~ \"Education\", \n    coicop == \"CP11\" ~ \"Restaurants and hotels\",\n    coicop == \"CP12\" ~ \"Miscellaneous goods and services\"\n    ),\n    percent = OBS_VALUE / 1000 * 100) %>% \n  filter((!coicop %in% c(\"CP00\")) & between(TIME_PERIOD, 2022, 2023)) %>% \n  select(coicop, coicop_name, TIME_PERIOD, percent)\n\n\nReplicating the plot\nBuilding the basic elements\nNow we already have the data set ready, we will start reproducing the graph, first by the basic elements (bar chart, correct axes’ positions and scales, and theme). We need to customise the labels on the y axis so that we would not have to rewrite the names on the data set. The colors of the bars also need to be manually picked, this can be done by using a third party web application to identify the color and then simply plug them into manual scale in ggplot (scale_fill_manual).\n\n\np_main <- ggplot(dataset, aes(x = percent,y = reorder(coicop_name, percent))) +\n  geom_col(position = position_dodge2(reverse = TRUE), aes(fill = as.character(TIME_PERIOD)), width = 0.6) +\n  #Axes and scales\n  scale_x_continuous(name = NULL, limits = c(0,20), breaks = seq(0,20,5), position = \"top\") +\n  scale_fill_manual(values = c(\"#ad9000\", \"#2a46aa\"), labels = c(\"Jan 2022\", \"Jan 2023\")) +\n  #Theme\n  theme(#Background and grid line\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_line(\n          colour = \"grey\", \n          linetype = \"dashed\", \n          size = 0.3),\n        plot.margin = margin(0,185,5,10),\n        #Axes\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        #Legend \n        legend.title = element_blank(),\n        legend.position = c(1.3, 0.97),\n        legend.key.height = unit(0.68, \"char\"),\n        legend.key.width = unit(1.25, \"char\"),\n        legend.spacing.y = unit(0.3, \"char\")\n        ) +\n  guides(fill = guide_legend(byrow = TRUE)) #helps spacing elements in legend\n\n#Y axis labels\nlabels <- c(\n  \"Food and\\nnon-alcoholic\\nbeverages\",\n  \"Housing,\\nwater\\nand energy\",\n  \"Transport\",\n  \"Miscellaneous\\ngoods and\\nservices\",\n  \"Restaurants\\nand hotels\",\n  \"Recreation\\nand culture\",\n  \"Household\\nequipment and\\nmaintenance\",\n  \"Health\",\n  \"Clothing\\nand footwear\",\n  \"Alcoholic\\nbeverages,\\ntobacco\\nand narcotics\",\n  \"Communications\",\n  \"Education\"\n) %>% rev()\n\n\np_main <- p_main + scale_y_discrete(name = NULL,labels = labels) \n\np_main\n\n\n\nIt is noted that in this project, we are replicating the original graph by building 2 separate graphs then later patch them together to achieve a similar look to the original graph. This is because using graphic icons (on the axis label) is not native to ggplot2. Additionally, there was no package that could directly attach the illustrations exactly in the manner of the original graph. Therefore, we will manually create a graph that only has a vector of the icons then attach it to the graph we just created above to achieve the same effect of the original graph.\nFirst we will complete replicating the first part of the graph by adding the annotation text on the right side of the plot.\n\n\ncaption_text <- \"In January 2023, the largest categories of\nhousehold consumption expenditure in the\nEU were: food and non-alcoholic beverages;\nhousing, water and energy; and transport.\nTogether they accounted for close to half\n(47.1 %) of total expenditure. All three of these\ncategories were characterised by high price\nincreases during 2022, underlying their role in\nrelation to the cost-of-living crisis.\\n\nThe COVID-19 crisis impacted not only\noverall economic activity, but also household\nconsumption patterns. Across the EU, the share\nof household expenditure on several categories\ncommonly related to eating and living at home\nincreased between January 2020 and January\n2021. However, with COVID-19 restrictions\nlifted, there was some evidence that household\nconsumption was returning to its pre-pandemic\nstructure. There was a rebound in the share\nof expenditure for activities outside the home\nbetween January 2022 and January 2023, most\nnotably an increase of 2.1 percentage points for\nrestaurants and hotels; there were also notable\ngains for recreation and culture and for transport\n(up 0.7 and 0.5 points, respectively).\"\n\np_main <- p_main +\n  labs(tag = caption_text) +\n  coord_cartesian(clip = \"off\") +\n  theme(plot.tag.position = c(1.060, 0.51),\n        plot.tag = element_text(hjust = 0, \n                                size = 9,\n                                colour = \"grey50\", \n                                lineheight = 1.25)) \np_main\n\n\n\nNow we already have all the elements of the main part of the original graph, we can adjust the text so that it looks like the original one. The original graph used an Adobe font, which is also not openly available, therefore we will use another font from Google fonts that closely resembles it (Open Sans).\n\n\n#Fonts\nfont_add_google(\"Open Sans\", family=\"opensans\")\nshowtext_auto()\nfont <- \"opensans\"\n\np_main <- p_main +\n  theme(\n    legend.text = element_text(vjust = 0.5, margin = margin(0,0,0,-3), face = \"bold\", \n                               size = 9, family = font),\n    plot.tag = element_text(family = font),\n    axis.text.y = element_text(margin = margin(0,0,0,-22),vjust = 0.4, \n                               family = font, size = 9, lineheight = 1.02),\n    axis.text.x = element_text(family = font, size = 9)\n  )\n\np_main\n\n\n\nBuilding icon graph (second graph)\nWe now create the second part of the graph which is the icons. To do this, we would first need to cut out the icons manually from the original graph and process them into appropriate file type (e.g. png). This can be done by using different third-party applications (such as Photoshop, Illustrator, Affinity Designer, etc.). We then use ggimage to turn the pictures into usable R object and plot them on a ggplot graph. We also need to remove all other elements (i.e. axis, grid, text, background, etc.) to have a singular graphic vector of the icons.\n\n\n#Add images path\ndataset <- dataset %>% \n  mutate(path = case_when(\n    coicop == \"CP01\" ~ \"images/Food@2x.png\",\n    coicop == \"CP02\" ~ \"images/Alcoholic@2x.png\",\n    coicop == \"CP03\" ~ \"images/Clothing@2x.png\",\n    coicop == \"CP04\" ~ \"images/Housing@2x.png\",\n    coicop == \"CP05\" ~ \"images/Householdequip@2x.png\",\n    coicop == \"CP06\" ~ \"images/Health@2x.png\",\n    coicop == \"CP07\" ~ \"images/Transport@2x.png\",\n    coicop == \"CP08\" ~ \"images/Communications@2x.png\",\n    coicop == \"CP09\" ~ \"images/Recreation@2x.png\",\n    coicop == \"CP10\" ~ \"images/Education@2x.png\", \n    coicop == \"CP11\" ~ \"images/Restaurant@2x.png\",\n    coicop == \"CP12\" ~ \"images/Miscellaneous@2x.png\"\n  ))\n\np_icon <- ggplot(dataset, aes(x = percent,y = reorder(coicop_name, percent))) +\n  geom_image(aes(image = path, x = 0), size=.12) +\n  theme(\n    axis.text = element_blank(),\n    panel.grid = element_blank(),\n    axis.ticks = element_blank(),\n    panel.background = element_blank()\n  ) + \n  labs(x = NULL, y = NULL, fill = NULL)\n\np_icon\n\n\n\nPatching things up…\nHaving 2 parts of the graph created, we now only need to merge them together to create a unified graph. Using patchwork package, we can adjust the size of the 2 graphs so that they look similar to the original graph. We also need to add the title and subtitle, along with the source of the data at the foot of the plot. Since the original graph has a second subtitle with a different color (which is also not native to ggplot2), we will write it as an html element using ggtext package.\n\n\ncaption_source = \"Source: Eurostat (online data code: <span style = 'color:#2a46aa'>prc_hicp_inw<\/span>)\"\n\np_replicated <- wrap_plots(list(p_icon, p_main), widths = c(8,16)) &\n  plot_annotation(\n    title = \"Household<br>consumption expenditure\",\n    subtitle = \"<span><b>Household budget structure<b><\/span><br>\n    <span style = 'font-size: 10pt; color:#878586'>\n    (%,share of total household consumption expenditure, EU, January 2022 and 2023)\n    <\/span>\",\n    caption = caption_source,\n    theme = theme(\n      plot.margin = margin(15,50,15,15),\n      plot.title = element_markdown(\n        colour = \"#2a46aa\", \n        size = 27,  \n        family = font,\n        face = \"bold\",\n        lineheight = 0.8),\n      plot.subtitle = element_markdown(\n        colour = \"#2a46aa\", size = 13,\n        family = font, lineheight = 1.3),\n    #caption / source\n    plot.caption.position = \"plot\",\n    plot.caption = element_markdown(\n      hjust = 0, \n      size = 8, \n      colour = \"#878586\")\n    )\n  )\np_replicated\n\n\n\nAlternative graph\nThe graph from Eurostat is fairly simple to understand and the visualisation issues are minimal. The text on the right of the graph is a little lengthy and quite misses the point of creating a graph (putting words and data into graphs and charts for quick understanding). The icons used also make the graph less reproducible and consequently less apt for sharing or scaling. We will consider these issues and make an alternative graph that presents the same information but is potentially better for interpretation.\nLoading libraries\n\n\nlibrary(scales)\nlibrary(ggstance)\nlibrary(fontawesome) #For icons in table in second plot\nlibrary(gt) #For creating nice tables\nlibrary(gtExtras) #For icons in gt\nlibrary(emojifont) #For easy plotting fontawesome\n\n\nFont\n\n\nfont_add_google(\"Montserrat\", family=\"montserrat\")\nshowtext_auto()\nfont <- \"montserrat\"\n\n\nWe are using a google font for easy access and reproducibility. Montserrat also looks modern and easy to read.\nLoad and transform data\n\n\ndata <- read_csv(\"custom_data.csv\")\ndata <- data %>% \n  select(coicop, geo, TIME_PERIOD, OBS_VALUE)\n\neu <- data %>% filter(geo == \"EU27_2020\" & coicop != \"CP00\" & TIME_PERIOD >= 2015) %>%\n  mutate(coicop_name = case_when(\n    coicop == \"CP01\" ~ \"Food and non-alcoholic beverages\",\n    coicop == \"CP02\" ~ \"Alcoholic beverages, tobacco and narcotics\",\n    coicop == \"CP03\" ~ \"Clothing and footwear\",\n    coicop == \"CP04\" ~ \"Housing, water and energy\", #change to fit the graph\n    coicop == \"CP05\" ~ \"Household equipment and maintenance\", #Change to fit the graph\n    coicop == \"CP06\" ~ \"Health\",\n    coicop == \"CP07\" ~ \"Transport\",\n    coicop == \"CP08\" ~ \"Communications\",\n    coicop == \"CP09\" ~ \"Recreation and culture\",\n    coicop == \"CP10\" ~ \"Education\", \n    coicop == \"CP11\" ~ \"Restaurants and hotels\",\n    coicop == \"CP12\" ~ \"Miscellaneous goods and services\"\n    ),\n    percent = OBS_VALUE / 10) %>% \n  select(coicop, coicop_name, TIME_PERIOD, percent) %>% \n  rename(year = TIME_PERIOD) %>% \n  group_by(coicop) %>% \n  mutate(\n    change = percent - lag(percent)\n  ) %>% ungroup()\n\n\nWe need to pull out more data from Eurostat so that we have the data from the previous years to turn the long text into a graph. The data transformation process is the same. Since we are turning the text into a graph, we will have to create 2 separate plots then patch them up together to create a whole graph.\nBuilding the graph\nWe start by building the background for the first graph (alternative version of the main plot in the original graph). We are keeping some elements of the original graph (vertical dashed-lines for grid-line, x-axis label on the top, etc.) so it does not look too different from the original but rather an enhancement based on the original graph.\nAlso, the original graph’s x-axis labels might be a bit unclear so we will put a ‘%’ sign next to the number so the graph is easier to read.\nMain plot background\n\n\nbg <- ggplot(eu, aes(y = reorder(coicop_name, percent), x = percent)) +\n  scale_x_continuous(limits = c(0,20),breaks = c(0,5,10,15,20), position = \"top\",\n                     labels = function(x) paste0(x, \"%\")) +\n  labs(subtitle = \"Share of total household consumption expenditure, European Union\") +\n  theme(\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"grey\",linetype = \"dashed\"),\n    panel.background = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(size = 12),\n    plot.title.position = \"plot\",\n    plot.subtitle = element_text(family = font, colour = \"grey60\", \n                                   size = 16 ,face = \"bold\")\n  ) \nbg\n\n\n\nMain Plot\nNow, we can plot the data onto the graph. I believe using 2 circles on the graph instead of the bar chart can deliver the same information but at the same time uses less space and has a more modern, sleek look that the old bar chart.\n\n\n#Data for plot\ny2223 <- eu %>% filter(year >= 2022)\n#Colours\np_color = \"blue\"\n\n\n\n\np_main <- bg +\n  geom_point(data = y2223,\n             aes(percent, \n                 reorder(coicop_name,percent), \n                 shape = as.factor(year)),\n             size = 5,\n             colour = p_color) +\n  scale_shape_manual(values = c(1, 19)) +\n  theme(\n    plot.margin = margin(10,10,10,10),\n    legend.position = \"top\",\n    legend.justification = \"right\",\n    legend.title = element_blank(),\n    legend.key = element_blank(),\n    legend.text = element_text(size = 12, family = \"montserrat\"),\n    legend.direction = \"horizontal\",\n    axis.text = element_text(family = \"montserrat\"),\n    axis.text.y = element_text(colour = p_color, size = 13) \n  )\np_main\n\n\n\nSecond plot\nFor the second plot, the message of the annotation text from the original graph is about the changes of the household spending categories since the incident of COVID-19. After the virus spread had subdued and curfew and restrictions had been lifted, people seemed to resume to normal activities (going to restaurant, travelling, etc.). Instead of writing in text, I thought that we can turn it into a table like graph that shows the trend of the spending compared to the previous year (up or down). With this, we can sort of see the story of how life unfolded after COVID-19 for each category.\n\n\n#Dataframe for second plot\np2_df <- eu %>% filter(year >= 2020) %>% \n  mutate(icon = if_else(change < 0, \"fa-angle-down\", \"fa-angle-up\"))\n\n# Icon size\nicon_size <- 8\ny_label_pos <- filter(p2_df, year == 2023) %>% arrange(desc(percent)) %>% pull(coicop_name) %>% rev()\n\np2 <- ggplot(p2_df, aes(x = year, y = factor(coicop_name, levels = factors))) +\n  scale_x_discrete(limits = c(2020, 2021, 2022, 2023),position = \"top\") +\n  geom_text(data = filter(p2_df, year == 2020),\n            aes(x = 2020, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size)+\n  geom_text(data = filter(p2_df, year == 2021),\n            aes(x = 2021, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  geom_text(data = filter(p2_df, year == 2022),\n            aes(x = 2022, y = coicop_name, label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  geom_text(data = filter(p2_df, year == 2023),\n            aes(x = 2023, y = reorder(coicop_name, percent), label = fontawesome(icon), color = icon),\n            family = \"fontawesome-webfont\",\n            size = icon_size) +\n  scale_colour_manual(values = c(\"red\", \"blue\")) +\n  scale_y_discrete(limits = y_label_pos) +\n  theme(\n    panel.grid.major.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.background = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title = element_blank(),\n    axis.text = element_text(size = 12, family = font, face = \"bold\"),\n    axis.text.y = element_blank(),\n    legend.position = \"none\"\n  ) \np2\n\n\n\nFinal result\n\n\nwrap_plots(list(p_main, p2), widths = c(17,6.5)) & \n  plot_annotation(\n    title = \"Household Consumption Expenditure\",\n    theme = theme(\n      plot.title = element_text(size = 26, family = font, \n                                colour = \"blue\", face = \"bold\")\n    )\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2023/100507500/100507500_files/figure-html5/out-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 1728
  },
  {
    "path": "projects/2023/100507931/",
    "title": "Public Trust in Government Hits Historic Lows",
    "description": "Using Pew Research data to visualize the evolution of public trust towards \ndifferent U.S. governments between 1972 and 2023.",
    "author": [
      {
        "name": "Ana Pérez-Barrera",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nLooking closely at the U.S.\n\nCleaning the data\nBuilding the chart\nThe background\nLet’s fill it\nAdding text\nAnnotations\n\nDefining the theme\nGoogle fonts\nArranging the final plot\n\nAlternative visualization\nManaging the data\nSeparate plots!\nKey data points\nFinal theme\n\nConclusions\nLimitations\n\nBibliography\n\nIntroduction\nAccording to the OECD (2013), Public Trust in Government represents the confidence of citizens and businesses in the actions of government to do what is right and perceived as fair. While levels of trust in institutions vary significantly across countries, opinion surveys suggest that there has been a decline in trust in public institutions in recent decades (United Nations, 2021). For instance, in the United States, overall trust in the national government has declined from 73% in 1958 to 24% in 2021. Western Europe has seen a similar steady decline in public trust since the 1970s.\nWhy should we care about public trust? Firstly, it is a fundamental indicator upon which the legitimacy and sustainability of political systems are built. Secondly, greater public trust has been found to improve compliance in regulations and tax collections, as well as to be a crucial determinant for successful government responses. Finally, increasing concerns suggest that the crisis of public confidence may contribute to support for extreme political views, rising public discontent, protests and, in some cases, violent conflict.\nLooking closely at the U.S.\nThe Pew Research Center has published an article showing the evolution of trust along 4 ideological lines between 1972 and 2023 in the U.S.: Public Trust in Government: 1958-2023 (2023). The report includes data on different trends in trust among party members, races or ideological leanings. This post will be based on the following graph by party and ideology:\nPublic Trust in Government: 1958-2023 (Pew Research Center, 2023).In line with the Pew Research Center findings, the U.S. is currently experiencing historic lows in levels of public trust. Consequently, fewer than two-in-ten Americans say they trust the government in Washington to do what is right “just about always” (1%) or “most of the time” (15%). This is among the lowest trust measures in nearly seven decades of polling.\nThe following ideas are extracted from the article:\nPublic trust reached a three-decade high shortly after the 9/11 terrorist attacks.\nSince 2007, the shares saying they can trust the government has not surpassed 30%.\nWhile Republicans express more pronounced levels of trust, Democrats’ attitudes have tended to be somewhat more consistent.\nThe aim of this post is to replicate the original graph, while proposing an alternative form of visualization that illustrates the main takeaways.\nCleaning the data\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggtext)\n\n\nData on surveys was obtained through different sources, such as the National Election Studies, Gallup, ABC/Washington Post, CBS/New York Times, CNN Polls, and Pew Research Center (from 2020 onward, data is collected through Pew Research Center’s online American Trends Panel; whereas data before 2020 was obtained through traditional telephone surveys). This data is available in csv format and consists on 134 observations representing public trust levels over time among 4 ideological lines.\n\n\ndata <-\n  read_csv(file = \"chart-export-6dcaa713-b94d-4cb5-b91e-e8d433400438.csv\",\n           skip = 3, quote = \"\\\\.\") |>\n  mutate(Date = mdy(str_remove_all(Date, \"\\t|\\\"\")),\n         `Conservative Rep/Lean Rep` =\n           as.numeric(str_remove_all(`Conservative Rep/Lean Rep`, '\"'))) |>\n  rename(pollster = .) \n\ndata<-na.omit(data)\n\ncolnames(data)[3] <- \"Liberal_Dem\"\ncolnames(data)[4] <- \"Cons_Dem\"\ncolnames(data)[5] <- \"Liberal_Rep\"\ncolnames(data)[6] <- \"Cons_Rep\"\n\nsummary(data)\n\n      Date              pollster          Liberal_Dem   \n Min.   :1972-10-15   Length:134         Min.   : 8.00  \n 1st Qu.:1991-03-02   Class :character   1st Qu.:24.25  \n Median :1999-02-08   Mode  :character   Median :30.00  \n Mean   :1999-05-25                      Mean   :29.61  \n 3rd Qu.:2009-04-29                      3rd Qu.:36.00  \n Max.   :2023-06-11                      Max.   :58.00  \n    Cons_Dem      Liberal_Rep       Cons_Rep    \n Min.   :12.00   Min.   : 9.00   Min.   : 4.00  \n 1st Qu.:26.00   1st Qu.:22.00   1st Qu.:15.25  \n Median :32.00   Median :31.00   Median :27.00  \n Mean   :31.69   Mean   :34.81   Mean   :30.49  \n 3rd Qu.:38.00   3rd Qu.:50.00   3rd Qu.:46.75  \n Max.   :56.00   Max.   :66.00   Max.   :69.00  \n\nBuilding the chart\nThe background\nSince the background of the graph is divided by presidential terms, the first step implies creating a vector of date strings for the start and end dates. I firstly established the intervals for the terms of Presidents Ford, Reagan, Clinton, Obama, and Biden. These intervals are then organized into a data frame named colored. Additionally, a vector assigns distinct colors to each president name, which will be later used for the annotations.\nSimilarly, I created a second set of intervals for Presidents Nixon, Carter, H.W. Bush, W. Bush, and Trump, saving them into a data frame named white. These are later used for coloring specific background areas of the plot.\n\n\ncolored_xmin <- c(\"1974-12-01\", \"1980-11-07\", \"1993-01-17\",  \n                  \"2008-12-21\",\"2021-04-11\")\ncolored_xmax <- c(\"1977-04-25\", \"1989-01-15\",\"2001-01-17\", \n                  \"2017-04-11\",\"2023-06-11\")\ncolored <- data.frame(xmin = as.Date(colored_xmin),\n                        xmax = as.Date(colored_xmax),\n                        interval = c(\"Ford\",\"Reagan\",\n                                    \"Clinton\", \"Obama\",\"Biden\" ))\ncolored_interval <-  c(\"Ford\" = \"#C81518\", \"Reagan\" = \"#C81518\",\n                         \"Clinton\" = \"#2E5A87\", \"Obama\" = \"#2E5A87\", \n                         \"Biden\" = \"#2E5A87\")\n  \nwhite_xmin <- c(\"1972-10-15\", \"1977-04-25\", \"1989-01-15\",\n                \"2001-01-17\",\"2017-04-11\")\nwhite_xmax <- c(\"1974-12-01\",\"1980-11-07\",\"1993-01-17\",\n                  \"2008-12-21\",\"2021-04-11\")\nwhite <- data.frame(xmin = as.Date(white_xmin),\n                      xmax = as.Date(white_xmax),\n                      interval = c(\"Nixon\", \"Carter\",\"H.W.Bush\", \n                                   \"W.Bush\", \"Trump\"))\nwhite_interval <- c(\"Nixon\" = \"#C81518\",\"Carter\" = \"#2E5A87\",\n                      \"H.W.Bush\" = \"#C81518\",\"W.Bush\" = \"#C81518\",\n                      \"Trump\" = \"#C81518\")\n\n\nSubsequently, the geom_rect function applies a rectangular shape using the intervals defined in the colored data frame. This is necessary to ensure that the rectangles do not overlap on the lines.\n\n\nPlot <- ggplot(data, aes(x = Date)) +\n  geom_rect(aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = 100),\n            data = colored,\n            fill = \"#E8e8da\", \n            alpha = 0.3,\n            inherit.aes = FALSE, na.rm = TRUE) +\n  guides(fill = FALSE)  +\n  theme_minimal()\n\nPlot\n\n\n\nLet’s fill it\nEach geom_line function is used to plot a line for a specific variable (Liberal Democrat, Cons-Moderate Democrat, Moderate-Lib Republican, and Conservative Republican) to represent the evolution of trust across ideological leanings.\n\n\nPlot <- Plot +\n   \n  geom_line(aes(y = Liberal_Dem, color = \"Liberal Dem/Lean Dem\"), \n             linetype=\"solid\", size=1.75, \n             alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Cons_Dem, color = \"Cons-Moderate Dem/Lean Dem\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Liberal_Rep, color = \"Moderate-Lib Rep/Lean Rep\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  geom_line(aes(y = Cons_Rep, color = \"Conservative Rep/Lean Rep\"), \n            linetype=\"solid\", size=1.75, \n            alpha = 1, linejoin = \"mitre\", lineend= \"round\") +\n  scale_color_manual(values = c(\"Conservative Rep/Lean Rep\" = \"#BF3B27\",\n                                \"Liberal Dem/Lean Dem\" = \"#456A83\",\n                                \"Cons-Moderate Dem/Lean Dem\" = \"#82A6BF\",\n                                \"Moderate-Lib Rep/Lean Rep\" = \"#E37F73\"),\n                     breaks = c(\"Conservative Rep/Lean Rep\", \n                                \"Moderate-Lib Rep/Lean Rep\", \n                                \"Cons-Moderate Dem/Lean Dem\", \n                                \"Liberal Dem/Lean Dem\"),\n                     name= \"\") +\n  scale_y_continuous(limits = c(0, 100), \n                     breaks = seq(0, 100,by = 20),\n                     expand = expansion(0)) + \n  scale_x_date(date_labels = \"%Y\",\n               limits = c(as.Date(\"1972-10-15\"),\n                          max(data$Date)),\n                breaks = seq(as.Date(\"1975-01-01\"),  \n                            max(data$Date), by = \"5 years\"),\n               expand = expansion(0)) + \n  geom_vline(xintercept = as.Date(\"1972-10-15\"), \n            color = \"darkgrey\", \n            size =0.5) \n \nPlot\n\n\n\nAdding text\n\n\nPlot <- Plot +\n  labs(title = \"Trust in government by party and ideology\",\n       subtitle = \"% who say they trust the government to do what is right just about always/most of the time\",\n       caption = \"PEW RESEARCH CENTER\",\n        x = \"\",\n        y = \"\") \n\nPlot\n\n\n\nAnnotations\nIn order to include the names of the Presidents at the top of the chart, I used the annotate function based on the colored and white data frames initially created. Here, I indicated the intervals for the presidential terms and the assigned colors depending on the political party. The text is then rotated in -90 degrees to place the names vertically.\n\n\nPlot <- Plot + annotate(\"text\", x = as.Date(colored_xmin) + \n                            (as.Date(colored_xmax) -\n                               as.Date(colored_xmin))/7, \n                        y = 94, \n                        label = colored$interval, \n                        size = 4, \n                        angle = -90,  \n                        color = colored_interval[colored$interval])\n  \nPlot <- Plot + annotate(\"text\", x = as.Date(white_xmin) +\n                            (as.Date(white_xmax) - \n                               as.Date(white_xmin))/7, \n                         y = 94, \n                        label = white$interval, \n                        angle = -90, \n                        color = white_interval[white$interval])\nPlot\n\n\n\nDefining the theme\nGoogle fonts\nI downloaded the specific types of font from Google Fonts and added them to my library. This will be later used within the theme to achieve an accurate replication of the overall graph.\n\n\nlibrary(showtext)\nlibrary(sysfonts)\nlibrary(showtextdb)\n\nsysfonts::font_add_google(\"Libre Franklin\", family=\"franklin\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Lato\", family=\"lato\")\nshowtext::showtext_auto()\nsysfonts::font_add_google(\"Almarai\", family=\"almarai\")\n\n\nArranging the final plot\nUltimately, I still needed to make some changes on the final theme. First of all, to place the legend where is originally located in the bottom, I used the argument legend.position. Subsequently, I indicated the specific attributes of the letter with legend.text. Then, I modified the axis attributes (line, text and ticks). The specifications are mostly based on the color and the size. I also had to set the margins for the axis.text.x.\nOn the other hand, I set the panel.grid as element_blank () to remove the grid lines from the plot. Finally, I specified the font, the color, the margins, and the size of the element_text for the title, subtitle and caption elements.\n\n\nPlot <- Plot +\n   \n   theme (legend.position = \"bottom\",\n          legend.key.height = unit(0.01, \"cm\"), \n          legend.key.width = unit(1, \"lines\"), \n          legend.text = element_text(family = \"almarai\", size = 16, \n                                      face = \"plain\", color =\"#4b4647\"),\n          axis.line.x =  element_line(color = \"#696969\",size = 0.7),\n          axis.line.y =  element_line(color = \"#a1a1a1\",  size = 0.5),\n          axis.text.y = element_text(margin = margin(r=0),size=16, \n                                   colour = \"#696969\"),\n          axis.text.x = element_text(margin = margin(t=7), size=16, \n                                   colour = \"#696969\"),\n          axis.ticks.x = element_line(size = 0.7, color = \"#696969\"), \n          axis.ticks.y = element_line(size =0.7,color= \"#696969\"),\n          axis.ticks.length.x = unit(0.15, \"cm\"),\n          axis.ticks.length.y = unit(0.15, \"cm\"), \n          panel.grid = element_blank(),\n          panel.grid.major.y = element_line(color = \"#E5E5E5\"),\n          plot.margin = margin(t=5,b=5,r=5,l=5), \n          plot.title = element_text( face = \"bold\", family = \"franklin\", \n                                    size = 22, hjust = -0.04), \n          plot.subtitle = element_text(face = \"italic\",colour = \"#8d8f8e\",\n                                      family = \"playfair\", margin = margin\n                                     (t = 9, b= 30, l=),\n                                     size = 17, hjust = -.05),\n          plot.caption = element_text(face = \"bold\",hjust = 0,\n                                     margin = margin ( 2,  0, 0, 1),\n                                     family = \"lato\", size = 14)) \n \n Plot <- Plot + theme(aspect.ratio = 1/3.3)\n Plot\n\n\n\nAlternative visualization\nMy purpose here is to present an alternative form of visualization to the previous graph. However, I want to ensure that key elements of the original plot remain recognizable in order to facilitate a straightforward comparison. The ultimate goal is to enhance the interpretation and ensure that the information is better presented through data visualisation.\nMy first thought when analyzing the original graph was that there was a lot of noise concentrated in the centre of the graph, which resulted in visual confusion and hindered a clear understanding of the message. Has public trust been declining? Is there a difference among ideologies? Where is this difference? Let’s improve it!\n\n\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(showtext)\nlibrary(MetBrewer)\nlibrary(scico)\nlibrary(ggtext)\nlibrary(patchwork)\nlibrary(gghighlight)\nlibrary(lubridate)\nlibrary(dplyr)\n\n\nManaging the data\nI believe that creating smoother evolution lines would help to avoid noise within the graph. For that purpose, I had to reshape the data (tidy_data) using the pivot_longer function. Then, I calculated the average trust for each combination of year and ideology using the group_by and summarise functions. The resulting data-frame has columns for “year,” “ideology,” and “mean_cases,” which shows the rounded average of public trust.\n\n\ntidy_data <- data |> \n  pivot_longer(cols=\"Liberal_Dem\":\"Cons_Rep\", \n               names_to = \"ideology\",values_to = \"cases\") |> \n  \n  group_by(year = lubridate::year(Date), ideology) |> \n  summarise(mean_cases = round(mean(cases, na.rm = TRUE)))\n  tidy_data$year <- as.numeric(tidy_data$year)\n  \nglimpse(tidy_data)\n\nRows: 184\nColumns: 3\nGroups: year [46]\n$ year       <dbl> 1972, 1972, 1972, 1972, 1974, 1974, 1974, 1974, 1…\n$ ideology   <chr> \"Cons_Dem\", \"Cons_Rep\", \"Liberal_Dem\", \"Liberal_R…\n$ mean_cases <dbl> 53, 66, 44, 62, 40, 40, 36, 39, 37, 40, 32, 44, 4…\n\nSeparate plots!\nI believe that the original graph has room for improvement, whether through simplification, by emphasizing key data points, or reducing visual clutter.Therefore, I used the facet_wrap function to visualize each ideological category individually. Subsequently, the geom_line function plots a line to represent the evolution of each ideology, with different colors assigned.\nThe geom_hline draws a horizontal dashed line at y = 60. The aim of highlighting only this line is to emphasize when public trust reached levels around 60%. Finally, gghighlight is used to display the other ideologies in the background, but nicely faded out. This is included to enhance the visual aesthetics of the plot. The plots are previously arranged to facilitate the comparison among ideologies in the final visualization chart.\n\n\n  tidy_data <- tidy_data |>\n  mutate(ideology = factor(ideology, \n                           levels = c(\"Liberal_Rep\", \n                                      \"Cons_Rep\", \n                                      \"Cons_Dem\",\n                                      \"Liberal_Dem\"))) |> \n  arrange(ideology, year)\n  \n  Plot2 <- ggplot(tidy_data, aes(x = year)) +\n  geom_hline(yintercept =  60,\n             linetype= \"dashed\", \n             size=.3, \n             color=\"#696969\") +\n  geom_line(aes(x=year, y=mean_cases, color=ideology),\n            linetype=\"solid\", \n            size=1.3, alpha = 1, \n            linejoin = \"round\", lineend= \"round\") +\n  gghighlight(use_direct_label = FALSE, \n              unhighlighted_params = list(colour = alpha(\"white\", .8))) +\n  facet_wrap(~ideology, labeller = labeller\n              (ideology = c (\"Liberal_Rep\" = \"Moderate Republican\",\n                             \"Liberal_Dem\" = \"Liberal Democrat\",\n                             \"Cons_Dem\" = \"Conservative Democrat\",    \n                             \"Cons_Rep\" =\"Conservative Republican\")))  +\n  scale_color_manual(values = c(\"Cons_Rep\" = \"#BF3B27\",\n                                \"Liberal_Dem\" = \"#456A83\",\n                                \"Cons_Dem\" = \"#82A6BF\",\n                                \"Liberal_Rep\" = \"#E37F73\")) +\n  scale_x_continuous(breaks = seq(min(tidy_data$year), \n                                 max(tidy_data$year), by = 10)) + \n  scale_y_continuous(breaks = c(0,20,40,60,80,100),\n                     labels = c(\"\", \"20\",\"40\",\"60\",\"\",\"\")) +\n  theme_minimal( ) +\n  labs(title = \"Trust in government by party and ideology\",\n       \n       subtitle = \"% who say they trust the government to do what is right just about always/most of the time\")\n  \n  Plot2 \n\n\n\nKey data points\nThe story I want to tell is that public trust has declined over time, reaching historic lows in the recent history of the U.S. For that purpose, i used both functions geom_point and geom_text to highlight the data points where public trust reached both its highest and lowest levels.\nThis way, the message is clear: public trust has indeed declined in recent years. In three of the four ideological leans, the maximum level of trust was only reached in 1972, i.e. 50 years ago. In the case of the liberal democrats, the maximum was reached in the begining of the 2000s. All four ideological leans tend to share a decline in public trust that seems to worsen from 2020 onward. A crisis in public trust!\n\n\n  Plot2 <- Plot2 +\n  geom_point(data = tidy_data  |> \n               group_by(ideology) |> \n               slice(which.min(mean_cases)),\n             aes(x = year, y = mean_cases,\n                 color = ideology),\n             shape = 16,size = 3) +\n  geom_text(data = tidy_data |> \n               group_by(ideology)  |> \n               slice(which.min(mean_cases)),\n             aes(x = year, y = mean_cases, \n                 color = ideology, \n                 label = mean_cases),\n             hjust = -1, vjust = 1, size= 5,  fontface=\"bold\")  +\n  geom_point(data = tidy_data |> \n                 group_by(ideology) |> \n                 slice(which.max(mean_cases)),\n               aes(x = year, y = mean_cases,\n                   color = ideology),\n               shape = 16,size = 3) +\n  geom_text(data = tidy_data |>\n               group_by(ideology) |> \n                slice(which.max(mean_cases)),\n              aes(x = year, y = mean_cases, \n                  color = ideology,\n                  label = mean_cases),\n              hjust = -.7, vjust = 0, size= 5,  fontface=\"bold\")\n\n  Plot2\n\n\n\nFinal theme\nThe main inspiration for the final theme was based on the Consumer Confidence Around the World chart from the R Gallery. Within the theme, the strip.text.x function adjusts the appearance of the text in the facet labels along the x-axis, the legend is removed, the axis.text adjusts the appearance of the y and x axis text, including margin, size, and color; plot.background sets the color of the background, and plot.(sub)title adjusts the appearance of both the title and subtitle, including font face, color, margin, and size.\nAs a result, a cleaner theme is achieved, where unnecessary noise is removed and only the key elements are maintained to tell the story that public trust is reaching historic lows. Moreover, the evolution of the target ideology is more obvious and it is possible to put in perspective with other ideologies.\n\n\n  Plot2 <- Plot2 + \n  theme(axis.title =element_blank(), \n        strip.text.x = element_text(face=\"bold\",size=15, ),\n        legend.position = \"none\",\n        axis.text.y = element_text(margin = margin(r=0),size=12, \n                                   colour = \"#696969\"),\n        axis.text.x = element_text(margin = margin(t=7),size=12, \n                                   colour = \"#696969\"),\n        plot.background = element_rect(color=\"#F4F5F1\",\n                                       fill=\"#F4F5F1\"),\n        plot.margin = margin(10,10,10,10),\n        plot.title = element_text(face = \"bold\", family = \"franklin\", \n                                  size = 22),\n        plot.subtitle = element_text(face = \"bold\",colour = \"#8d8f8e\",  \n                                     margin = margin(t = 8, b= 30), \n                                     size =17)) \n\n  Plot2\n\n\n\nConclusions\nThe final visualization allows to extract some information that was perhaps not so obvious in the original graph. The main conclusions I draw are as follows:\nRepublican trust appears to be more polarized, exhibiting extremes in confidence levels. Republicans tend to express either high or very low levels of trust in government.\nDemocrats, on the other hand, tend to be consistently skeptical in their trust towards government. Even in instances where trust is expressed, it rarely surpasses the 50%.\nThere is a general trend of declining political trust in the United States, affecting citizens across the ideological spectrum.\nLimitations\nThe main limitation of the improved chart is that some information from the original chart has been removed to maintain a clean theme. For example, the presidential terms and the names of the presidents, which allowed to track trust according to who was in power. On the other hand, including additional information on crucial events in history would have helped to contextualize such evolution, like the Vietnam War, the 9/11 terrorist attacks or the COVID-19 pandemic. In this case, I have opted for a clean theme following the less is more norm.\nBibliography\nBell, P. (2023). Public Trust in Government: 1958-2023 | Pew Research Center. Pew Research Center - U.S. Politics & Policy. https://www.pewresearch.org/politics/2023/09/19/public-trust-in-government-1958-2023/\nOECD (2013), “Trust in government”, in Government at a Glance 2013, OECD Publishing, Paris. DOI: https://doi.org/10.1787/gov_glance-2013-7-en\nPerry, J. (2021). Trust in public institutions: Trends and implications for economic security | Division for Inclusive Social Development - U.N. https://www.un.org/development/desa/dspd/2021/07/trust-public-institutions/\n\n\n\n",
    "preview": "projects/2023/100507931/100507931_files/figure-html5/unnamed-chunk-9-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 2112,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100510783/",
    "title": "With Whom Did We Spend Our Time in 2020?",
    "description": "This article goes through the steps of recreating a bar chart with small\nmultiples using the ggplot2 package in R. The original chart shows the\ndistributions, by age, with whom we spend our time. The replication and\nenhanced versions include new data from the year 2020.",
    "author": [
      {
        "name": "Eric Hausken-Brates",
        "url": {}
      }
    ],
    "date": "2024-01-19",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nOriginal chart\nReplication\nCollecting the data\nColor theme of the plot\nBuilding the chart\nFormatting the theme\nAnnotations\nSaved chart\n\nEnhanced version\nSaved chart\n\n\n\n\nlibrary(tidyverse)\n\n\nOriginal chart\nI found this chart in an article called “Who We Spend Time with as We Get Older” by Nathan Yau. This article includes data from the American Time Use Survey from 2011 to 2019. Yau did not include 2020 data because they did not include a couple months due to the COVID-19 pandemic.\nThe chart in Figure 1 stood out because it had a lot of information broken down in static small multiples. The X-axis measures the age, from 15 to 80 years old, of the survey respondents. The Y-axis measures the percentage of respondents for each age group who spent time with the person titled in each bar chart. While the X-axis is fixed, the Y-axis is free so you cannot compare one chart to another.\nThe point of the chart is to compare the distributions by age. The facets are sorted by peak age from youngest to oldest, meaning that “Parent” has a peak at minimum age. Meanwhile, the peak for “Neighbors or Acquaintances” is at the maximum age of 80, which is why its bar chart is positioned at the bottom right corner.\nComparing the different charts, I noticed that the work-related facets– including co-workers, clients, managers, and customers– have similar distributions and peak around late 20s. The other work-related person, “Person Whom I Supervise,” peaks later but maintains a similar distribution.\n\n\n\nFigure 1: Source: FlowingData\n\n\n\nReplication\nCollecting the data\nThe most difficult aspect of putting together the plot was collecting and transforming the data. Instead of using the website that Nathan Yau linked in the article, I went to the U.S. Bureau of Labor Statistics website, which has all the data for the American Time Use Survey.\nAfter combining three datasets downloaded from the BLS.gov site using tidyverse joins and transformations 1, I exported the data to a csv file. You can see an overview of the data below.\n\n\ndata <- read_csv(\"data.csv\")\n\ndata$whofct <- forcats::fct_reorder(\n  .f = data$who, data$Y, min\n  ) \n\nglimpse(data)\n\nRows: 6,432\nColumns: 9\n$ who      <chr> \"Alone\", \"Alone\", \"Alone\", \"Alone\", \"Alone\", \"Alone…\n$ TEAGE    <dbl> 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18,…\n$ category <chr> \"Alone\", \"Family\", \"Friend\", \"Work\", \"Alone\", \"Fami…\n$ n        <dbl> 287, 0, 0, 0, 390, 0, 0, 0, 508, 0, 0, 0, 357, 0, 0…\n$ N        <dbl> 1071, 0, 0, 0, 1391, 0, 0, 0, 1561, 0, 0, 0, 1028, …\n$ p        <dbl> 0.2679739, 0.0000000, 0.0000000, 0.0000000, 0.28037…\n$ X        <dbl> 0.7260842, 0.7260842, 0.7260842, 0.7260842, 0.72608…\n$ Y        <dbl> 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 1…\n$ whofct   <fct> Alone, Alone, Alone, Alone, Alone, Alone, Alone, Al…\n\nColor theme of the plot\nTo obtain the colors for the plot, I uploaded the screenshot of the plot to an online color generator. These are the codes for the four colors in the original article.\n\n\ncolors <- c(\"#CCCCCC\", \"#A8A0D6\", \"#C4BA81\", \"#7AB486\" )\n\n\n\n\n\nFigure 2: Color Theme\n\n\n\nBuilding the chart\nFirst step was to set up the ggplot with the right coordinates and axes.\n\n\nplt <- data |> \n  ggplot(aes(x = TEAGE, y = p, fill = category))\nplt\n\n\n\nSecond step was to incorporate the small multiples using facet_wrap and rename the axes.\nThe code scales = \"free\" removes the restriction that all the axes are on the same scale. You can see that the Y-axis has a different scale for each facet. Since the range of the X-axis (variable TEAGE) in the data goes from 15 to 80 for all the facets (whofct), this code does not affect the X-axis’s scale.\n\n\nplt <- plt +\n  facet_wrap(\n    ~ whofct , scales = \"free\", ncol = 5, \n  )\n\nplt\n\n\n\nThird step was to add the geom_col.\n\n\nplt <- plt + \n  geom_col(\n    width = .8, \n  ) +\n  geom_hline(yintercept = 0, linewidth = .4)\n  \nplt\n\n\n\nFormatting the theme\nI used theme_void() to remove all the formatting.\n\n\nplt <- plt +\n  theme_void() \n\n\nThe chunk below shows the various formatting code to set the theme. I tried to set the font to be as close to the orignal chart as possible using the available fonts in the system.\nFont\nAxis text, facet title, caption -> “Menlo”\nTitle -> “Optima”\nSubtitle -> “Publico Text”\nNote that strip.clip = \"off\" is used to allow the facet titles to go beyond the strict border of the “strip background.” I also added vjust = -.2 to the facet settings so that the titles would be aligned slightly below the strip background and onto the chart, as does the original chart.\n\n\nplt <- plt +\n  theme(\n    \n    # axis settings\n    axis.text = element_text(\n      family = \"Menlo\", \n      size = 6, \n      color = \"gray30\"\n      ),\n    axis.ticks = element_line(\n      color = \"gray30\"\n      ),\n    axis.ticks.length = unit(-1.0, \"mm\"),\n    \n    # set spacing and margins\n    panel.spacing.x = unit(4, \"mm\"),\n    panel.spacing.y = unit(1, \"mm\"),\n    plot.margin = margin(4, 4, 4, 4, \"mm\"),\n    plot.title.position = \"plot\",\n    \n    # strip/facet placement and format\n    strip.text = element_text(\n      family = \"Menlo\", \n      hjust = 0.3, \n      vjust = -.2,  \n      size = 10, \n      face = \"bold\"\n      ),\n    strip.clip = \"off\", \n    \n    #  background color\n    plot.background = element_rect(fill = \"white\"), \n    \n    # remove legend\n    legend.position = \"none\",\n    \n    # format title, subtitle, and caption\n    plot.title = element_text(\n      family = \"Optima\", \n      size = 18, \n      hjust = 0.5, \n      margin = margin(4,4,1,4, \"mm\")\n    ), \n    plot.subtitle = element_text(\n      size = 12, \n      margin = margin(1,4,4,4, \"mm\"), \n      family = \"Publico Text\", \n      hjust = 0.5\n      ),\n    plot.caption = element_text(\n      family = \"Menlo\", \n      color = \"gray30\", \n      size = 6, \n      margin = margin(8,0,0,0, unit = \"mm\"))\n  )\n\nplt\n\n\n\nAnnotations\nI created a table for the annotations with the X and Y coordinates, the facet title (whofct) and category, the label text, and the horizontal justification.\n\n\nTable 1: annotations\n\n\nx\n\n\ny\n\n\nwhofct\n\n\nlabel\n\n\ncategory\n\n\nhj\n\n\n20\n\n\n0.30\n\n\nAlone\n\n\nMost people get some alone\ntime during a day.\n\n\nAlone\n\n\n0\n\n\n20\n\n\n0.04\n\n\nGrandchild\n\n\nGrandkids\nenter the\npicture.\n\n\nFamily\n\n\n0\n\n\n60\n\n\n0.30\n\n\nOwn household child\n\n\nKids enter\nthe picture.\n\n\nFamily\n\n\n0\n\n\n85\n\n\n0.04\n\n\nCo-Worker\n\n\nGotta pay\nthe bills.\n\n\nWork\n\n\n1\n\n\n85\n\n\n0.18\n\n\nParent\n\n\nWhile young, we commonly\nspend time with\nimmediate family.\n\n\nFamily\n\n\n1\n\n\n85\n\n\n0.07\n\n\nFriends\n\n\nTime with friends\nis also most common\nat a younger age.\n\n\nFriend\n\n\n1\n\n\nI made the whofct variable a factor so that it is consistent with the same variable of the main dataset.\n\n\nannotations$whofct <- factor(annotations$whofct)\n\n\nI added annotations using geom_text and set the color scale to the variable colors using scale_fill_manual(...).\n\n\nplt <- plt +\n  aes() +\n  geom_text(data = annotations, \n            aes(x = x, y = y, label = label), \n            color = \"gray10\",\n            size = 3,\n            family = \"Publico Text\",\n            fontface = \"italic\",\n            hjust = annotations$hj, \n            vjust = 1\n  ) +\n  scale_y_continuous(\n    label = scales::label_percent(accuracy = .1)\n  ) +\n  scale_fill_manual(\n    values = colors \n  ) +\n  labs(\n    \n    # TITLES \n    title = \"WHO WE SPEND TIME WITH, BY AGE\",\n    subtitle = \"Sorted by peak age from youngest to oldest.\",\n    caption = \"Created by Eric Hausken | Data source: American Time Use Survey 2020\\n\n    Chart inspired by: FlowingData\",\n    x = \"YEARS OLD\"\n    ) \n\n\nSaved chart\nFinally, I saved the chart using ggsave() to a .png with width and height of 11 and 8 inches.\n\n\nggsave(filename = \"Replication_plot.png\", \n       plot = plt, \n       width = unit(11, \"in\"), \n       height = unit(8, \"in\"))\n\n\n\n\n\nFigure 3: Replication\n\n\n\nEnhanced version\nFor the enhanced version, I replaced the color scheme to represent the magnitude of each column in percentage points. Instead of fill = category, the code now shows fill = p.\n\n\nplt_2 <- data |> \n  ggplot(aes(x = TEAGE, y = p, fill = p)) \n\n\n\n\n\nMost of the theme and code is the same for the enhanced version. The differences are in the color scale and legend. Here is the code for those enhancements.\n\n\nplt_2 <- plt_2 +\n  labs(\n    \n    # TITLES \n    title = \"WHO WE SPEND TIME WITH, BY AGE\",\n    subtitle = \"Sorted by peak age from youngest to oldest.\n    Color coded by percentage of age group that spent time with this person.\",\n    caption = \"Created by Eric Hausken | Data source: American Time Use Survey 2020\\n\n    Chart inspired by: FlowingData\") +\n  \n  theme(\n    \n    # legend format\n    legend.position = c(.95, 0.08),\n    legend.justification = 1,\n    legend.direction = \"vertical\",\n    legend.title = element_text(size = 8, family = \"Menlo\"),\n    legend.text = element_text(size = 6, family = \"Menlo\" ),\n    legend.title.align = 1,\n    legend.key.height = unit(.15, \"in\"),\n    ) +\n  \n  # color scale for columns and legend\n  scale_fill_gradient2(\n    low = colors[1], \n    mid = colors[3], \n    high = colors[4], \n    midpoint = .1,\n    guide = guide_colorbar(\n    title.position = \"left\",\n    title = \"Percentage\\nof Age Group\"),\n    labels = c(\"0.0%\", \"20.0%\", \"40.0%\", \"60.0%\"),\n    breaks = c(0, .2, .4, .6)\n  )  \n\n\nSaved chart\nOnce again, I saved it to a .png file with dimensions 11x8 inches.\n\n\nggsave(filename = \"Enhanced_version_plot.png\", \n       plot = plt_2, \n       width = unit(11, \"in\"), \n       height = unit(8, \"in\"))\n\n\n\n\n\nFigure 4: Enhanced version\n\n\n\n\nR code inspired by: Henrick Lindberg↩︎\n",
    "preview": "projects/2023/100510783/Replication_plot.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 3300,
    "preview_height": 2400
  },
  {
    "path": "projects/2023/100385252/",
    "title": "Life Expectancy Increased in All Countries of the World",
    "description": "The aim of this project is to reproduce, layer by layer, a chart on Life\nExpectancy evolution from Our World in Data.",
    "author": [
      {
        "name": "Alejandra Costa",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nGetting and preparing the data\nObtaining the data\nData transformation\nAdjusting country data\nPreliminary adjustments\n\nCreate Graph\nInitial elements\nManaging labels\nAppearance adjustments\nAnnotations, background segments and arrows\n\nEnhancement and alternative graphs\nEnhanced graph\nAlternative graph\n\n\nAcross the world, people are leaving longer. In 1800, the average global life expectancy was 32 years. Nevertheless, by 2012 this figure had more than doubled, reaching 70 years. But when and where has this improvement in life expectancy occurred?\nIn order to understand such worldwide increase in longevity, we can look at the “Life Expectancy of the World Population in 1800, 1950 and 2012” chart, sourced from Our World in Data. Using information on population and life expectancy at birth from Gapminder.org, the mentioned chart shows how living standards have increased over the long run through the visualization of life expectancy evolution over the world.\nOriginal chartAccordingly, this post aims to replicate the provided chart, as well as to propose potential enhancements and alternatives.\nGetting and preparing the data\n\n\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(readxl)\nlibrary(ggstream)\nlibrary(ggtext)\n\n\nObtaining the data\nAll information used in the chart is obtained from Gapminder.org. The data consist of population and life expectancy observations, both by country and by year. Since the raw data sets contain information that will not be needed for our project, just data on life expectancy at birth, population, year and country is selected.\n\n\npop_data <- read.csv(file = \"Pop_country.csv\", sep = \";\") |> \n  select(\"Country\", \"Year\", \"Population\") \n\nlife_data <- read.csv(\"LifeExpect.csv\", sep = \";\") |> \n  select(\"Country\", \"Year\", \"LifeExpectAtBirth\")\n\n\nData transformation\nNow, both life expectancy and population information can be joined by country and year into a single data set. The plot only displays information for 1800, 1950 and 2012, therefore, data are filtered according to the mentioned years.\nSince the x-axis of the original plot represents the cumulative share of the world population, where countries are ordered by ascending life expectancy, some transformations are needed to compute it. This way, data are ordered by increasing life expectancy for each of the years and subsequently the cumulative share of the world population is computed.\n\n\ndataset <- inner_join(pop_data, life_data, by = c(\"Country\", \"Year\")) |> \n  filter(Year %in% c(\"1800\", \"1950\", \"2012\")) |> \n  mutate(Year = factor(Year, levels = c(2012, 1950, 1800))) |>\n  drop_na() |> \n  arrange(Year, LifeExpectAtBirth) |>\n  group_by(Year) |> \n  mutate(share = cumsum((as.numeric(Population)))/ sum(as.numeric(Population))) |> \n  mutate(share = round(share, digits = 5))\n\n\nAdjusting country data\nIn order to align the countries names of the data set with the way they are displayed in the labels of the plot, we need to apply some specific transformations.\n\n\ndataset <- dataset |> \n  mutate(Country = ifelse( Country == \"Russia\" & Year ==\"1950\", \"URSS\", Country))|>\n  mutate(Country = ifelse( Country == \"United States\", \"USA\", Country)) \n\n\nOne particularity of the original plot is that for each of the years displayed, a different group of countries is highlighted. Therefore, specific lists containing the groups of countries to be labelled are created for each of the three years.\n\n\nlist_2012 <- c(\"Sierra Leone\", \"Mozambique\", \"Nigeria\", \"Somalia\", \"Afghanistan\",\n               \"Rwanda\", \"India\", \"Pakistan\", \"Russia\", \"Indonesia\", \"Brazil\",\n               \"China\", \"Mexico\", \"Costa Rica\", \"South Korea\", \"USA\", \"Australia\",\n               \"Germany\", \"Spain\", \"Japan\") \n\nlist_1950 <- c(\"Bhutan\", \"Somalia\", \"India\", \"China\",\"South Korea\", \"Brazil\",\n               \"URSS\", \"Cuba\", \"Japan\", \"Germany\", \"Canada\", \"USA\", \"Norway\") \n\nlist_1800 <- c(\"India\", \"South Korea\", \"Nigeria\", \"Spain\", \"Russia\", \"China\",\n               \"France\", \"Germany\", \"Netherlands\", \"Belgium\", \"USA\") \n\n\nIn line with the lists above, an additional column is included in the data set to indicate whether the country should be labelled or not.\n\n\ndataset <- dataset |> \n  mutate(label = \n           ifelse( (Country %in% list_2012 & Year == \"2012\") | \n                   (Country %in% list_1950 & Year == \"1950\") | \n                   (Country %in% list_1800 & Year == \"1800\"), \"Yes\", \"No\")) \n\n\nPreliminary adjustments\nBefore starting to build the graph, we can work on some preliminary steps, that will be applied not only to the replication chart, but also to the enhanced and alternative versions, which will allow us to keep the code cleaner. This way, we create several character vectors containing the caption and the right side notes to be included later in the plot.\n\n\nsubtitle_text <-str_wrap(\n      \"Countries are ordered along the x-axis ascending by the life expectancy of the population. Data for almost all countries is shown in this chart, but not all data points are labelled with the country name.\", \n      width =124)\ncaption_text = paste(\n  \"Data Source: The data on life expectancy by country and population are taken from Gapminder.org.\",\n  \"The interactive data viusalization is available at OurWolrdData.org. There you find the raw data and more viusalizations on this topic.                                                          Licensed under CC-BY-SA by the author Max Roser.\", \n  sep=\"\\n\")\n\ncaption_2012 <- paste(\" Global Average\", \"Life Expectancy:\", \"      70 years\", sep= \"\\n\") \n\ncaption_1950 <- paste(\" Global Average\", \"Life Expectancy:\", \"      48 years\", sep= \"\\n\") \n\ncaption_1800 <- paste(\" Global Average\", \"Life Expectancy:\", \"      32 years\", sep= \"\\n\")  \n\n\nAfter these steps, our data set is ready in order to start with the creation of the plot.\nCreate Graph\nInitial elements\nTo begin, the chart is plotted using geom_line() and geom_area(), enabling the representation of life expectancy in stacked areas for each of the years. To match the plot with the original graph’s palette, two vectors are created, one containing the specific colors to fulfill the areas, and other to draw the lines.\nTo adjust the scale of the plot and stick as much as possible to the shape of the original plot, breaks in the axes are manually introduced along with th axis labels. However, later on, we will need to include some annotations in the right side of the plot. Therefore, the x-limits are set beyond 1 to create additional space.\n\n\narea_color <- c(\"#84A98C\", \"#FFD399\",\"#FFCAD3\") \nline_color <- c(\"#238B45\", \"#ff6900\", \"#99000d\") \n\nplot <- \n  ggplot(dataset, \n         aes(x = share, y = LifeExpectAtBirth,\n             label= as.factor(Year), \n             color = as.factor(Year))) +\n  geom_line() +\n  geom_area(aes(fill = as.factor(Year)), \n            position = position_dodge(width = 0), \n            alpha = 0.8) +\n  scale_fill_manual(values = area_color) +\n  scale_color_manual(values = line_color) +\n  scale_x_continuous(\n    breaks = c(0.0, 0.25, 0.5, 0.75, 1), \n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1.1)) +\n  scale_y_continuous(\n    breaks = seq(0, 90, by = 10), \n    labels = c(\"\",\"10\",\"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\"),\n    expand=c(0,0),\n    limits = c(0, 95)) +\n  guides(color = FALSE, fill = FALSE)\n\nplot  \n\n\n\nManaging labels\nOur next step is to include the labels of the countries for each year along the x-axis. To achieve this, we consider the subset formed by those countries with “Yes” in the label column.\nSince the plot involves a large number of labels inside the graph, geom_text_repel() is used to adjust the position of the countries and minimize overlap. Another advantage is that it allows for constraining the labels within specified limits, avoiding them from extending beyond the graph.\n\n\nplot <- \n  plot + \n  geom_text_repel(data = subset(dataset, label == \"Yes\"), aes(label = Country),\n                  xlim = c(0, 1),\n                  nudge_y = 0.05,  \n                  max.overlaps = 10, \n                  colour = \"black\",\n                  size = 2, \n                  segment.size = 0, \n                  segment.color = NA) \n  \n\nplot\n\n\n\nAppearance adjustments\nWe proceed by adding the corresponding title, subtitle and caption to the plot, as well as adjusting the graph appearance, where the font used is “Playfair Display”, downloadable from Google Fonts.\n\n\nsysfonts::font_add_google(\"Playfair Display\") \n\nplot <- plot +\n   labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = subtitle_text,\n    caption = caption_text,\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\")\n\n\nUntil now, the panel grid extended beyond our chart due to the larger x-limits we have set. To address this, the grid is removed and the background is set transparent, since, later on, we will manually add horizontal segments specifically adjusted to the established. Accordingly, we just include a vertical black line to represent the y-axis.\n\n\nplot <- plot + \n  theme(\n    axis.line.y = element_line(colour = \"black\", linewidth = 0.05),  \n    axis.line.x = element_blank(),\n    plot.background = element_rect(fill = \"white\"),\n    panel.background = element_rect(fill  = \"white\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 15, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 1, color = \"#525252\"),\n    plot.caption = element_text(size = 5, hjust = 0, vjust = -1, color = \"#525252\",lineheight = 0.8),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 5)),\n    axis.title.y = element_text(size = 8, margin = margin(r = 8), vjust = 0.05),\n    axis.text.x = element_text(size = 9, color = \"black\"), \n    axis.text.y = element_text(size = 6, color = \"black\"),\n    plot.margin= margin(t = 10, r = 3, b = 10, l = 6))\n\n\nplot\n\n\n\nAnnotations, background segments and arrows\nThe last step is to work on the annotations, the background grid and the arrows.\nOnce the background of the plot has been removed, independent segments are manually included in the background as a substitute of the grid in order to stick to the aesthetics of the original graph.\n\n\n#include background lines\n\nplot <- plot +\n  annotate(\"segment\", x=1, xend = 1, y=0, yend=93,  \n           color = \"black\",linewidth = 0.05, alpha= 1) +\n  annotate(\"segment\", x=0, xend = 1, y=10, yend=10, \n           color = \"#969696\",linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=20, yend=20, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\",x=0, xend = 1, y=30, yend=30, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=40, yend=40, \n           color = \"#666666\", linewidth = 0.002, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=50, yend=50, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=60, yend=60, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=70, yend=70, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=80, yend=80, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=90, yend=90, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=0, yend=0, \n           color = \"black\", linewidth = 0.05, alpha= 1)\n\n\nNow we include the right margin notes specifying the global average life expectancy and the corresponding year.\n\n\nnote_2012 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      70 years\", sep= \"\\n\") \n\nnote_1950 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      48 years\", sep= \"\\n\") \n\nnote_1800 <- paste(\" Global Average\", \"Life Expectancy:\", \n                   \"      32 years\", sep= \"\\n\")  \n\nplot <- plot +\n  annotate(\"text\", x = 1.018, y = 86,\n           label = \"2012\",\n           hjust=0,\n           size=5,\n           color=\"#005824\") +\n    annotate(\"text\", x = 1.013, y = 81,\n           label = caption_2012,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 67,\n           label = \"1950\",\n           hjust=0,\n           size=5,\n           color=\"#ffa600\") +\n  annotate(\"text\", x = 1.013, y = 62,\n           label = caption_1950,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 40,\n           label = \"1800\",\n           hjust=0,\n           size=5,\n           color=\"#99000d\") +\n  annotate(\"text\", x = 1.013, y = 35,\n           label = caption_1800,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\")\n\n\nLastly, geom_segment() is used to include the two big arrows inside the graph, as well as the two arrows between the notes of the right margin.\n\n\nplot <-\n  plot +\n  geom_segment(x = 1.05, y = 70,\n             xend = 1.05, yend = 77, \n             linewidth = 0.6,\n             color = \"#737373\", \n             arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 1.052, y = 43,\n               xend = 1.052, yend = 58, linewidth = 0.6,\n               color = \"#737373\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 0.9, y = 41,\n               xend = 0.9, yend = 61,linewidth = 1.4,\n               color = \"#e68600\",\n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) +\n  geom_segment(x = 0.3, y = 44,\n               xend = 0.3, yend = 64,linewidth = 1.4,\n               color = \"#38B200\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) \n\nplot\n\n\n\nEnhancement and alternative graphs\nEnhanced graph\nOne of the inconsistencies I found in the original graph is that the setting of the labels does not follow a fixed criterion, since different groups of countries are labelled for each of the years – some countries appear in the three different years, while other just appear once. Consequently, my first proposal in an enhanced plot based on the replication of the original plus an additional small modification, in which the same group of countries is highlighted in each line, which makes the plot more coherent\nTo achieve this, a common list for the three countries is created, which subsequently will be used to subset the data when using geom_text_repel. The remaining code is kept as in the replication section.\n\n\nlist_improved <- c(\"Mozambique\", \"Nigeria\", \"Pakistan\", \"India\", \"USA\", \"Spain\",\n                   \"China\", \"Mexico\", \"Brazil\", \"Cuba\", \"Japan\", \"Belgium\", \"Norway\")\n\ndataset <- dataset |> \n  mutate(label_improved = \n           ifelse((Country %in% list_improved), \"Yes\", \"No\")) \n\n\nplot2 <- \n  ggplot(dataset, \n         aes(x = share, y = LifeExpectAtBirth,\n             label= as.factor(Year), \n             color = as.factor(Year))) +\n  geom_line() +\n  geom_area(\n    aes(fill = as.factor(Year)), \n    position = position_dodge(width = 0), \n    alpha = 0.9\n    ) +  \n  geom_text_repel(\n    data = subset(dataset, label_improved == \"Yes\"),\n    aes(label = Country), \n    xlim = c(0, 1),\n                  nudge_x = 0.01,  \n                  max.overlaps = 10, \n                  colour = \"black\",\n                  size = 2, \n                  segment.size = 0, \n                  segment.color = NA) +\n  guides(color = FALSE, fill = FALSE) +\n  scale_fill_manual(values = area_color) +\n  scale_color_manual(values = line_color) +\n  scale_x_continuous(\n    breaks = c(0.0, 0.25, 0.5, 0.75, 1), \n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1.1)\n   )+\n  scale_y_continuous(\n    breaks = seq(0, 90, by = 10), \n    labels = c(\"\",\"10\",\"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \"80\", \"90\"),\n    expand=c(0,0),\n    limits = c(0, 95)) +\n   labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = subtitle_text,\n    caption = caption_text,\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\") +\n  theme(\n    axis.line.y = element_line(colour = \"black\", linewidth = 0.05),  \n    axis.line.x = element_blank(),\n    plot.background = element_rect(fill = \"white\"),\n    panel.background = element_rect(fill  = \"white\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.ticks = element_blank(),\n    plot.title = element_text(size = 16, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 1, color = \"#525252\"),\n    plot.caption = element_text(size = 5, hjust = 0, vjust = -1, color = \"#525252\",lineheight = 0.8),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 5)),\n    axis.title.y = element_text(size = 8, margin = margin(r = 8), vjust = 0.05),\n    axis.text.x = element_text(size = 9, color = \"black\"), \n    axis.text.y = element_text(size = 6, color = \"black\"),\n    plot.margin= margin(t = 10, r = 3, b = 10, l = 3)) \n\nplot2 <- plot2 +\n  annotate(\"segment\", x=1, xend = 1, y=0, yend=93,  \n           color = \"black\",linewidth = 0.05, alpha= 1) +\n  annotate(\"segment\", x=0, xend = 1, y=10, yend=10, \n           color = \"#969696\",linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=20, yend=20, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\",x=0, xend = 1, y=30, yend=30, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=40, yend=40, \n           color = \"#666666\", linewidth = 0.002, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=50, yend=50, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=60, yend=60, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=70, yend=70, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n  annotate(\"segment\", x=0, xend = 1, y=80, yend=80, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4) +\n  annotate(\"segment\", x=0, xend = 1, y=90, yend=90, \n           color = \"#969696\", linewidth = 0.001, alpha= 0.4)+\n   annotate(\"segment\", x=0, xend = 1, y=0, yend=0, \n           color = \"black\", linewidth = 0.05, alpha= 1)\n\nplot2 <- plot2 +\n annotate(\"text\", x = 1.018, y = 86,\n           label = \"2012\",\n           hjust=0,\n           size=5,\n           color=\"#005824\") +\n    annotate(\"text\", x = 1.013, y = 81,\n           label = caption_2012,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 67,\n           label = \"1950\",\n           hjust=0,\n           size=5,\n           color=\"#ffa600\") +\n  annotate(\"text\", x = 1.013, y = 62,\n           label = caption_1950,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") +\n   annotate(\"text\", x = 1.018, y = 40,\n           label = \"1800\",\n           hjust=0,\n           size=5,\n           color=\"#99000d\") +\n  annotate(\"text\", x = 1.013, y = 35,\n           label = caption_1800,\n           hjust=0,\n           size=1.5,\n           lineheight=1,\n           color=\"#525252\") \n\nplot2 <- plot2 +\n\n  geom_segment(x = 1.046, y = 70,\n             xend = 1.046, yend = 77, \n             linewidth = 0.6,\n             color = \"#737373\", \n             arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 1.046, y = 43,\n               xend = 1.046, yend = 58, linewidth = 0.6,\n               color = \"#737373\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.2, \"cm\"))) +\n  geom_segment(x = 0.9, y = 41,\n               xend = 0.9, yend = 61,linewidth = 1.4,\n               color = \"#e68600\",\n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) +\n  geom_segment(x = 0.3, y = 44,\n               xend = 0.3, yend = 64,linewidth = 1.4,\n               color = \"#38B200\", \n               arrow=arrow(type = \"closed\", angle = 22, length= unit(0.9, \"cm\"))) \n\nplot2\n\n\n\nAlternative graph\nThe alternative proposed is an entirely new plot that represents the same information from another perspective. This new proposal aims to make the plot simpler, making it more understandable.\nAdditionally, information regarding the world region to which each country belongs is included, providing a more comprehensive plot and allowing the identification of potential patterns between areas. Also, with this kind of chart, by observing the slopes, we can observe the level of inequality across countries for each year in terms of living standards and life expectancy. For instance, in 1950, we observe a steep slope, meaning that there was a high inequality between countries, despite life expectancy levels were higher than in 1800.\nIn order to create the proposal, the chart is plotted using geom_jitter() along with faced_grid(), therefore, an independent subplot is displayed for each of the years, where countries are represented by the data points.\n\n\ncolors_faced <- c(\"orange\", \"#7570b3\",\"#7fc97f\", \"#43a2ca\")\n\ndata_regions <- read.csv(file = \"Geographies.csv\", sep = \";\") |> \n  select(\"name\", \"four_regions\")\n\ndata <- full_join(dataset, data_regions, by = c(\"Country\"=\"name\")) |> \n  drop_na() |> \n  mutate(Year_f = factor(Year, levels = c(\"1800\", \"1950\", \"2012\")))\n\nunique_regions <- unique(data$four_regions)\n\nplot3 <-\n  ggplot(\n    data, \n    aes(x=share,y=LifeExpectAtBirth, \n        color = as.factor(four_regions), \n        group = Year_f)\n    ) +\n  geom_jitter(\n    data= data,\n    position = position_jitter(width = 0.3), \n    alpha = 0.8\n    ) +\n  scale_color_manual(values = colors_faced)  +\n  facet_grid(~Year_f) \n\n\nBy using geom _smooth(), a curve is added to the data points, whose slope serves as an indicator of he inequality in terms of life expectancy across countries.\n\n\nplot3 <- plot3 + geom_smooth(method = \"lm\", se = TRUE, \n              formula = y ~ x, \n              color = \"darkgrey\",linewidth = 0.001, linetype = \"dashed\") \n\nplot3\n\n\n\nNow, we work on the scale adjustments and set the appearance setting.\n\n\nplot3 <- plot3 +\n  scale_x_continuous(\n    breaks = c(0, 0.25, 0.5, 0.75, 1),\n    labels = c(\"0\", \"1/4\", \"1/2\", \"3/4\", \"1\"),\n    expand = c(0, 0),\n    limits = c(0, 1))+\n  scale_y_continuous(\n    breaks = seq(0, 100, by = 20),\n    labels = c(\"\",\"20\",\"40\", \"60\", \"80\", \"100\"),\n    expand=c(0,0),\n    limits = c(0, 100)) +\n  labs(\n    title = \"Life Expectancy of the World population in 1800, 1950 and 2012\",\n    subtitle = \"Countries are ordered along the x-axis ascending by the life expectancy of the population.\",\n    caption = \"Data Source: The data on life expectancy by country and population are taken from Gapminder.org.\",\n    x = \"Cumulative Share of the World Population\",\n    y = \"Life Expectancy At Birth\") +\n  theme(\n    plot.background = element_rect(fill = \"transparent\"),\n    panel.background = element_rect(fill  = \"#F0F0F0\"),\n    strip.text.x = element_text(size = 10, face = \"bold\"),\n    panel.grid.major.x = element_line(color = \"white\", linewidth = 0.0000001),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"white\", linewidth = 0.0000001),\n    plot.title = element_text(size = 14, family = \"Playfair Display\", margin = margin(b=-2, t = -1), vjust = 2.6),\n    plot.subtitle = element_text(size = 8, family = \"Playfair Display\", lineheight = 0.5, color = \"#525252\"),\n    plot.caption = element_text(size = 6, hjust = 0, vjust = -0.5, color = \"#737373\"),\n    plot.caption.position = \"plot\",\n    axis.title.x = element_text(size = 10, margin = margin(t = 10)),\n    axis.title.y = element_text(size = 10, margin = margin(r = 8)),\n    panel.spacing = unit(0.5, \"cm\"),\n    legend.text=element_text(size=8,family = \"Playfair Display\"),\n    legend.position = \"right\",\n    legend.title = element_blank(),\n    legend.key = element_blank(),\n    legend.key.height = unit(0.5, \"cm\"),\n    plot.margin= margin(t = 10, r = 10, b = 10, l = 5))\n\n\nplot3\n\n\n\nFinally, following the same procedure as in the previous graphs, we create an specific list containing the countries to be highlighted and subsequently, such information is included in a new column in the data set, that will allows us to create a subset when applying geom_text_repel().\n\n\nlist_alternative <- c(\"Mozambique\", \"India\", \"Pakistan\", \"USA\", \"Spain\", \"China\", \"Mexico\", \"Brazil\", \"Cuba\")\n\ndata <- data |> \n  mutate(label_alternative = \n           ifelse((Country %in% list_alternative), \"Yes\", \"No\"))\n\nplot3 <- plot3 +\n   geom_text_repel(\n     data = subset(data, label_alternative == \"Yes\"), \n     aes(label = Country), \n     xlim = c(0, 1),max.overlaps = 50,\n     nudge_y = 0.05, nudge_x = -0.01, \n     colour = \"black\",size = 2, \n     segment.size = 0, \n     segment.color = NA)  \nplot3\n\n\n\nThe final step is to include the annotations indicating the average global life expectancy for each of the years. In order to place the notes inside each of the subplots, a data frame is created, in which the position along the y- and x-axis is specified. Subsequently, geom_text() is used to include such notes in our final plot.\n\n\ndata_text <- data.frame(\n  Year_f = c(1800, 1950, 2012),\n  label = c(caption_1800, caption_1950, caption_2012),\n  x  = c(0.35, 0.35, 0.35),\n  y = c(92, 92, 92))\n\n\nplot3 <- plot3 +\n  geom_text(\n    data = data_text,\n    aes(x = x, y = y,label = label), lineheight = 1,\n    hjust = 0, size = 2, color = \"black\")\n\n\nplot3\n\n\n\n\n\n\n",
    "preview": "projects/2023/100385252/100385252_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1344,
    "preview_height": 960
  },
  {
    "path": "projects/2023/100407614/",
    "title": "Cigarettes Sales and Lung Cancer Mortality in the US",
    "description": "Every year, around 8 million people die prematurely as a result of smoking.\nIn this case, examining the relationship across the cigarettes sales in men in the United States.",
    "author": [
      {
        "name": "Andrea Baños-Ramos",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction and Motivation\nReplication work\nLoad the main files\nLoad the libraries\nData Generating Process\nSetting the individual axes, coordinates and scales\nPerforming simple linear graphs\nEstablishing the axes, coordinates and scales\nRescaling of age_males_death variable\nIntersecting charts and filtering the data\nSelecting the suitable font style\nModifying the appearance of the axes by altering the color and size of their titles\nIncorporating annotations on the most relevant dates\n\nEnhancement Chart\n\nIntroduction and Motivation\nThe selected chart from Our World in Data explains the relationship that may exist between daily cigarette sales per adult and the lung cancer death rate per 100,000 men in the United States.\nThe consumption of cigarettes significantly increased in wealthy countries, including the United States, in the early 20th century. Similarly, lung cancer trends closely mirror those of smoking, although with a delay. We can observe how, from the second half of the 20th century, possibly reaching its peak, until now, the daily sales of cigarettes and the lung cancer death rate attributed to smoking have significantly decreased. Finally, the choice of this chart was driven by my concern for global health, aiming to investigate risk factors that significantly impact health and may even cause the death of millions of people.\nSmoking and lung cancer mortality in the US. Source: Our World in Data.Replication work\nLoad the main files\n\n\ncsv_file <- read.csv(\"sales-of-cigarettes-per-adult-per-day.csv\")\ncsv_file2 <- read.csv(\"lung-cancer-deaths-per-100000-by-sex-1950-2002.csv\")\n\n\nLoad the libraries\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggtext)\n\n\nData Generating Process\nIn order to carry out the replication process, I will clean the two databases, taking into account numerous variables such as entity (in this case, the country is the United States), year (ranging from 1900 to 2017), sales_cig (representing daily cigarette sales per adult), and age_males_death (indicating the rate of deaths in men attributed to lung cancer).\n\n\nsales <- data.frame(csv_file[1:2767, 1:4]) # Data Frame (rectangular data structures)\nsales_daily <- sales |> filter(Entity == \"United States\") |> \n  rename(sales_cig = Sales.of.cigarettes.per.adult.per.day..International.Smoking.Statistics..2017..,\n         entity = Entity, year = Year) |> \n  select(entity, year, sales_cig)\n\ncancer <- data.frame(csv_file2[1:4572, 1:5])\ncancer_deaths <- cancer |> filter(Entity == \"United States\") |> \n  rename(age_males_death = age.standardized_death_rate_per_100k_male,\n         entity = Entity, year = Year) |> \n  select(entity, year, age_males_death)\n\n\nSetting the individual axes, coordinates and scales\n\n\np <- ggplot(sales_daily) +\n  aes(year, sales_cig)\np\n\n\nq <- ggplot(cancer_deaths) +\n  aes(year, age_males_death)\nq\n\n\n\nPerforming simple linear graphs\nWith ggplot, we can create a line chart using the sales_daily database, plotting the year on the x-axis and sales_cig on the y-axis, without any explanatory legend. The same approach is applied to ages_males_death using the cancer_deaths database.\n\n\np <- ggplot(sales_daily) +\n  aes(year, sales_cig) +\n  geom_line(aes(color = \"#800080\")) +\n  theme(legend.position = \"none\")\np\n\n\nq <- ggplot(cancer_deaths) +\n  aes(year, age_males_death) +\n  geom_line(aes(color = \"#CC0000\")) +\n  theme(legend.position = \"none\")\nq\n\n\n\nEstablishing the axes, coordinates and scales\n\n\ncross_chart <- ggplot() +\n  theme_minimal() +\n  coord_cartesian(clip = \"off\") +\n  scale_x_continuous(\n    expand = c(0, 0), limits = c(1900, 2015), breaks = seq(1900, 2010, by = 10)) +\n  theme(axis.text.y = element_blank(),\n        axis.text.y.right = element_blank()) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 1,\n    label = \"1\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 2,\n    label = \"2\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 3,\n    label = \"3\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 4,\n    label = \"4\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 5,\n    label = \"5\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 6,\n    label = \"6\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 7,\n    label = \"7\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 8,\n    label = \"8\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 9,\n    label = \"9\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 10,\n    label = \"10\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 11,\n    label = \"11\",\n    vjust = -0.5, hjust = 0, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 1,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 2,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 3,\n    label = \"15\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 4,\n    label = \"20\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 5,\n    label = \"25\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 6,\n    label = \"30\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 7,\n    label = \"35\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 8,\n    label = \"40\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 9,\n    label = \"45\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 10,\n    label = \"50\",\n    vjust = -0.5, hjust = 1, size = 6,\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 11,\n    label = \"55\",\n    vjust = -0.5, hjust = 1, size = 6\n  )\ncross_chart\n\n\n\nRescaling of age_males_death variable\n\n\nnew_min <- 19.56\nnew_max <- 55\nage_males_death <- cancer_deaths$age_males_death\nold_min <- min(age_males_death)\nold_max <- max(age_males_death)\nage_males_death <- (((age_males_death-old_min) / (old_max - old_min))\n                    * (new_max - new_min)) + new_min\ncancer_deaths$age_males_death <- age_males_death\n\n\nIntersecting charts and filtering the data\nTo overlay the line charts, we scale them by dividing the maximum value of sales_cig and age_males_death. As we can observe, there is a small peak in the raw data, specifically in the series representing cigarette sales, indicating that the authors who generated this graph likely underwent some standardization process to address it.\n\n\nscale <- max(sales_daily$sales_cig)/\n  max(cancer_deaths$age_males_death)\n\ncancer_deaths <- cancer_deaths |> \n  mutate(age_males_death = if_else(year >= 2016, NA, age_males_death))\n\ncross_chart <- ggplot() +\n  geom_line(\n    data = sales_daily,\n    aes(x = year, y = sales_cig, color = \"Sales of Cigarettes\"),\n    size = 1\n  ) +\n  geom_line(\n    data = cancer_deaths,\n    aes(x = year, y = age_males_death * scale, color = \"Cancer Deaths\"),\n    size = 1\n  ) +\n  labs(\n    title = \"Cigarette sales and lung cancer mortality in the US\",\n    x = \"Year\",\n    y = \"Cigarettes sold per adult per day\"\n  ) +\n  scale_color_manual(\n    values = c(\"Sales of Cigarettes\" = \"#800080\", \n               \"Cancer Deaths\" = \"#CC0000\")\n  ) +\n  scale_y_continuous(\n    sec.axis = sec_axis(\n      ~./scale,\n      breaks = seq(0, 55, by = 5),\n      name = \"Rate of lung cancer deaths per 100,000 men\",\n      labels = scales::number_format()\n    ),\n    breaks = seq(min(0), max(11), by = 1)\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\ncross_chart\n\n\n\nSelecting the suitable font style\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"font_title\")\nsysfonts::font_add_google(\"Lato\", family=\"font_y_axis\")\nshowtext::showtext_auto()\n\n\nModifying the appearance of the axes by altering the color and size of their titles\nTo change the color of specific words in the title, we use the command span style, followed by theme(plot.title = element_markdown). To eliminate the distance between the first value on the x-axis and the origin, I use scale_x_continuous(expand = c(0, 0)). This setting removes the padding or expansion on the x-axis. Additionally, theme_minimal() is employed to eliminate non-essential elements in the plot, creating a clean and simple design. The breaks command is used to display numbers on each axis at intervals of 1, 5, or 10. Sec_axis is employed to align the second y-axis (on the right) to a scale that approximates the first y-axis (on the left). Finally, annotate is used to place the axis titles at the top left and top right.\n\n\ncross_chart <- ggplot() +\n  geom_line(\n    data = sales_daily,\n    aes(x = year, y = sales_cig, color = \"Sales of Cigarettes\"),\n    size = 1\n  ) +\n  geom_line(\n    data = cancer_deaths,\n    aes(x = year, y = age_males_death * scale, \n        color = \"Cancer Deaths\"),\n    size = 1\n  ) +\n  labs(\n    title = \"<span style='color:#800080'>Cigarette sales<\/span> <span style='color:black'>and<\/span> <span style='color:#CC0000'>lung cancer mortality<\/span> <span style='color:black'>in the US<\/span>\",\n    x = \"\",\n    y = \"\",\n    caption = \"Data sources: International Smoking Statistics (2017): WHO Cancer Mortality Database (IARC). The death rate from lung-cancer is age-standardized.\"\n  ) +\n  scale_color_manual(\n    values = c(\"Sales of Cigarettes\" = \"#800080\", \n               \"Cancer Deaths\" = \"#CC0000\")\n  ) +\n  scale_y_continuous(\n    sec.axis = sec_axis(\n      ~./scale,\n      breaks = seq(0, 55, by = 5),\n      name = \"\",\n      labels = scales::number_format()\n    ),\n    breaks = seq(min(0), max(11), by = 1)\n  ) +\n  scale_x_continuous(\n    expand = c(0, 0),\n    limits = c(1900, 2018),\n    breaks = seq(1900, 2010, by = 10)\n  ) +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    plot.title = element_text(\n      color = \"#800080\",\n      hjust = 0,\n      size = 40,\n      margin = margin(l = -20),\n      family = \"font_title\"\n    ),\n    plot.margin = margin(t = 10, r = 10, b = 10, l = 20, \n                         unit = \"pt\"),\n    axis.text.x = element_text(size = 15, hjust = 0.25, \n                               family = \"font_y_axis\"),\n    axis.text.y = element_blank(),\n    axis.text.y.right = element_blank(),\n    plot.caption = element_text(\n      size = 12,\n      hjust = 0,\n      color = \"#5b5b5b\",\n      margin = margin(l = -20),\n      family = \"font_y_axis\"\n    )\n  ) +\n  annotate(\n    \"text\",\n    x = Inf,\n    y = 12.5,\n    label = \"Rate of lung cancer deaths\\nper 100,000 men\",\n    vjust = 1,\n    hjust = 1,\n    size = 6,\n    color = \"#CC0000\",\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, \n    y = 12.5,\n    label = \"Cigarettes sold\\nper adult per day\",\n    vjust = 1,\n    hjust = 0.17,\n    size = 6, \n    color = \"#800080\", \n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) + coord_cartesian(clip = \"off\") +\n  annotate(\n    \"text\",\n    x = -Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 1,\n    label = \"1\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 2,\n    label = \"2\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 3,\n    label = \"3\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 4,\n    label = \"4\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 5,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 6,\n    label = \"6\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 7,\n    label = \"7\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 8,\n    label = \"8\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 9,\n    label = \"9\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 10,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = -Inf, y = 11,\n    label = \"11\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#800080\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 0,\n    label = \"0\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 1,\n    label = \"5\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 2,\n    label = \"10\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 3,\n    label = \"15\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 4,\n    label = \"20\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 5,\n    label = \"25\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 6,\n    label = \"30\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 7,\n    label = \"35\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 8,\n    label = \"40\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 9,\n    label = \"45\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 10,\n    label = \"50\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"text\",\n    x = Inf, y = 11,\n    label = \"55\",\n    vjust = -0.5, hjust = 1, size = 6, color = \"#CC0000\", \n    family = \"font_y_axis\"\n  )\ncross_chart + theme(plot.title = element_markdown())\n\n\n\nIncorporating annotations on the most relevant dates\nAnnotations are included using annotate(“text”), and arrows are added with annotate(“curve” or “segment”), depending on the shape of the arrow. The arrow command is used to specify the dimension and type of the arrowhead, in this case, it is a closed arrow. Finally, lineheight is used to determine the spacing between lines.\n\n\ncross_chart + theme(plot.title = element_markdown()) +\n  annotate(\n    \"curve\",\n    x = 1926.5, xend = 1929,\n    y = 5, yend = 4.4,\n    curvature = -0.2,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n    )\n  ) +\n  annotate(\n    \"text\",\n    x = 1926, y = 5,\n    hjust = 1,\n    label = \"1929: The Great Depression\",\n    color = \"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x = 1941.5, xend = 1944.5,\n    y = 9.2, yend = 8.2,\n    curvature = -0.2,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n    )\n  ) +\n  annotate(\n    \"text\",\n    x=1941, y=9.2,\n    hjust=1,\n    label =\"1945: The Second World War ends\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1946.5, xend = 1949,\n    y=10.6, yend= 9.6,\n    curvature = -0.2,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1946, y=10.5,\n    hjust=1,\n    label =\"In the late 1940s and early 50s epidemiologists\\n establish that smoking is harmful to people's health\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1960.5, xend = 1964,\n    y=11.65, yend= 10.9,\n    curvature = -0.5,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1960, y=11.5,\n    hjust=1,\n    label =\"1964: Surgeon General's report links smoking\\n to deaths from cancer and heart disease\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"curve\",\n    x= 1968.5, xend = 1970,\n    y=12.2, yend= 10.3,\n    curvature = -0.2,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1968, y=12.2,\n    hjust=1,\n    label =\"1970: the US bans cigarette ads on radio and television\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1983, xend = 1983,\n    y=8.35, yend= 9,\n    arrow = arrow(\n     type = \"closed\",\n     length = unit(0.015, \"npc\"),\n     angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1983, y=8.3,\n    hjust=0.9, vjust=1,\n    label =\"1983: federal tax on\\n cigarettes doubles\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1986, xend = 1986,\n    y=7.05, yend= 8.4,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1986, y=7.0,\n    hjust=0.97, vjust=1,\n    label =\"1986: Surgeon General's\\n report on secondhamd-smoke\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1991, xend = 1991,\n    y=6.05, yend= 6.9,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1991, y=6,\n    hjust=0.97, vjust=1,\n    label =\"Increasing bans on inflight smoking\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1995, xend = 1995,\n    y=5.05, yend= 6.3,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1995, y=5,\n    hjust=0.97, vjust=1,\n    label =\"Nicotine replacement medications\\n become widely available over the counter\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 1998, xend = 1998,\n    y=4.05, yend= 5.8,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=1998, y=4,\n    hjust=0.97, vjust=1,\n    label =\"1998: California bans smoking in restaurants\",\n    color =\"#5b5b5b\",\n    size = 5,\n    family = \"font_y_axis\"\n  ) +\n  annotate(\n    \"segment\",\n    x= 2009, xend = 2009,\n    y=2.8, yend= 3.5,\n    arrow = arrow(\n      type = \"closed\",\n      length = unit(0.015, \"npc\"),\n      angle = 20\n   )\n  ) +\n  annotate(\n    \"text\",\n    x=2009, y=2.75,\n    hjust=0.97, vjust=1,\n    label =\"2009: federal tax increased again\\n from $0.39 to $1.01 per pack\",\n    color =\"#5b5b5b\",\n    size = 5,\n    lineheight = 0.75,\n    family = \"font_y_axis\"\n  )\n\n\n\nEnhancement Chart\nAs an improvement to the chart or an alternative visualization of these data, I have created a Correlation Connected Scatter to display the correlation between both series. As we can observe, it addresses the major issue we had previously, as all milestones are now marked on the same series, allowing us to attribute the effects correctly. This is achieved visually with the viridis color scale.\n\n\nmerged_data <- merge(sales_daily, cancer_deaths, \n                     by = c(\"entity\", \"year\"))\n\nmin(merged_data$sales_cig)\n\n[1] 3.2\n\nmax(merged_data$sales_cig)\n\n[1] 11\n\nmin(merged_data$age_males_death)\n\n[1] 19.56\n\nmax(merged_data$age_males_death)\n\n[1] 55\n\nviridis_color <- viridisLite::viridis(5)\n\nenhanc_chart <- ggplot(merged_data) +\n  aes(sales_cig, age_males_death, color = year) +\n  scale_color_viridis_c() +\n  geom_path(\n    arrow=arrow(\n    angle=15, type=\"closed\",\n    length=unit(0.1, \"inches\"))) +\n  geom_label(\n    data = subset(merged_data,\n                  year %in% c(1929, 1945, 1949, 1964,\n                              1970, 1983, 1986, 1992,\n                              1995, 1998, 2009)), \n    aes(label = as.character(year)), \n    family = \"font_y_axis\") +\n  coord_cartesian(clip = \"off\") +\n  theme_minimal() +\n  theme(legend.position=c(0, 1),\n        legend.justification=c(0, 1)) +\n  labs(\n    title = \"Correlation between Cigarette sales and Lung cancer mortality in the US\",\n    x = \"Cigarettes sold\\nper adult per day\",\n    y = \"Rate of lung cancer deaths\\nper 100,000 men\") +\n  scale_x_continuous(breaks = seq(3, 11, by = 1)) +\n  scale_y_continuous(breaks = seq(20, 55, by = 5)) +\n  theme(legend.position = \"none\",\n        plot.title = element_text(hjust = 0,\n                                  size = 30,\n                                  family = \"font_title\"),\n        plot.margin = margin(t = 10, \n                             r = 20, \n                             b = 10,\n                             l = 20,\n                             unit = \"pt\"),\n        axis.text.x = element_text(size = 20,\n                                   color = \"black\"),\n        axis.text.y = element_text(size = 20, \n                                   color = \"black\"),\n        axis.title.x = element_text(size = 20, \n                                    family = \"font_y_axis\"),\n        axis.title.y = element_text(size = 20,\n                                    family = \"font_y_axis\")) \nenhanc_chart\n\n\n\nAdding the milestones in the same series:\n\n\nenhanc_chart +\n  geom_rect(\n    aes(xmin = 8.5, xmax = 10.78, ymin = 32.5, ymax = 35),\n    fill = \"transparent\", color = viridis_color[2], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.55, y = 33.75,\n    label = \"Surgeon General's report links smoking\\nto deaths from cancer and heart disease\",\n    color = viridis_color[2], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 8.5, xmax = 10, ymin = 42.4, ymax = 44.9),\n    fill = \"transparent\", color = viridis_color[2], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.55, y = 43.65,\n    label = \"The US bans cigarette ads\\non radio and television\",\n    color = viridis_color[2], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 8.9, xmax = 10, ymin = 54.3, ymax = 56.8),\n    fill = \"transparent\", color = viridis_color[3], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 8.95, y = 55.55,\n    label = \"Federal tax on\\ncigarettes doubles\",\n    color = viridis_color[3], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 7.35, xmax = 8.8, ymin = 50.5, ymax = 53),\n    fill = \"transparent\", color = viridis_color[3], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 7.4, y = 51.75,\n    label = \"Surgeon General's report\\non secondhand smoke\",\n    color = viridis_color[3], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 5.85, xmax = 7, ymin = 53.7, ymax = 56.2),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 5.9, y = 54.95,\n    label = \"Increasing bans\\non inflight smoking\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 3.95, xmax = 6.35, ymin = 49.55, ymax = 52.05),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 4, y = 50.8,\n    label = \"Nicotine replacement medications\\nbecome widely available over the counter\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 5.9, xmax = 7.3, ymin = 44.75, ymax = 47.25),\n    fill = \"transparent\", color = viridis_color[4], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 5.95, y = 46,\n    label = \"California bans smoking\\nin restaurants\",\n    color = viridis_color[4], size = 5, hjust = 0, lineheight = 0.75,\n    family = \"font_y_axis\"\n  ) +\n  geom_rect(\n    aes(xmin = 3.65, xmax = 5.35, ymin = 33.7, ymax = 36.2),\n    fill = \"transparent\", color = viridis_color[5], size = 0.5\n  ) +\n  annotate(\n    \"text\", x = 3.7, y = 34.95,\n    label = \"Federal tax increased again\\nfrom $0.39 to $1.01 per pack\",\n    color = \"#DAA520\", size = 5, hjust = 0, lineheight = 0.75, \n    family = \"font_y_axis\"\n  )\n\n\n\nFurthermore, it is easier to observe in this graph that there is a strong positive correlation between daily cigarette sales and deaths attributed to lung cancer in the United States. The arrows start moving upward to the right and then downward to the left, indicating a positive correlation. In addition, the alignment and clear direction of the arrows suggest a strong correlation.\nTo sum up, it is evident that both the death rate and daily cigarette sales have decreased significantly from the second half of the 20th century to the present. For instance, we transitioned from approximately 9.1 daily cigarettes sold with a 53.61% lung cancer death rate in men in 1983 to 3.7 daily cigarettes sold with a 36.85% lung cancer death rate in men in 2009.\n\n\n\n",
    "preview": "projects/2023/100407614/100407614_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1152
  },
  {
    "path": "projects/2023/100430912/",
    "title": "Annual Global Corporate Investment in AI by Type",
    "description": "This project replicates a graph from Our World in Data and proposes an improvement.",
    "author": [
      {
        "name": "María Jurado-Millán",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplication\nCleaning and preparing data\nBuilding the graph and scales\nLabs and themes\n\nImprovement\n\nIntroduction\nThis graph was published by Our World in Data in June 2023 and shows the evolution of investment in artificial intelligence by type from 2013 to 2022. The unit of measure is US dollars adjusted by inflation. This is important because it allow us to make comparisons across time, taking into account that prices change over time. Data is adjusted according the US Consumer Price Index (CPI).\nI chose this chart because nowadays, artificial intelligence is a very trending topic and it is interesting to see how the investment market has behaved the past years. It is not surprising that the investment trend is increasing because it is a booming sector, but it is interesting that it reached a peak in 2021 and decreased in 2022. Does the pandemic have anything to do with this?\nThe purpose of this project is to replicate the original graph shown below and propose an improvement using the same data.\nAnnual global corporate investment in artificial intelligence, by type. Figure from ourworldindata.org.Replication\nThe first step is to run necessary libraries and the database.\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n\nCleaning and preparing data\nThe original database contains 50 observations from 2013 to 2022 and 5 variables, Merger/Acquisition, Public Offering, Private Investment, Minority Stake and Total. The names of the columns are modified to simplify the coding and rows names are reordered to follow the graph’s structure. Since the graph doesn’t show the Total investment, these information can be omitted, as well as the “Code” column that only has NA’s an as is not giving any information at all, can be eliminated.\nSteps:\nOpen the database and rename columns to simplify the code.\n\n\ndata<-read_csv(file=\"corporate-investment-in-artificial-intelligence-by-type.csv\")\nhead(data)\n\n# A tibble: 6 × 4\n  Entity             Code   Year Total corporate investment - inflat…¹\n  <chr>              <lgl> <dbl>                                 <dbl>\n1 Merger/Acquisition NA     2022                           77173925249\n2 Merger/Acquisition NA     2021                          119660000000\n3 Merger/Acquisition NA     2020                           27284262020\n4 Merger/Acquisition NA     2019                           33821216045\n5 Merger/Acquisition NA     2018                           23621530919\n6 Merger/Acquisition NA     2017                           27282738242\n# ℹ abbreviated name:\n#   ¹​`Total corporate investment - inflation adjusted`\n\ndata<-data |> \n  rename(entity = Entity, year = Year,\n         amount = \"Total corporate investment - inflation adjusted\")\n\n\nEliminate non useful information.\n\n\ndata<- data |> \n  select(-Code) |> \n  filter(entity != \"Total\")\n\n\nConvert year column into a date variable instead of numeric.\n\n\ndata<- data |>\n  mutate(year=make_date(year=year, month=1, day=1),\n         year=as.Date(year))\n\n\nOrder data in the same structure as the graph.\n\n\ndata<-data |> \n  mutate(entity=factor(entity, levels=c(\n    \"Merger/Acquisition\", \"Public Offering\", \"Private Investment\", \"Minority Stake\")))\nhead(data)\n\n# A tibble: 6 × 3\n  entity             year             amount\n  <fct>              <date>            <dbl>\n1 Merger/Acquisition 2022-01-01  77173925249\n2 Merger/Acquisition 2021-01-01 119660000000\n3 Merger/Acquisition 2020-01-01  27284262020\n4 Merger/Acquisition 2019-01-01  33821216045\n5 Merger/Acquisition 2018-01-01  23621530919\n6 Merger/Acquisition 2017-01-01  27282738242\n\nBuilding the graph and scales\nNow that data is cleaned and prepared,we can start building the graph. This graph is plotted using geom_col function, which is the R function used for bar charts in ggplot2 package.The fill aesthetic is set to the variable “entity”, and the color palette is introduced manually with the function rgb() that allow us to find the exact color from the HTML format in R.\nSteps:\nCreate the plot and define the axes.\n\n\ng<-ggplot(data,\n       aes(x=year,y=amount, fill=entity))\n\n\nProperly scale the axes, including the breaks and renaming these breaks.\n\n\ng<- g + \n  scale_x_date(date_breaks=\"year\",\n               date_labels = \"%Y\")+\n  scale_y_continuous(breaks=c(0,50000000000,100000000000,150000000000,200000000000,250000000000),\n                     labels = c(\"$0\",\"$50 billion\",\"$100 billion\",\"$150 billion\",\"$200 billion\",\"$250 billion\"))\n\n\nInclude the dotted lines.\n\n\ng<- g +\n  geom_hline(yintercept=c(50000000000,100000000000,150000000000,200000000000,250000000000),\n             linetype=\"dotted\")\n\n\nAdd the necessary information to fill the plot with and their corresponding color.\n\n\ng<- g +\n  geom_col() + scale_fill_manual(values = c(\n    \"Merger/Acquisition\" = \"#B13507\",\n    \"Public Offering\" = \"#4C6A9C\",\n    \"Private Investment\" = \"#578145\",\n    \"Minority Stake\" = \"#883039\"\n  ))\ng\n\n\n\nLabs and themes\nThis section is formed by the final retouches. The tittle and subtitle are added in the same font as the original graphic and located at the right position and size. The background and the legend are also modified.\nSteps:\nInclude the necessary fonts.\n\n\nsysfonts::font_add_google(\"Playfair Display\", family=\"playfair_display\")\nsysfonts::font_add_google(\"Roboto\", family=\"roboto\")\nshowtext::showtext_auto()\n\n\nAdd the tittle and subtitle.\n\n\ng<- g+\n  labs(x=NULL, y=NULL, \n       title=\"Annual global corporate investment in artificial intelligence, by type\", \n       subtitle=\"This data is expressed in US dollars, adjusted for inflation.\")\n\n\nAdjust them to the exact font, size and location.\n\n\ng<- g+\ntheme(plot.title = element_text(color=\"#5b5b5b\", size=20, family = \"playfair_display\"),\n        plot.subtitle=element_text(color=\"#5b5b5b\", size=15, family = \"roboto\"),\n        plot.title.position = \"plot\")\n\n\nEliminate the title of the legend.\n\n\ng<- g+\n  theme(legend.title = element_blank())\n\n\nChange the background of the graph to the same color as the original one.\n\n\ng<- g+\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\"))\ng\n\n\n\nImprovement\nThe suggested improvement involves transitioning from a bar chart to a line chart. This change is motivated by the current graphical representation’s limitations, particularly because in year 2021 we can not see if Merger/Acquisition sector invested more than Private Investment. Given that data is a time series, I consider that a line chart would be more appropriate because it captures better the evolution over time. The objective of this adjustment is to enhance the clarity and interpretability of the presented data, providing a better overview of the evolution by type across the years.\nSteps:\nReorder data to show the variables from higher to lower investment.\n\n\ndata<-data |> mutate(entity=factor(entity, levels=c(\n  \"Private Investment\", \"Merger/Acquisition\", \"Public Offering\", \"Minority Stake\"))) |> \n  arrange(data)\n\n\nCreate the line chart and specify the axes.\n\n\np<- ggplot(data) +\n  aes(x=year,y=amount)+\n  geom_line(aes(color=entity))\n\n\nProperly scale the axes, including the breaks and renaming these breaks.\n\n\np<- p +\n  scale_x_date(date_breaks=\"year\",\n               date_labels = \"%Y\")+\n  scale_y_continuous(breaks = c(0,20000000000,40000000000,60000000000,80000000000,100000000000,120000000000),\n                     labels = c(\"$0\",\"$20 billion\",\"$40 billion\",\"$60 billion\",\"$80 billion\",\"$100 billion\", \"$120 billion\"))\n\n\nInclude the dotted lines.\n\n\np<- p +\n  geom_hline(yintercept=c(0,20000000000,40000000000,60000000000,80000000000,100000000000,120000000000),\n             linetype=\"dotted\",color=\"#5b5b5b\")\n\n\nAdd the title and subtitle.\n\n\np<- p +\n  labs(x=NULL, y=NULL,\n       title=\"Annual global corporate investment in artificial intelligence, by type\", \n       subtitle=\"This data is expressed in US dollars, adjusted for inflation.\")\n\n\nAdjust them to the proper font, size and location.\n\n\np<- p +\n  theme(plot.title = element_text(color=\"#5b5b5b\", size=20, family = \"playfair_display\"),\n        plot.subtitle=element_text(color=\"#5b5b5b\", size=15, family = \"roboto\"),\n    plot.title.position = \"plot\")\n\n\nEliminate the title of the legend\n\n\np<- p +\n  theme(legend.title = element_blank())\n\n\nChange the background of the graph.\n\n\np<- p +\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\"))\n\np\n\n\n\nThis graph illustrates the evolution of Artificial Intelligence investments by type over time. In 2021, private investment surpasses Merger and Acquisition funding, a detail not evident in the original graph. This improvement makes the graph considerably more informative as it now displays the investment amounts for each type, enhancing clarity and ease of interpretation.\n\n\n\n",
    "preview": "projects/2023/100430912/100430912_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100508332/",
    "title": "Women's Suffrage Across Time",
    "description": "The recreation of a graph illustrating the development of the women's suffrage\nmovement throughout the years.This graph is replicated and then improved by\nadding data describing the development of women's political participation.",
    "author": [
      {
        "name": "Alexandra Salo",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nEurope, Asia-Pacific regions were front-runners in women’s suffrage\nCleaning and inputting the data\nCreating the graph\n\nImprovements to the graph\n\nEurope, Asia-Pacific regions were front-runners in women’s suffrage\nI chose a filled area chart illustrating the women’s suffrage movement globally throughout the years. Here is the original chart by the Pew Research Center:\n\n\n\nFigure 1: Original graph\n\n\n\nYou can find the graph originally here.\nCleaning and inputting the data\nView and input the data set. Set up the packages I will use in this project.\n\n\n#packages and reading data\nlibrary(ggplot2)\nlibrary(readxl)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(countrycode)\nlibrary(ggh4x)\nsysfonts::font_add_google(\"Lato\", family=\"lato\")\n\ndata_right_to_vote_unclean <- read.csv(\"country-field_suffrage-field_right_to_vote.csv\", header = 7)\n\n\nI got my data from this website: https://data.ipu.org/historical-women. Too late into the project, I realised that this data set doesn’t give me the total data that the original graph did, so they must have made their own data set.\nFirstly I need to set my data correct. The data is in groups according to region, which I could not find already readily made in any package, so I had to do it manually. So here I clean and trim the data, while also adding a new column specifying the region.\n\n\n#remove unnecessary rows and columns\ncolnames(data_right_to_vote_unclean) <- data_right_to_vote_unclean[6, ]\ndata_right_to_vote <- data_right_to_vote_unclean[-c(1:6), ]  # Remove the rows\n\n#put all the countries into Regions (as in the original graph)\ndata_right_to_vote <- data_right_to_vote |> \n  mutate(Region = case_when(\n    Country %in% c(\"Angola\", \"Benin\", \"Botswana\", \"Burkina Faso\", \"Burundi\", \"Cameroon\", \"Cabo Verde\", \n                   \"Gambia (The)\", \"Central African Republic\", \"Chad\", \"Comoros\", \"Democratic Republic of the Congo\",\n                   \"Congo\", \"Côte d'Ivoire\", \"Djibouti\", \"Eritrea\", \"Eswatini\", \"Ethiopia\", \"Gabon\",\n                   \"Gambia\", \"Ghana\", \"Guinea\", \"Equatorial Guinea\", \"Guinea-Bissau\", \"Kenya\", \"Lesotho\", \n                   \"Liberia\", \"Madagascar\", \"Malawi\", \"Mali\", \"Mauritania\", \"Mauritius\", \"Mayotte\", \"Mozambique\", \n                   \"Namibia\", \"Niger\", \"Nigeria\", \"Rwanda\", \"Senegal\", \"Seychelles\", \"Sierra Leone\", \n                   \"Somalia\", \"South Africa\", \"South Sudan\", \"Sudan\", \"United Republic of Tanzania\", \"Togo\", \n                   \"Uganda\", \"Zambia\", \"Zimbabwe\", \"Sao Tome and Principe\") \n    ~ \"Sub-Saharan Africa\",\n    Country %in% c(\"United States of America\", \"Mexico\", \"Canada\") \n    ~ \"North America\",\n    Country %in% c(\"Algeria\", \"Bahrain\", \"Djibouti\", \"Egypt\", \"Iraq\", \"Jordan\", \"Kuwait\", \"Lebanon\", \n                   \"Libya\", \"Mauritania\", \"Morocco\", \"Oman\", \"Qatar\", \"Saudi Arabia\", \"Somalia\", \"Sudan\", \n                   \"Syrian Arab Republic\", \"Tunisia\",  \"United Arab Emirates\", \"Yemen\", \"Islamic State of Afghanistan\", \n                   \"Afghanistan\", \"Iran (Islamic Republic of)\", \"Pakistan\", \"Israel\", \"West Bank and Gaza\") \n    ~ \"Middle East-North Africa\",\n    Country %in% c(\"Aruba\", \"Argentina\", \"Antigua and Barbuda\", \"Bahamas\", \"Belize\", \"Bolivia (Plurinational State of)\", \n                   \"Brazil\", \"Barbados\", \"Chile\", \"Colombia\", \"Costa Rica\", \"Cuba\", \"Cayman Islands\", \n                   \"Dominica\", \"Dominican Republic\", \"Ecuador\", \"Grenada\", \"Guatemala\", \"Guyana\", \"Honduras\", \n                   \"Haiti\", \"Jamaica\", \"Saint Kitts and Nevis\", \"Saint Lucia\", \"Nicaragua\", \"Panama\", \n                   \"Peru\", \"Puerto Rico\", \"Paraguay\", \"El Salvador\", \"Suriname\", \"Turks and Caicos Islands\", \n                   \"Trinidad and Tobago\", \"Uruguay\", \"Saint Vincent and the Grenadines\", \"Venezuela (Bolivarian Republic of)\") \n    ~ \"Latin America-Caribbean\",\n    Country %in% c(\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\", \"Belarus\", \"Belgium\", \n                   \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\", \"Czech Republic\", \"Denmark\", \n                   \"Estonia\", \"Finland\", \"France\", \"Georgia\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\", \n                   \"Ireland\", \"Italy\", \"Kazakhstan\", \"Kosovo\", \"Latvia\", \"Liechtenstein\", \"Lithuania\", \"Luxembourg\", \n                   \"Malta\", \"Republic of Moldova\", \"Monaco\", \"Montenegro\", \"Netherlands\", \"North Macedonia\", \n                   \"Norway\", \"Poland\", \"Portugal\", \"Romania\", \"Russian Federation\", \"San Marino\", \"Serbia\", \"Slovakia\", \n                   \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\", \"Türkiye\", \"Ukraine\", \"United Kingdom\", \"Vatican City\") \n    ~ \"Europe\",\n    Country %in% c(\"Cambodia\", \"Indonesia\", \"Lao People's Democratic Republic\", \"Malaysia\", \"Myanmar\", \n                   \"Japan\",  \"Democratic People's Republic of Korea\", \"Republic of Korea\", \"Singapore\", \n                   \"Philippines\", \"Thailand\", \"Timor-Leste\", \"Viet Nam\", \"China\", \"Mongolia\", \"Armenia\", \n                   \"Azerbaijan\", \"Georgia\", \"Kyrgyzstan\", \"Tajikistan\", \"Uzbekistan\", \"Turkmenistan\" , \n                   \"Bangladesh\", \"Bhutan\", \"India\", \"Maldives\", \"Nepal\", \"Pakistan\", \"Sri Lanka\", \n                   \"Micronesia (Federated States of)\", \"Fiji\", \"French Polynesia\", \"Kiribati\", \n                   \"Marshall Islands\", \"Nauru\", \"New Caledonia\", \"New Zealand\", \"Palau\", \"Solomon Islands\", \n                   \"Tonga\", \"Tuvalu\", \"Vanuatu\", \"Samoa\" ,  \"Papua New Guinea\", \"Wallis and Futuna\") \n    ~ \"Asia-Pacific\",\n    TRUE ~ \"Other\"))\n\n#remove and rename columns\ndata_right_to_vote <-  data_right_to_vote |> \n  relocate(Region, .after = Country) |> \n  relocate(`Women’s right to vote`, .after = Region) |> \n  select(2:4) |> \n  rename(Year = `Women’s right to vote`)\n\n\nHere I widen the data and get a column for each year between 1882 and 2020. During the year that women got the right to vote in each country we assign TRUE.\n\n\nfor(i in 1882:2020) {\n  data_right_to_vote[[as.character(i)]] <- 0\n}\n\nfor(i in 1:nrow(data_right_to_vote)) {\n  data_right_to_vote[[data_right_to_vote[i, \"Year\"]]][i] <- TRUE\n}\n\n\nHere I removing all the duplicates, and keeping the row with the lowest value for year. As this is how I chose to define the data, in some countries they have multiple rows for different stages of women’s suffrage (eg. in 1912 women got the right to vote in local elections and in 1920 national elections).\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  arrange(Country, Year) |> \n  distinct(Country, .keep_all = TRUE) |> \n  select(-Year)\n\n\nThen I bring in the data to be narrow, so we are left with an obervation for every year and country, and the year that women had gotten the first initial taste of suffrage, returns TRUE.\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  pivot_longer( cols = c(\"1882\":\"2020\"), names_to = \"Year\", \n    values_to = \"Right_to_vote\"\n  )\n\n\nHere I transform the data so that for for every year that women had the right to vote, it returns true. It returns false for every year they did not in each country.\n\n\ndata_right_to_vote <- data_right_to_vote |> \n  group_by(Country) |> \n  mutate(Right_to_vote = cumsum(Right_to_vote > 0) > 0) \n\n\nHere I create a new data set that tells us how many countries had given women the right to vote in each region in every year.\n\n\ndata_right_to_vote$Year <- as.numeric(data_right_to_vote$Year)\n\nvoting_data <- data_right_to_vote |> \n  group_by(Year, Region) |> \n  summarize(count_right_to_vote_region = sum(Right_to_vote) ) |> \n  ungroup() \n\n\nCreating the graph\nWe start by lagging the valuables so that we can get the effect of the steps in the graph. Then we create the first step of the graph and get the main graph characteristics. So the filled area of each region, this was surprisingly difficult to get, because I tried using geom_area() and geom_step() in the same function but I couldn’t combine them. Then I was able to achieve the result with the lagging of the values (to get the step like borders).\n\n\n# generate new points (lagged values) to \"hold\" the value until the next step\ndf <- voting_data |> \n  group_by(Region) |> \n  mutate(count_right_to_vote_region = lag(count_right_to_vote_region)) |> \n  na.omit() |> \n  rbind(voting_data) \n\nn <-  ggplot() +\n  geom_area(data = df, aes(Year, count_right_to_vote_region, \n                           fill = factor(Region, levels = c(\"Sub-Saharan Africa\", \"North America\", \"Middle East-North Africa\", \"Latin America-Caribbean\", \"Europe\", \"Asia-Pacific\")))) + \n  scale_fill_manual(values=c(\"#c7c3cc\", \"#756b80\", \"#e5cb84\", \"#edddae\", \"#df996b\", \"#e9ba9b\")) +\n  theme_gray(base_size = 10, base_family=\"lato\") \n\nn\n\n\n\nHere we add on to main characteristics of the graph and add the top line showing total numbers of countries that have given women the right to vote.\n\n\nsumdf <- voting_data |> \n  group_by(Year) |> \n  mutate(sum_count_right_to_vote = sum(count_right_to_vote_region)) |> \n  ungroup()\n  \nn <- n + \n  geom_step(data = sumdf, aes(Year, sum_count_right_to_vote), linewidth = 0.3)\n\nn\n\n\n\nHere I take steps to format the axis and all the details of the axes and the labs. The most difficult part here was figuring out the ticks, but once I found the ggh4x package, it was pretty straight forward.\n\n\nn <- n + theme(legend.position = \"none\", \n               axis.title.x = element_blank(),\n               axis.title.y = element_blank())\n\nx_break <- c(1893, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020 )\nx_break_names <- c(\"1893          \", \"1900\", \"'10\", \"'20\", \"'30\", \"'40\", \"'50\", \"'60\", \"'70\", \"'80\", \"'90\", \"2000\", \"'10\", \"'20\")\n\nminor_breaks_v <- c(1893:2020)\n\n n <-  n  +  \n   scale_x_continuous(\n     name = NULL, \n     breaks = x_break, \n     labels = x_break_names, \n     limits = c(1893, 2020), \n     minor_breaks = seq(1893,2020, by= 1), \n     expand = c(0, 0), \n     guide = \"axis_minor\" )  +\n   scale_y_continuous(\n     limits = c(0, 200), \n     expand = c(0, 0)) +\n   theme(\n     axis.text.x = element_text(size = 6), \n     axis.text.y = element_text(size = 6),\n     axis.ticks = element_line(size = 0.1),\n     axis.ticks.length = unit(7, \"pt\"),\n     ggh4x.axis.ticks.length.minor = rel(0.5)) + \n   labs(\n  title = \"Europe, Asia-Pacific regions were front-runners in\\nwomen's suffrage\", \n  subtitle = \"Number of nations allowing women the right to vote in national\\nelections, by year\", \n  caption = \"Note: Women in Afghanistan had the right to vote beginning 1929, but this right\\nwas taken away several times before being restored in 2004. Saudi Arabia and\\nBrunei do not hold national elections, and Hong Kong and Macau do not participate\\nin China's elections. Women vote in local elections in all 4 areas.\\nSource: Pew Research Center analysis of government publications, historical\\ndocuments from organizations like the United Nations and the Inter-Parliamentary\\nUnion, and various news reports to determine women's enfranchisement history in\\n198 countries and self-administering territories.\") +\n   geom_hline(\n     yintercept = 0, color = \"black\", size= 0.2) \n \n n\n\n\n\nHere I further adjust the formatting of the graph, so that the titles and caption matched the original as closely as possible. I chose the font Lato from google fonts to achieve this effect.\n\n\nn1 <-  n +\ntheme(\n  plot.title = element_text(face = \"bold\", \n                            size = 13, \n                            hjust = 0, \n                            vjust = 1.5, \n                            lineheight = 1), \n  plot.title.position = \"plot\",\n  plot.subtitle = element_text(\n    face = \"italic\", \n    color = \"#8f9092\", \n    size = 11, \n    hjust = 0, \n    vjust = 1.8, \n    lineheight = 1), \n  plot.caption = element_text(\n    color = \"#8f9092\", \n    size = 8, \n    hjust = 0), \n  plot.caption.position = \"plot\"\n  )\n\nn1\n\n\n\nHere I adjust the background formatting and the clipping of the graph. I turn off clipping in the coord_fixed, to allow my future annotations to continue past the limits.\n\n\nn2 <- n1 + theme(\n  panel.background = element_rect(fill = \"white\"),  \n  panel.grid.major.y = element_line(color = \"gray\", linetype = \"dotted\"), \n  panel.grid.minor.y = element_blank(),  # Remove minor grid lines)\n  text = element_text(family = \"lato\"), \n  aspect.ratio = 1.4\n  ) + \n  coord_fixed(0.8, clip = \"off\") \nn2\n\n\n\nHere I add the annotations for each region.\n\n\n#Africa label\nn3 <-  n2 + annotate(\n    \"text\", \n    x = 1998,  # X-coordinate\n    y = 145,   # Y-coordinate\n    label = \"Sub-Saharan Africa\",  # Text to display\n    size = 2,  # Text size\n    color = \"#6f6673\"  # Text color\n  ) \n#North America\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 2012,  \n    y = 130,  \n    label = \"North America\",  \n    size = 2, \n    color = \"#4c4852\"  \n  )\n\n#Middle East- North Africa\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 2014,  \n    y = 118,   \n    label = \"Middle East-\", \n    size = 2,  \n    color = \"#88723b\") + annotate(\n    \"text\", \n    x = 2014, \n    y = 112,   \n    label = \"North Africa\",\n    size = 2,  \n    color = \"#88723b\")\n    \n#Latin America- Caribbean\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 1995,  \n    y = 96,   \n    label = \"Latin America-\", \n    size = 2,  \n    color = \"#88723b\" , \n    vjust = 2\n    ) + annotate(\n    \"text\", \n    x = 1995, \n    y = 90,   \n    label = \"Caribbean\", \n    size = 2,  \n    color = \"#88723b\" , \n    vjust = 2\n    ) \n\n#Europe\nn3 <-  n3 + annotate(\n    \"text\", \n    x = 1980,  \n    y = 47,   \n    label = \"Europe\",  \n    size = 2,  \n    color = \"#965a31\"  \n  )\n\nn3\n\n\n\nHere I add the annotations (point and text) for y=1 and y=73 (the final total value).\n\n\nn4 <- n3 +\n  geom_point(data = subset(data_right_to_vote, Year == 2020), aes(x = 2020, y = 173), color = \"black\", size = 0.4) +\n  geom_text(data = subset(data_right_to_vote, Year == 2020),\n            aes(label = \"Total\\n 173\", x= 2014, y=166), \n            vjust = -1.2, hjust = 0, size = 2, lineheight = 1) +\n  geom_point(data = subset(data_right_to_vote, Year == 1893), aes(x = 1893, y = 2), color = \"black\", size = 0.4) +\n  geom_text(data = subset(data_right_to_vote, Year == 1893),\n            aes(label = \"1\", x= 1893, y=1), \n            vjust = -1, hjust = 0.5, size = 2, lineheight = 1) + \n  geom_segment(aes(x = 1893, y =220, xend = 2020, yend = 220,\n               color = \"black\", size = 1))  \n\n# adding last annotation, Asia-Pacific\nn5 <-  n4 + annotate(\n    \"text\", \n    x = 1990,  \n    y = 15,   \n    label = \"Asia-Pacific\",  \n    size = 2,  \n    color = \"#b97648\" )\n\n\nAnd I am finally led to the final graph, which is as close as I can get it to the original!\n\n\nn5\n\n\n\nImprovements to the graph\nOriginally I considered different ways to improve the graph. I made some different iterations of the graph, most notably trying to make the graph proportional to each region. But once I had come to the main idea, the overall outlook and shape looked quite similar, and the message of the graph got a little lost in my opinion. It was not clear what the graph’s message was in this form I had experimented with.\nTo me, the main information the graph is trying to convey is when and which general regions were at the forefront of the women’s suffrage movement. I wanted to maintain this, but add another element, showing the interaction between women’s suffrage and women’s political participation (in the form of % of women in politics).\nSo I was able to obtain data on the amount of women in parliament/ highest chambers of all nations. Here I read and format the data to be appropriate for my use.\n\n\ndata_women_in_parliament_unclean <- read_xlsx(\"women_in_parliament-historical_database-1945_to_2018.xlsx\")\n\ndata_women_in_parliament <-  data_women_in_parliament_unclean |> \n  select(1,4,9) |> \n  rename(Women_in_parliament = '% Of Women in Chamber') \n\ndata_women_in_parliament$Women_in_parliament <- as.numeric(data_women_in_parliament$Women_in_parliament)\n\n\nOriginally I wanted to explore how the average % of women in their nations’ highest chambers developed over time. However, since I had the scale 0-200 in use for the y-axis, I decided to change my approach to avoid a dual axis.\nI decided to explore and graph the amount of nations having 20% or more of women represented in their highest chamber. Here I mutate the data to find the number of countries each year with 20% or over.\n\n\n#finding the amount of countries with over 20% women in parliament for each year\nimproved_data <-  data_right_to_vote |> \n  left_join(data_women_in_parliament, by = c(\"Country\", \"Year\"))\n\nimproved_data <-improved_data |> \n  mutate(\n    more_20_perc = case_when\n    (Women_in_parliament >= 0.2 ~ TRUE,\n      Women_in_parliament < 0.2 ~FALSE, \n      is.na(Women_in_parliament) ~ NA))\n\nimproved_data <- improved_data |> \n  group_by(Year) |> \n  mutate(count_20_perc = sum(more_20_perc, na.rm = TRUE))\n\n\nHere I add the line to visualize the amount of countries having more than 20% female highest chambers.\n\n\ng <- n4\n\ng <- g + \n  geom_step(data = improved_data, aes(Year, count_20_perc), size = 0.4)\ng\n\n\n\nSince the data only goes to 2018, I changed the axes slightly. Then I also go on to update the other information in the graph, for eg. the titles, captions etc.\n\n\nx_break <- c(1893, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2018 )\nx_break_names <- c(\"1893          \", \"1900\", \"'10\", \"'20\", \"'30\", \"'40\", \"'50\", \"'60\", \"'70\", \"'80\", \"'90\", \"2000\", \"'10\", \"2018\")\n\ng <-  g  +  \n   scale_x_continuous(name = NULL, breaks = x_break, labels = x_break_names, limits = c(1893, 2018), minor_breaks = minor_breaks_v, expand = c(0, 0) ) +\n   scale_y_continuous(limits = c(0, 200), expand = c(0, 0)) +\n  theme(axis.text.x = element_text(size = 6), \n         axis.text.y = element_text(size = 6),\n         axis.ticks = element_line(size = 0.1),\n         axis.ticks.length = unit(7, \"pt\"),\n         ggh4x.axis.ticks.length.minor = rel(0.5))\n\ng <-  g + labs(\n  title = \"Europe, Asia-Pacific regions were front-runners in\\nwomen's suffrage, women still underrepresented in politics\", \n  subtitle = \"Number of nations allowing women the right to vote in national elections,\\nand number of nations with +20% of women in their highest chamber, by year\", \n  caption = \"Note: Women in Afghanistan had the right to vote beginning 1929, but this right was taken\\naway several times before being restored in 2004. Saudi Arabia and Brunei do not hold\\nnational elections, and Hong Kong and Macau do not participate in China's elections. Women\\nvote in local elections in all 4 areas. Source: IPU Parline, Global data on national\\nparliaments- historical data on women.\"\n)\n\ng\n\n\n\nFinally I add the annotations and labels to this to illustrate the addition better.\n\n\ng <- g +\n  geom_point(data = subset(voting_data, Year == 2018), aes(x = 2018, y = 173), color = \"black\", size = 0.7) +\n  geom_point(data = subset(voting_data, Year == 2016), aes(x = 2016.5, y = 51), color = \"black\", size = 1) + \n  geom_text(data = subset(voting_data, Year == 2016), aes(label = \"Maximum\\n51 \", x = 2016.5, y = 60), size = 2, lineheight = 1) +\n  annotate(\n    \"text\",\n    x = 2018, y = 20,\n    label = \"  Number of countries\\n  with their highest\\n  chamber consisting\\n of + 20% women\",\n    hjust = 0, vjust = 0.5,\n    color = \"#8f9092\", size = 3) + \n  annotate(\n    \"text\", \n    x = 1975,  \n    y = 12,   \n    label = \"Asia-Pacific\",  \n    size = 2,  \n    color = \"#b97648\" )\n\n\nFinally we have the final graph with improvements.\n\n\ng\n\n\n\n\n\n\n",
    "preview": "projects/2023/100508332/100508332_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 998
  },
  {
    "path": "projects/2023/100516517/",
    "title": "Bipartisanship Unveiled: The Evolution of Recent History in the Spanish Congress",
    "description": "Replication and alternative rendition of a streamgraph sourced from El Orden Mundial,\nutilizing data on congressional deputies available on the official website of the Spanish Congress.",
    "author": [
      {
        "name": "Candela Gómez-Blanco",
        "url": {}
      }
    ],
    "date": "2024-01-18",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nPreparing the data base\nCollecting the data\nCleaning the database\nDefinite graph data base\n\nReplication: stream_graph\nSetting the actual colors\nAnnotations\n\nA different representation of the data\nLimitations of the original graph\nAlternative graph\n\n\nIntroduction\nThis project is based on the graph posted in the article “El desfile político en la democracia española” (The Political Parade in Spanish Democracy), published by El Orden Mundial in 2023. In this piece, the authors delve into the evolution of the Spanish Congress of Deputies throughout its democratic history. Specifically, they analyze the distribution of seats among major political parties and ideologies, emphasizing the development of bipartisanship from the 1977 elections to the present.\nThe article includes the following graph, which effectively illustrates this evolution. At a glance, it becomes evident that, since the first democratic elections, the composition of the Congress has been characterized by a dominant two-party system and consistent support for peripheral nationalist parties. This trend is largely influenced by an electoral system that favors major parties in smaller constituencies, to the detriment of minority formations at the national level.\nOriginal graphI encountered this graph worth replicating, being a comprehensive representation of the data. Given that it seemed to encapsulate a significant amount of information effectively, suggesting improvements could pose a considerable challenge.\nPreparing the data base\nCollecting the data\nPreparing the database involved collecting data on the deputies who have served in Congress over the years. I obtained this information from the official website of the Congress of Deputies (https://www.congreso.es/es/opendata/diputados) by downloading the Excel files corresponding to the 15 legislatures. Combining the data from each of these legislatures into a unified Excel file, I stored it in this project’s Git-Hub folder. The subsequent task involved cleaning and preparing this database.\n\n\n#Load these libraries\n\nlibrary(dplyr)\nlibrary(readxl)\nlibrary(lubridate)\nlibrary(stringr)\n\n#Read the database\ngraph_db<-read_xlsx(\"terms-unified.xlsx\")\n\n\nCleaning the database\nCleaning the database involved making adjustments over the original dataset, which comprised 6470 rows, each representing an individual deputy in Congress, and 9 columns containing specific deputy-related information.\nThe primary task, and the most challenging aspect of the entire assignment, was determining the characteristics our database needed to have to enable the creation of our graph. This involved identifying the necessary variables and how the data should be organized. Our interest did not lie in individualized deputy information, but rather in aggregating deputies based on their political affiliations. Additionally, we needed to ascertain the distribution of deputies for each year in which general elections were held. Once we clarified our objective, these were the next steps and encountered difficulties:\nSelecting the essential variables was required to achieve this goal. That is, we needed the name of the deputies (for an individualized register of each record), the political party to which each deputy belonged, and the start and end dates of their tenure as deputies.\nIt’s worth noting that some deputies conclude their tenure before the legislature ends, while others assume office midway through the term. Consequently, none of the available variables in the original database served our graph’s purpose. To address this, after determining the precise dates of each general election, a new column labeled “Elections” was created, narrowing down the dates to those in which general elections were celebrated.\nFurthermore, another variable called “num_deputies” was established. This variable calculated the cumulative count of deputies per political party. Each new enrollment contributed +1 in the most recent election, while each termination date deducted -1 in the subsequent legislature, enabling a comprehensive tally of deputies per political party over time.\n\n\nclean_data <- graph_db |>\n  # Selecting the variables of interest and converting to date\n  select(NOMBRE, FORMACIONELECTORAL, FECHAALTA, FECHABAJA) |>\n  mutate(across(c(FECHAALTA, FECHABAJA), ymd)) |> \n  # Removing duplicate values (changes in parliamentary groups)\n  distinct() |> \n  # Pivoting the date, sorting, and converting to year, removing NAs\n  tidyr::pivot_longer(c(FECHAALTA, FECHABAJA), values_to = \"FECHA\") |> \n  arrange(FECHA) |> \n  mutate(\n    Elections = case_when(\n      FECHA >= as.Date(\"1977-06-15\") & FECHA < as.Date(\"1979-03-01\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1977-06-15\"),\n      FECHA >= as.Date(\"1977-06-15\") & FECHA < as.Date(\"1979-03-01\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1979-03-01\"),\n      FECHA >= as.Date(\"1979-03-01\") & FECHA < as.Date(\"1982-10-28\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1979-03-01\"),\n      FECHA >= as.Date(\"1979-03-01\") & FECHA < as.Date(\"1982-10-28\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1982-10-28\"),\n      FECHA >= as.Date(\"1982-10-28\") & FECHA < as.Date(\"1986-06-22\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1982-10-28\"),\n      FECHA >= as.Date(\"1982-10-28\") & FECHA < as.Date(\"1986-06-22\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1986-06-22\"),\n      FECHA >= as.Date(\"1986-06-22\") & FECHA < as.Date(\"1989-10-29\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1986-06-22\"),\n      FECHA >= as.Date(\"1986-06-22\") & FECHA < as.Date(\"1989-10-29\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1989-10-29\"),\n      FECHA >= as.Date(\"1989-10-29\") & FECHA < as.Date(\"1993-06-06\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1989-10-29\"),\n      FECHA >= as.Date(\"1989-10-29\") & FECHA < as.Date(\"1993-06-06\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1993-06-06\"),\n      FECHA >= as.Date(\"1993-06-06\") & FECHA < as.Date(\"1996-03-03\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1993-06-06\"),\n      FECHA >= as.Date(\"1993-06-06\") & FECHA < as.Date(\"1996-03-03\") & \n        name == \"FECHABAJA\" ~ as.Date(\"1996-03-03\"),\n      FECHA >= as.Date(\"1996-03-03\") & FECHA < as.Date(\"2000-03-12\") & \n        name == \"FECHAALTA\" ~ as.Date(\"1996-03-03\"),\n      FECHA >= as.Date(\"1996-03-03\") & FECHA < as.Date(\"2000-03-12\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2000-03-12\"),\n      FECHA >= as.Date(\"2000-03-12\") & FECHA < as.Date(\"2004-03-14\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2000-03-12\"),\n      FECHA >= as.Date(\"2000-03-12\") & FECHA < as.Date(\"2004-03-14\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2004-03-14\"),\n      FECHA >= as.Date(\"2004-03-14\") & FECHA < as.Date(\"2008-03-09\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2004-03-14\"),\n      FECHA >= as.Date(\"2004-03-14\") & FECHA < as.Date(\"2008-03-09\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2008-03-09\"),\n      FECHA >= as.Date(\"2008-03-09\") & FECHA < as.Date(\"2011-11-20\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2008-03-09\"),\n      FECHA >= as.Date(\"2008-03-09\") & FECHA < as.Date(\"2011-11-20\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2011-11-20\"),\n      FECHA >= as.Date(\"2011-11-20\") & FECHA < as.Date(\"2015-12-20\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2011-11-20\"),\n      FECHA >= as.Date(\"2011-11-20\") & FECHA < as.Date(\"2015-12-20\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2015-12-20\"),\n      FECHA >= as.Date(\"2015-12-20\") & FECHA < as.Date(\"2016-06-26\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2015-12-20\"),\n      FECHA >= as.Date(\"2015-12-20\") & FECHA < as.Date(\"2016-06-26\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2016-06-26\"),\n      FECHA >= as.Date(\"2016-06-26\") & FECHA < as.Date(\"2019-04-28\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2016-06-26\"),\n      FECHA >= as.Date(\"2016-06-26\") & FECHA < as.Date(\"2019-04-28\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2019-04-28\"),\n      FECHA >= as.Date(\"2019-04-28\") & FECHA < as.Date(\"2019-11-10\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2019-04-28\"),\n      FECHA >= as.Date(\"2019-04-28\") & FECHA < as.Date(\"2019-11-10\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2019-11-10\"),\n      FECHA >= as.Date(\"2019-11-10\") & FECHA < as.Date(\"2023-07-23\") & \n        name == \"FECHAALTA\" ~ as.Date(\"2019-11-10\"),\n      FECHA >= as.Date(\"2019-11-10\") & FECHA < as.Date(\"2023-07-23\") & \n        name == \"FECHABAJA\" ~ as.Date(\"2023-07-23\"),\n      FECHA >= as.Date(\"2023-07-23\") &\n        name == \"FECHAALTA\" ~ as.Date(\"2023-07-23\"),\n      FECHA >= as.Date(\"2023-07-23\") &\n        name == \"FECHABAJA\" ~ as.Date(\"2023-07-23\")\n    )\n  ) |>\n  na.omit() |>\n  # Cumulative sum by electoral formation: +1 for STARTDATE, -1 for ENDDATE\n  group_by(FORMACIONELECTORAL) |> \n  mutate(num_deputies = cumsum(if_else(name == \"FECHAALTA\", 1, -1))) |>   \n  # We keep the last value per date and party\n  select(Elections, FORMACIONELECTORAL, num_deputies) |> \n  group_by(Elections, FORMACIONELECTORAL) |> \n  slice_tail() |>\n  # Removing transient records, where the total sum per date is less than 340\n  group_by(Elections) |> \n  filter(sum(num_deputies) > 300) |>\n  ungroup() |> \n  # Removing zeros\n  filter(num_deputies > 0)\n\n\nWithin the electoral formations, there were inconsistencies in the representation of party names. For instance, parties like VOX, Junts, or CiU, among others, were written in different formats regarding capitalization. Additionally, some parties were represented by their acronyms (such as “UP”) in some instances and by their full names in others for (“Unidas Podemos”). These variations needed standardization. Moreover, there were various coalitions of parties that, for graphing purposes, needed to be considered as deputies of only one party. For instance, the acronym “PSOE-A” should be counted as deputies of the PSOE party. To streamline this process and avoid addressing each party individually, the ‘str_detect’ function was used. However, certain party names shared letters and the order of some acronyms, such as ‘UP’ and ‘UPyD.’ Therefore, specific recategorizations were established without employing the previously mentioned function.\n\n\nclean_data <- clean_data |> \n  mutate(recat = case_when(\n    FORMACIONELECTORAL == \"CD\" ~ \"UCD\",\n    FORMACIONELECTORAL == \"UP\" ~ \"PODEMOS\",\n    FORMACIONELECTORAL == \"CP\" ~ \"PP\",\n    FORMACIONELECTORAL == \"PSUC\" ~ \"Otros catalanes\",\n    str_detect(FORMACIONELECTORAL, \"CIU|CiU|CDC|UDC\") ~ \"CiU\",\n    str_detect(FORMACIONELECTORAL, \"Junts|JUNTS\") ~ \"Junts\",\n    str_detect(FORMACIONELECTORAL, \"ERC\") ~ \"ERC\",\n    str_detect(FORMACIONELECTORAL, \"PODEMOS|POD|EN COMÚ|ECP\") ~ \"PODEMOS\",\n    str_detect(FORMACIONELECTORAL, \"MÁS PAÍS\") ~ \"Más País\",\n    str_detect(FORMACIONELECTORAL, \"PCE\") ~ \"PCE\",\n    str_detect(FORMACIONELECTORAL, \"IU\") ~ \"IU\",\n    str_detect(FORMACIONELECTORAL, \"PSOE|PSE|PSC\") ~ \"PSOE\",\n    str_detect(FORMACIONELECTORAL, \"US\") ~ \"US\",\n    str_detect(FORMACIONELECTORAL, \"SUMAR\") ~ \"SUMAR\",\n    str_detect(FORMACIONELECTORAL, \"Cs\") ~ \"Cs\",\n    str_detect(FORMACIONELECTORAL, \"CDS\") ~ \"CDS\",\n    str_detect(FORMACIONELECTORAL, \"UCD\") ~ \"UCD\",\n    str_detect(FORMACIONELECTORAL, \"UPyD\") ~ \"UPyD\",\n    str_detect(FORMACIONELECTORAL, \"AP|PP\") ~ \"PP\",\n    str_detect(FORMACIONELECTORAL, \"Vox|VOX\") ~ \"VOX\",\n    str_detect(FORMACIONELECTORAL, \"PNV\") ~ \"PNV\",\n    str_detect(FORMACIONELECTORAL, \"HB\") ~ \"HB\",\n    str_detect(FORMACIONELECTORAL, \"EH Bildu\") ~ \"EH Bildu\",\n    str_detect(FORMACIONELECTORAL, \"CC\") ~ \"CC\",\n    TRUE ~ \"Otros\"\n  ))\n\n\nDefinite graph data base\nTo proactively manage potential errors I might face, I opted to create a new database at this stage, which will be the definitive one used for our graph.\nI organized the data by grouping it based on the ‘Elections’ and ‘recat’ columns. Then, I summarized the data by calculating the total number of deputies (‘num_deputies’ column) for each category and stored this information in a new column named ‘total_deputies’.\nTwo crucial adjustments were necessary to ensure the graph’s accurate representation:\nTransforming the ‘recat’ column into a factor specifying a certain order for its levels. This order was structured to mirror the original graph’s arrangement: regional parties on the left, followed by a progressive ideological sequence from left-leaning parties to right-leaning formations.\nTypically, graphs displaying an evolving trend have years or dates plotted along the X-axis. However, our graph’s design was oriented differently with dates on the Y-axis. Attempting to flip the graph using ‘coord_flip’ resulted in an inverted orientation, placing the most recent years at the bottom. To resolve this, I converted the dates into decimal values, facilitating the reversal of their order. This adjustment ensured that the ticks representing election dates on the Y-axis were proportionally spaced according to the time between each election.\n\n\n#Creating the final graph database\ngraph_base <- clean_data |> \n  group_by(Elections, recat) |> \n  summarise(total_deputies = sum(num_deputies)) |> \n  ungroup() \n\n#Ordering the political parties by their ideology\ngraph_base$recat <- factor(graph_base$recat,\n                           levels = c(\"VOX\", \"PP\", \"Cs\", \"UCD\", \"CDS\", \n                                      \"UPyD\", \"US\", \"PSOE\", \"SUMAR\", \n                                      \"Más País\", \"PODEMOS\", \"PCE\", \n                                      \"IU\", \"Otros catalanes\", \"CiU\", \n                                      \"ERC\", \"Junts\", \"PNV\", \"HB\", \n                                      \"EH Bildu\", \"CC\", \"Otros\"))\n\n#Adding the DECIMAL_DATE column\ngraph_base$DECIMAL_DATE <- decimal_date(graph_base$Elections)\nfechas_unicas <- unique(graph_base$DECIMAL_DATE)\n\n\nReplication: stream_graph\nThe graph we aim to replicate is a stream graph. These visualizations demonstrate changes in the composition and distribution of multiple variables over time. They prove useful in depicting time series data and how the distribution of different categories or groups within these series evolves over time. In this instance, it’s a proportional stream graph, meaning the width of the bands varies based on each category’s proportion at a specific moment in time. Hence, although the number of deputies in the Congress can fluctuate between 300 and 400, our graph will have a constant width, because it considers the proportion of deputies from each electoral party concerning the total number of deputies at any given time.\nThe following code accomplishes the following:\nCreates the proportional flow graph using the “ggplot2” package.\nFlips the graph to make it vertical.\nAdjusts the axis limits to accommodate annotations.\nEstablishes themes and styles, refining the appearance of the graph, including titles, subtitles, and axis formatting to mimic the original graph.\n\n\n#Loading needed libraries\nlibrary(ggstream)\nlibrary(ggplot2)\n\n# Creating a ggplot object with the new database\n\ngraph <- ggplot(data = graph_base, aes(x = DECIMAL_DATE, y = total_deputies)) +\n  # Adding a stream plot with recat as fill and proportional type\n  geom_stream(aes(fill = recat), type = \"proportional\") +\n  # Formatting y-axis labels as percentages\n  scale_y_continuous(labels = scales::percent_format(), breaks = NULL) +\n  # Formatting x-axis labels and reversing the scale\n  scale_x_continuous(trans = \"reverse\", \n                     breaks = fechas_unicas,\n                     labels = function(x) floor(x)) + \n  # Flipping coordinates to create a vertical plot\n  coord_flip(ylim = c(0, 1.2), \n             xlim = c(2023.556, 1975)) +  \n  # Adding axis labels and titles\n  labs(x = \"\", y = \"350 diputados\", fill = \"Orientación ideológica\",\n       title = \"**El desfile político en la democracia española**\",\n       subtitle = \"**Composición del Congreso (1977-2023)**\",\n       caption = paste(\"**Autor:**\", \"Álvaro Merino (2023)\", sep = \"<br>\")) +\n  # Modifying the appearance of various plot elements using theme settings\n  theme(\n    plot.title = ggtext::element_markdown(size = 10, color = \"#272727\"), \n    plot.title.position = \"plot\", \n    plot.subtitle = ggtext::element_markdown(size = 9, color = \"#6A6A6A\"), \n    plot.caption = ggtext::element_markdown(size = 4, color = \"#6A6A6A\"), \n    axis.ticks.y = element_line(size = 0.5, color = \"#6A6A6A\"), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.text.y = element_text(size = 4, color = \"#6A6A6A\"),\n    axis.title.x = element_text(size = 5, color = \"#6A6A6A\", hjust = 0.43), \n    panel.grid.major.x = element_blank(),\n    aspect.ratio = 4/2,\n    panel.border = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"none\"\n  )\n\ngraph\n\n\n\nSetting the actual colors\nTo precisely establish the same colors as the target graph, I utilized the eyedropper tool available in Paint to extract the exact code for each color. Then, I manually assigned specific colors to each of the categories represented in the graph.\n\n\ngraph <- graph + \n  scale_fill_manual(values = c(\n    \"VOX\" = \"#1F3D71\",\n    \"PP\" = \"#4D76BF\",\n    \"Cs\" = \"#E89433\",\n    \"UCD\" = \"#E6A55B\",\n    \"CDS\" = \"#C98B2C\",\n    \"UPyD\" = \"#FFC38D\",\n    \"US\" = \"#E2706D\",\n    \"PSOE\" = \"#BE4D4C\",\n    \"SUMAR\" = \"#A61918\",\n    \"PODEMOS\" = \"#D07F7F\",\n    \"PCE\" = \"#650904\",\n    \"Más País\" = \"#650904\",\n    \"IU\" = \"#9B2E33\",\n    \"CiU\" = \"#EAC659\",\n    \"Junts\" = \"#EAC659\",\n    \"ERC\" = \"#DDAB0B\",\n    \"Otros catalanes\" = \"#DDAB0B\",\n    \"PNV\" = \"#46862C\",\n    \"HB\" = \"#ABD894\",\n    \"EH Bildu\" = \"#A1B944\",\n    \"CC\" = \"#3B3D40\",\n    \"Otros\" = \"#E0E3E0\"\n  ))\n\ngraph\n\n\n\nAnnotations\nThe chosen graph required numerous annotations to provide a comprehensive representation. To achieve this, the ggannotate library was employed. This library significantly simplifies the process of placing labels and annotations on ggplot2-generated graphs. One of its notable advantages is its capability to swiftly and easily insert labels. With ggannotate, we can position labels precisely which expedites the process while ensuring accurate placement of annotations.\nParty labels\nThe initial step involved establishing labels linked to the names of electoral formations and their respective segments.\n\n\n# remotes::install_github(\"mattcowgill/ggannotate\")\nlibrary(ggannotate)\n#For adding each annotation run: ggannotate(graph)\n\ngraph <- graph + \n  geom_text(\n    data = data.frame(x = 1981.458, y = 0.638, label = \"UCD\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.116, y = 0.912, label = \"VOX\"), \n    mapping = aes(x = x, y = y, label = label), \n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1986.226, y = 0.912, label = \"Alianza \\n Popular\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1989.632, y = 0.850, label = \"Coalición \\n Popular\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2011.771, y = 0.7889, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1997.00, y = 0.788, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1982.820, y = 0.19, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2005.130, y = 0.310, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1994.571, y = 0.15, label = \"IU\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1979.2, y = 0.1, label = \"PCE\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2021.989, y = 0.3, label = \"Sumar\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, angle = 30L, colour = \"white\", \n    fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2015.177, y = 0.23, \n                      label = \"Podemos y \\n confluencias\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2019.321, y = 0.465, label = \"Más País\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2019.4, xend = 2019.4, y = 0.41, yend = 0.39, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 1987.078, y = 0.381, label = \"CDS\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", fontface = 2, inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1987.2, xend = 1987.2, y = 0.43, yend = 0.50, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1978.1, y = 0.15, label = \"Unidad \\n Socialista\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 1978.1, xend = 1978.1, y = 0.2, yend = 0.25, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 2016.938, y = 0.65, label = \"Ciudadanos\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, angle = -105L, colour = \"white\", \n    fontface = 2, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 2010.388, y = 0.343, label = \"UPyD\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 2010.388, xend = 2010.388, y = 0.41, yend = 0.475, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1989, y = 0.139, \n                      label = \"PNV \\n Herri Batasuna\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, hjust = 0L, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1988.6, xend = 1988.6, y = 0.05, yend = 0.12, \n           color = \"white\", size = 0.1) +\n  annotate(\"segment\", x = 1989.5, xend = 1989.5, y = 0.043, yend = 0.12, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 1998.173, y = 0.192, label = \"Coalición Canaria\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, hjust = 0L, colour = \"white\", inherit.aes = FALSE) +\n  annotate(\"segment\", x = 1998.18, xend = 1998.18, y = 0.024, yend = 0.17, \n           color = \"white\", size = 0.1) +\n  geom_text(\n    data = data.frame(x = 2004.546, y = 0.166, label = \"ERC\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2004.65, xend = 2004.65, y = 0.06, yend = 0.13, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 2017.8, y = 0.16, \n                      label = \"Junts \\n ERC \\n PNV \\n Bildu\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)+\n  annotate(\"segment\", x = 2016.6, xend = 2016.6, y = 0.055, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2017.4, xend = 2017.4, y = 0.048, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2018.2, xend = 2018.2, y = 0.03, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  annotate(\"segment\", x = 2019, xend = 2019, y = 0.02, yend = 0.12, \n           color = \"white\", size = 0.1)+\n  geom_text(\n    data = data.frame(x = 1992.154, y = 0.1, label = \"CiU\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.5, colour = \"white\", inherit.aes = FALSE)\n\ngraph\n\n\n\nX and Y axes\nFollowing that, annotations related to the X and Y axes were established, since they had a specific format that wasn’t available in any predefined theme.\n\n\ngraph <- graph + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 2023.556, \n                      ymin = -0.06, ymax = -0.06),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.67, xmax = 2024.67, ymin = 0, ymax = 1),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.4, xmax = 2024.67, ymin = 0, ymax = 0), \n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 2024.4, xmax = 2024.67, ymin = 1, ymax = 1), \n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#6A6A6A\", fill = \"#6A6A6A\", alpha = 0.25, inherit.aes = FALSE)\n\ngraph\n\n\n\nThird Axis: Presidencies\nThe third axis, parallel to the Y-axis, was crafted using annotations. This axis informs about the succession of presidencies over the years, and was done by connecting points with segments and specifying the president’s name and their affiliated party.\n\n\ngraph <- graph + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 1980.5, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1977.425, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1980.5, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  geom_rect(\n    data = data.frame(xmin = 1981, xmax = 1982.322, ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1981, y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1982.322 , y = 1.059, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 1982.822, xmax = 1995.669, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1982.822, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 1995.669 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1996.169, xmax = 2003.699, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1996.169, y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2003.699 , y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2004.199, xmax = 2011.385, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2004.199, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2011.385 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2011.885, xmax = 2018.821, \n                      ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2011.885, y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2018.821 , y = 1.059, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2019.321, xmax = 2023, ymin = 1.059, ymax = 1.059),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2019.321, y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2023 , y = 1.059, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  geom_text(\n    data = data.frame(x = 1978.5, y = 1.094, label = \"Adolfo\\nSuárez\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.532, y = 1.1, \n                      label = \"Leopoldo\\nCalvo-Sotelo\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1988.61, y = 1.1, label = \"Felipe\\nGonzález\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1999.235, y = 1.1, label = \"José María\\nAznar\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2007.202, y = 1.1, \n                      label = \"José Luis\\nRodríguez\\nZapatero\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2014.991, y = 1.1, label = \"Mariano\\nRajoy\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.833, y = 1.1, label = \"Pedro\\nSánchez\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.23, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)\n\ngraph \n\n\n\nLegend\nLastly, since the colors of each stream had to be manually defined, there wasn’t an automated way for R to show the color transitions based on the ideological orientation in which the parties of the graph are organized. To mimic these color transitions in the legend, I assembled small squares representing the colors I used.\n\n\ngraph <- graph +  \n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.06, ymax = -0.05),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#650904\", alpha = 1, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.05, ymax = -0.04),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#A61918\", alpha = 1 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.04, ymax = -0.03),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#9B2E33\", alpha = 0.9, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.03, ymax = -0.02),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#BE4D4C\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.02, ymax = -0.01),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#D07F7F\", alpha = 0.7, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = -0.01, ymax = 0),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E2706D\", alpha = 0.4, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.01, label = \"Izquierda\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.15, ymax = 0.17),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#C98B2C\", alpha = 1, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.17, ymax = 0.19),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E89433\", alpha = 1 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.19, ymax = 0.21),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#E6A55B\", alpha = 0.9, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.22, label = \"Centro\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.34, ymax = 0.37),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#1F3D71\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.37, ymax = 0.40),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#4D76BF\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.41, label = \"Derecha\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.7, hjust = 0L, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.55, ymax = 0.58),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#DDAB0B\", alpha = 0.8, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.58, ymax = 0.61),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#EAC659\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.62, label = \"Partidos\\ncatalanes\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE) +\n  geom_rect(data = data.frame(xmin = 1975.4, xmax = 1976, \n                              ymin = 0.76, ymax = 0.78),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#46862C\", alpha = 0.7, inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.78, ymax = 0.8),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#A1B944\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.8, ymax = 0.82),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#ABD894\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.83, label = \"Partidos\\nvascos\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE) +\n  geom_rect(\n    data = data.frame(xmin = 1975.4, xmax = 1976, ymin = 0.95, ymax = 0.98),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    fill = \"#3B3D40\", alpha = 0.9 , inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1975.6, y = 0.99, \n                      label = \"Otros partidos\\nregionales\"),\n    mapping = aes(x = x, y = y, label = label),\n    colour = \"#6A6A6A\", size = 1.5, hjust = 0L, inherit.aes = FALSE)\n\ngraph\n\n\n\nA different representation of the data\nLimitations of the original graph\nGeom_streams are a very eye-catching option and, truth be told, the chosen plot it is a quite good representation of the data meant for graphical visualization. However, a limitation I would like to highlight is that it seems that the beauty of the composition is put before the accuracy of the data. For example, if we take a look in the original graph to the emergence of the parties that appeared in the last decade we see how:\nVox seems to gradually appear in the congress since 2016 in the geom_streams plot, when in reality, it gained parliamentary representation in 2019.\nSimilarly, SUMAR gained parliamentary seats in 2023, yet in the plot, it seems to have been present in the congress since 2019.\nIn the same way, Podemos gained representation in 2014, not 2011.\nAlternative graph\nTo counteract these discrepancies, I opted for an alternative representation using a line graph. While it might lack the visual appeal of geom_streams, it offers a more accurate portrayal. This line graph provides exact deputy counts for each party, accurately displaying the appearance and disappearance of parties over time.\nThe previous graph showcased the constant number of seats secured by regional parties over the years studied. To ensure clarity and concentrate on parties taking turns in power, regional parties were deliberately excluded to eliminate unnecessary noise. This strategy focuses attention on parties that alternate in power, enabling a more streamlined analysis of the evolving trends in bipartisanship over the years.\n\n\n#Selected parties\npartidos_seleccionados <- c(\"VOX\", \"PP\", \"Cs\", \"UCD\", \"CDS\", \"UPyD\",\n                            \"US\", \"PSOE\", \"SUMAR\", \"PODEMOS\",  \"PCE\",\n                            \"Más País\", \"IU\")\n\ngraph_base_filtered <- graph_base |> \n  filter(recat %in% partidos_seleccionados)\n\n#Alternative graph\np<- ggplot(graph_base_filtered, aes(DECIMAL_DATE, total_deputies)) +\n  scale_x_continuous(breaks = fechas_unicas, \n                     labels = function(x) floor(x), \n                     expand = c(0,0)) +\n  scale_y_continuous(breaks = c(176), \n                     expand = c(0,0), \n                     name = \"Diputados\") +\n  geom_line(aes(color = recat), linewidth = 1.5) +\n  labs(x = \"\", y = \"\", fill = \"Orientación ideológica\",\n       title = \"**Evolución del bipartidismo en la democracia española**\",\n       subtitle = \"**Composición del Congreso (1977-2023)**\",\n       caption = paste(\"**Autora:**\", \"Candela Gómez Blanco (2023)\", \n                       sep = \"<br>\")) +\n  theme(\n    plot.title = ggtext::element_markdown(size = 13, color = \"#272727\"),\n    plot.subtitle = ggtext::element_markdown(size = 11, color = \"#6A6A6A\"),\n    plot.caption = ggtext::element_markdown(size = 5, color = \"#6A6A6A\"),\n    axis.text.x = element_text(angle = 90, hjust = 1),\n    axis.ticks.y = element_line(color = \"#272727\"), \n    axis.text.y = element_text(color = \"#272727\"),\n    plot.background = element_rect(color = \"white\", fill = \"white\"),\n    axis.title.x = element_blank(),\n    axis.title.y = element_text(size = 8, color = \"#6A6A6A\"),\n    legend.position = \"none\",\n    panel.background = element_rect(fill = \"white\", color = \"white\")) +\n  scale_color_manual(\n    values = c(\n    \"VOX\" = \"#4D76BF\", \"PP\" = \"#4D76BF\", \"Cs\" = \"#FFC38D\", \"UCD\" = \"#FFC38D\",\n    \"CDS\" = \"#FFC38D\", \"UPyD\" = \"#FFC38D\", \"US\" = \"#E2706D\", \"PSOE\" = \"#E2706D\",\n    \"SUMAR\" = \"#E2706D\", \"PODEMOS\" = \"#E2706D\", \"PCE\" = \"#E2706D\", \n    \"Más País\" = \"#650904\", \"IU\" = \"#E2706D\")) +\n  coord_cartesian(\n    xlim = c(1977.452, 2029), \n    ylim = c(0, 280), \n    clip = \"off\") \n\np\n\n\n\nAnnotations\nLabels\nUsing ggannotate once again, annotations for all the selected parties were included, ensuring the text and segments retain consistent colors in order to prevent confusion\n\n\n#ggannotate(p)\n\np <- p + \n  geom_rect(\n    data = data.frame(xmin = 1977.718, xmax = 1977.718, \n                      ymin = 7.363, ymax = 32.993),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 1978.232, y = 48.203, \n    label = \"US\"), mapping = aes(x = x, y = y, label = label), \n    inherit.aes = FALSE, colour = \"#BE4D4C\")+\n  geom_rect(\n    data = data.frame(xmin = 1981.237, xmax = 1981.237, \n                      ymin = 10.19, ymax = 50.103),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.16, y = 62.457, label = \"PCE\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1991.669, xmax = 1991.669, \n                      ymin = 19.694, ymax = 40.6),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1991.589, y = 48.203, label = \"IU\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\")+\n  geom_rect(\n    data = data.frame(xmin = 2013.289, xmax = 2016.063, \n                      ymin = 71.01, ymax = 71.01),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2008.1, y = 71.96, label = \"Podemos y confluencias\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2012.595, xmax = 2015.754, \n                      ymin = 38.7, ymax = 38.7),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2009.899, y = 39.65, label = \"Ciudadanos\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 2012.441, xmax = 2018.836, \n                      ymin = 28.246, ymax = 28.246),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2010.746, y = 27.296, label = \"VOX\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 1978.0, xmax = 1978.0, \n                      ymin = 173.485, ymax = 193.44),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1978.5, y = 204.053, label = \"UCD\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\" ) +\n  geom_rect(\n    data = data.frame(xmin = 1986.785, xmax = 1986.785, \n                      ymin = 188.848, ymax = 211.655),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1986.707, y = 217.357, label = \"PSOE\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2000.037, xmax = 2000.037, \n                      ymin = 190.749, ymax = 205.953),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1999.96, y = 214.348, label = \"PP\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 1987.94, xmax = 1987.94, \n                      ymin = 19.694, ymax = 43.45),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 0.25, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1987.863, y = 51.054, label = \"CDS\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\") +\n  annotate(\n    \"curve\", x = 2008.3 , y = 3  , xend = 2001 , yend = 40 , \n    color = \"#E6A55B\", curvature = -0.2, \n    arrow = arrow(length = unit(0.01, \"npc\"), angle = 20, type = \"closed\")) +\n  geom_text(\n    data = data.frame(x = 2000.459, y = 47.849, label = \"UPyD\"),\n    mapping = aes(x = x, y = y, label = label),\n    inherit.aes = FALSE, colour = \"#E6A55B\")\n\np\n\n\n\nPresidencies axis\nI opted to retain the axis relative to the presidencies of the original axis, as it provides pertinent information that I didn’t want to lose. I simply adjusted the coordinates appropriately to visualize it horizontally.\nMoreover, these segments were utilized as a legend to keep the graph as uncluttered as possible.\n\n\n#Presidencies axis\np <- p + \n  geom_rect(\n    data = data.frame(xmin = 1977.425, xmax = 1980.5, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1977.425, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1980.5, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  geom_rect(\n    data = data.frame(xmin = 1981, xmax = 1982.322, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#E6A55B\", fill = \"#E6A55B\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1981, y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\")+\n  annotate(\"point\", x = 1982.322 , y = 260, shape = 21, size = 1, \n           colour = \"#E6A55B\", fill = \"#E6A55B\") +\n  geom_rect(\n    data = data.frame(xmin = 1982.822, xmax = 1995.669, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1982.822, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 1995.669 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 1996.169, xmax = 2003.699, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 1996.169, y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2003.699 , y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2004.199, xmax = 2011.385, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2004.199, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2011.385 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\") +\n  geom_rect(\n    data = data.frame(xmin = 2011.885, xmax = 2018.821, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#4D76BF\", fill = \"#4D76BF\", alpha = 1, size = 0.75,\n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2011.885, y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\")+\n  annotate(\"point\", x = 2018.821 , y = 260, shape = 21, size = 1, \n           colour = \"#4D76BF\", fill = \"#4D76BF\") +\n  geom_rect(\n    data = data.frame(xmin = 2019.321, xmax = 2023, ymin = 260, ymax = 260),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"#BE4D4C\", fill = \"#BE4D4C\", alpha = 1, size = 0.75, \n    inherit.aes = FALSE)+\n  annotate(\"point\", x = 2019.321, y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  annotate(\"point\", x = 2023 , y = 260, shape = 21, size = 1, \n           colour = \"#BE4D4C\", fill = \"#BE4D4C\")+\n  geom_text(\n    data = data.frame(x = 1978.5, y = 250, label = \"Adolfo\\nSuárez\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1981.3, y = 250, \n                      label = \"Leopoldo\\nCalvo-Sotelo\\n(UCD)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#E6A55B\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 1988.613, y = 250, \n                      label = \"Felipe\\nGonzález\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE)+\n  geom_text(\n    data = data.frame(x = 1999.235, y = 250, label = \"José María\\nAznar\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2007.202, y = 248, \n                      label = \"José Luis\\nRodríguez\\nZapatero\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2014.991, y = 250, label = \"Mariano\\nRajoy\\n(PP)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#4D76BF\", hjust = 0L, inherit.aes = FALSE) +\n  geom_text(\n    data = data.frame(x = 2020.833, y = 250, label = \"Pedro\\nSánchez\\n(PSOE)\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 1.75, colour = \"#BE4D4C\", hjust = 0L, inherit.aes = FALSE) \n\np\n\n\n#Legend\n\np <- p + \n  geom_text(\n    data = data.frame(x = 1978.847, y = 266.886, label = \"Centro\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE, colour = \"#6A6A6A\") +\n  geom_text(\n    data = data.frame(x = 1989.169, y = 265.925, label = \"Izquierda\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE,  colour = \"#6A6A6A\")+\n  geom_text(\n    data = data.frame(x = 1999.975, y = 265.925, label = \"Derecha\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE, colour = \"#6A6A6A\")\n\np\n\n\n\nRelevant milestones\nFinally, I decided to include annotations pointing specific important events that, when reading the article, stand out prominently.\nThis line graph distinctly showcases the shifts between the right and left since the 90s and allow us to visualize the emergence of other parties in 2015. As detailed in the article, this pivotal juncture marked the end of the prevailing two-party model, culminating in the establishment of the first coalition government in Spanish democracy in 2020.\nAdditionally, a horizontal line indicating the 176 deputies, the minimum required for an absolute majority, has been included. Every party surpassing this threshold managed to govern independently.\n\n\np <- p +\n  geom_rect(\n    data = data.frame(xmin = 2015, xmax = 2015, ymin = 0, ymax = 240),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE,\n    linetype = \"dashed\") +\n  geom_text(\n    data = data.frame(x = 2015.136, y = 214.048, \n                      label = \"Ruptura del bipartidismo\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE) +\n   geom_rect(\n     data = data.frame(xmin = 2020, xmax = 2020, ymin = 200, ymax = 240),\n     mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n     colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE,\n     linetype = \"dashed\") +\n  geom_text(\n    data = data.frame(x = 2020.2, y = 190, \n                      label = \"Primer gobierno\\n de coalición\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE) +\n  geom_rect(\n    data = data.frame(xmin = 1977.452, xmax = 2023, ymin = 176, ymax = 176),\n    mapping = aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n    colour = \"black\", fill = \"grey55\", alpha = 0.25, inherit.aes = FALSE)+ \n  geom_text(\n    data = data.frame(x = 2024.652, y = 177.382, label = \"Mayoría\\nabsoluta\"),\n    mapping = aes(x = x, y = y, label = label),\n    size = 3.35, inherit.aes = FALSE)\n\np\n\n\n\n\n\n\n",
    "preview": "projects/2023/100516517/100516517_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2024-01-23T18:19:31+01:00",
    "input_file": {},
    "preview_width": 672,
    "preview_height": 1248
  },
  {
    "path": "projects/2023/100505771/",
    "title": "Mexico's Export Dynamics from 1996 to 2020 by Sector",
    "description": "Replication and alternative version of the over time graph sector exports of Mexico by the Growth Lab at Harvard University.",
    "author": [
      {
        "name": "Valeria Contreras",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nReplica\nEnhacement\nConclusion\n\nIntroduction\nThe Atlas of Economic Complexity, developed by the Growth Lab at Harvard University, introduced a comprehensive profile of countries in the year 2019. Where users are invited to embark enter on an interactive exploration, navigating through the economic structures and growth dynamics of over 130 nations. Within this context, our focus turns to México, where we start our visual journey through its economic landscape, observing the details of export dynamics across diverse sectors in the previous years.\nThis tutorial aims to replicate the existing graph and present an alternative visualization using the identical dataset.\nOriginal graph from the Atlas of Economic Complexity.The x-axis represents the timeline from 1996 to 2020, offering a chronological journey through the years. Meanwhile, the y-axis measures the current gross export in billions of dollars, serving as a measure for the economic impact of each sector where each sector is distinguished by a unique color.\nReplica\nStarting with the journey of replication, we start by recreating the above plot and below you will find the complete code along with some insights into the challenges I faced while recreating it.\n\n\nlibrary(ggplot2)\nlibrary(readxl)\nlibrary(dplyr)\nlibrary(ggthemes)\nlibrary(ggstream)\nlibrary(ggrepel)\nlibrary(RColorBrewer)\n\n\nexportmex <- read_xlsx(\"EXPORTS-MEXICO.xlsx\")\n\n\ncolors <-\n  c(\n    \"#b33d6d\",\n    \"#2b607c\",\n    \"#7cdada\",\n    \"#7ba2d9\",\n    \"#8c7ad7\",\n    \"#c47cda\",\n    \"#d87b7a\",\n    \"#bb9689\",\n    \"#dab57c\",\n    \"#f4d025\",\n    \"#7cdaa0\"\n  )\n\nlegend_colors <-\n  c(\n    \"#b33d6d\",\n    \"#7cdaa0\",\n    \"#f4d025\",\n    \"#dab57c\",\n    \"#bb9689\",\n    \"#d87b7a\",\n    \"#c47cda\",\n    \"#8c7ad7\",\n    \"#7ba2d9\",\n    \"#7cdada\",\n    \"#2b607c\"\n  )\n\nsysfonts::font_add_google(\"Noto Sans JP\", family = \"sans-serif\")\n\nexportmex <-\n  exportmex |> mutate(`Current Gross Export` = sub(\"\\\\$\", \"\", `Current Gross Export`))\nCurrent_Gross_Export <- as.numeric(exportmex$`Current Gross Export`)\nyear <- as.numeric(exportmex$Year)\n\n\nexclude_value <- 550\nlabel_positions <- data.frame(\n  Sector = c(\n    \"Agriculture\",\n    \"Minerals\",\n    \"Vehicles\",\n    \"Machinery\",\n    \"Electronics\"\n  ),\n  Position = c(30, 60, 170, 250, 330)\n)\n\n\n\n\nexportmex |> ggplot() +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    breaks = seq(0, 550, 50),\n    labels = function(x) \n      paste0(\"$\", x, \"B\")\n  ) +\n  coord_cartesian(ylim = c(0, exclude_value), expand = FALSE) +\n  scale_x_continuous(\n    name = \" \",\n    breaks = seq(1996, 2020, 2),\n    limits = c(min(exportmex$Year), max(exportmex$Year))\n  ) +\n  scale_fill_manual(values = colors) +\n  geom_stream(aes(fill = Sector),\n              type = \"ridge\",\n              bw = .60,\n              n_grid = 200) +\n  theme_gray() +\n  theme(\n    text = element_text(family = \"sans-serif\"),\n    panel.background = element_rect(fill =  \"#f5f5f5\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey80\", size = .3),\n    axis.ticks.length = unit(0.2, \"cm\"),\n    axis.ticks = element_line(color = \"grey80\", size = .3),\n    plot.margin = margin(l = 5, t = -15),\n    axis.text = element_text(color = \"#616161\"),\n    axis.text.x = element_text(\n      angle = 60,\n      hjust = 1,\n      size = 5,\n      margin = margin(5, 0, 0, 0)\n    ),\n    axis.text.y = element_text(\n      size = 5,\n      family = \"sans-serif\",\n      margin = margin(0, 0, 0, 5)\n    ),\n    axis.title.y = element_text(\n      size = 8,\n      family = \"sans-serif\",\n      color = \"#616161\",\n      margin = margin(r = 1)\n    ),\n    legend.position = \"bottom\",\n    legend.text = element_blank(),\n    legend.spacing.x = unit(0.1, \"cm\"),\n    legend.text.align = 10,\n    legend.box.spacing = unit(1, \"cm\"),\n    legend.key.height = unit(0.35, \"cm\"),\n    legend.key.width = unit(0.35, \"cm\"),\n    legend.title = element_text(color = \"#616161\", size = 6),\n    legend.justification = c(0.3, 0),\n    legend.margin = margin(t = -25)\n  ) +\n  labs(title = \" \",\n       fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) +\n  guides(fill = guide_legend(nrow = 1, override.aes = list(fill = legend_colors))) +\n  geom_text(\n    data = label_positions,\n    aes(x = Inf, y = Position, label = Sector),\n    color = \"#E8E9EB\",\n    angle = ifelse(\n      label_positions$Sector == \"Electronics\",\n      15,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        8,\n        ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n      )\n    ),\n    hjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        2.1,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          5.2,\n          ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n        )\n      )\n    ),\n    vjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      -2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        -.9,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          -5,\n          ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n        )\n      )\n    ),\n    size = ifelse(\n      label_positions$Sector == \"Electronics\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        4,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          3,\n          ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n        )\n      )\n    ),\n    na.rm = TRUE\n  )\n\n\n\nThere were some series of challenged that added both complexity and valuable lessons, to start with, the first challenge was on the current gross export amounts, since the original data set already had the sign “$” and the letter “B” on the numbers, the ggplot didn’t organize well the amounts, I had to remove those characters from the “Current Gross Export” variable and then convert it to number as below,\n\n\nexportmex <-\n  exportmex |> mutate(`Current Gross Export` = sub(\"\\\\$\", \"\", `Current Gross Export`))\nCurrent_Gross_Export <- as.numeric(exportmex$`Current Gross Export`)\n\n\nIn second place, I must mention the sectors, since ggplot2 order alphabetically by default I needed to modify them so I can give them the same order as on the original graph.\n\n\ncolors <-\n  c(\n    \"#b33d6d\",\n    \"#2b607c\",\n    \"#7cdada\",\n    \"#7ba2d9\",\n    \"#8c7ad7\",\n    \"#c47cda\",\n    \"#d87b7a\",\n    \"#bb9689\",\n    \"#dab57c\",\n    \"#f4d025\",\n    \"#7cdaa0\"\n  )\n\n\nAn aesthetic where I invested a lot of time was, setting up the correct angles and direction of each label per sector, I used if else function so I can move the label of each sector separately, I had to be very meticulous on this because if I move the angle the other aesthetics of the label would change, and to set them up exactly as the original plot was a challenge.\n\n\ngeom_text(\n  data = label_positions,\n  aes(x = Inf, y = Position, label = Sector),\n  color = \"#E8E9EB\",\n  angle = ifelse(\n    label_positions$Sector == \"Electronics\",\n    15,\n    ifelse(\n      label_positions$Sector == \"Minerals\",\n      8,\n      ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n    )\n  ),\n  hjust = ifelse(\n    label_positions$Sector == \"Electronics\",\n    2,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      2.1,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        5.2,\n        ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n      )\n    )\n  ),\n  vjust = ifelse(\n    label_positions$Sector == \"Electronics\",\n    -2,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      -.9,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        -5,\n        ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n      )\n    )\n  ),\n  size = ifelse(\n    label_positions$Sector == \"Electronics\",\n    4,\n    ifelse(\n      label_positions$Sector == \"Machinery\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        3,\n        ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n      )\n    )\n  ),\n  na.rm = TRUE\n)\n\n\nThe last thing that was also complicated for me to recreate was the legend, even though I did not put the images as the original plot, I spent a lot of time investigating on how to set up the colors horizontally and just in 1 row, and finally came up with below setting,\n\n\nlabs(title = \" \",\n     fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) + guides(fill = guide_legend(\n       nrow = 1,\n       override.aes = list(fill = legend_colors)\n     ))\n\n\nI adjusted the number of rows within the “guides” function to reflect the changes. Additionally, I redefined the order of the key legend colors, aligning the legend with the same color sequence as in the original plot.\n\n\nlegend_colors <-\n  c(\n    \"#b33d6d\",\n    \"#7cdaa0\",\n    \"#f4d025\",\n    \"#dab57c\",\n    \"#bb9689\",\n    \"#d87b7a\",\n    \"#c47cda\",\n    \"#8c7ad7\",\n    \"#7ba2d9\",\n    \"#7cdada\",\n    \"#2b607c\"\n  )\n\n\nI opted to not include the images in the legend and the arrow in the Y-axis title, as these are interactive elements, they weren’t considered for the replication plot.\nThe curves deviate slightly from those in the original plot. Despite experimenting with the parameters “bw” and “n_grid” in the geom_stream, I couldn’t achieve the exact smoothness of the original plot. Consequently, I changed from geom_stream to geom_area, resulting in the plot shown below,\n\n\nexportmex |> ggplot() +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    breaks = seq(0, 550, 50),\n    labels = function(x)\n      paste0(\"$\", x, \"B\")\n  ) +\n  coord_cartesian(ylim = c(0, exclude_value), expand = FALSE) +\n  scale_x_continuous(\n    name = \" \",\n    breaks = seq(1996, 2020, 2),\n    limits = c(min(exportmex$Year), max(exportmex$Year))\n  ) +\n  scale_fill_manual(values = colors) +\n  geom_area() +\n  theme_gray() +\n  theme(\n    text = element_text(family = \"sans-serif\"),\n    panel.background = element_rect(fill =  \"#f5f5f5\"),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey80\", size = .3),\n    axis.ticks.length = unit(0.2, \"cm\"),\n    axis.ticks = element_line(color = \"grey80\", size = .3),\n    plot.margin = margin(l = 10),\n    axis.text = element_text(color = \"#616161\"),\n    axis.text.x = element_text(\n      angle = 60,\n      hjust = 1,\n      size = 5,\n      margin = margin(5, 0, 0, 0)\n    ),\n    axis.text.y = element_text(\n      size = 5,\n      family = \"sans-serif\",\n      margin = margin(0, 0, 0, 5)\n    ),\n    axis.title.y = element_text(\n      size = 8,\n      family = \"sans-serif\",\n      color = \"#616161\",\n      margin = margin(r = 10)\n    ),\n    legend.position = \"bottom\",\n    legend.text = element_blank(),\n    legend.spacing.x = unit(0.1, \"cm\"),\n    legend.text.align = 10,\n    legend.box.spacing = unit(1, \"cm\"),\n    legend.key.height = unit(0.4, \"cm\"),\n    legend.key.width = unit(0.4, \"cm\"),\n    legend.title = element_text(color = \"#616161\", size = 6),\n    legend.justification = c(0.3, 0)\n  ) +\n  labs(title = \" \",\n       fill = paste(\"PRODUCT\", \"SECTORS\", sep = \"\\n\")) +\n  guides(fill = guide_legend(nrow = 1, override.aes = list(fill = legend_colors))) +\n  geom_text(\n    data = label_positions,\n    aes(x = Inf, y = Position, label = Sector),\n    color = \"#E8E9EB\",\n    angle = ifelse(\n      label_positions$Sector == \"Electronics\",\n      15,\n      ifelse(\n        label_positions$Sector == \"Minerals\",\n        8,\n        ifelse(label_positions$Sector == \"Machinery\", 8, 0)\n      )\n    ),\n    hjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        2.1,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          5.2,\n          ifelse(label_positions$Sector == \"Agriculture\", 3, 1.8)\n        )\n      )\n    ),\n    vjust = ifelse(\n      label_positions$Sector == \"Electronics\",\n      -2,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        -.9,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          -5,\n          ifelse(label_positions$Sector == \"Agriculture\", 0.6, 0.2)\n        )\n      )\n    ),\n    size = ifelse(\n      label_positions$Sector == \"Electronics\",\n      4,\n      ifelse(\n        label_positions$Sector == \"Machinery\",\n        4,\n        ifelse(\n          label_positions$Sector == \"Minerals\",\n          3,\n          ifelse(label_positions$Sector == \"Agriculture\", 2.8, 6)\n        )\n      )\n    ),\n    na.rm = TRUE\n  )\n\n\n\nThe curves closely resemble those of the original plot, although they may lack the same level of smoothness. However, their distinct features are as pronounced as those in the original plot.\nGiven that Geom stream is not perfect, I chose to include both plots in the project. This allows us to observe the replication that most closely aligns with the original plot.\nEnhacement\nAs I aimed to illustrate the evolution of each sector, I transitioned from a stream graph to a geom_area, applying facet wrap to assign each sector to a distinct grid. I originally contemplate a line graph, and reconsidered due to the 11 sectors, realizing it might result in a spaghetti chart, making it visually overwhelming and challenging to interpret. Opting for facet wrap, I allocated a dedicated section to each sector, improving the graphic’s clarity and making it more accessible to recognize individual sector patterns.\n\n\ndisplay.brewer.all()\n\n\nmy_palette <- brewer.pal(11, \"Paired\")\nprint(my_palette)\n\n [1] \"#A6CEE3\" \"#1F78B4\" \"#B2DF8A\" \"#33A02C\" \"#FB9A99\" \"#E31A1C\"\n [7] \"#FDBF6F\" \"#FF7F00\" \"#CAB2D6\" \"#6A3D9A\" \"#FFFF99\"\n\nBelow is the code,\n\n\nexportmex |> ggplot()  +\n  aes(Year, Current_Gross_Export, fill = Sector) +\n  geom_area() +\n  facet_wrap (\n    ~ factor(\n      Sector,\n      levels = c(\n        \"Vehicles\",\n        \"Machinery\",\n        \"Electronics\",\n        \"Minerals\",\n        \"Agriculture\",\n        \"Other\",\n        \"Services\",\n        \"Chemicals\",\n        \"Metals\",\n        \"Textiles\",\n        \"Stone\"\n      )\n    ),\n    scales = \"free_y\",\n    nrow = 3,\n    strip.position = \"top\"\n  ) +\n  theme(strip.background = element_blank(),\n        legend.position = \"none\") +\n  scale_fill_manual(\n    values = my_palette\n  ) +\n  scale_y_continuous(\n    name = \"Current Gross Export\",\n    expand = c(0, 0),\n    labels = function(x)\n      paste0(\"$\", x, \"B\")\n  ) +\n  scale_x_continuous(\n    name = \" Years\" ,\n    breaks = seq(1996, 2020, 6),\n    limits = c(min(exportmex$Year),\n               max(exportmex$Year))\n  ) +\n  ggtitle(\"Export Trends (1996-2020) in Mexico by Sector in Current Gross $ \") +\n  theme(\n    axis.text.y = element_text(\n      size =  5,\n      family = \"sans-serif\",\n      margin = margin(l = 10)\n    ),\n    axis.title.y = element_text(\n      size = 10,\n      family = \"sans-serif\",\n      color = \"#616161\"\n    ),\n  ) +\n  theme(\n    legend.position = \"none\",\n    strip.text = element_text(size = 10, family = \"sans-serif\"),\n    axis.ticks = element_line(color = \"grey80\"),\n    plot.margin = margin (l = 10, b = 8, t = 10),\n    plot.title = element_text(\n      face = \"bold\",\n      hjust = 0,\n      size = 11,\n      vjust = 3\n    ),\n    axis.text.x = element_text(margin = margin(b = 10), size = 5)\n  )\n\n\n\nFirstly, my goal was to change the color palette of the original graph, as certain colors give challenges for individuals with color blindness. I discovered the “Viridis” library in R, which allows us to implement a colorblind-friendly palette. This palette became the foundation for the enhanced graph. It’s essential to consider inclusivity in data visualization since color plays an important role. By accommodating color-blind individuals, we expand our audience and amplify the impact of our work.\n\n\nlibrary(RColorBrewer)\nmy_palette <- brewer.pal(11, \"Paired\")\nprint(my_palette)\n\nscale_fill_manual(\n  values = my_palette)\n\n\nSecondly, I arranged each sector in descending order based on their current gross export values. This deliberate arrangement places the sector with the highest current gross export impact at the top left, gradually descending to the sector with the lowest impact at the bottom right. The objective behind this strategic organization is to offer readers a more structured and intuitive visualization of the data.\nTo achieve this, I employed a systematic approach by establishing specific levels for the “Sector” variable and ordering them according to the desired organization, as mentioned earlier. The relevant code part for this configuration is provided below,\n\nfacet_wrap ( ~ factor(\n  Sector,\n  levels = c(\n    \"Vehicles\",\n    \"Machinery\",\n    \"Electronics\",\n    \"Minerals\",\n    \"Agriculture\",\n    \"Other\",\n    \"Services\",\n    \"Chemicals\",\n    \"Metals\",\n    \"Textiles\",\n    \"Stone\"\n  )\n)\n\nConclusion\nIn the journey of replicating the existing graph, I navigated through data and visualization challenges, where tested my analytic and coding skills, ultimately, I’m proud of the progress made on ggplot2 and R. The replica thought me how to handle complex data sets to address them into a visual representation and to critically evaluate the choices of the creators so I could improve the graph according to my criteria, and for the enhancement, I provide an illustrate representation of my intended improvement representing the Current Gross Export for each sector over the years with spontaneity and clarity of each sector.\nAnd lastly, I would like to thank Iñaki for all the help I receive to be able to recreate this plot and to learn all about ggplot2.\n\n\n\n",
    "preview": "projects/2023/100505771/100505771_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2023/100506380/",
    "title": "The Phenomenon of Poverty",
    "description": "Visualizing the global distribution of disposable income between 1990 and 2019- Our World in Data.",
    "author": [
      {
        "name": "Frederick Peña-Sims",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nThe original graph\n\nGetting the data right\nPackages\nGetting the data\nCleaning the data\n\nBuilding the graph\nThe theme\nLabeling the Axes\nFilling the plot\nLabeling the… Labels\nWhat’s the name again?\nLimitations\n\nIs there a better way?\nInitial idea\nFocusing on development\nAdapting the theme\nCreating the alternative plot\nGive it a title…\nand make it move\n\n\nIntroduction\nPoverty is a longstanding issue of known human societies ingrained into the logic of ‘Capital and Ideology’. Be it out of colonial motivation, the United Nations, after the great catastrophe that was the second world war, set out its aim to diminish poverty globally and is now prominently presented as the first of 17 Sustainable Development Goals for 2030. While progress has been made, the Covid-19 pandemic, certainly, undid previously made progress. This project takes a look at the historical development of global distribution of the population between different poverty thresholds.\nThe original graph\nThe original graph can be found on the web page of Our World in Data. It, visually, portrays how daily disposable income has been globally distributed between 1990 and 2019. One major strength of this graph is that, at a glance, one is able to see, tentatively, historical developments of each disposable income bracket in relation to each other.\nOriginal chart from Our World in Data.Getting the data right\nPackages\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(gganimate)\nlibrary(forcats)\nlibrary(ggrepel)\n\n\nGetting the data\nThe data is easily accessible under the integrated download button below the graph on the previously indicated web page of Our World in Data.\n\n\ndata_raw <- read.csv(\"data/distribution-of-population-between-different-poverty-thresholds-up-to-30-dollars.csv\")\ndata_raw <- as_tibble(data_raw)\n\n\nCleaning the data\nA first step, I cleaned the data adhering to the tidy data principle that one variable should be stored in one column. To achieve that, the pivot_longer command is used. Before, the previous column names are renamed to render them more intuitive to understand. Finally, we end up with to new columns, ‘disp_inc’ expressing the classification of the poverty threshold (daily disposable income) and ‘am_people’ allocating the amount of people.\n\n\nsum(is.na(data_raw))\n\n[1] 0\n\ndata <-\n  data_raw |> \n  rename(\n    b_40_dollars_and_more = X.40...total.number.of.people.above.poverty.line,\n    b_30_40_dollars = X.30..40...total.number.of.people.between.poverty.lines,\n    b_20_30_dollars = X.20..30...total.number.of.people.between.poverty.lines,\n    b_10_20_dollars = X.10..20...total.number.of.people.between.poverty.lines,\n    b_6.85_10_dollars = X.6.85..10...total.number.of.people.between.poverty.lines,\n    b_3.65_6.85_dollars = X.3.65..6.85...total.number.of.people.between.poverty.lines,\n    b_2.15_3.65_dollars = X.2.15..3.65...total.number.of.people.between.poverty.lines,\n    b_1_2.15_dollars = X.1..2.15...total.number.of.people.between.poverty.lines,\n    below_1_dollar = X.1...total.number.of.people.below.poverty.line) |> \n  pivot_longer(cols = 4 :12,\n               names_to = \"disp_inc\",\n               values_to = \"am_people\") \n\n\nAs the final graph is based on the ‘natural’ order of the poverty thresholds, this logic must be replicated in the data. As such, the variable on (daily) disposable income is reverted into an ordered factor variable, with specified levels.\n\n\ndata <-\n  data |> \n  mutate(disp_inc = factor(disp_inc, \n                           levels = c(\n                             \"b_40_dollars_and_more\",\n                             \"b_30_40_dollars\",\n                             \"b_20_30_dollars\",\n                             \"b_10_20_dollars\",\n                             \"b_6.85_10_dollars\",\n                             \"b_3.65_6.85_dollars\",\n                             \"b_2.15_3.65_dollars\",\n                             \"b_1_2.15_dollars\",\n                             \"below_1_dollar\"),ordered = T))\n\n\nFinally, the original data set contains data not only on the global scale but also per country and even sometimes on the sub-country level. As such, only the data pertaining to the entity ‘World’ is kept in the final data set.\nNote, that a lot of country level data is missing for a considerable amount of years. This will be of great importance when an alternative graph is proposed.\n\n\ndata_world <-\n  data |> \n  filter(Entity == \"World\") |> \n  mutate(Year = as.numeric(Year),\n         am_people = as.numeric(am_people))\n\n\nBuilding the graph\nThe theme\nA major part of this graph is Our World in Data’s distinctive theme. To replicate the theme, I developed my own theme function based on the theme ‘minimal’, allowing me to easily draw the required plot background. Using the ‘%+replace%’ function, I allowed myself to easily change the base theme manually. The entire function code is provided down below. Bits and pieces of the function code were added throughout the coding process.\n\n\ntheme_owid <- function(){ \n  font <- \"Etoile\"   \n  \n  theme_minimal() %+replace%    \n    \n    theme(\n      panel.grid.minor = element_blank(),\n      panel.grid.major = element_blank(),\n      \n      axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"),\n      axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11),\n      axis.text.y = element_text(size = 11,\n                                 vjust = 0.5),\n      \n      legend.position = \"none\",\n      \n      plot.title = element_text(size = 16, \n                                hjust = 0,\n                                color = \"#444444\"),\n      plot.title.position = \"plot\",\n      plot.subtitle = element_text(size = 9.5,\n                                   color = \"grey\",\n                                   hjust = 0,\n                                   margin = margin(b = 20, t = 2.5)), \n      plot.caption = element_text(hjust = 0, \n                                  margin = margin(t = 20),\n                                  size = 8.5),\n      plot.caption.position = \"plot\",\n      \n      plot.margin = margin(t = 5, r = 5, b = 5, l = 5)\n      \n    )\n}\n\n\nThe preliminary theme function was based on the subsequent lines of code. First, all lines (called grid), part of the original theme are redacted with the command ‘element_blank()’. Subsequently, the x-axis ticks were adjusted in size and color, and the x-axis labels were assigned there correct position. The legend was disbanded as labels will replace it subsequently.\n\ntheme(\n      panel.grid.minor = element_blank(),\n      panel.grid.major = element_blank(),\n      \n      axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"),\n      axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11),\n      axis.text.y = element_text(size = 11),\n      \n      legend.position = \"none\")\nThe final theme background is accomplished by manually creating grid lines with the ‘geom_segment’ argument. To encompass the subsequent incorporation of the labels, the ‘coord_cartesian’ function extends the plot space to the imaginative x-axis spot 2025. With the application of the theme function and the removal of the axes labels, the subsequent basic structure is attained.\n\n\np <- \n  ggplot() +\n  coord_cartesian(xlim= c(1990, 2029), expand = T) +\n  geom_segment(aes(x = 1990, xend = 2019, y = 0, yend = 0),\n               linetype = \"solid\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 1000000000, yend = 1000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 2000000000, yend = 2000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 3000000000, yend = 3000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 4000000000, yend = 4000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 5000000000, yend = 5000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 6000000000, yend = 6000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 7000000000, yend = 7000000000),\n               linetype = \"dashed\", color = \"grey\") +\n  theme_owid() +\n  labs(x = NULL,\n       y = NULL)\np\n\n\n\nLabeling the Axes\nQuite obviously, the axes labeling is skewed (look at the ‘2020’), badly positioned (the space between x-axis labels and the actual x-axis), and simply illegibly labeled (y-axis labels). The subsequent code rectifies these issues.\n\n\np <-    \n  p +\n  scale_x_continuous(breaks = c(1990, 1995, 2000, 2005, 2010, 2015, 2019),\n                     expand= c(0, 0)) +\n  scale_y_continuous(breaks = c(0, 1000000000, 2000000000, 3000000000,4000000000\n                                ,5000000000, 6000000000, 7000000000, 8000000000),\n                     labels = c(\"0\", \"1 billion\", \"2 billion\", \"3 billion\", \n                                \"4 billion\",\"5 billion\", \"6 billion\",\n                                \"7 billion\", \"8 billion\"),\n                     expand = c(0, 0)) \np\n\n\n\nAs can be seen on the x-axis, the labels ‘2000’ and ‘2019’ were adjusted concerning their placement relative to the x-axis tick. For this the subsequent code was used, manually setting the positioning of the x-axis labels.\ntheme(axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 0.5, 0.5, 0.5, 1),\n                                 size = 11))\nFilling the plot\nFINALLY, it is time to fill the plot. I use the ‘geom_area’ function to create a stacked plot with filled areas. The areas are stacked according to the levels assigned to each category of disposable income in the data cleaning procedure. The colors of the areas were manually set according to the colors in the original plot. Also, the areas are slightly transparent, also replicated in this code (‘alpha = 0.8’).\n\n\np <-    \n  p + \n  geom_area(data = data_world,\n            aes(x = Year, y = am_people, group = disp_inc, fill = disp_inc),\n            alpha = 0.85) +\n  scale_fill_manual(values = c(b_40_dollars_and_more = \"#6494c5\",\n                               b_30_40_dollars = \"#7cb4d5\",\n                               b_20_30_dollars = \"#b3d7e8\",\n                               b_10_20_dollars = \"#deecf4\",\n                               b_6.85_10_dollars = \"#fafafa\",\n                               b_3.65_6.85_dollars = \"#fee6d8\",\n                               b_2.15_3.65_dollars= \"#f7bfa7\",\n                               b_1_2.15_dollars = \"#e39083\",\n                               below_1_dollar = \"#ca5e6b\")) \np\n\n\n\nLabeling the… Labels\nNow onto the labels. These gave me the biggest problems. First and foremost, aligning labels with their correct position in the plot was a mess to say the least. Either the labeling was bunched up in the bottom right indicating where each area would end as if they were not stacked or labels were inverted, were the lowest category ‘below 1$ a day’ was displayed at the top of the plot. Both these problems were solved within the geom_text_repel function delineating the ‘y =’ option. After subsetting the data set to only values for the year 2019, the aes function provides information on the labels properties. To label each area correctly, I had to create the total sum of people from which I would subtract the accumulated sum of the variable ‘am_people’. As the original labeling was inverted this would correct this initial malfunction. Furthermore, labels were supposed to be ‘attached’ to the middle of the geom_area. To solve this issue, the previously described score was combined (through addition) with the mathematical expression halving the amount of people variable. Label names were adjusted within a ‘case_when’ function and nudged so they do not overlap. Unfortunately, I was not able to recreate the exact shape and arrangement of the labels and their according lines.\n\n\ndata_world_2019 <-   \n  data_world |>    \n  filter(Year == 2019)\n\ntotal_sum_people <- sum(data_world_2019$am_people)\n\n\n\n\np <-   \n  p +\n  geom_text_repel(data = filter(data_world, Year == 2019),\n                  aes(x = Year,\n                      y = total_sum_people - cumsum(am_people) + 0.5 * am_people,\n                      label = case_when(\n                        disp_inc == \"b_40_dollars_and_more\" ~ \"above $40 a day\",\n                        disp_inc == \"b_30_40_dollars\" ~ \"$30-$40 a day\",\n                        disp_inc == \"b_20_30_dollars\" ~ \"$20-$30 a day\",\n                        disp_inc == \"b_10_20_dollars\" ~ \"$10-$20 a day\",\n                        disp_inc == \"b_6.85_10_dollars\" ~ \"$6.85-$10 a day\",\n                        disp_inc == \"b_3.65_6.85_dollars\" ~ \"$3.65-$6.85 a day\",\n                        disp_inc == \"b_2.15_3.65_dollars\" ~ \"$2.15-$3.65 a day\",\n                        disp_inc == \"b_1_2.15_dollars\" ~ \"$1-$2.15 a day\",\n                        disp_inc == \"below_1_dollar\" ~ \"below $1 a day\",\n                        TRUE ~ disp_inc),\n                      color = disp_inc),\n                  direction = \"y\",\n                  nudge_x = 3,  \n                  size = 3.25,\n                  vjust = 0,\n                  hjust = 0,\n                  segment.size = 0.5,\n                  segment.linetype = \"solid\",\n                  segment.color = \"grey\") +\n  scale_color_manual(values = c(b_40_dollars_and_more = \"#2f6cad\",\n                                b_30_40_dollars = \"#4c9ac7\",  \n                                b_20_30_dollars = \"#80abc3\", \n                                b_10_20_dollars = \"#afb3bd\", \n                                b_6.85_10_dollars = \"#bdb5b5\",\n                                b_3.65_6.85_dollars = \"#c1aea7\",\n                                b_2.15_3.65_dollars= \"#d39393\", \n                                b_1_2.15_dollars = \"#e39083\", \n                                below_1_dollar = \"#ca5e6b\")) \np\n\n\n\nWhat’s the name again?\nI added labels with ‘labs’ function. I was unable to create three different captions with varying text sizes.\n\n\np <-   \n  p +\n  theme_owid() +\n  labs(title = \"Distribution of population between different poverty\\nthresholds, World, 1990 to 2019\",\n       subtitle = \"This data is adjusted for inflation and for differences in the cost of living between countries.\",\n       caption = paste(\"Data source: World Bank Poverty and Inequality Platform (2022) – Learn more about\", \n                       \"this data\\nNote: This data is expressed in international-$ at 2017 prices.\", \n                       \"Depending on the country and year,\\nit relates to income measured after\", \n                       \"taxes and benefits, or to consumption, per capita.\\nOurWorldInData.org/poverty | CC BY\"))\np\n\n\n\nLimitations\nAs already pointed out, a key limitation of my graph are the labels that are not perfectly replicated concerning their position and the shape of the lines. Moreover, the website allows to dynamically look at the changing distribution over time, from 1990 to 2019. I was not able to recreate this function. However, the benefit of this visualization is also very limited due to the lack of information one can draw from it because of the ‘free’ x-axis.\nIs there a better way?\nInitial idea\nInstead of differently visualizing the given data, I wanted to use additional data to tell a different story. The story I wanted to tell is closely linked to Lakner and Milanovic’ (2013) working paper (found here), the first contribution visualizing the so called elephant curve. It show per capita income growth for every income percentile globally. One of the main takeaways is the accelerated growth for the lower global middle class, stagnation for the upper global middle class, and exponential growth for the global elite. Concerning the first, Lakner and Milanovic already pointed out the driving force India and China played in propelling millions out of poverty and into accelerated income growth in the lower global middle class. Piggy backing on these findings, I wanted to visually incorporate data for India and China into the visualization, distinguishing the proportion for every disposable income category. As such, one could see the contribution of China and India to the developments. Unfortunately, both, data for China and India is very limited in the data set for multiple years.\nFocusing on development\nAs my initial idea for an alternative was not possible, I wanted to focus on improving the alternative graph provided by Our World in Data. Their alternative uses facets to portray the development of every metric over time. The underlying notion is that developments over time become more apparent, as developments in a stacked graph are less palpable for the spectator. This is also why I decided against a distributive stacked graph, where areas are defined by the share they make up at point x.\nHowever, Our World in Data’s version has some shortcomings. First, there is no scale on the y-axis of each of the facets. This renders it more difficult to draw information from the graph. Moreover, the animation - as is true for the previous graph - is not fixed in the animation, adding some degree of awkwardness to the animation. As such, I made sure to incorporate some improvements.\nAdapting the theme\nTo create a more informative plot background, I adjusted my own Our World in Data inspired function to the requirements of a facet plot. This included the code for the position for the x-axes labels, which I reduced to four and the placement and color of each facet’s title. Additionally, the spacing between facets was adjusted manually and the properties of the strip titles were defined.\n\n\ntheme_owid_facet <- \n  function(){font <- \"Etoile\"    \n  theme_minimal() %+replace%   \n    theme(panel.grid.minor = element_blank(), \n          panel.grid.major = element_blank(), \n          axis.ticks.x.bottom = element_line(size = .5, color = \"grey\"), \n          axis.text.x = element_text(hjust = c(0, 0.5, 0.5, 1), size = 11), \n          axis.text.y = element_text(size = 11),\n          \n          legend.position = \"none\",\n          plot.title = element_text(size = 16,\n                                    hjust = 0,\n                                    colour = \"#444444\",\n                                    margin = margin(b = 2.5)),\n          plot.title.position = \"plot\",\n          plot.subtitle = element_text(size = 9.5,\n                                       color = \"grey\",\n                                       hjust = 0,\n                                       margin = margin(b = 10)),\n          plot.caption = element_text(hjust = 0,    \n                                      margin = margin(t = 7.5), \n                                      size = 8.5),\n          plot.caption.position = \"plot\",\n          plot.margin = margin(t = 5, r = 5, b = 5, l = 5),\n          strip.placement = \"outside\",\n          strip.text = element_text(colour = \"#002147\",\n                                    hjust = -0.005),\n          strip.background = element_blank(),\n          panel.spacing.x = unit(1.5, \"lines\"),\n          panel.spacing.y = unit(1, \"lines\")\n    )\n  }\n\n\nCreating the alternative plot\nTo create the plot, first the labels of the facets were created and stored in an object, which was subsequently included in the function ‘facet_wrap’. The remainder remains similar to the replication graph, with some minor distinct changes. The y-axis was replaced with an inscription in only the first facet describing the most upper line (1.5 billion). This caused me a bit of a headache, because just using ‘geom_text’ to only annotate in one facet (‘annotate’ annotates in every facet) messed up the order of the facets.\nSo I had to create a workaround. First, I created an object (‘custom_levels’), storing the levels of the variable about to be faceted. This was then plugged into a data frame, created to only select the first level from the ‘custom_levels’ object in an ‘if_else’ structure to assign the label ‘1.5 billion’ storing it under the variable ‘label’. If the label for the variable for disposable income equals the first level of the custom levels object, ‘1.5 billion’ is pasted, else nothing is specified. This would generate a facet plot, where the remainder of the facets are allocated ‘geom_text’ according to their ‘custom_levels’. To prevent this from happening, the label variable of created data frame is altered, setting the label for every disposable income variable to empty except for the first level in the ‘custom_levels’ object. Lastly, I ensured that there is only 9 options for the ‘geom_text’ to be applied with the ‘unique’ function.\n\n\nlabels <- c(\"b_40_dollars_and_more\" = \"above $40 a day\", \n            \"b_30_40_dollars\" = \"$30-$40 a day\",      \n            \"b_20_30_dollars\" = \"$20-$30 a day\",    \n            \"b_10_20_dollars\" = \"$10-$20 a day\",  \n            \"b_6.85_10_dollars\" = \"$6.85-$10 a day\", \n            \"b_3.65_6.85_dollars\" = \"$3.65-$6.85 a day\",\n            \"b_2.15_3.65_dollars\" = \"$2.15-$3.65 a day\", \n            \"b_1_2.15_dollars\" = \"$1-$2.15 a day\",     \n            \"below_1_dollar\" = \"below $1 a day\") \n\n\ncustom_levels <- c(\n  \"b_40_dollars_and_more\",\n  \"b_30_40_dollars\",\n  \"b_20_30_dollars\",\n  \"b_10_20_dollars\",\n  \"b_6.85_10_dollars\",\n  \"b_3.65_6.85_dollars\",\n  \"b_2.15_3.65_dollars\",\n  \"b_1_2.15_dollars\",\n  \"below_1_dollar\")\n\ndat_text <- data.frame(\n  label = ifelse(data_world$disp_inc == custom_levels[1], \"1.5 billion\", \"\"),\n  disp_inc = data_world$disp_inc)\n\ndat_text$label[dat_text$disp_inc %in% custom_levels[-1]] <- \"\"\n\ndat_text <- unique(dat_text)\n\n\nThis data frame information is then plugged into the ‘geom_text’ function in the final code, using the label column to label each facet (with only the first facet being visually labeled).\n\n\na <- \n  data_world |> \n  ggplot(aes(x = Year, y = am_people, group = disp_inc)) +\n  facet_wrap(~ disp_inc, labeller = labeller(disp_inc = labels)) +\n  geom_segment(aes(x = 1990, xend = 2019, y = 0, yend = 0),\n               linetype = \"solid\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 500000000, yend = 500000000),\n               linetype = \"dashed\", color = \"grey\") +\n  geom_segment(aes(x = 1990, xend = 2019, y = 1e9, yend = 1e9),\n               linetype = \"dashed\", color = \"grey\")+\n  geom_segment(aes(x = 1990, xend = 2019, y = 1500000000, yend = 1500000000),\n               linetype = \"dashed\", color = \"grey\") +\n  coord_cartesian(xlim = c(1990, 2019), expand = TRUE) +\n  theme_owid_facet() +\n  scale_y_continuous(breaks = c(0, \n                                500000000 , \n                                1000000000, \n                                1500000000, \n                                2000000000),\n                     labels = c(),\n                     expand = c(0, 0)) +\n  scale_x_continuous(breaks = c(1990, 2000, 2010, 2019),\n                     expand= c(0, 0)) +\n  labs(x = NULL,\n       y = NULL) +\n  geom_area(stat = \"identity\", fill = \"#002147\", alpha = 0.8) +\n  geom_text(data = dat_text,\n            mapping = aes(x = 1994.5, y = 1370000000, label = label),\n            color = \"grey\", show.legend = FALSE)\n\na\n\n\n\nGive it a title…\nTitle, subtitle, and caption were again included by simply adding the ‘labs’ function.\n\n\na <-  \n  a +  \n  labs(\n    title = \"Distribution of population between different poverty\\nthresholds, World, 1990 to 2019\",  \n    subtitle = \"This data is adjusted for inflation and for differences in the cost of living between countries.\",\n    caption = paste(\"Data source: World Bank Poverty and Inequality Platform (2022) – Learn more about\", \n                       \"this data\\nNote: This data is expressed in international-$ at 2017 prices.\", \n                       \"Depending on the country and year,\\nit relates to income measured after\", \n                       \"taxes and benefits, or to consumption, per capita.\\nOurWorldInData.org/poverty | CC BY\")) + \n  coord_cartesian(clip = \"off\")\na\n\n\n\nand make it move\nFor the facet wrap, I was able to animate it. Instead of leaving the x-axis free, it is fixed in my animation, making it easier to to understand the relationship between year and amount of people pertaining to a certain category of disposable income. To only create one loop, the gifski package provides to opportunity to manually set ‘looping’ to false.\n\n\na_fluid <-  \n  a + \n  transition_reveal(Year) \n\nanimate(a_fluid, renderer = gifski_renderer(loop = FALSE))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100506380/100506380_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  },
  {
    "path": "projects/2023/100513254/",
    "title": "Energy Generation by Fuel Type",
    "description": "Using the Energy Institute’s data to reproduce Bloomberg’s chart and to provide an alternative representation.",
    "author": [
      {
        "name": "Giorgio Rivoli",
        "url": {}
      }
    ],
    "date": "2024-01-14",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nLibraries and data\nReplicating the chart\nConstruction of the circular chart\nColored areas\nAnnotate\nFlags\nComments\nTitle and legend\nTheme\n\nAlternative version\nLibraries and data\nCoordinates and axes\n\n\nIn September 2023, Bloomberg published an article titled “Apple’s Supply Chain Is on a Collision Course With Climate Change”. Within this article, the supplier countries of the Cupertino-based company are examined. Specifically, for each of these countries, based on data from the Energy Institute, the resources used to produce their energy are highlighted. The results are depicted in the following graph:\nEnergy generation by fuel type. Source: BloombergThe purpose of this project is to replicate this graph as faithfully as possible and subsequently provide an alternative representation of the data.\nLibraries and data\nRegarding the libraries used, we aimed to limit the use primarily to “ggplot2”. However, due to specific aspects of the graph, it was necessary to import additional libraries. As for the data, as previously mentioned, we referred to the “Statistical Review of World Energy” report by the Energy Institute. Given that this report spans over 60 pages and includes data not only for the countries featured in our graph, we proceeded to transcribe the relevant data into an Excel file. Nonetheless, the imported data serves solely an informative purpose because constructing the graph required manually inputting this data, albeit relying on the aforementioned Excel file.\n\n\nlibrary(ggplot2)\nlibrary(png)\nlibrary(grid)\nlibrary(readxl)\n\ndata <- read_excel(\"Data.xlsx\")\n\n\nReplicating the chart\nConstruction of the circular chart\nFirst of all, we need to build the base of our chart. This consists of a larger circumference with three concentric circles inside, each progressively smaller. Additionally, there are also 13 equidistant spokes, one for each of the countries of interest. Initially, we assign three different variables to the number of circumferences, the number of points for each circumference, and the number of spokes. Additionally, we create a variable to which we assign a vector containing the names of the countries that will be displayed in our chart.\n\n\nnum_circles <- 4\nnum_points <- 100\nnum_rays <- 13\n\ncountries <- c(\"Indonesia\", \"India\", \"Mainland China\", \n               \"Mexico\", \"South Korea\", \"Japan\", \n               \"US\", \"Vietnam\", \"Germany\", \n               \"UK\", \"Thailand\", \"Taiwan\", \"Malaysia\")\n\n\nAfterwards, we use a function that allows us to generate our concentric circles.\n\n\ngenerate_concentric_circles <- function(num_circles, num_points) {\n  circles_data <- lapply(1:num_circles, function(i) {\n    r <- i / (num_circles + 1)\n    data.frame(\n      x = r * cos(seq(0, 2 * pi, length.out = num_points)),\n      y = r * sin(seq(0, 2 * pi, length.out = num_points)),\n      radius = r\n    )\n  })\n  do.call(rbind, circles_data)\n}\n\n\nIn the following code, we have a function that displays equidistant spokes originating from the center of the circle. Moreover, each spoke is associated with the name of a country from the ‘countries’ vector.\n\n\ngenerate_rays <- function(num_rays, max_radius, countries) {\n  angle <- seq(0, 2 * pi, length.out = num_rays + 1)[-1]\n  data.frame(\n    x = cos(angle) * max_radius,\n    y = sin(angle) * max_radius,\n    country = rev(countries)  # Inverte l'ordine dei paesi\n  )\n}\n\n\nAfter that, we store within three different variables the data necessary to construct our circular chart.\n\n\ncircles_data <- generate_concentric_circles(num_circles, num_points)\nmax_radius <- max(circles_data$radius)\nrays_data <- generate_rays(num_rays, max_radius, countries)\n\n\nFinally, we proceed with the graphical representation of what has been done so far.\n\n\ngg_circle <- ggplot() +\n  geom_polygon(data = circles_data, aes(x, y, group = radius), fill = \"gray92\", \n               color = \"gray\") +\n  geom_path(data = circles_data, aes(x, y), color = \"gray\") +\n  geom_segment(data = subset(rays_data, sqrt(x^2 + y^2) <= max_radius), \n               aes(x = 0, y = 0, xend = x, yend = y), color = \"white\")\n\ngg_circle\n\n\n\nColored areas\nWe now proceed with constructing the chart, adding colored areas that represent the resources used by various countries for energy production. This phase has been the most complex of the project. In fact, we experimented with several approaches, including the ‘geom_area’ option, for creating the colored areas, but none of them yielded satisfactory results. Ultimately, we chose to use “geom_polygon.” However, the main issue with using geom_polygon is that each colored area is composed of numerous small sections. This not only made the code inevitably longer but also resulted in the areas being slightly more square-shaped and less rounded compared to the original.\nTo create the aforementioned areas, we first created four lists, one for each colored area. Within each list, there are coordinates for each country that represent the individual colored sections. These, when summed together, will constitute the entire area.\n\n\nblack_areas <- list(\n  thailand_coal = data.frame(x = c(0, 0.023, 0.18), y = c(0, 0.15, 0.275)),\n  taiwan_coal = data.frame(x = c(0, 0.18, 0.275), y = c(0, 0.275, 0.14)),\n  malaysia_coal = data.frame(x = c(0, 0.275, 0.5), y = c(0, 0.14, 0)),\n  indonesia_coal = data.frame(x = c(0, 0.5, 0.53), y = c(0, 0, -0.277)),\n  india_coal = data.frame(x = c(0, 0.53, 0.275), y = c(0, -0.277, -0.4)),\n  china_coal = data.frame(x = c(0, 0.275, 0.008), y = c(0, -0.4, -0.035)),\n  mexico_coal = data.frame(x = c(0, 0.008, -0.082), y = c(0, -0.035, -0.225)),\n  south_korea_coal = data.frame(x = c(0, -0.082, -0.177), y = c(0, -0.225, -0.16)),\n  japan_coal = data.frame(x = c(0, -0.177, -0.152), y = c(0, -0.16, -0.04)),\n  us_coal = data.frame(x = c(0, -0.152, -0.3), y = c(0, -0.04, 0.075)),\n  vietnam_coal = data.frame(x = c(0, -0.3, -0.18), y = c(0, 0.075, 0.162)),\n  germany_coal = data.frame(x = c(0, -0.18, -0.01), y = c(0, 0.162, 0.025)),\n  uk_coal = data.frame(x = c(0, -0.01, 0.023), y = c(0, 0.025, 0.15))\n)\n\ngray_area <- list(\n  thailand_gas = data.frame(x = c(0.023, 0.18, 0.362, 0.075), \n                            y = c(0.15, 0.275, 0.525, 0.65)),\n  taiwan_gas = data.frame(x = c(0.18, 0.275, 0.55, 0.362), \n                          y = c(0.275, 0.14, 0.28, 0.525)),\n  malaysia_gas = data.frame(x = c(0.275, 0.5, 0.625, 0.55), \n                            y = c(0.14, 0, 0, 0.28)),\n  indonesia_gas = data.frame(x = c(0.5, 0.53, 0.53, 0.625), \n                             y = c(0, -0.277, -0.285, 0)),\n  india_gas = data.frame(x = c(0.53, 0.275, 0.3, 0.53), \n                         y = c(-0.277, -0.4, -0.4, -0.285)),\n  china_gas = data.frame(x = c(0.275, 0.008, 0.06, 0.3), \n                         y = c(-0.4, -0.035, -0.5, -0.4)),\n  mexico_gas = data.frame(x = c(0.008, -0.082, -0.175, 0.06), \n                          y = c(-0.035, -0.225, -0.475, -0.5)),\n  south_korea_gas = data.frame(x = c(-0.082, -0.177, -0.37, -0.175), \n                               y = c(-0.225, -0.16, -0.33, -0.475)),\n  japana_gas = data.frame(x = c(-0.177, -0.152, -0.45, -0.37), \n                          y = c(-0.16, -0.04, -0.117, -0.33)),\n  us_gas = data.frame(x = c(-0.152, -0.3, -0.38, -0.45), \n                      y = c(-0.04, 0.075, 0.095, -0.117)),\n  vietnam_gas = data.frame(x = c(-0.3, -0.18, -0.28, -0.38), \n                           y = c(0.075, 0.162, 0.25, 0.095)),\n  germany_gas = data.frame(x = c(-0.18, -0.01, -0.14, -0.28), \n                           y = c(0.162, 0.025, 0.35, 0.25)),\n  uk_gas = data.frame(x = c(-0.01, 0.023, 0.075, -0.14), \n                      y = c(0.025, 0.15, 0.65, 0.35))\n)\n\nblue_area <- list(\n  thailand_ren = data.frame(x = c(0.075, 0.362, 0.4, 0.097), \n                            y = c(0.65, 0.525, 0.575, 0.78)),\n  taiwan_ren = data.frame(x = c(0.362, 0.55, 0.7, 0.4), \n                          y = c(0.525, 0.28, 0.37, 0.575)), \n  malaysia_ren = data.frame(x = c(0.55, 0.625, 0.77, 0.7), \n                            y = c(0.28, 0, 0, 0.37)),\n  indonesia_ren = data.frame(x = c(0.625, 0.525, 0.675, 0.77), \n                             y = c(0, -0.285, -0.35, 0)),\n  india_ren = data.frame(x = c(0.525, 0.26, 0.425, 0.675), \n                         y = c(-0.285, -0.415, -0.62, -0.35)),\n  china_ren = data.frame(x = c(0.26, 0.06, 0.076, 0.425), \n                         y = c(-0.415, -0.5, -0.67, -0.62)),\n  mexico_ren = data.frame(x = c(0.06, -0.175, -0.242, 0.076), \n                          y = c(-0.5, -0.475, -0.625, -0.67)),\n  south_korea_ren = data.frame(x = c(-0.175, -0.40, -0.5, -0.23), \n                               y = c(-0.475, -0.30, -0.45, -0.625)),\n  japan_ren = data.frame(x = c(-0.376, -0.45, -0.625, -0.5), \n                         y = c(-0.32, -0.117, -0.15, -0.45)),\n  us_ren = data.frame(x = c(-0.45, -0.38, -0.775, -0.625), \n                      y = c(-0.117, 0.1, 0.186, -0.15)),\n  vietnam_ren = data.frame(x = c(-0.38, -0.28, -0.55, -0.775), \n                           y = c(0.1, 0.25, 0.482, 0.186)),\n  germany_ren = data.frame(x = c(-0.28, -0.141, -0.242, -0.55), \n                           y = c(0.25, 0.35, 0.63, 0.482)),\n  uk_ren = data.frame(x = c(-0.141, 0.075, 0.097, -0.242), \n                      y = c(0.35, 0.65, 0.78, 0.63))\n)\n\nyellow_ocra_area <- list(\n  indonesia_nuc = data.frame(x = c(0.77, 0.675, 0.707, 0.77), \n                             y = c(0, -0.35, -0.37, 0)),\n  india_nuc = data.frame(x = c(0.675, 0.425, 0.45, 0.707), \n                         y = c(-0.35, -0.62, -0.65, -0.37)),\n  china_nuc = data.frame(x = c(0.425, 0.076, 0.081, 0.45), \n                         y = c(-0.62, -0.67, -0.68, -0.65)),\n  mexico_nuc = data.frame(x = c(0.076, -0.255, -0.275, 0.081), \n                          y = c(-0.67, -0.615, -0.735, -0.68)),\n  japan_nuc = data.frame(x = c(-0.24, -0.5, -0.54, -0.275), \n                         y = c(-0.615, -0.45, -0.475, -0.725)),\n  us_nuc = data.frame(x = c(-0.5, -0.625, -0.76, -0.54), \n                      y = c(-0.45, -0.15, -0.183, -0.475)),\n  vietnam_nuc = data.frame(x = c(-0.625, -0.775, -0.775, -0.76), \n                           y = c(-0.15, 0.186, 0.186, -0.183)),\n  germany_nuc = data.frame(x = c(-0.775, -0.55, -0.575, -0.775), \n                           y = c(0.186, 0.482, 0.51, 0.186)),\n  uk_nuc = data.frame(x = c(-0.55, -0.242, -0.275, -0.575), \n                      y = c(0.482, 0.63, 0.72, 0.51)),\n  thailand_nuc = data.frame(x = c(-0.242, 0.097, 0.097, -0.275), \n                            y = c(0.63, 0.78, 0.78, 0.72)),\n  taiwan_nuc = data.frame(x = c(0.097, 0.4, 0.44, 0.097), \n                          y = c(0.78, 0.575, 0.645, 0.78)),\n  malaysia_nuc = data.frame(x = c(0.4, 0.7, 0.7, 0.44), \n                            y = c(0.575, 0.37, 0.37, 0.645))\n)\n\n\nAfter doing this, we can visualize the graphical outcome.\n\n\ngg_areas <- gg_circle + lapply(black_areas, function(area) {\n  geom_polygon(data = area, aes(x = x, y = y), fill = \"black\", color = \"black\", alpha = 0.9)\n}) +\n  lapply(gray_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"dimgray\", color = \"dimgray\", alpha = 0.9)  \n  }) +\n  lapply(blue_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"blue1\", color = \"blue1\", alpha = 0.9)\n  }) +\n  lapply(yellow_ocra_area, function(area) {\n    geom_polygon(data = area, aes(x = x, y = y), fill = \"gold3\", color = \"gold3\", alpha = 0.9)  \n  })\n\ngg_areas\n\n\n\nAnnotate\nGiven that we have created the main core of our graph, let’s now proceed by adding all the details. Before doing so, in order to avoid potential display issues with some elements, we will adjust the dimensions of our graph by expanding the axes.\n\n\ngg_exp <- gg_areas + coord_fixed(expand = FALSE) +\n  scale_x_continuous(expand = c(0, 0), limits = c(-1.2, 1.2), \n                     breaks = seq(-1.2, 1.2, by = 0.1)) +\n  scale_y_continuous(expand = c(0, 0), limits = c(-1.2, 1.2), \n                     breaks = seq(-1.2, 1.2, by = 0.1))\n\ngg_exp\n\n\n\nOnce done, let’s proceed to add various elements using ‘annotate’. Initially, we’ll add country names outside the circumference, near the reference radius. Then, we’ll add points and lines to highlight a particular energy resource. Finally, above each respective circumference, we’ll add the percentages 25%, 50%, 75%, and 100%, enhancing the interpretability of the graph.\n\n\ngg_det <- gg_exp +  \n  annotate(\"text\", x = -0.415, y = -0.795, label = \"South Korea\", \n           size = 3.7, color = \"black\") + \n  annotate(\"text\", x = -0.68, y = -0.557, label = \"Japan\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.162, y = -0.848, label = \"Mexico\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.62, y = -0.7, label = \"Mainland China\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.79, y = -0.395, label = \"India\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.088, y = 0.843, label = \"Thailand\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.325, y = 0.794, label = \"UK\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.71, y = 0.575, label = \"Germany\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.884, y = 0.215, label = \"Vietnam\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = -0.843, y = -0.188, label = \"US\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.52, y = 0.71, label = \"Taiwan\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.818, y = 0.407, label = \"Malaysia\", \n           size = 3.7, color = \"black\") +\n  annotate(\"text\", x = 0.92, y = 0.0079, label = \"Indonesia\", \n           size = 3.7, color = \"black\")+\n  annotate(\"point\", x = -0.27, y = -0.73, size = 2, color = \"black\") + \n  annotate(\"point\", x = -0.37, y = -0.33, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.078, y = -0.67, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.275, y = -0.395, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.525, y = -0.276, size = 2, color = \"black\") +\n  annotate(\"point\", x = 0.075, y = 0.645, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.242, y = 0.63, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.55, y = 0.482, size = 2, color = \"black\") +\n  annotate(\"point\", x = -0.775, y = 0.186, size = 2, color = \"black\") +\n  annotate(\"segment\", x = -0.27, y = -0.73, xend = -0.29, \n           yend = -0.775, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.37, y = -0.33, xend = -0.61, \n           yend = -0.54, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.078, y = -0.67, xend = 0.1, \n           yend = -0.815, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.275, y = -0.395, xend = 0.47, \n           yend = -0.67, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.525, y = -0.276, xend = 0.732, \n           yend = -0.38, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.075, y = 0.645, xend = 0.0935, \n           yend = 0.81, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.242, y = 0.63, xend = -0.29, \n           yend = 0.765, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.55, y = 0.482, xend = -0.61, \n           yend = 0.54, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.775, y = 0.186, xend = -0.798, \n           yend = 0.192, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = -0.76, y = -0.183, xend = -0.8, \n           yend = -0.196, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.44, y = 0.645, xend = 0.462, \n           yend = 0.68, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.7, y = 0.37, xend = 0.722, \n           yend = 0.383, color = \"black\", size = 0.5) +\n  annotate(\"segment\", x = 0.77, y = 0, xend = 0.816, \n           yend = 0, color = \"black\", size = 0.5)\n\ngg_det\n\n\n\nFlags\nNow that we’ve added the country names, we can also include the flags. In this regard, the following code aims to import and position the flags correctly next to their respective country names. After saving the flag images in PNG format within a folder, we import them using ‘readPNG’. Subsequently, for each flag, we specify the desired coordinates on both the X and Y axes. Finally, we also indicate the dimensions we want to assign to each image.\n\n\nuk_flag<- readPNG(\"flags/UK.png\")\nuk_flag_x <- -0.403\nuk_flag_y <- 0.803\nuk_flag_width <- 0.08\n\nthai_flag <- readPNG(\"flags/Thailand.png\")\nthai_flag_x <- 0.21\nthai_flag_y <- 0.843\nthai_flag_width <- 0.08\n\ntaiwan_flag <- readPNG(\"flags/Taiwan.png\")\ntaiwan_flag_x <- 0.635\ntaiwan_flag_y <- 0.715\ntaiwan_flag_width <- 0.08\n\nmal_flag <- readPNG(\"flags/Malaysia.png\")\nmal_flag_x <- 0.95\nmal_flag_y <- 0.41\nmal_flag_width <- 0.084\n\nindia_flag <- readPNG(\"flags/India.png\")\nindia_flag_x <- 0.89\nindia_flag_y <- -0.397\nindia_flag_width <- 0.08\n\nchina_flag <- readPNG(\"flags/China.png\")\nchina_flag_x <- 0.814\nchina_flag_y <- -0.7\nchina_flag_width <- 0.077\n\nmex_flag <- readPNG(\"flags/Mexico.png\")\nmex_flag_x <- 0.285\nmex_flag_y <- -0.85\nmex_flag_width <- 0.08\n\nsk_flag <- readPNG(\"flags/South Korea.png\")\nsk_flag_x <- -0.588\nsk_flag_y <- -0.796\nsk_flag_width <- 0.094\n\njap_flag <- readPNG(\"flags/Japan.png\")\njap_flag_x <- -0.79\njap_flag_y <- -0.557\njap_flag_width <- 0.085\n\nus_flag <- readPNG(\"flags/USA.png\")\nus_flag_x <- -0.93\nus_flag_y <- -0.19\nus_flag_width <- 0.085\n\nviet_flag <- readPNG(\"flags/Vietnam.png\")\nviet_flag_x <- -1.012\nviet_flag_y <- 0.217\nviet_flag_width <- 0.08\n\nger_flag <- readPNG(\"flags/Germany.png\")\nger_flag_x <- -0.848\nger_flag_y <- 0.574\nger_flag_width <- 0.08\n\nindonesia_flag <- readPNG(\"flags/Indonesia.png\")\nindonesia_flag_x <- 1.06\nindonesia_flag_y <- 0.01\nindonesia_flag_width <- 0.08\n\n\nOnce that’s done, with ‘annotate_custom’, we can display the flags within our graph.\n\n\ngg_flag <- gg_det + annotation_custom(\n    rasterGrob(uk_flag, interpolate = TRUE),\n    xmin = uk_flag_x - uk_flag_width / 2,\n    xmax = uk_flag_x + uk_flag_width / 2,\n    ymin = uk_flag_y - uk_flag_width / 2, \n    ymax = uk_flag_y + uk_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(thai_flag, interpolate = TRUE),\n    xmin = thai_flag_x - thai_flag_width / 2,\n    xmax = thai_flag_x + thai_flag_width / 2,\n    ymin = thai_flag_y - thai_flag_width / 2, \n    ymax = thai_flag_y + thai_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(taiwan_flag, interpolate = TRUE),\n    xmin = taiwan_flag_x - taiwan_flag_width / 2,\n    xmax = taiwan_flag_x + taiwan_flag_width / 2,\n    ymin = taiwan_flag_y - taiwan_flag_width / 2, \n    ymax = taiwan_flag_y + taiwan_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(mal_flag, interpolate = TRUE),\n    xmin = mal_flag_x - mal_flag_width / 2,\n    xmax = mal_flag_x + mal_flag_width / 2,\n    ymin = mal_flag_y - mal_flag_width / 2, \n    ymax = mal_flag_y + mal_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(india_flag, interpolate = TRUE),\n    xmin = india_flag_x - india_flag_width / 2,\n    xmax = india_flag_x + india_flag_width / 2,\n    ymin = india_flag_y - india_flag_width / 2, \n    ymax = india_flag_y + india_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(china_flag, interpolate = TRUE),\n    xmin = china_flag_x - china_flag_width / 2,\n    xmax = china_flag_x + china_flag_width / 2,\n    ymin = china_flag_y - china_flag_width / 2, \n    ymax = china_flag_y + china_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(mex_flag, interpolate = TRUE),\n    xmin = mex_flag_x - mex_flag_width / 2,\n    xmax = mex_flag_x + mex_flag_width / 2,\n    ymin = mex_flag_y - mex_flag_width / 2, \n    ymax = mex_flag_y + mex_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(sk_flag, interpolate = TRUE),\n    xmin = sk_flag_x - sk_flag_width / 2,\n    xmax = sk_flag_x + sk_flag_width / 2,\n    ymin = sk_flag_y - sk_flag_width / 2, \n    ymax = sk_flag_y + sk_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(jap_flag, interpolate = TRUE),\n    xmin = jap_flag_x - jap_flag_width / 2,\n    xmax = jap_flag_x + jap_flag_width / 2,\n    ymin = jap_flag_y - jap_flag_width / 2, \n    ymax = jap_flag_y + jap_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(us_flag, interpolate = TRUE),\n    xmin = us_flag_x - us_flag_width / 2,\n    xmax = us_flag_x + us_flag_width / 2,\n    ymin = us_flag_y - us_flag_width / 2, \n    ymax = us_flag_y + us_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(viet_flag, interpolate = TRUE),\n    xmin = viet_flag_x - viet_flag_width / 2,\n    xmax = viet_flag_x + viet_flag_width / 2,\n    ymin = viet_flag_y - viet_flag_width / 2, \n    ymax = viet_flag_y + viet_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(ger_flag, interpolate = TRUE),\n    xmin = ger_flag_x - ger_flag_width / 2,\n    xmax = ger_flag_x + ger_flag_width / 2,\n    ymin = ger_flag_y - ger_flag_width / 2, \n    ymax = ger_flag_y + ger_flag_width / 2\n  ) +\n  annotation_custom(\n    rasterGrob(indonesia_flag, interpolate = TRUE),\n    xmin = indonesia_flag_x - indonesia_flag_width / 2,\n    xmax = indonesia_flag_x + indonesia_flag_width / 2,\n    ymin = indonesia_flag_y - indonesia_flag_width / 2, \n    ymax = indonesia_flag_y + indonesia_flag_width / 2\n  )\n\ngg_flag\n\n\n\nComments\nAfter doing that, let’s add comments related to nine out of the thirteen countries present in the graph. To do this, first, we’ll save the textual descriptions in different variables. Then, using ‘annotate’, we’ll position the comments next to their respective countries.\n\n\ntext_thai <- \"Thailand generates 84% of its energy     \\nfrom fossil fuels, mostly from natural gas\"\n\ntext_indonesia <- \"Coal comprises 62% of \\nIndonesia's energy mix \"\n\ntext_india <- \"India and China get most of their  \\nenergy from coal at 74% and 61%\"\n\ntext_mexico <- \"Mexico uses very little col and  \\ngets is energy from gas at 56%\\nand renewables at 24%           \"\n\ntext_sk <- \"Nuclear makes up 28% \\nSouth Korea's energy generation               \"\n\ntext_japan <- \"Nearly two thirds of Japan's \\nenergy is from gas and coal\"\n\ntext_viet <- \"Half of Vietnam's energy         \\nis from renewables\"\n\ntext_germany <- \"41% of UK's and 44% of Germany's \\n           energy are from renewables\"\n\ngg_com <- gg_flag +   annotate(\"text\", x = 0.298, y = 0.94, label = text_thai, \n                     size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.995, y = -0.085, label = text_indonesia, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.955, y = -0.525, label = text_india, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = 0.312, y = -0.95, label = text_mexico, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.455, y = -0.897, label = text_sk, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.821, y = -0.65, label = text_japan, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.952, y = 0.111, label = text_viet, \n           size = 2.7, color = \"black\") +\n  annotate(\"text\", x = -0.87, y = 0.68, label = text_germany, \n           size = 2.7, color = \"black\")\n\ngg_com\n\n\n\nTitle and legend\nTo properly position and display the title and legend, let’s first move the graph a bit downwards. Once done, using ‘gg_title,’ we’ll add our title. Then, due to the complex nature of the original graph, we were compelled to manually add the legend using ‘annotate’. In fact, we started by listing the names of the energy sources, and then we placed a square of the corresponding color next to each name. Below is the code and the resulting graph.\n\n\ngg_plot1 <- gg_com + theme(plot.margin = margin(t = 50, r = 0, b = 0, \n                                    l = 0, unit = \"pt\")) +\n  ggtitle(\"Energy Generation by Fuel Type\") + \n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, \n                                  size = 27, face = \"bold\")) +\n  annotate(\"text\", x = -0.49, y = 1.167, label = \"Coal\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = -0.266, y = 1.167, label = \"Natural gas\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.03, y = 1.167, label = \"Renewables\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.28, y = 1.167, label = \"Nuclear\", \n           size = 3.5, color = \"black\") +\n  annotate(\"text\", x = 0.465, y = 1.167, label = \"Other\", \n           size = 3.5, color = \"black\") +\n  annotate(geom = \"rect\", xmin = -0.55, xmax = -0.58, \n           ymin = 1.15, ymax = 1.18, fill = \"black\") +\n  annotate(geom = \"rect\", xmin = -0.39, xmax = -0.42, \n           ymin = 1.15, ymax = 1.18, fill = \"dimgray\") +\n  annotate(geom = \"rect\", xmin = -0.1, xmax = -0.13, \n           ymin = 1.15, ymax = 1.18, fill = \"blue1\") +\n  annotate(geom = \"rect\", xmin = 0.16, xmax = 0.19, \n           ymin = 1.15, ymax = 1.18, fill = \"gold3\") +\n  annotate(geom = \"rect\", xmin = 0.37, xmax = 0.4, \n           ymin = 1.15, ymax = 1.18, fill = \"gray92\")\n\ngg_plot1\n\n\n\nTheme\nFinally, all that remains is to remove the axes and gridlines, achieving a cleaner result.\n\n\ngg_fin <- gg_plot1 + theme_void() +\n  ggtitle(\"Energy Generation by Fuel Type\") + \n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, \n                                  size = 27, face = \"bold\"))\n\ngg_fin\n\n\n\nAlternative version\nIn this section, we present a different representation of the same data. We deemed it preferable to opt for an entirely different type of visualization rather than making improvements to the original graph. In fact, we don’t see valid reasons to use a circular chart for this data, as it makes interpretation considerably more complex. In our alternative version, we chose to represent the data using a simple stacked bar plot, which undoubtedly allows for a more immediate understanding. Further changes we made will be presented within this section.\nLibraries and data\nAlso in this case, we begin by importing the necessary libraries and the Excel file that we will use to access the data, which we will then manually enter. Compared to the previous graph, we have chosen to group the available data differently. In this version, we include coal and natural gas under the broader category of ‘fossil fuels.’ We haven’t made any changes to either the ‘renewable’ sources or ‘nuclear’ energy. Although many consider nuclear energy a clean source, according to the European Union, due to the use of uranium, it cannot be classified as renewable energy. Finally, we have also retained the ‘Other’ category as residual energy sources. We have made this reclassification because, in the current era, rather than detailing the various sources, it is more important to distinguish between polluting fossil fuels and renewable ones. This way, it will be easier to immediately understand which countries are more virtuous and which ones still need to take steps towards a greener energy approach.\n\n\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(readxl)\n\ndata <- read_excel(\"Data.xlsx\")\n\ndati <- data.frame(\n  Country = c(\"China\", \"Germany\", \"India\", \"Indonesia\", \"Japan\", \"Malaysia\", \n              \"Mexico\", \"South Korea\", \"Taiwan\", \"Thailand\", \"United Kingdom\", \n              \"United States\", \"Vietnam\"),\n  Other = c(1, 4, 0, 3, 14, 1, 11, 1, 4, 1, 3, 1, 0),\n  Nuclear = c(5, 5, 3, 0, 4, 0, 4, 9, 8, 0, 11, 19, 0),\n  Renewables = c(30, 44, 21, 19, 21, 21, 24, 28, 8, 15, 41, 21, 50),\n  Fossil_fuels = c(64, 47, 76, 78, 61, 78, 61, 62, 80, 84, 45, 59, 50)\n)\n\n\nCoordinates and axes\nNow, let’s proceed with creating our graph. We’ll begin by plotting a Cartesian plane, where numerical values will be represented on the X-axis, while we’ll list the thirteen countries on the Y-axis. These countries have been ordered based on the data so that those primarily generating energy from fossil fuel sources are positioned lower, and as we move upwards, we find those utilizing a more substantial percentage of renewable sources and other sources, besides the more polluting ones.\n\n\ncustom_order <- c(\n  \"Thailand\", \"Taiwan\", \"Indonesia\", \"Malaysia\", \"India\", \n  \"China\", \"South Korea\", \"Mexico\", \"Japan\", \"United States\", \"Vietnam\", \n  \"Germany\", \"United Kingdom\"\n)\ndati_long <- melt(dati, id.vars = \"Country\")\ndati_long$Country <- factor(dati_long$Country, levels = custom_order)\n\np <- ggplot(dati_long, aes(x = value, y = Country, fill = variable))\np\n\n\n\nNow let’s continue building the graph by adding the bars with the legend.\n\n\np + geom_bar(stat = \"identity\", width = 0.95)\n\n\n\nAfterward, we’ll change the colors associated with each energy source. Compared to the original graph, we have chosen different colors that are more visible and distinguishable from each other. Specifically, we relied on the ‘YlGnBu’ palette from the RColorBrewer package.\n\n\np <- p +\n  geom_bar(stat = \"identity\", width = 0.83) +\n  scale_fill_manual(values = c(\n    Other = \"#474a35\",\n    Nuclear = \"#edf8b1\",\n    Renewables = \"#7fcdbb\",\n    Fossil_fuels = \"#2c7fb8\"\n  ), labels = c(\n    Other = \"Other\",\n    Nuclear = \"Nuclear\",\n    Renewables = \"Renewables\",\n    Fossil_fuels = \"Fossil fuels\"\n  ))\np\n\n\n\nThen, we simplified the graph by removing the axis titles and changing the theme.\n\n\np <- p +\n  labs(title = \"\", x = \"\", y = \"\") +\n  theme_minimal()\np\n\n\n\nLater on, we made some minor adjustments to enhance the visual appearance. Initially, we changed the font of the axis labels, making them bold for better visibility, and additionally italicized the country names to give them a more refined look. Then, we highlighted both axes to facilitate data interpretation. Finally, we made some modifications to the legend, moving it to the top center in a horizontal position, and changing the text font.\n\n\np <- p +\n  theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust = 1, family = \"Arial\", face = \"bold\"),\n        axis.text.y = element_text(family = \"Arial\", face = \"bold.italic\"),\n        axis.title = element_text(family = \"Arial\", face = \"bold\"),\n        axis.line = element_line(color = \"black\"),\n        panel.grid = element_blank(),\n        legend.title = element_text(face = \"bold\", family = \"Arial\"),\n        legend.text = element_text(family = \"Arial\"),\n        legend.position = \"top\",  \n        legend.box = \"horizontal\")\np\n\n\n\nAfterward, we made some changes to the X-axis, displaying the percentages, which undoubtedly makes interpretation easier, and limiting its length.\n\n\np <- p + \n  scale_x_continuous(\n    labels = c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\"),\n    breaks = c(0, 25, 50, 75, 100),\n    limits = c(0, 100),  \n    expand = c(0, 0)\n  )\np\n\n\n\nFurthermore, in order to make interpreting the graph even simpler, especially concerning the percentage of energy from sources other than fossil fuels, we added dashed vertical lines corresponding to the 25%, 50%, and 100% percentages.\n\n\np <- p +\n  geom_vline(xintercept = c(25, 50, 75), linetype = \"dashed\", color = \"black\", alpha = 0.4)\np\n\n\n\nLet’s proceed further by refining some details, removing the title from the legend.”\n\n\np <- p +\n  guides(fill = guide_legend(reverse = TRUE, title = NULL))\np\n\n\n\nFinally, let’s complete the graph by adding the title in the appropriate position.\n\n\np +\n  ggtitle(\"Energy Generation by Fuel Type\") +\n  theme(plot.title = element_text(hjust = 0.5, vjust = 2, size = 27, face = \"bold\"))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100513254/100513254_files/figure-html5/unnamed-chunk-15-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1910,
    "preview_height": 1881
  },
  {
    "path": "projects/2023/100516910/",
    "title": "Club Convergence Graphs",
    "description": "Visual representation of Convergence Clubs for European countries in terms of R&D spending following KMeans and Phillips&Sul methodologies.",
    "author": [
      {
        "name": "Bernard Banyuls",
        "url": {}
      }
    ],
    "date": "2024-01-08",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nIntroduction\nData\nMethodology\nKMeans\nClub Convergence\n\nKMeans\nOriginal graph\nReplication\nAlternative\n\nClub Convergence\nOriginal graph\nReplication\nAlternative\n\n\nIntroduction\nThese project is divided in two parts following the idea of convergence clubs, the first part focuses on applying KMeans algorithm following the data that formal Beta-convergence uses, and the second part will be regarding the methodology proposed by Phillips and Sul to study the existence of Convergence Clubs.\nThe project does not focuses on how KMeans and ClubConvergence methodologies work but rather how we could replicate the graphs that different libraries show the results and its respective improvement or alternative representation.\nData\nThe data used comes from the eurostat database, and is the Research and Development spending per capita of European countries from 2005-200. In which for the KMeans representation we have the base value of 2005, and the growth in percentage terms in that range. For the case of club convergence we used the annual values of each country.\n\n\nlibrary(ggplot2)\nlibrary(tidyverse)\n\n#kmeans dataframe\nkmeans <- data.frame(\n  RD2005 = c(6.275703, 2.624669, 4.833102, 6.847262, 6.518114, \n             4.338597, 6.201928, 4.655863, 5.461711, 6.358016, \n             4.283587, 5.596568, 3.475067, 3.845883, 6.930886, \n             4.417635, 4.213608, 6.395762, 6.600143, 3.591818, \n             4.739701, 2.727853, 5.331268, 3.589059, 6.952059, \n             7.070979),\n  Growth = c(0.92375108, 1.69681154, 1.16036030, 0.52391288, \n             0.63775027, 1.55277085, 0.62851413, 0.79388677, \n             0.34673183, 0.31490307, 0.75596008, 0.44273349, \n             1.21811383, 1.46337410, 0.09846755, 0.99757606, \n             0.90737537, 0.57252347, 0.62278834, 1.66619833, \n             1.01064686, 1.24432410, 0.84397491, 1.44594353, \n             0.18259257, 0.32154540),\n  Classes = c(1, 0, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2, 0, 0, 1, \n              2, 2, 1, 1, 0, 2, 0, 2, 0, 1, 1)\n)\n\nkmeans$Classes <- factor(kmeans$Classes)\n\n#Club Convergence Club 1 dataframe\nRD_c1 <- data.frame(\n  country = rep(c(\"Austria\", \"Belgium\", \"Denmark\", \n                  \"Finland\", \"Germany\", \"Luxembourg\", \n                  \"Netherlands\", \"Sweden\"), each = 16),\n  year = rep(2005:2020, times = 8),\n  value = c(\n    1.2636954, 1.2597917, 1.2560107, 1.2523861, \n    1.2489316, 1.2456249, 1.2424396, 1.2393501, \n    1.2362968, 1.2332214, 1.2300758, 1.2268392, \n    1.2234943, 1.2200762, 1.216634, 1.2132162,\n    1.1931131, 1.1917045, 1.1903862, 1.1892365, \n    1.1883264, 1.1876866, 1.1873416, 1.1873075, \n    1.1875762, 1.1881236, 1.188915, 1.1899046, \n    1.1910207, 1.1922126, 1.1934391, 1.1946641,\n    1.3207855, 1.3145264, 1.3084158, 1.3024538, \n    1.2966115, 1.2908368, 1.285117, 1.2794547, \n    1.2738372, 1.2682436, 1.2626524, 1.2570401, \n    1.2513862, 1.2457252, 1.2401036, 1.2345612,\n    1.3467373, 1.3342167, 1.3219579, 1.3099375, \n    1.2981126, 1.2864238, 1.2748457, 1.2633862, \n    1.2520707, 1.2409227, 1.2299724, 1.2192528, \n    1.2087581, 1.1984812, 1.188409, 1.1785213,\n    1.2454659, 1.2415035, 1.2376704, 1.234019, \n    1.2305783, 1.2273345, 1.2242728, 1.2213699, \n    1.2185924, 1.2159016, 1.2132533, 1.2106106, \n    1.2079341, 1.20522, 1.2024912, 1.19978,\n    1.3466198, 1.3334351, 1.3205158, 1.307873, \n    1.2955232, 1.2834622, 1.271719, 1.260325, \n    1.249302, 1.2386057, 1.2281681, 1.2179158, \n    1.2077794, 1.1977508, 1.1878533, 1.1781052,\n    1.2124217, 1.2072734, 1.2023008, 1.1975962, \n    1.1932373, 1.1892418, 1.1856002, 1.1822699, \n    1.179186, 1.1762552, 1.1734111, 1.1706133, \n    1.1678222, 1.1650372, 1.1622778, 1.1595588,\n    1.3522649, 1.3423129, 1.3326128, 1.3232417, \n    1.314261, 1.3056945, 1.2975129, 1.2896621, \n    1.282073, 1.2746767, 1.2674274, 1.2602729, \n    1.2531619, 1.2460934, 1.2391038, 1.2322215\n  )\n)\n\n\nMethodology\nKMeans\nThere are several algorithms for clustering, but the standard one is the Hartigan-Wong algorithm in which the total variance of the individuals within a cluster is defined as the sum of the squared Euclidean distances between the elements and the corresponding centroid.\nThe centroid of each group is the center of the group that corresponds to the mean value of each individual in that cluster.\nThe clustering algorithm follows the following processes:\nThe algorithm randomly places \\(k\\) centroids in the data as initial centroids. And then, each individual \\(x_i\\) is assigned to the nearest centroid using the Euclidean distance.\nThe next step is to calculate the average value of each cluster that becomes the new centroid and the individuals \\(x_i\\) are reassigned to the new centroids \\(μ_k\\).\nThe previous step is repeated until the centroids do not change, thus achieving that the total variation of individuals within a cluster is the minimum possible.\nClub Convergence\nFor the analysis of convergence clubs, we will apply the methodology developed by Phillips and Sul (2007) through Stata program and RStudio of Du (2017). This methodology allows us to study the existence of convergence clubs without having to separate our data sample into subgroups through several variables in common.\nDue to the word count limit, the mathematical development cannot be presented. However, for details, you can follow the work of Phillips and Sul (2007, 2009) and Du (2017). However, the following t-regression model will be the one studied in the present work:\nThe following t regression model developed by Phillips and Sul (2007) is used:\n\\[log⁡(H_1/H_t )-2log⁡{log⁡(t)}=a+blog⁡(t)+ε_t for t=[rT],[rT]+1,…,T\";  \" r>0 \\]\nIn which, if there is convergence \\(H_i\\) will be 0 and, therefore \\(log⁡(H_1/H_t)\\) will tend to infinity. For this to occur \\(b\\) has to be greater than or equal to zero, in case it is negative the hypothesis of absolute convergence would be rejected and we would proceed to analyze if there are convergence clubs.\nFor convergence clubs, Phillips and Sul (2007) developed an algorithm to identify the various clubs that might be in a sample.\nThe following process represents how this algorithm works:\nCross-section classification: The different countries are ordered in decreasing order, i.e., from highest to lowest, taking into account the values of the last period.\nClub formation: We start by forming groups from the country with the highest value in the last period. Then we look for the first k such that when we do the log \\(t\\) regression test statistic, we are left with \\(t_k\\) being greater than -1.65. This is done for the first two countries, and in case it is not satisfied, it is performed for the second and third countries, and so on until a pair of countries is found that does satisfy the test. In case there is no pair of countries, i.e., there is no \\(k\\) that meets this requirement, there would be no convergence subgroups in our data sample.\nScreening of individuals to create convergence clubs: In the event that in the club formation, we have encountered a pair, we proceed to perform the same test by adding countries in the order we previously classified. When the criterion is no longer met, we would have our first club.\nRecursion and stopping rule: A subgroup is made with the individuals that have not been screened in the previous step. The log \\(t\\) regression test is performed and if it is greater than -1.65, another group is formed. Otherwise, the three previous steps would be performed with this subgroup.\nKMeans\nOriginal graph\nThe original graph represents the R&D spending per capita growth from 2005 to 2020, and the base value in 2005 in an scatter plot with three different background areas colored representing the different classes obtained using the kmeans algorithm for these two features. The graph was done by myself in python using mathplotlib and the kmeans algorithm to obtain the graph.\nR&D spending per capita - Clustering. Source: Own elaboration.Replication\nThe first thing we have to do to replicate this graph is to do a simple scatterplot in which we have to plot the points twice, one with the color of the “class” and another point in the same place but a little bit wider in a white color.\nThis first step is pretty straight forward as we only have to graph the points of each country, and then we have to plot the centroids manually with the same idea of plotting the point twice to give a wider border to each point.\nThen, the next step is to put the legend inside the graph rather than outside. Although there are still some minor changes that we should focus before plotting the colored areas indicating each different class such as removing the grid lines among other things.\n\n\nggplot(kmeans) +\n  geom_point(aes(x = RD2005, y = Growth), color = \"white\", \n             size = 7, shape = 16) +\n  geom_point(aes(x = RD2005, y = Growth, color = Classes), \n             size = 6, shape = 16) +\n  geom_point(x = 3.3, y = 1.5, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 3.3, y = 1.5, size = 12, color = \"#440154\", shape = 16) +\n  geom_point(x = 4.8, y = 0.9, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 4.8, y = 0.9, size = 12, color = \"#fde725\", shape = 16) +\n  geom_point(x = 6.6, y = 0.45, size = 18, color = \"white\", shape = 16) +\n  geom_point(x = 6.6, y = 0.45, size = 12, color = \"#21918c\", shape = 16) +\n  scale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\")) +\n  labs(x = \"RD2005\", y = \"Growth\") + \n  theme(\n    legend.position = c(.95, .95),\n    legend.justification = c(\"right\", \"top\"),\n    legend.box.just = \"right\",\n    legend.margin = margin(6, 6, 6, 6)\n    )\n\n\n\nThe complicated part while replicating the plot is how we create the background which is composed of three different colored areas representing each class the countries are part of.\nWe will use the geom_polygon() to color these areas, and for that matter we have to create three temporary dataframes as we can observe in the code that shows which points it will cross the polygon before coloring the area of the shape.\nThen, in this part we have also removed all the information that is not shown in the original graph such as the axis ticks and improving the legend to match the original graph.\n\n\nviolet <- data.frame(x = c(2.1, 2.1, 3.2, 4.3), y = c(2, -1, -1, 2))\nyellow <- data.frame(x = c(3.2, 4.3, 6.3, 5.5, 3.5), y = c(-1, 2, 2, -1, -1))\nblue  <- data.frame(x = c(6.1, 5.3, 8, 8), y = c(2, -1, -1, 2))\n\n\nggplot(kmeans) +\nscale_y_continuous(breaks = c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6), \n                   minor_breaks = NULL) +\nscale_x_continuous(breaks = c(3, 4, 5, 6, 7), minor_breaks = NULL) +  \ntheme(axis.title = element_text(face =\"italic\", size=15)) +\ntheme(\n  legend.position = c(0.99, 0.99),\n  legend.justification = c(\"right\", \"top\"),\n  legend.box.just = \"right\",\n  legend.margin = margin(11, 5, 5,11),\n  legend.spacing.x = unit(0.8, \"cm\"), \n  legend.text = element_text(size = 16),\n  legend.title = element_text(size = 15),\n  legend.background = element_rect(fill = \"#f0f6f7\", size = 0.3, \n                                   color =\"gray\")) +\nguides(color = guide_legend(override.aes = list(size = 8))) +\nggtitle(\"k-means with 3 cluster(s)\") +\ntheme(plot.title = element_text(hjust = 0.5, size=17)) +\ntheme(legend.spacing.x = unit(0.5, 'cm')) +\ntheme(legend.text.align = 0.5) +\ntheme(\n  axis.line = element_blank(),      \n  axis.text = element_blank(),     \n  axis.ticks = element_blank(),      \n  panel.grid.major = element_blank(),  \n  panel.grid.minor = element_blank()) +\ntheme(axis.title = element_text(face =\"italic\", size=14, color = \"black\")) +\nlabs(y = \"RDGROWTH\", x=\"RD2005\") +\ncoord_cartesian(xlim = c(min(kmeans$RD2005), max(kmeans$RD2005)), \n                ylim = c(min(kmeans$Growth), max(kmeans$Growth))) +\ngeom_polygon(aes(x = x, y = y), data = violet, fill = \"#c1b0cb\") +\ngeom_polygon(aes(x = x, y = y), data = yellow, fill = \"#eee9bf\") +\ngeom_polygon(aes(x = x, y = y), data = blue, fill = \"#b8d3d8\") +\ngeom_point(aes(x = RD2005, y = Growth), color = \"white\", size = 7, shape = 16) +\ngeom_point(aes(x = RD2005, y = Growth, color = Classes), size = 6, shape = 16) +\ngeom_point(x = 3.3, y = 1.5, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 3.3, y = 1.5, size = 10, color = \"#440154\", shape = 16) +\ngeom_point(x = 4.8, y = 0.9, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 4.8, y = 0.9, size = 10, color = \"#fde725\", shape = 16)+\ngeom_point(x = 6.6, y = 0.52, size = 18, color = \"white\", shape = 16) +\ngeom_point(x = 6.6, y = 0.52, size = 10, color = \"#21918c\", shape = 16)+\nscale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\"))\n\n\n\nAlternative\nOne of the main problems that this graph has is that first the colored background may confuse readers thinking that a country different from the original set of countries falls into certain color it would be part of that class, although how kmeans work it would not be exactly like that, for that matter although in the original graph and its replication the colored area makes the graph more enhancing it may confuse the reader.\nAnother problem is that the graph does not give so much information as there is no axis ticks, we do not fully know which is the range of the R&D spending and its unit measure. Although a better version of the replication would be the first step shown above one alternative is to represent the scatter plot using a facet_wrap to differentiate better between the classes.\nTo complicate the graph I decided to color the facet label to match the color of the class. Although there is a library called ggh4x, that allows us to do this thing easily, there is another way using geom_rect() which is better explained here.\nIn order to do this, we have to create a dataset that contains a column with all the facet names, in this case the different classes we have for the countries. Followed by another column that contains the labels we have for each class. We then specify the color using scale_fill_manual() and it is important that we use coord_cartesian() for two reasons:\nTo cut the panel area in the plot to only contain the points so the panel does not change to accomodate the geom_rect.\nTo turn clipping off, so layers outside the panel can be seen.\nAnd finally, it is important to turn strip.background to transparent so we can see the color of each box.\n\n\ntemp_df <- data.frame(\n  Classes = c(0,1,2),\n  var_color = c(\"Class 0\", \"Class 1\", \"Class 2\"))\n\nggplot(kmeans) + \n  geom_rect(\n    data = temp_df,\n    aes(\n      xmin = -Inf, xmax = Inf,\n      ymin = 2.1, ymax = 2.6,     \n      fill = var_color, alpha = 0.4\n    )\n  ) +     \n  coord_cartesian(clip = \"off\", ylim = c(0, 2))  + \n  geom_point(aes(x = RD2005, y = Growth, color = factor(Classes)), size = 5) +  \n  scale_color_manual(values = c(\n    \"0\" = \"#440154\",\n    \"1\" = \"#21918c\", \n    \"2\" = \"#fde725\"\n  )) + \n  facet_wrap(~ factor(Classes, labels = c(\"Class 0\", \"Class 1\", \"Class 2\")), \n             ncol = 1 ) +\n  scale_fill_manual(\n    values = c(\"Class 0\" = \"#440154\", \"Class 1\" = \"#21918c\", \n               \"Class 2\" = \"#fde725\")) +\n  theme_bw() +\n  theme(\n    strip.background = element_rect(fill = NA),\n    strip.text = element_text(size = 12, face = \"bold\"),\n    legend.position = \"none\",\n    axis.text.x = element_text(color = \"black\", size = 12),\n    axis.text.y = element_text(color = \"black\", size = 12),\n    axis.title.x = element_text(color = \"black\", size = 14),\n    axis.title.y = element_text(color = \"black\", size = 14),\n    axis.ticks = element_line(color = \"black\")\n  ) +   \n  labs(\n    title = \"Kmeans with 3 cluster(s)\",\n    x = \"log(RD2005percapita)\",\n    y = \"Growth(%)\",\n    subtitle = \"European clusters in terms of R&D spending\",\n    caption = \"Kmeans algorithm has been applied to EU countries in terms of \nthe log of the R&D spending per capita and its respective growth from 2005-2020\"\n  ) \n\n\n\nClub Convergence\nOriginal graph\nThe original graph is a representation of the countries of the three different clubs obtained and a fourth graph that takes into account the average of each club. The graph has been done using the ClubConvergence package in R in which the four graphs are shown in the same figure using only one line of code to get the result once the clubs were calculated.\nFor that matter as the four graphs are exactly the same only changing the club representing I will only replicate one of the clubs in order to show a better alternative to represent a club visually. Although the way to replicate the exact figure would be creating four graphs, one for each club and another one with the average of each club and then using patchwork to create the figure.\n\nReplication\nThe graph is pretty simple to replicate it only takes time to assign each color, shape and type of line to each country.\nThe point shape options in ggplot are the ones we can observe in the following picture:\nPoint Shape Options in ggplot. Source:Albert’s BlogAnd the line shape options in ggplot are the ones we can observe in the following picture:\n\nThe following scheme of colors, shapes and linetype for each country is assigned using this code:\n\n\ncountry_colors <- c(\n  \"Austria\" = \"#61d04f\",\n  \"Belgium\" = \"#28e2e5\",\n  \"Denmark\" = \"#080404\",\n  \"Finland\" = \"#df536b\",\n  \"Germany\" = \"#9e9e9e\",\n  \"Luxembourg\" = \"#f5c710\",\n  \"Netherlands\" = \"#2297e6\",\n  \"Sweden\" = \"#cd0bbc\"\n)\n\ncountry_shapes <- c(\n  \"Austria\" = 17,\n  \"Belgium\" = 16,\n  \"Denmark\" = 15,\n  \"Finland\" = 16,\n  \"Germany\" = 18,\n  \"Luxembourg\" = 1,\n  \"Netherlands\" = 0,\n  \"Sweden\" = 16\n)\n\n\ncountry_linetypes <- c(\n  \"Austria\" = \"dotted\",\n  \"Belgium\" = \"longdash\",\n  \"Denmark\" = \"solid\",\n  \"Finland\" = \"dotdash\",\n  \"Germany\" = \"dotdash\",\n  \"Luxembourg\" = \"solid\",\n  \"Netherlands\" = \"dashed\",\n  \"Sweden\" = \"dashed\"\n)\n\n\nTo replicate the graph is really straightforward as we only have two represent the lines and points using geom_line() and geom_point respectively, assign the line types, shape types and colors for each country.\n\n\nggplot(RD_c1, aes(x = year, y = value, color = country, shape = country, \n                  linetype = country)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw() +\n  scale_x_continuous(breaks = RD_c1$year, labels = RD_c1$year) +\n  scale_y_continuous(breaks = c(1.20, 1.25, 1.30, 1.35)) +\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), \n        axis.title.x = element_blank()) +\n  ylab(\"h\") +\n  scale_color_manual(values = country_colors) +\n  scale_shape_manual(values = country_shapes) +\n  scale_linetype_manual(values = country_linetypes)+ \n  theme(legend.position = \"none\") +\n  theme(panel.border = element_rect(colour = \"black\", fill=NA, size=0.7),\n        axis.text.y = element_text(angle = 90, colour = \"black\"),\n        axis.title.y=element_text(colour=\"black\"),\n        axis.text.x = element_text(colour = \"black\")\n        )\n\n\n\nAlternative\nOne of the main issues with the graph is that there is no legend and we do not know which is country is which although it would just deleting theme(legend.position = “none”) from the previous code, although a better alternative would be representing the graph using facet_wrap and gghighlight mainly.\n\n\nlibrary(gghighlight)\n\nggplot(RD_c1) +\n  geom_line(aes(x=year, y=value, color=country, linetype = country)) +\n  geom_point(aes(x=year, y=value, color = country, shape = country)) +\n    gghighlight(use_direct_label = FALSE,\n              unhighlighted_params = list(colour = alpha(\"grey85\", 0.5), \n                                          shape=1, linetype = \"solid\")) +\n  theme_bw() +\n  scale_x_continuous(breaks = seq(min(RD_c1$year), max(RD_c1$year), by = 5)) +  \n  scale_y_continuous(breaks = c(1.20, 1.25, 1.30, 1.35)) +\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    axis.title.x = element_blank(),\n    axis.text.x = element_text(size = 8)  \n  ) +\n  ylab(\"h\") +\n  scale_color_manual(values = country_colors) +\n  scale_shape_manual(values = country_shapes) +\n  scale_linetype_manual(values = country_linetypes) +\n  facet_wrap(~country, scales = \"fixed\") +  # Facet by country\n  theme(legend.position = \"none\")+\n  theme(\n    axis.text = element_text(color=\"black\", size=7),\n    strip.text.x = element_text(face=\"bold\"),\n    plot.background = element_rect(color=\"#F4F5F1\", fill=\"#F4F5F1\"),\n    legend.position = \"none\",\n    legend.title = element_text(face=\"bold\")\n  ) + theme(strip.background = element_blank(),\n             panel.spacing=unit(1,\"lines\"))\n\n\n\n\n\n\n",
    "preview": "projects/2023/100516910/100516910_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 3264,
    "preview_height": 1536
  },
  {
    "path": "projects/2023/100481433/",
    "title": "The world is progressively embracing democracy",
    "description": "A reproduction of the Our World in Data visualization, which is based on the\nclassification and assessment of countries' political regimes by Skaaning et al. (2015).",
    "author": [
      {
        "name": "Sofia Villamil Erosa",
        "url": {}
      }
    ],
    "date": "2023-12-22",
    "categories": [
      "2023"
    ],
    "contents": "\n\nContents\nDemocracy\nDefinitions\n\nGetting the data\nBuilding the chart\nData\nStarting with the graphic\nFinal touches\n\nImproving the chart\nBuilding the new chart\n\n\nDemocracy\nThe graphic I choose shows how democracy has spread across countries, how it differs between them, and whether we are moving\ntowards a more democratic world. The variables denoted in the chart shows the number of electoral democracies in the world based\non the Lexical Index of Electoral Democracy-classification from Skaaning et al. (2015).\nThe Lexical Index definition attained from Our World in Data establishes that it is a classification system that categorizes\npolitical systems or regimes based on easily observable characteristics. It aims to avoid difficult evaluations by experts or\nresearchers and relies on its own teams to assess specific criteria. These criterions are used to identify democracies and\nnon-democracies. The index is able to track political systems over time, measured since the year 1789, and includes 242 countries.\nThe index prioritizes straightforward and objective factors, making it a tool for quick assessments and comparisons.\nDefinitions\nTypes of Democracy in the Lexical Index:\nNon-Electoral Autocracy: A political system characterized by a single entity or a small group holding power without\nelections, often with a single autocrat or ruling elite.\nOne-Party Autocracy: A system where a single political party maintains absolute control over the government, suppressing\nthe opposition and competitive elections.\nMulti-Party Autocracy without Elected Executive: A political system with multiple parties, but the executive leader is\nnot elected democratically.\nMulti-Party Autocracy: Features multiple political parties, but the political system still retains autocratic elements.\nExclusive Democracy: Inclusive of elections but excludes certain groups or individuals from political participation.\nMale Democracy: A democracy where only male citizens are allowed to participate in elections.\nElectoral Democracy: A political system with regular elections where citizens can choose their leaders, but this may not\nguarantee full democratic rights.\nPolyarchy: A comprehensive democracy with competitive elections, civil liberties, political pluralism, and broad\nparticipation.\nThese definitions reflect the categorization of political systems within the Lexical Index, based on specific characteristics and\nlevels of inclusiveness attained from Skaaning et al. (2015), with “Polyarchy” representing the highest level of democracy and\ninclusivity.\nGetting the data\nThe dataset, obtained from Our World in Data and based on research by Skaaning et al. (2015), categorizes the world’s nations\ninto democracies and autocracies. This graphic dynamically captures the shifts in these counts from 1789 through 2022, offering\ninsights into the evolving landscape of global political systems nowadays. All the data needed for this chart can be downloaded\ndirectly from the Our World in Data website in the topic Democracy\n(https://ourworldindata.org/grapher/countries-democracies-autocracies-lexical).\n\n\ndata <- read.csv(\"data_world.csv\", sep = \";\", dec = \",\")\n\n\nBuilding the chart\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n\nData\nThe data scoured from Our World in Data needed to be converted to frequency tables . The graph’s vertical axis, which I aimed to\nreplicate, utilized cumulative frequency as a metric, necessitating the data’s conversion. Subsequently, I identified and chose\nthe specific columns needed for the replication, resulting in the creation of a new data-set named df_reduced.\n\n\ndf_reduced <- data %>%\n  select(Year, Frec.Non.electoral.autocracies, Frec.One.party.autocracies,\n         Frec.Multi.party.autocracies.without.elected.executive,\n         Frec.Multi.party.autocracy, Frec.Exclusive.democracies, \n         Frec.Male.democracies, Frec.Electoral.democracies, \n         Frec.Polyarchies) \n\ncustom_order <- c(\"Frec.Non.electoral.autocracies\", \"Frec.One.party.autocracies\", \n                  \"Frec.Multi.party.autocracies.without.elected.executive\",\n                  \"Frec.Multi.party.autocracy\", \"Frec.Exclusive.democracies\",\n                  \"Frec.Male.democracies\", \"Frec.Electoral.democracies\",\n                  \"Frec.Polyarchies\")\n\n\nTo enhance accessibility and facilitate the chart-building process, I converted the new dataset into tidy data. During this\nconversion, several changes were implemented, and intervals were established for the axis.\n\n\ndf_long <- df_reduced %>%\n  pivot_longer(cols = -Year, names_to = \"Democracy_Type\", values_to = \"n\")\n\ndf_long <- df_long %>%\n  mutate(Democracy_Type = factor(Democracy_Type, levels = custom_order))\n\ninterval_x <- c(1789, 1850, 1900, 1950, 2000, 2022)\n\ninterval_y <- seq(0, 100, by = 0.2)   \n\n\nDue to each variable having an associated color. The following color vector was created for each value.\n\n\ndemocracy_colors <- c(\n  \"Frec.Non.electoral.autocracies\" = \"#d73027\",\n  \"Frec.One.party.autocracies\" = \"#f46d43\", \n  \"Frec.Multi.party.autocracies.without.elected.executive\" = \"#fdae61\", \n  \"Frec.Multi.party.autocracy\" = \"#fee090\", \n  \"Frec.Exclusive.democracies\" = \"#e0f3f8\",\n  \"Frec.Male.democracies\" = \"#abd9e9\",\n  \"Frec.Electoral.democracies\" = \"#74add1\", \n  \"Frec.Polyarchies\" = \"#4575b4\"\n)\n\n\nStarting with the graphic\nTo construct the visual representation, I utilized the geom_area function from ggplot, tailored for generating\nStacked Area Charts.\n\n\nplot <- ggplot(df_long, aes(x = Year, y = n, fill = Democracy_Type)) +\n  geom_area(alpha = 0.8, size = 0.2, aes(color = Democracy_Type)) +\n  labs(x = NULL, y = NULL, fill = NULL) +\n  scale_x_continuous(limits = c(1789, 2085), breaks = interval_x, minor_breaks = NULL) +\n  scale_y_continuous(labels = scales::percent_format(scale = 100), breaks = interval_y) +\n  scale_fill_manual(values = democracy_colors) +\n  scale_color_manual(values = democracy_colors) +\n  coord_cartesian(expand=0) +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(\n      color=\"#5b5b5b\", size = 10, family = \"Lato\", angle = 0, \n      hjust = c(0.1, 0.3, 0.5, 0.5, 0.5, 1), margin = margin(t = 0)),\n    axis.ticks.x = element_line(color=\"#5b5b5b\", size = 0.2),\n    axis.ticks.length = unit(0.1, \"cm\"),\n    legend.position = \"none\",\n    panel.grid = element_blank(),\n    axis.text.y = element_text(\n      color=\"#5b5b5b\", size = 10, family = \"Lato\", margin = margin(r = 0))\n  ) +\n  ggtitle(\n    \"Countries that are democracies and autocracies, World\", \n    subtitle = \"Political regimes based on the classification and assessment by Skaaning et al. (2015).\") +\n  theme(plot.title = element_text(\n    color=\"#5b5b5b\", family = \"serif\", size = 15, face = \"bold\", hjust = -0.27),\n        plot.subtitle = element_text(\n          color=\"#5b5b5b\", family = \"Lato\", size = 9, hjust = -0.24)\n  )\nplot\n\n\n\nI employed the intervals created during the data organization for both the x-axis and the y-axis in constructing the graphic.\nGiven that the y-axis represents frequencies in percentage, the code was modified to reflect this in the visualization. The year\nlimits were adjusted to fit the dimensions required for displaying custom labels for each democratic type. While the code’s limits\nspan from 1789 to 2085, the graphic displays the period from 1789 to 2022 on the x-axis.\nTo achieve a custom separation between each year on the x-axis, adjustments were made in the theme section, specifically in\naxis.text.x, where the spacing between each year was manually configured in order to be exactly the distance displayed\nin the graphic of reference.\nFinal touches\nI generated custom labels with corresponding colors and segments, mirroring the structure observed in the graphic that I aimed\nto replicate.\n\n\ncustom_legend <- data.frame(\n  Democracy_Type = levels(df_long$Democracy_Type),\n  x = rep(2022, length(levels(df_long$Democracy_Type))),\n  y = seq(0, 1, length.out = length(levels(df_long$Democracy_Type))),\n  label = c(\"Polyarchies\",\n            \"Electoral\\ndemocracies\",\n            \"Male\\ndemocracies\",\n            \"Exclusive\\ndemocracies\",\n            \"Multi-party\\nautocracy\",\n            \"Multi-party\\nautocracies\\nwithout elected\\nexecutive\",\n            \"One-party\\nautocracies\",\n            \"Non-electoral\\nautocracies\"\n  ),\n  label_distance = c(11, 11, 11, 21, 4, 31, 4, 8),\n  segment_distance = c(10, 10, 10, 20, 3, 30, 3, 7), \n  vertical_offset_segment = c(0.20, 0.33, 0.338, -0.16, 0.15, 0.09, 0.01, -0.04),\n  vertical_offset_label = c(0.20, 0.33, 0.338, -0.16, 0.15, 0.09, 0.01, -0.04)\n)\n\ncorrected_Democracy_Type <- rev(custom_legend$Democracy_Type)\n\n\nTo replicate the specific placement of labels and segments in the target graphic, I modified the code to permit manual\nadjustments for the angle, vertical, and horizontal placement of both text and segments. Thus, segment_distance makes\nreference to the horizontal placement of the segment and vertical_offset_segment\nis for the vertical placement.\nFurthermore, I introduced a custom legend to the plot and fine-tuned the size parameters to precisely match the dimensions of\nthe desired graphic.\n\n\nplot2 <- plot +\n  geom_text(\n    data = custom_legend,\n    aes(x = x + label_distance, \n        y = y + vertical_offset_label, \n        label = label, \n        color = corrected_Democracy_Type),\n    size = 2.5,\n    family = \"Lato\",\n    hjust = 0\n  ) +\n  geom_segment(\n    data = custom_legend,\n    aes(x = x + segment_distance, \n        xend = x + 1, \n        y = y + vertical_offset_segment, \n        yend = y + vertical_offset_segment, \n        color = \"#5b5b5b\"),\n    size = 0.5\n  ) +\n  theme(\n    plot.margin = margin(0.3, 0.3, 0.3, 0.3, \"cm\")\n  )\n\nplot2\n\n\n\nImproving the chart\nUpon careful consideration, I determined that there was no apparent need for enhancements in the replicated graphic. Consequently,\nI opted to generate a new visual representation utilizing the same dataset.\nBuilding the new chart\nIn an effort to retain as much of the original code as possible, I generated a new custom color palette to address perceived\ndeficiencies in the previous one. This adjustment was made to enhance visibility, ensuring that all colors are easily discernible.\nAdditionally, I maintained the code for creating custom labels in the process as I wanted to highlight that code and expand the\nuse of it to improve the new graphic.\n\n\ndemocracy_colors <- c(\n  \"Frec.Non.electoral.autocracies\" = \"#081d58\",\n  \"Frec.One.party.autocracies\" = \"#253494\",\n  \"Frec.Multi.party.autocracies.without.elected.executive\" = \"#225ea8\",\n  \"Frec.Multi.party.autocracy\" = \"#41b6c4\",\n  \"Frec.Exclusive.democracies\" = \"#7fcdbb\",\n  \"Frec.Male.democracies\" = \"#c7e9b4\",\n  \"Frec.Electoral.democracies\" = \"#1d91c0\",\n  \"Frec.Polyarchies\" = \"black\"\n)\ncustom_legend <- data.frame(\n  Democracy_Type = levels(df_long$Democracy_Type),\n  x = rep(2022, length(levels(df_long$Democracy_Type))),\n  y = seq(0, 1, length.out = length(levels(df_long$Democracy_Type))),\n  label = c(\n    \"Polyarchies\",\n    \"Electoral democracies\",\n    \"Male democracies\",\"Exclusive democracies\",\n    \"Multi-party autocracy\",\n    \"Multi-party autocracies without elected executive\",\n    \"One-party autocracies\",\n    \"Non-electoral autocracies\"\n  ),\n  label_distance = c(3, -20, 3, 3, -60, -220  , 3, -220),\n  vertical_offset_label = c(0.38, 0.17,-0.28, -0.27, -0.59, -0.32, -0.76, 0)\n)\n\ncorrected_Democracy_Type <- rev(custom_legend$Democracy_Type)\n\n\nThe chosen type of chart for improvements was a Parallel Plot utilizing the geom_line function from ggplot. I chose this\napproach as it provides a clearer representation of the evolution of each democracy type throughout the analysis period.\nIn trying to create the new graphic, I aimed for a fresh look while retaining the essence of the original one I sought to\nreplicate. To achieve this, I employed much of the existing code I had created for the previous graphic. Additionally, I\nintroduced some modifications to add distinctive elements that I deemed necessary, resulting in a new and improved interpretation\nof the same data set.\n\n\nplot_parallel_custom <- ggplot(df_long, aes(x = Year, y = n, color = Democracy_Type)) +\n  geom_line(aes(group = Democracy_Type), alpha = 0.8, size = 1) +\n  scale_x_continuous(limits = c(1789, 2065), breaks = interval_x, minor_breaks = NULL) +\n  scale_y_continuous(labels = scales::percent_format(scale = 100), breaks = interval_y) +\n  geom_text(\n    data = custom_legend,\n    aes(x = x + label_distance, \n        y = y + vertical_offset_label, \n        label = label, \n        color = corrected_Democracy_Type),\n    size = 2.8,\n    family = \"Playfair Display ExtraBold\",\n    hjust = 0) +\n  scale_color_manual(values = democracy_colors) +\n  labs(\n    x = \"Years\",\n    y = \"Percentage of Countries\",\n    title = \"Countries that are democracies and autocracies, World.\",\n    subtitle = \"Political regimes based on the classification and assessment by Skaaning et al. (2015).\"\n  ) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_text(\n      color = \"#252525\", family = \"serif\", size = 15, face = \"bold\", \n      hjust = -0.1, vjust = 0),\n    axis.title.x = element_text(\n      color = \"#252525\", family = \"serif\", size = 12, hjust = 0.44, vjust = -1),   \n    axis.title.y = element_text(\n      color = \"#252525\", family = \"serif\", size = 12,vjust = 3), \n    plot.subtitle = element_text(\n      color = \"#252525\", family = \"Lato\", size = 9, hjust = -0.1, \n      vjust = 0, face = \"italic\"),\n    axis.text.x = element_text(\n      color = \"#5b5b5b\", size = 9, family = \"Playfair Display ExtraBold\", \n      vjust = 0 , hjust = c(0, 0, 0, 0, 0.5, 1), margin = margin(t = -9)),\n  axis.text.y = element_text(\n    color = \"#5b5b5b\", size = 9, family = \"Playfair Display ExtraBold\", \n    vjust = 0, hjust = 0, margin = margin(r = -22 )\n    )\n  ) +\n  theme(\n    plot.margin = margin(0.4, 0.4, 0.5, 0.7, \"cm\"), \n  ) +\n  guides(color = \"none\")\n\nplot_parallel_custom\n\n\n\nRecognizing the need for enhanced interpretability, I decided to include legends for both the x-axis and y-axis, making it easier\nto understand the various measures depicted in the plot. To improve readability, I made adjustments such as changing the font\ncolor to black. Moreover, I relocated the labels inside the graphic instead of just using segments, believing that this\nmodification would enhance comprehension of each type of democracy and its evolution over time.\n\n\n\n",
    "preview": "projects/2023/100481433/100481433_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2024-01-18T12:28:07+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100482711/",
    "title": "What Future for Amazon - Some Lessons from the Past",
    "description": "Evolution of Amazon Deforestation (1988 - 2021) with Basis on Inpe - Sistema PRODES Data.",
    "author": [
      {
        "name": "Artem Urlapov",
        "url": {}
      }
    ],
    "date": "2023-06-09",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nReplica\nEnhancement\nConclusion\n\nIntroduction\nShortly after 2022 Brazilian General Election, which was transcendental for a whole series of reasons: namely, Luiz Inácio Lula da Silva had not only promised ‘to unite a divided Brazil and to seek fair global trade’—turning away from Jair Bolsonaro’s divisive and populist rhetoric—, but he was also fairly adamant in his pledge to protect the Amazon, vowing ‘to crack down on illegal deforestation and rebuild relationships with countries financing the protection of the rainforest’.\nThus, observing closely the election—not least because of my own sense of concern about the environment—, I came across the following article (in Portuguese) published by BBC on November the 18th of 2021, which outlines the fact that the government of Jair Bolsonaro had registered in 2021 the largest rate of Amazon deforestation since 2006, as can be seen in the aforementioned article.\nAmazon deforestation since 2006. Source: BBC.Replica\nIn what follows, I will provide the R code in its entirety and will also comment on some of the challenges that I came across when trying to reproduce the BBC graph.\nIt must be remarked that all data needed for this task is available here.\nAs such, the full code for the replication part is, as follows:\n\n\nlibrary(readr)\nlibrary(ggplot2)\n\nAmazoniaDeforestation <- read_delim(\"AmazoniaDeforestation.csv\", delim = \";\", show_col_types = FALSE)\n\nAmazoniaDeforestation <- as.data.frame(AmazoniaDeforestation)\n\ntext <- paste(\"O governo Bolsonaro\", \"registrou o maior\", \"desmatamento\", \"desde 2006\", sep=\"\\n\")\n\nAmazonia <- ggplot(AmazoniaDeforestation, aes(x = Year, y = Total)) +\n  geom_histogram(stat = \"identity\", fill = \"turquoise4\", width = 0.5, position = position_dodge(2.5)) +\n  scale_x_continuous(breaks = c(1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2021)) +\n  scale_y_continuous(breaks = c(0, 5000, 10000, 15000, 20000, 25000, 30000)) +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  ggtitle (\"Desmatamento Anual da Amazônia em km2\") +\n  theme(plot.background = element_rect(fill = \"white\"), panel.background = element_rect(fill = \"white\")) +\n  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +\n  geom_hline(yintercept=c(5000, 10000, 15000, 20000, 25000, 30000), linetype=\"dotted\") +\n  geom_hline(yintercept = 0) +\n  annotate(\"text\", x = 2008, y = 20500, label = text, hjust=0, lineheight=1) +\n  geom_rect(aes(xmin = 2018.6, xmax = 2022, ymin = 0, ymax = 35000), fill = \"navajowhite2\", alpha = 0.01) +\n  geom_curve(aes(x = 2018, y = 17000, xend = 2021, yend = 13500), colour = \"black\",\n             arrow = arrow(length = unit(0.02, \"npc\"), type = \"open\"), curvature = -0.6) +\n  labs(caption = c(\"BBC\", \"Fonte: Inpe/Sistema PRODES\")) +\n  theme(plot.caption = element_text(hjust=c(1, 0)))\n\nAmazonia\n\n\n\nWhile I must certainly say that it has not been exceedingly hard for me to replicate the original graph, there have been some caveats here and there, nevertheless.\nIn first place, I had to address with utmost care the following line of code:\n\n\ngeom_rect(aes(xmin = 2018.6, xmax = 2022, ymin = 0, ymax = 35000), fill = \"navajowhite2\", alpha = 0.01)\n\n\nThis is because there was a risk that the chosen colour could possibly “eclipse” the colour of the bars.\nIn second place, having mentioned the colour of the bars, it took me quite a lot of time to find out which colour could most faithfully represent the bars. In the end, I ended up settling for ‘turquoise4’, as illustrated in the piece of code below:\n\n\ngeom_histogram(stat = \"identity\", fill = \"turquoise4\", width = 0.5, position = position_dodge(2.5))\n\n\nIn third place, while this may be deemed a rather inconsequential issue (though I believe that it is certainly not), I had to rigourously add the lines of text in exactly the right place—as they appear in the original graph:\n\n\ngeom_text(aes(x = 2012, y = 20500, label = \"O governo Bolsonaro\"), colour = \"black\") +\ngeom_text(aes(x = 2011.25, y = 19000, label = \"registrou o maior\"), colour = \"black\") +\ngeom_text(aes(x = 2010.9, y = 17500, label = \"desmatamento\"), colour = \"black\") +\ngeom_text(aes(x = 2010.25, y = 16000, label = \"desde 2006\"), colour = \"black\")\n\n\nPlease, note that I had to be very meticulous indeed in what to the choice of ‘x’ and ‘y’ coordinates it concerns.\nWith regard to this approach, I must say that—following Professor Iñaki Ucar’s kind suggestion—I ended up introducing a much more elegant ‘workaround’.\nThus, I first proceeded to define the text that I was going to use for the annotation, and after that I used the ‘annotate’ function:\n\n\ntext <- paste(\"O governo Bolsonaro\", \"registrou o maior\", \"desmatamento\", \"desde 2006\", sep=\"\\n\")\n\n\n\n\nannotate(\"text\", x = 2008, y = 20500, label = text, hjust=0, lineheight=1)\n\n\nIn fourth and final place, as trivial as it could possibly seem to some, I actually invested a lot of time in “getting the arrow right” in the following line of code:\n\n\ngeom_curve(aes(x = 2018, y = 17000, xend = 2021, yend = 13500), colour = \"black\",\n           arrow = arrow(length = unit(0.02, \"npc\"), type = \"open\"), curvature = -0.6)\n\n\nHere, especially, I had to be very attentive in what to “unit”, “type”, and “curvature” it refers, so that once again the obtained result could perfectly resemble the original graph.\nEnhancement\nRegarding the enhancement part, truth be told, I had a number of possible ideas in mind. On purpose of this, all credit is due to Professor Iñaki Ucar for his kind suggestions, meaningful reflections, and the time he took to discuss with me what the best outcome could be.\nAs such, I could have opted, for instance, to maintain the ‘bar structure’, while differentiating distinct time periods by means of a number of colours with basis on the colour of the ruling government at each point in time, in order to see under which government/-s deforestation was more or less prevalent.\nBut, in the end, I decided to elaborate a dynamic map of the evolution of deforestation for 1988 - 2021 period. This choice was made primarily for 2 reasons:\nNot all 9 Brazilian States have been impacted in equal measure; hence, it was—I much believe—interesting to see which ones bore more impact and which ones bore less (and also when—in time—).\nSince I had already replicated a piece of time series, I thought that it would be more challenging; hence, I would be able to learn more about Data Visualisation in R by settling for a map.\nThe code in question for the enhancement part is, as follows:\n\n\nlibrary(tidyverse) \nlibrary(gganimate)\nlibrary(sf)\nlibrary(geobr)\n\nDeforestation_Long <- \n  AmazoniaDeforestation %>%\n  select(-Total) %>%\n  pivot_longer(-Year, names_to = \"name_state\", values_to = \"Deforestated Area\") %>%\n  mutate(name_state = trimws(name_state))\n  \nAmazon <- read_amazon(showProgress = FALSE)\n\nStates <- read_state(showProgress = FALSE) %>% \n  mutate(name_state = stringi::stri_trans_general(str = name_state, id = \"Latin-ASCII\"))\n\nStates_Deforestation <- left_join(States, Deforestation_Long, by = \"name_state\") %>% \n  drop_na()\n\nDeforestation_Cumulative <- States_Deforestation %>% \n  group_by(name_state) %>% \n  mutate(\"Desmatamento Acumulado\" = cumsum(`Deforestated Area`)) %>% \n  mutate(\"Desmatamento Acumulado (%)\" = `Desmatamento Acumulado` / as.numeric(sf::st_area(geom)) * 1e6)\n\nAmazoniaStateDeforestation <- ggplot() +\n  labs(caption = \"\\n Fonte: Sistema PRODES\") +\n  geom_sf(data = st_simplify(States), colour = \"darkgrey\") +\n  geom_sf(data = st_simplify(Deforestation_Cumulative),\n          aes(fill = `Desmatamento Acumulado`, group = interaction(`Desmatamento Acumulado`, Year))) +\n  geom_sf(data = st_simplify(Amazon), colour = \"darkred\", size = 6, fill = NA) +\n  ggtitle(\"\\n Desmatamento Anual da Amazônia em km2: \\n Ano {round(frame_time)}\") +\n  scale_fill_viridis_c(option = \"D\")\n\nAnimatedMap <- AmazoniaStateDeforestation + transition_time(Year)\n\nanimate(AnimatedMap, fps = 10, nframes = 100, duration = 10)\n\n\n\nNeedless to say, the enhancement part proved to be quite more difficult for me rather than the replication part.\nNext, I will proceed to illustrate some of the challenges that I faced:\nFirst of all, it took me a while (and several attempts in the meantime) to find the right ‘library’ for Brazil. For instance, I had initially intended to visualise the 9 Brazilian States that belong to the Amazon by means of a ‘library’ called ‘brazilmaps’. Much unfortunately, I discovered that this ‘library’ in question is very much outdated, and has a very limited number of functions. But, luckily, after some rather extensive search, I managed to find a really great ‘library’ called ‘geobr’, which suited my requirements just fine.\nIn second place, as it stems quite naturally from what has been mentioned above, I had to study all the commands that are provided in this ‘library’ before proceeding to start elaborating the map: these include, for instance, ‘read_amazon’, ‘read_meso_region’ or ‘read_states’.\nIn third place, I made a mistake when it came to the function ‘trimws()’. Thus, what I did initially was to add ‘drop_na’ after ‘left_join’ in order to discard NAs. However, the correct version is, as follows:\n\n\nmutate(name_state = trimws(name_state))\n\n\nIn fourth place, I had initially used the command ‘read_meso_region’, which turned out to not be the right one; since I was very much interested in States and not Regions. Consequently, the right piece of code is this one:\n\n\nDeforestation_Cumulative <- States_Deforestation %>% \ngroup_by(name_state)\n\n\nIn fifth place, something that I did not know was that I had to use ... (‘backticks’) instead of “…” or ‘…’ in order for R to be able to recognise that I was referring to a variable. This is very much what happened to me in the two following lines of code:\n\n\nDeforestation_Cumulative <- States_Deforestation %>% \n  group_by(name_state) %>% \n  mutate(\"Desmatamento Acumulado\" = cumsum(`Deforestated Area`)) %>% \n  mutate(\"Desmatamento Acumulado (%)\" = `Desmatamento Acumulado` / as.numeric(sf::st_area(geom)) * 1e6)\n\n\n\n\nAmazoniaStateDeforestation <- ggplot() +\n  labs(caption = \"\\n Fonte: Sistema PRODES\") +\n  geom_sf(data = st_simplify(States), colour = \"darkgrey\") +\n  geom_sf(data = st_simplify(Deforestation_Cumulative),\n          aes(fill = `Desmatamento Acumulado`, group = interaction(`Desmatamento Acumulado`, Year)))\n\n\nAs such, when I had initially put “Desmatamento Acumulado”, R was not able to recognise that what I had in my mind was a variale; but it did perfectly recognise Desmatamento Acumulado, of course.\nIn sixth place, an additional problem that I encountered was that due to the update of ‘sf’ R ‘library’, the animated map was not loading, due to some incompatibility between ‘sf’ and ‘transformr’ R libraries. On purpose of this, I did manage to find a temporary workaround at the end of this GitHub post. Also, as I discovered after some rather extensive search, in order to use the previous version of ‘transformr’, it was necessary to install ‘RTools’ in first place.\nIn seventh and final place, I must say that I did somewhat struggle insofar that I intended to reach the final goal (a dynamic visualisation) instead of pausing to pay more attention to the intermediate step (making sure that I had a good static visualisation in first place). In this sense, had I done that from the beginning, I much believe that some of the aforementioned mistakes could have been avoided. But I am here to learn, after all… so, no regrets!\nConclusion\nAll in all, I am very happy with what I managed to achieve: the first (replica) part is quite faithful indeed to the original BBC graph, while the second (enhancement) part does clearly show exactly what I had intended to illustrate—the unequal impact of deforestation, namely how some Amazon States were more affected than the others in time.\nThis leads me to the logical reasoning that, if I were to give a sound economic and environmental piece of advice, then I am quite convinced that Brazil would certainly be better off by enhancing its governance (concretely, its environment protection laws) on a State—rather than Nation—level.\nThis is much because, as can be seen from the map that I elaborated, while we tend to speak of the issue of deforestation of the Amazon in general terms, the root of the problem actually lies in the fact that deforestation is—and has historically been—very much concentrated in only a handful of States out of the total number of 9 States that comprise the Amazon.\nLast but not least, I am deeply grateful to Professor Iñaki Ucar for having led me in the way of acquisition of knowledge in the sphere of Data Visualisation in R.\n\n\n\n",
    "preview": "projects/2022/100482711/100482711_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2023-06-09T10:22:53+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100392586/",
    "title": "HDI - What a time to be alive",
    "description": "Using the United Nation's Human Development Index (HDI) data to produce The Economist's map and other visualizations.",
    "author": [
      {
        "name": "Emma Perez Hernandez",
        "url": {}
      }
    ],
    "date": "2023-02-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting and cleaning data\nBasic elements\nMap and main legend\nSecond legend\n\nProjection and annotations\nProjection\nSpatial coordinates\nAnnotations\n\nFinal result\nAlternative visualization\nPreparing data\nAxes and annotations\nData\nFinal static result\nMoving the wrong direction? 1990 VS 2021\nAdding motion\nAnd finally… a GIF\n\n\nThe Economist published this map in September 2022 in order to highlight that ‘living standards are moving in the wrong direction’.\nIt is striking how most countries in the world have worsened their scores in the Human Development Index (HDI) between 2019 and 2021, which makes the map mainly red. The HDI, calculated by the United Nations since 1990, is a summary measure of average achievement in three key dimensions of human development: life expectancy, education and have a decent standard of living (income per person.)\nThe aim of this tutorial is to reproduce the map and propose an alternative visualization using the same dataset.\nHDI map. Source: The Economist.\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggthemes)\nlibrary(sf)\nlibrary(giscoR)\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(patchwork)\n\n\n\n\nsysfonts::font_add_google(\"Open Sans\", family = \"Open Sans\")\nshowtext::showtext_auto()\n\n\nGetting and cleaning data\nAll the data needed for this map can be downloaded directly from the UNDP website.\nThey provide a complete data set with the latest ranking (2021), the index value for each country since 1990 and its components. Since the map only shows the change between 2019 and 2021, I select a subset of the data to compute the growth change in the required period, the country name and the ISO3 code.\n\n\nHDI <- read.csv(\"HDR21-22_Composite_indices_complete_time_series.csv\")\n\nmy_data <- HDI %>%\n  select(country, iso3, hdi_2019, hdi_2021) %>%\n  mutate(change = ((hdi_2021 / hdi_2019) - 1) * 100) %>%\n  mutate(change = round(change, 1))\n\n\nTo draw the world map, the giscoR packaged is used to get the geographic information of each country in an sf format, which is required to use geom_sf in ggplot.\n\n\nworld <- giscoR::gisco_get_countries()\nclass(world)\n\n[1] \"sf\"         \"data.frame\"\n\nNow, the geographical information and the HDI data can be joined by the ISO3 code to form the complete dataset. This dataset must also be class sf, so I use st_as_sf to keep this format. Then, the Antarctica is removed from the final data, since this region does not appear in the original map.\n\n\n# checking that both data sets contain the same countries\nhdi_data <- HDI %>%\n  distinct(iso3) %>%\n  as_vector()\nnat_data <- world$ISO3_CODE\ndiffer <- as.data.frame(setdiff(hdi_data, nat_data))\n\nall_data <- st_as_sf(left_join(world, my_data, by = c(\"ISO3_CODE\" = \"iso3\")))\n\nall_data <- all_data %>% filter(!ISO3_CODE %in% c(\"ATA\"))\n\nsummary(all_data)\n\n   CNTR_ID           NAME_ENGL          ISO3_CODE        \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n  CNTR_NAME             FID              country         \n Length:256         Length:256         Length:256        \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n                                                         \n    hdi_2019         hdi_2021          change       \n Min.   :0.3930   Min.   :0.3850   Min.   :-5.2000  \n 1st Qu.:0.6105   1st Qu.:0.5995   1st Qu.:-1.5000  \n Median :0.7460   Median :0.7390   Median :-0.9000  \n Mean   :0.7275   Mean   :0.7206   Mean   :-0.9838  \n 3rd Qu.:0.8435   3rd Qu.:0.8350   3rd Qu.:-0.3000  \n Max.   :0.9620   Max.   :0.9620   Max.   : 2.6000  \n NA's   :65       NA's   :65       NA's   :65       \n          geometry  \n MULTIPOLYGON :134  \n POLYGON      :122  \n epsg:4326    :  0  \n +proj=long...:  0  \n                    \n                    \n                    \n\nBasic elements\nMap and main legend\nTo start with, the map is plotted by using geom_sf, which automatically interprets the geographical data.\nThe fill aesthetic is set to the variable “change”, and the proper scale fill is added to fix the same breaks and colors than The Economist. The guide for it is guide_colorsteps.\nColor is fixed in white and the size in 0.1 to generate the lines for countries’ contour.\nTheme_map is added, since it sets all chart elements in blank but for the map.\n\n\nm <- ggplot(data = all_data) +\n  geom_sf(aes(fill = change), color = \"white\", size = 0.1) +\n  scale_fill_stepsn(\n    breaks = c(-4, -2, 0, 2),\n    colors = c(\"#be0f08\", \"#f6423c\", \"#ffa9a6\", \"#a4bfd6\", \"#1e5c98\"),\n    na.value = \"#e0ded4\",\n    guide = guide_colorsteps(\n      even.steps = TRUE,\n      order = 1,\n      ticks = TRUE,\n      ticks.colour = \"black\",\n      ticks.linewidth = 1,\n      direction = \"horizontal\",\n      title = NULL,\n      draw.llim = TRUE,\n      draw.ulim = TRUE,\n      frame.color = \"black\",\n      label.theme = element_text(size = 8))) +\n  theme_map()\n\nm\n\n\n\nSecond legend\nSince the previous legend does not show the missing values, another legend has to be configured for them. To do so, I get a very small region (Gibraltar), and add it as another map layer with color aesthetic in blank. For this aes, a scale color is defined in which a guide_legend is added specifying the proper color in the override.aes argument.\n\n\nGibraltar <- all_data %>% filter(ISO3_CODE == \"GIB\")\n\nm <- m + geom_sf(data = Gibraltar, aes(color = \"\")) +\n  scale_color_discrete(guide = guide_legend(\n    axis = FALSE,\n    label = FALSE,\n    title = \"No data\",\n    title.position = \"right\",\n    title.vjust = 0.5,\n    title.hjust = 0,\n    title.theme = element_text(\n      size = 8,\n      color = \"grey50\"),\n    override.aes = list(color = \"#e0ded4\", fill = \"#e0ded4\"),\n    order = 2,\n    direction = \"horizontal\"))\nm\n\n\n\nNow that we have both legends, we adjust them with themeoptions to place them in their correct positions and with the same spaces in between\n\n\nm <- m + theme(\n  legend.position = c(0.63, 0.95),\n  legend.key = element_rect(color = \"white\"),\n  legend.key.height = unit(2.2, \"mm\"),\n  legend.key.width = unit(4.7, \"mm\"),\n  legend.margin = margin(0, 0, 0, 0),\n  legend.direction = \"horizontal\",\n  legend.box = \"horizontal\",\n  legend.spacing = unit(4.7, \"mm\"),\n  legend.spacing.y = unit(1, \"mm\"),\n  legend.background = element_blank())\nm\n\n\n\nProjection and annotations\nTo add the black points placed in the center of each of the countries annotated, we can filter them from the\ndataset and get their geographical centers with st_point_on_surface\nAnother dataframe is created for Australia\n\n\npoints <- all_data %>% filter(ISO3_CODE %in% c(\"LBN\", \"BGD\", \"VEN\", \"NAM\"))\ncountries_center <- st_point_on_surface(points)\n\naustralia <- all_data %>% filter(ISO3_CODE == \"AUS\")\n\n\nThen, we can add them in two different layers\n\n\nm <- m + geom_sf_text(\n  data = australia, aes(label = paste(NAME_ENGL, \"1.1\")),\n  size = 2.5,\n  color = \"#1e5c98\") +\n  geom_sf(data = countries_center, size = 0.5)\n\nm\n\n\n\nProjection\nTo this point, all the geographic information available in our dataset has been used, but the map does not look the same than the original because by default the projection used by geom_sf is the standard latitude and longitude coordinates.\nSince the one used by The Economist is the Robinson projection, the coordinate system of the map has to be changed in accordance.\n\n\nm <- m +\n  coord_sf(crs = st_crs(\"+proj=robin\"))\n\nm\n\n\n\nSpatial coordinates\nAfter changing the projection, all the following annotations must be in the same Coordinate Reference System, so a new sf object is created with the standard coordinates (latitude and longitude) of each country to be annotated and other for the end of the segment linked to it. Then, they are transformed to the Robinson projection.\n\n\nlebanon <- st_sfc(st_point(c(35.49, 33.9)), crs = 4326)\nlebanon <- st_transform(lebanon, \"+proj=robin\")\nlebanon_end <- st_sfc(st_point(c(-14, 33.9)), crs = 4326)\nlebanon_end <- st_transform(lebanon_end, \"+proj=robin\")\n\nnamibia <- st_sfc(st_point(c(17.7, -23)), crs = 4326)\nnamibia <- st_transform(namibia, \"+proj=robin\")\nnamibia_end <- st_sfc(st_point(c(8, -23)), crs = 4326)\nnamibia_end <- st_transform(namibia_end, \"+proj=robin\")\n\nvenezuela <- st_sfc(st_point(c(-65, 6.5)), crs = 4326)\nvenezuela <- st_transform(venezuela, \"+proj=robin\")\nvenezuela_end <- st_sfc(st_point(c(-85, 6.5)), crs = 4326)\nvenezuela_end <- st_transform(venezuela_end, \"+proj=robin\")\n\nbangladesh <- st_sfc(st_point(c(90, 23.7)), crs = 4326)\nbangladesh <- st_transform(bangladesh, \"+proj=robin\")\nbangladesh_end <- st_sfc(st_point(c(130, 23.7)), crs = 4326)\nbangladesh_end <- st_transform(bangladesh_end, \"+proj=robin\")\n\n\nAnnotations\nWith the elements above, segments and text annotations can be put in place using annotate. The name and the change value of each country are used as labels, and their corresponding colors are also added.\n\n\nm <- m + annotate(\"segment\",\n  x = lebanon[[1]][1], y = lebanon[[1]][2],\n  xend = lebanon_end[[1]][1], yend = lebanon_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = lebanon_end[[1]][1], y = lebanon_end[[1]][2],\n    label = \"Lebanon -5.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = namibia[[1]][1], y = namibia[[1]][2],\n    xend = namibia_end[[1]][1], yend = namibia_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = namibia_end[[1]][1], y = namibia_end[[1]][2],\n    label = \"Namibia -3.8\",\n    hjust = 1.05,\n    color = \"#f6423c\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = venezuela[[1]][1], y = venezuela[[1]][2],\n    xend = venezuela_end[[1]][1], yend = venezuela_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = venezuela_end[[1]][1], y = venezuela_end[[1]][2],\n    label = \"Venezuela -4.2\",\n    hjust = 1.05,\n    color = \"#be0f08\",\n    size = 2.5) +\n  annotate(\"segment\",\n    x = bangladesh[[1]][1], y = bangladesh[[1]][2],\n    xend = bangladesh_end[[1]][1], yend = bangladesh_end[[1]][2], size = 0.5) +\n  annotate(\"text\",\n    x = bangladesh_end[[1]][1], y = bangladesh_end[[1]][2],\n    label = \"Bangladesh 2.6\",\n    hjust = -0.05,\n    color = \"#1e5c98\",\n    size = 2.5)\n\nm\n\n\n\nFinal result\nLastly, adding the proper title, subtitle and caption, and placing them in the same positions, the final map is achieved. The font used is “Open Sans”, which can be downloaded from Google Fonts.\n\n\nm + labs(\n  title = \"What a time to be alive\",\n  subtitle = \"Change in UN Human Development Index, 2019-21, %\",\n  caption = \"Source: United Nations\") +\n  theme(\n    plot.title = element_text(\n      face = \"bold\",\n      family = \"Open Sans\",\n      size = 8,\n      hjust = 0.14,\n      margin = margin(10, 0, 5, 0)),\n    plot.title.position = \"panel\",\n    plot.subtitle = element_text(\n      size = 8,\n      family = \"Open Sans\",\n      hjust = 0.195,\n      margin = margin(0, 0, 1, 0)),\n    plot.caption = element_text(\n      size = 6.5,\n      family = \"Open Sans\",\n      hjust = 0.14,\n      color = \"grey50\",\n      margin = margin(0, 0, 0, 0)),\n    plot.caption.position = \"panel\")\n\n\n\nAlternative visualization\nThe Economist’s map shows just a narrow time span of the evolution of living standards, and it does not allow to see which areas are better off worldwide either. Since the data provided by UN does contain all this information, I want to produce a chart that convey regional disparities and temporal evolution.\nAdditionally, as the HDI index is also produce separately for men and women, it is possible to compute the difference between them for each country and year (if available). In this way, a measure of the gender gap is generated as HDI male - HDI female, whose evolution in time can also be tracked. In this way, a gender perspective is added to the alternative visualization.\nPreparing data\nThe UN’s dataset is in a wide format, with years added to the name of each variable, having more than 1000 columns.\nIn order to produce a tidy dataset with only the required information, I compute it by joining 3 different sub dataframes (main index, male and female) by country and year.\n\n\nHDI <- HDI %>% rename(ranking_2021 = hdi_rank_2021)\n\np <- HDI %>%\n  select(matches(\"^(hdi)(_)([0-9]+)$\"), iso3, country, ranking_2021, region, hdicode) %>%\n  pivot_longer(contains(\"hdi_\"),\n    names_sep = \"_\",\n    names_to = c(\"hdi\", \"year\"), values_to = \"value\"\n  )\n\n\nf <- HDI %>%\n  select(contains(\"hdi_f\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_f\") %>%\n  mutate(year = str_remove(year, \"hdi_f_\"))\n\nm <- HDI %>%\n  select(contains(\"hdi_m\"), country) %>%\n  pivot_longer(contains(\"hdi_\"), names_to = c(\"year\"), values_to = \"hdi_m\") %>%\n  mutate(year = str_remove(year, \"hdi_m_\"))\n\nhditotal <- left_join(p, m, by = c(\"year\" = \"year\", \"country\" = \"country\"))\nhditotal <- left_join(hditotal, f, by = c(\"year\" = \"year\", \"country\" = \"country\"))\n\n\nOnce the data is ready, I generate the gender gap variable and convert year to numeric.\nIn addition, I remove the observations related to aggregated areas () and create a Region variable based on the original one used to classify developing regions, where missing values correspond to developed countries.\n\n\nhditotal <- hditotal %>%\n  mutate(\n    f_m_diff = hdi_m - hdi_f,\n    year = as.numeric(year)\n  ) %>%\n  filter(!startsWith(iso3, \"ZZ\")) %>%\n  mutate(Region = case_when(\n    region == \"AS\" ~ \"Arab States\",\n    region == \"EAP\" ~ \"East Asia & Pacific\",\n    region == \"ECA\" ~ \"Europe & Central Asia\",\n    region == \"LAC\" ~ \"Latin America & Caribbean\",\n    region == \"SA\" ~ \"South Asia\",\n    region == \"SSA\" ~ \"Sub-Saharan Africa\",\n    TRUE ~ \"Developed\"))\n\n\nAxes and annotations\nTo start with, I create a vector with the different levels of HDI according to UNDP, which will be used to mark the Y axis.\n\n\nhdi_levels <- c(0.5, 0.7, 0.8, 1)\nhdi_text_levels <- c(\"Low\", \"Medium\", \"High\", \"Very High\")\n\n\nThe axes are fix in a way that maximize the ink ratio, so I first analyze the range of the variables to be displayed in all available years\n\n\nrange(hditotal$value, na.rm = TRUE)\n\n[1] 0.216 0.962\n\nrange(hditotal$f_m_diff, na.rm = TRUE)\n\n[1] -0.0373798  0.2707924\n\nThe year 1990 is selected to create the static plot. The Y axe starts in 0.2 since is the lowest value achieved by HDI, and maximum 1.\nThe X axis’ limits allow to show the maximum and minimum values of HDI Gender Gap.\n\n\na <- hditotal %>%\n  filter(year == 1990) %>%\n  ggplot() +\n  scale_y_continuous(limits = c(0.2, 1), breaks = hdi_levels) +\n  scale_x_continuous(limits = c(-0.08, 0.28), expand = c(0, 0)) +\n  xlab(\"HDI Gender gap\") +\n  ylab(\"Human Development Index (HDI)\")\na\n\n\n\nNotice that countries in which women are better off than men have a negative value, so they will appear on the left size of 0. To highlight this fact, I add a dashed line in 0. I also add dashed lines in each of the levels of HDI to differentiate them clearly. Additionally, I add an annotation showing the corresponding level under the dashed line. To do so, I specify its position just two decimals below the HDI level mark.\n\n\nhdi_pos_levels <- c(0.48, 0.68, 0.78, 0.98)\n\na <- a + geom_hline(yintercept = c(0.5, 0.7, 0.8, 1), linetype = \"dashed\", color = \"grey\") +\n  geom_vline(xintercept = c(0), linetype = \"dashed\", color = \"grey50\") +\n  annotate(\"text\",\n    y = hdi_pos_levels, x = -0.08,\n    color = \"darkgray\", vjust = 1.3, hjust = 0, size = 3.5,\n    label = hdi_text_levels)\na\n\n\n\nSince I want the background to be blank and other visual details differently, I adjust the elements in theme in accordance.\n\n\na <- a + theme(\n  text = element_text(family = \"Open Sans\"),\n  axis.line.y = element_blank(),\n  axis.line.x = element_line(color = \"gray50\"),\n  axis.ticks = element_blank(),\n  axis.text = element_text(size = 9),\n  axis.title = element_text(size = 9),\n  axis.text.y.left = element_text(margin = margin(10, 10, 10, 10)),\n  panel.grid.major.x = element_line(linetype = 1, color = \"grey\", size = 0.05),\n  panel.grid.minor = element_blank(),\n  panel.background = element_blank())\na\n\n\n\nNow, I add the year we are referring to in a new geom_text layer.\n\n\na <- a + geom_text(aes(0.24, 0.9, label = as.factor(year)), size = 8.5, color = \"gray\")\na\n\n\n\nData\nWe are ready to add the data. In order to show the situation of each country in each year, I will generate a scatter plot with using geom_jitter, in which the aesthetics are set as follows:\n- Human Development Index value for the given year mapped to position Y\n- HDI Gender Gap mapped to position X\n- HDI female for the given year mapped to size\n- Development region mapped to color (hue)\n\n\na <- a + geom_jitter(aes(y = value, x = f_m_diff, color = Region, size = hdi_f), alpha = 0.6)\na\n\n\n\nSince I want to adjust the color palette and the elements of the legends, I add scale_color_brewer for the color, and scale_size_area for the bubbles’ size.\nIn them, I set the legends options with guide_legend and make bigger color points and title adjustments.\n\n\na <- a +\n  scale_color_brewer(\n    palette = \"Set1\",\n    guide = guide_legend(\n      title = \"Region\",\n      override.aes = list(size = 5),\n      direction = \"vertical\",\n      title.vjust = 1,\n      title.hjust = 0,\n      title.position = \"top\",\n      order = 2,\n      label.theme = element_text(size = 7))) +\n  scale_size_area(\n    breaks = c(0.2, 0.5, 0.7, 0.8, 1),\n    guide = guide_legend(\n      title = \"HDI female\",\n      title.vjust = 1,\n      title.hjust = 0.5,\n      title.position = \"top\",\n      direction = \"vertical\",\n      label.position = \"right\",\n      order = 1))\n\na\n\n\n\nAdding title, subtitle and caption\n\n\na <- a + labs(\n  title = \"Human Development Index and Gender gaps\",\n  subtitle = \"Gender gap =  HDI male - HDI female\",\n  caption = \"Source: United Nations\")\na\n\n\n\nFinal static result\nTweaking legend and titles’ details to fix their sizes and background\n\n\na <- a + theme(\n  plot.title = element_text(face = \"bold\", size = 10),\n  plot.caption = element_text(size = 7.5, hjust = 0, color = \"grey50\"),\n  plot.subtitle = element_text(face = \"italic\", size = 9),\n  plot.title.position = \"plot\",\n  plot.caption.position = \"plot\",\n  legend.key = element_blank(),\n  legend.direction = \"v\",\n  legend.title = element_text(size = 8))\na\n\n\n\nFinally, it is worth annotating the countries which are outliers or have interesting positions in the plot. To do so, I select a bunch of countries and save them in a vector. Them, I filter the dataset to get this names along with its data in 1990. Finally, I add a new geom_text\n\n\ncountries <- c(\"Spain\", \"Afghanistan\", \"China\", \"Yemen\", \"India\", \"Niger\", \"Uruguay\")\n\nlabels1990 <- hditotal %>% filter(country %in% countries, year == 1990)\n\na_lab <- a + geom_text(\n  data = labels1990, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3) \n\na_lab\n\n\n\nMoving the wrong direction? 1990 VS 2021\nHaving the chart for 1990 ready, we can reproduce it for different years using %+% to use the whole data set and filtering the desired year. I create the static chart for 2021 like this\n\n\nd <- a %+% (hditotal %>% filter(year == 2021))\n\nlabels2021 <- hditotal %>% filter(country %in% countries, year == 2021)\n\nd_lab <- d + geom_text(\n  data = labels2021, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3)\n\nd_lab\n\n\n\nPlacing both years together, we can see the changes produced in 30 years of evolution:\nMuch more countries in the “Very High” HDI area\nLess Y dispersion: concentrated in the top par, implying higher HDI in general\nLess X dispersion: most countries between 0 an 0.1 HDI gender gap, with some outliers\nMany more countries at the left side of 0, implying better liver standards for women than for men\nLess very small bubbles: in general, HDI female has risen worldwide\nGreat movement up of the two most populated countries (China, India)\nLow HDI area: Sub-Saharan countries + those with highest gender gap in 2021\n\n\na_lab + (d_lab +plot_layout(guides=\"keep\")) + plot_layout(guides=\"collect\")\n\n\n\nAdding motion\nThe main goal of this visualization is to show historical evolution taking advantage of the time series availability in UNDP data.\nTo achieve that, I use plotly to add the variable year as a frame aesthetic used to add animation.\nIn order to have the labels for all years, I do the same than for 1990 but without filtering for 1990. Then, I add the geom_text as before and save it with a new name (b). Additionally, I set scale_x_continuous(limits = c(-0.08, 0.28)) which replaces the previous one, in which expand was fixed to 0. Now, since plotly does not keep much of the formatting, I allow for more space to keep visible all the elements.\n\n\nall_labels <- hditotal %>% filter(country %in% countries)\n\nb <- a + geom_text(\n  data = all_labels, aes(y = value, x = f_m_diff, label = country),\n  check_overlap = TRUE,\n  size = 3\n) + scale_x_continuous(limits = c(-0.08, 0.28))  \n\n\nBy using %+% hditotal we switch to use the whole data set\n\n\nggplotly(b %+% hditotal + aes(frame = year),\n  width = 750, height = 550,\n  dynamicTicks = FALSE) \n\n\n\nAnd finally… a GIF\nThe package gganimate also allows us add a different kind of motion. It keeps all formatting much better than ggplotly, showing clearly how regions have evolved over the past 30 years, converging towards higher levels of human development (moving up) and reducing the HDI gender gap (moving to the left).\nAs before, we have to use the whole data set. I create a new object for that (c). We also have to add two more lines specific of this package in which we specify the transition time and the way in which it moves.\n\n\nc <-  b %+% hditotal\n\nc <- c +\n  transition_time(as.integer(year)) +\n  ease_aes(\"linear\")\n\n\nNow we just use animate\n\n\n# sizes fit better with this option in the gif\nshowtext::showtext_opts(dpi=96)\nanimate(c, height = 400, width = 600)\n\n\n\n\n\n\n",
    "preview": "projects/2022/100392586/100392586_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100470958/",
    "title": "Satellite images defy economic data of authoritarian regimes",
    "description": "Highly customized dumbbell chart that compares official GDP against\nsatellite-based estimation of GDP, across 103 countries.",
    "author": [
      {
        "name": "Freddy Andrés Camargo",
        "url": {}
      }
    ],
    "date": "2023-02-02",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData collection\nVisualization assembly\nThe grid\nData layer\nScales\nAppereance\nLegend\nAnnotations\n\nAlternative\n\nSatellite images of the brightness of the earth, also called nighttime lights data (NTL, from the US Air Force’s Defense Meteorological Satellite Program), have been used as a proxy for economic activity. Luis R. Martínez, professor at the Harris School of Public Policy at the University of Chicago, not only developed a model to calculate the GDP of every country based in the NTL data set, but he also found that countries with less political rights and civil liberties report overestimated GDP. The goal of this article is to rebuild a chart designed by The Economist to show the magnitude of this finding.\nThe Economist’s chartData collection\nThe data includes different records per country: the GDP from World Bank, the GDP estimated based on NTL, and the yearly growth of each one between 2002 and 2021. In addition, it includes the status in the Freedom in the World Index 2021, published by Freedom House, which classifies each country in three categories (Free, Partly Free, and Not Free). Finally, the population is incorporated, because for visualization purposes the chart only shows countries with more than 5 million population. Mr. Martínez provided me the projections of the NTL model, after contacting him by email.\n\n\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(ggrepel)\nlibrary(tidyverse)\nlibrary(patchwork)\n\n\nLet’s see how the data looks like:\n\n\nDF <- read.csv(\"economist.csv\")\n\n\n\nCountry.Name\nYear\nGDP. growth.LCU.R\nGDP.in. 2015.USD.R\nGDP.growth. LCU.adjExag.NTL\n1\nLibya\n2021\n31\n60910775962\n20\n2\nYemen, Rep.\n2021\n-2\n33429671860\n-2\n3\nZimbabwe\n2021\n6\n20562359266\n4\n4\nGreece\n2021\n8\n200827546085\n8\n5\nLebanon\n2021\n-11\n30979755568\n-11\n\n\n\n\n\n\n\nGDP.in. 2015.USD.NTL\nGDP.var.R\nGDP.var.NTL\nFIW.Status\nPopu.2021\n\n36634943488\n8.73\n-34.61\nNF\n6958538\n\n29289246720\n-25.33\n-34.58\nNF\n30490639\n\n15954965504\n10.36\n-14.36\nNF\n15092171\n\n197563367424\n-7.88\n-9.38\nF\n10664568\n\n26433470464\n11.82\n-4.59\nPF\n6769151\nVisualization assembly\nThe grid\nThe chart emphasizes the importance of the Y-axis, which shows percentage change in GDP. The X-axis doesn’t include a new variable. We just order the countries from lowest to highest GDP growth. We add 3 facets that correspond to the categories in the Freedom in the World Index, assigning a color to each one.\n\n\nc <- ggplot(DF, aes(x = order, y = GDP.var.NTL, xend = order, \n                    yend = GDP.var.R, color = FIW.Status)) +\n  facet_wrap(~ factor(FIW.Status, levels = c(\"F\", \"PF\", \"NF\")))\n\nc\n\n\n\nData layer\nWe want to draw a vertical dumbbell chart. As a consequence, we specify two sets of coordinates in the Y-axis, one for the GDP-NTL growth, and the other for the GDP-official growth. In order to connect both points, we add a segment that evidences how big is the distance between them. Then, we create a dumbbell per country.\nWe scale the size of each point to show the size of the economy, according to the respective methodology. In the beginning, we create a horizontal reference line where Y is equal to 0, below the data points.\n\n\nc <- c + \n  geom_hline(yintercept = 0, linewidth = 0.25) +\n  geom_segment() +\n  geom_point(aes(xend = order, y = GDP.var.R, size = GDP.in.2015.USD.R/1e+12), \n             shape = 21, fill = \"#C7C5BD\", color = \"white\") +\n  geom_point(aes(size = GDP.in.2015.USD.NTL / 1e+12, fill = FIW.Status), \n             shape = 21, color = \"white\") \n\nc\n\n\n\nScales\nWe adjust manually the bubbles colors, according to the freedom categories. However, as we defined a point shape that allows us to specify a border color (# 21), we see that each point has a border color ‘white’ to facilitate the distinction between countries.\nWe adapt the size, to highlight largest economies, but keeping visible the smallest with the help of the range argument. In addition, we define the breaks for the size scale.\nThe Y-axis has breaks for every 50 percentage points in a range between -50 and 450. Note that this axis is placed on the right. Furthermore, the X-axis needs an extra space for annotations.\n\n\nc <- c + scale_color_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_fill_manual(values = c(\"#FFC259\", \"#F6423C\", \"#FFA9A6\")) +\n  scale_size(range = c(1, 12), breaks = c(0.1, 2, 10), \"GDP in 2021, $trn†\") + \n  scale_y_continuous(\n    position = \"right\",\n    limits = c(-50, 450),\n    n.breaks = 10,\n    expand = expansion(0)\n  ) +\n  lims(x = c(0.5, 46)) \n\nc\n\n\n\nAppereance\nThe Economist’s chart has a minimalist and clean design. We use the correspondent theme provided by the “ggthemes” library, as a base. It is required to include many theme adjustments to conclude the design. As an important piece of the visual aspect, we incorporate the “PT Sans” font type to make the chart more light and stylized.\n\n\nsysfonts::font_add_google(\"PT Sans\")\nshowtext::showtext_auto()\n\n\nWe assign a white background, and remove the divisions between facets, as well as its titles, to integrate the canvas. Observe that we reduce the grid linewidth and change its color, to highlight the dumbbells. Now, the bottom line is not a frame of the chart.\n\n\nc <- c + \n  theme_economist_white() + \n  theme(\n    plot.background = element_rect(fill = \"white\"),\n    panel.spacing.x = unit(0, \"cm\"),\n    strip.background = element_rect(fill = \"white\"), \n    strip.text = element_text(color = \"white\"), \n    panel.grid = element_line(color = \"ligthgray\", linewidth = 0.10), \n    axis.line.x.bottom = element_line(color = \"gray\", linewidth = 0.10),\n  )\n\nc\n\n\n\nWe remove the titles from both axis. Besides, we withdraw texts and ticks from X-axis. On the other hand, we move the legends to the top right position, saving a space for the dumbbell legend. Also we change their color to harmonize the chart. Perceive that now the Y-Axis texts are aligned with the horizontal gridlines.\n\n\nc <- c + theme(\n  axis.title.x = element_blank(), \n  axis.title.y = element_blank(), \n  axis.text.y = element_text(vjust = -0.5, color = \"#2C2E2E\"), \n  axis.text.x = element_blank(),\n  axis.ticks.x = element_blank(),\n  legend.background = element_rect(fill = \"white\"),\n  legend.position = c(0,0.85),\n  legend.direction = \"horizontal\",\n  legend.justification = c(0, 1),\n  legend.key = element_rect(fill = \"transparent\"),\n  plot.caption = element_text(hjust = 0, vjust = -1, \n                              color = \"#454545\", size = 8)\n)\n\nc\n\n\n\nLegend\nWe take out the fill and size legends. But most importantly, we adjust the position of the legend title of the size. What’s more, we create an additional chart to represent the dumbbell legend. Later, we add it to the main chart as an inset.\n\n\nc <- c + guides(color = FALSE, fill = FALSE, \n                size = guide_legend(title.position = \"top\"))\n\nz <- data.frame(\n  name = c(\"Satelite-based\\n estimate\"),\n  x = c(3), y = c(5)\n)\n\nv <- data.frame(\n  name = c(\"Reported\"),\n  x = c(3), y = c(7)\n)\n\npinset <- ggplot(z, aes(x, y)) +\n  geom_segment(aes(x=3, xend=3, y=5, yend=7), linewidth=0.5) +\n  geom_point(size=2)+\n  geom_point(data=v,size=2, color=\"grey\")+\n  geom_text(aes(label=name), hjust= -0.1, size=4, lineheight = .5) +\n  geom_text(data=v,aes(label=name), hjust= -0.2, size=4) + \n  lims(x = c(2.9, 4), y = c(4.6, 7.3)) +\n  ggtitle(\"Change in GDP, 2002-21, %*\", ) +\n  theme_void() + \n  theme(\n    panel.background = element_rect(fill = \"white\", color=\"white\"),\n    plot.background = element_rect(fill = \"white\", color=\"white\"),\n    panel.border = element_rect(colour = \"white\", fill=NA),\n    plot.title = element_text(face = \"bold\", hjust = 0.3, size= 12, vjust = 3)\n  )\n\npinset\n\n\n\nAnnotations\nThe chart has 4 annotations types:\nText labels for a group of countries per category, including largest economies.\nCategories titles inside of each facet.\nThe average values per category.\nA brief summary of the average values for autocratic countries.\nThe caption that includes some clarifications about the chart.\nWe add the labels bringing geom_text() into play, and filtering the data set to keep those countries that we need. Note that we separate the 4 largest economies, because we place them with independent coordinates taking into account its bubble size. In addition, we include category titles.\n\n\ntitles <- data.frame(\n  labels = c(\"Free countries\", \"Partly free\", \"Not free\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = 20,\n  GDP.var.NTL = c(175, 225, 275),\n  GDP.var.R = c(170, 220, 270)\n)\n\ncountriestxt <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\", \"Australia\", \n             \"Ireland\", \"India\", \"Russia\", \"Mexico\", \"Peru\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\", \"F\", \"F\", \"PF\", \"NF\", \"PF\", \"F\"),\n  order = c(5, 11, 21, 34, 27, 35, 41, 10, 5, 34),\n  GDP.var.NTL = c(-6, 11, 25, 175, 56, 144, 159, 27, 17, 112),\n  GDP.var.R = c(-6, 11, 25, 175, 56, 144, 159, 27, 17, 112)\n  )\n\nc <- c +\n   geom_text(data = DF%>% filter(label == 1 & \n          !(Country.Name %in% c(\"Japan\", \"Britain\",\"United States\", \"China\",\n            \"Australia\", \"Ireland\", \"India\", \"Russia\", \"Mexico\", \"Peru\"))), \n            aes(label = Country.Name), color = \"#454545\",\n            vjust = 1.5, hjust = -0.1, check_overlap = T) +\n  geom_text(data= countriestxt, aes(label = labels), color=\"#454545\", hjust=0)+\n  geom_text(data = titles, aes(label = labels), fontface = \"bold\", size=4.5)\n\nc\n\n\n\nTo point out the averages, we draw a set of 3 dumbbells with a black border, and we include a label for them. Observe that we should create independent data frames, for annotations that require a specific location inside the chart. Then, we map these data frames with ggplot components.\n\n\nav_data <- DF %>% \n  group_by(FIW.Status)  %>%\n  summarise(\n    av.GDP.var.R = mean(GDP.var.R),\n    av.GDP.var.NTL = mean(GDP.var.NTL),\n    av.GDP.usd.R = mean(GDP.in.2015.USD.NTL)/1000000000000,\n    av.GDP.usd.NTL = mean(GDP.in.2015.USD.NTL)/1000000000000\n  )\n\nav_data <- av_data[c(1,3,2),]\n\naverage <- data.frame(\n  Country.Name = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  GDP.in.2015.USD.NTL = as.vector(av_data$av.GDP.usd.NTL),\n  GDP.in.2015.USD.R = as.vector(av_data$av.GDP.usd.R),\n  GDP.var.R = as.vector(av_data$av.GDP.var.R),\n  GDP.var.NTL = as.vector(av_data$av.GDP.var.NTL),\n  order= c(22,19,17),\n  colorT = c(\"grey\", \"grey\", \"grey\"),\n  colorB = c(\"#FFC259\", \"#F6423C\",\"#FFA9A6\"),\n  fill = c(\"black\", \"black\", \"black\")\n)\n\navTitles <- data.frame(\n  labels = c(\"Average\", \"Average\", \"Average\"),\n  FIW.Status = c(\"F\", \"PF\", \"NF\"),\n  order = c(20, 16, 14),\n  GDP.var.NTL = c(85, 138, 165),\n  GDP.var.R = c(80, 133, 160)\n  )\n\nc <- c +\n  geom_segment(data = average, aes(x=order, xend=order, y=GDP.var.NTL, \n                                   yend=GDP.var.R), color=\"black\") +\n  geom_point(data = average,aes(x=order, y=GDP.var.NTL, \n             size=GDP.in.2015.USD.NTL, fill=FIW.Status), \n             shape=21, color=\"black\") + \n  geom_point(data = average, aes(x=order, y=GDP.var.R, size=GDP.in.2015.USD.R), \n             shape=21, color=\"black\", fill=\"gray\") +\n  geom_text(data= avTitles, aes(label= labels), fontface = \"bold\", \n            size= 3.5, color = \"black\") \n\nc\n\n\n\nThe autocratic category summary and the caption are added. We highlight that the summary is incorporated just to one facet. It means that we should specify the level of the factor that we want to use. To conclude, we combine the inset with the “Patchwork” library, specifying the desired position.\n\n\nsumQuote <- data.frame(\n  text = \"↓ Autocratic countries reported\\nGDP growth of 147% on average.\nSatellite imagery suggests the\\ntrue figure is 76%\",\n  FIW.Status = factor(\"NF\", levels = c(\"F\", \"PF\", \"NF\")),\n  order = 0.5,\n  GDP.var.NTL = 420,\n  GDP.var.R = 420\n)\n\ncaptiontx <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate\", sep=\" \"\n            )\n\nc <- c +\n  geom_label(data = sumQuote, aes(label = text), color = \"black\", \n             size = 3, hjust = 0, vjust = 1, lineheight = .8, fill = \"white\", \n             label.size = NA, label.padding = unit(0, \"cm\")) +\n  labs(caption = captiontx) + \n  inset_element(pinset, left=0, bottom=0.83, right=0.3, top=1, align_to=\"full\")\n\nc\n\n\n\nAlternative\nAnalyzing the original chart, we can see that it has some advantages. For instance, it allows us to identify each of the 103 countries, or it separates clearly the Freedom categories. Nevertheless, we realize that the X-axis is used to create an order among dumbbells, but it doesn’t add more information. Therefore, we propose an alternative visualization that uses this axis to compare GDP values.\nIn our chart, the Y-axis shows the officialy reported GDP growth, while the X-axis illustrates the NTL-based estimate of GDP. As a result, we should expect that each country will be located in the intersection line where Y is equal to X. However, the autocratic countries are far away from this line, as their value of the officialy reported GDP.\n\n\nlineAnnotations <- data.frame(\n  labels = c(\"Countries close to this line have official GDP = NTL GDP \", \n             \"+50 pp Inflation\", \"+100 pp Inflation\", \"+200 pp Inflation\"),\n  GDP.var.R = c(340, 445,445,445),\n  GDP.var.NTL = c(353, 387, 337, 237),\n  FIW.Status = c(\"PF\", \"PF\", \"PF\", \"PF\")\n  )\n\nEcountrieslbl <- data.frame(\n  labels = c(\"Japan\", \"Britain\", \"United States\", \"China\",\"Russia\", \n             \"Turkey\", \"Mexico\", \"Philippines\", \"India\"),\n  FIW.Status = c(\"F\", \"F\", \"F\", \"NF\",\"NF\", \"NF\", \"PF\", \"PF\", \"PF\"),\n  GDP.var.R = c(-5, 10, 30, 390, 83, 179, 50, 135, 228),\n  GDP.var.NTL = c(18, 31, 58, 149, 16, 92, 4, 110, 173)\n  )\n\ncaptiontxt <- paste(\"\\n\",\n  \"*Countries with over 5m people, freedom status in 2021\",\n            \"†In 2021 $ at market exchange rates,\",\n            \"assuming reported 1992 GDP figures are accurate.\",\n            \"'PP' means Percentage Points.\",\n            sep=\" \"\n            )\n\nDF$FIW.Status <- factor(DF$FIW.Status, levels=c(\"F\", \"PF\", \"NF\"))\n\n\n\n\nggplot(DF, aes(GDP.var.NTL, GDP.var.R, fill= FIW.Status)) + \n  geom_abline(slope = 1, intercept = 0, linetype=\"dashed\") +\n  geom_abline(slope = 1, intercept = 50, linetype=2, linewidth=0.1) +\n  geom_abline(slope = 1, intercept = 100, linetype=2, linewidth=0.1) +\n  geom_abline(slope = 1, intercept = 200, linetype=2, linewidth=0.1) +\n  geom_point(aes(size=GDP.in.2015.USD.NTL/1e+12), shape=21, alpha=0.8) + \n  geom_text(data = DF%>% filter(label == 1 & (Country.Name %in% \n            c(\"Greece\", \"Australia\", \"South Korea\", \"Ghana\",\"Poland\", \n              \"Ireland\", \"Yemen, Rep.\", \"Libya\", \"Rwanda\"))), \n    aes(label = Country.Name), check_overlap = T, hjust = -0.15, vjust=1.3) +\n  geom_text(data = Ecountrieslbl, aes(label=labels), hjust=0) + \n  geom_text(data = lineAnnotations[1,], aes(label = labels), angle = 25.8, \n            fontface=\"bold\", color=\"#44B4C1\") +\n  geom_text(data = lineAnnotations[2:4,], aes(label = labels), \n            angle = 26, fontface=\"bold\", size = 4) +\n  lims(x= c(-50,450)) + \n  scale_size(range = c(1,12), breaks= c(0.1,2,10), \"GDP in 2021, $trn†\") +\n  scale_fill_manual(values=c(\"#FEC427\",\"#255D91\", \"#B41D11\"), \n    name= \"Freedom Status\", labels=c(\"Free\", \"Partly Free\", \"Not Free\")) + \n  scale_x_continuous(limits=c(-50, 450), n.breaks=10, expand=expansion(0)) +\n  scale_y_continuous(limits = c(-50, 450), n.breaks = 10) +\n  labs(x= \"NTL-estimated GDP\", y=\"Official GDP\") + \n  ggtitle(\"GDP growth, 2002-21, %*\", ) +\n  labs(caption = captiontxt) +\n  theme_minimal()+\n  theme(\n    panel.background = element_rect(fill= \"#F3F0EA\"),\n    plot.background = element_rect(fill= \"#F3F0EA\"),\n    panel.grid = element_line(linetype = 2),\n    panel.grid.major = element_line(size = 0.5, colour = \"grey\"),\n    panel.border = element_rect(color = \"#F3F0EA\", fill=NA),\n    axis.title.y =  element_text(color = \"black\"), \n    axis.text.y = element_text(color = \"black\"),\n    legend.position=c(1, 0.01),\n    legend.justification=c(1, 0),\n    legend.background = element_rect(fill=\"#F3F0EA\", color=\"#F3F0EA\"),\n    axis.line.x.bottom = element_line(color = \"#F3F0EA\"),\n    axis.line.y.left  = element_line(color = \"#F3F0EA\"),\n    plot.title = element_text(face = \"bold\", hjust = 0, size= 15, vjust = 3),\n    plot.caption = element_text(hjust = 0, color =\"#454545\", size = 8),\n    plot.margin = unit(c(10,5.5,5.5,5.5), 'pt')\n  )\n\n\n\n\n\n\n",
    "preview": "projects/2022/100470958/100470958_files/figure-html5/unnamed-chunk-12-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100462872/",
    "title": "Use of Social Media Platforms in 2021 (U.S.) by Demographic Group",
    "description": "Replication and alternative version of a heatmap from 'Social Media Use in\n2021' (Pew Research Center).",
    "author": [
      {
        "name": "Marina Sánchez Moreno",
        "url": {}
      }
    ],
    "date": "2023-01-24",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nCollection and data processing\nCollection of data\nCleaning and processing data\nStoring the new dataframe\n\nReplication: heatmap\nChanging the name and ordering X axis labels\nY axis labels order, padding and pre-faceting\nBuilding the plot: geom_tile()\nFacetting\nX axis and legend scale\nTitle, subtitle, caption and tag\nFonts and Theme\nAnnotation\n\nAlternative version: parallel coordinates\nBuilding the plots: ggparcoord()\nColor scales and theme\nPatchwork and general theme\n\nConclusions\n\nIntroduction\nThis project is based on a graph from the article “Social Media Use in 2021”,\npublished by Brooke Auxier and Monica Anderson in April, 2021. In this article,\nthe authors focus on the differences in the use of social media platforms\nthrough time (from 2012 to 2021), as well as on the differences in use in each\nplatform within different demographic groups in 2021 in the U.S.\nThe platforms under study are: YouTube, Facebook, Instagram, Pinterest,\nLinkedIn, Snapchat, Twitter, Whatsapp, TikTok, Reddit and Nextdoor. Regarding\nthe demographic groups and divided at the same time in subgroups, we find:\ngender (Men and Women), race/ethnicity (Black, White and Hispanic), age\n(18-19 y/o, 30-49 y/o, 50-64 y/o and 65+ y/o), income (<$30K, $30K-$49,999,\n$50K-$74,999 and $75K+), education (High School or less, Some College,\nCollege+) and place (Urban, Suburban and Rural), as well as the total (that\nfrom now on, we will be considering when talking about this categories).\nThe results are obtained from a survey conducted on 1502 participants.\nI found this publication worth reading since it gives some numbers to analyse\nthe real tendencies in the use of Social Media and, in some cases, disarm some\nunfounded general beliefs regarding this topic (although the scope is obviously\nlimited to one country).\nBut, let’s get visual. The plot I chose from this article is a heatmap that\nrepresents the percentage of people from several socioeconomic groups that\nactually use each platform. Here you can see the original plot:\nOriginal plotI found this plot interesting to work with since this kind of matrix\ndistribution of the elements was slightly different from the graphs we are use to\nplot and since it had many aspects to practice: the text annotation of values\ninside the matrix had different aesthetics (white and bold and black and plain),\nthe facets could be challenging and the font use seemed elaborated.\n\n\n# Load needed libraries\nlibrary(tidyverse)\nlibrary(tidytext)\nlibrary(ggtext)\n\n\nCollection and data processing\nCollection of data\nFirst, we need to download the raw data file from the original article page (we\nneed to log-in to the PEW RESEARCH CENTER website first to access the dataset\nand the documentation of the methodology). We can find the data .csv file in\nthe documentation in the GitHub folder of this project. Once we have it in our\ndirectory, we can read it and store it in “data”:\n\n\n# Collect and store raw data\ndata <- read.csv(\"./documentation/Jan 25-Feb 8, 2021 - Core Trends Survey - CSV.csv\")\n\n\nCleaning and processing data\nWhen we take a look at the data, we find a total of 89 columns and 1502 rows,\nwhere each observation represents the answers of one participant). The high\namount of columns (apart from being in wide format) is due to the fact that the\ndataset is also shared by other article (‘Mobile Technology and Home Broadband\n2021’).\nTo clean this dataframe, we need to:\nFirst, think what table we need (final output, original plot): Platforms,\ndemographic groups and percentages. Since the percentages are not in the dataset,\nwe need to compute them by using the values of the platforms and the weights\n(explained in the methodology section of the article).\nSelect the variables we need according to our previous conclusions. To\nunderstand which variables are the ones we are looking for and which values\nrepresent what, it is essential that we read carefully the documentation\n(Jan 25-Feb 8, 2021 - Core Trends Survey - Questionnaire.docx):\nSocioeconomic categories: gender, racecmb, hisp, age, educ2, usr, income\nweight: weight\nPlatforms = web1a (Twitter), web1b (Instagram), web1c (Facebook), web1d\n(Snapchat), web1e (YouTube), web1f (Whatsapp), web1g (Pinterest), web1h\n(LinkedIn), web1i (Reddit)\n\nRename platforms columns, pivot longer the platforms and create dummy\nvariables of subgroups when needed.\n\n\nclean_data <- data %>% \n  # Keeping the above mentioned columns of interest:\n  select(contains(\"racec\") | starts_with(\"hisp\") | contains(\"gender\") |\n           contains(\"educ2\") | contains(\"usr\") | contains(\"income\") |\n           contains(\"weight\") | contains(\"web\") | contains(\"age\")) %>% \n  # Rename the columns of each platform with the actual platform name:\n  dplyr::rename(Twitter = web1a, Instagram = web1b, Facebook = web1c, \n                Snapchat = web1d, YouTube = web1e, Whatsapp = web1f,\n                Pinterest = web1g, LinkedIn = web1h, Reddit = web1i,\n                TikTok = web1j, Nextdoor = web1k) %>% \n  # Select these platform columns and pivot them into two columns:\n  pivot_longer(matches(\"^[A-Z]\", ignore.case = FALSE),\n               names_to = \"Platform\", # One column for the name of the platform \n               values_to = \"YesNo\" ) %>% # Another for the values (1=Yes, 0=No)\n  transform(YesNo = as.numeric(YesNo)) %>% \n  # PLACE: Create 3 columns, one for each of the Urban/Suburban/Rural values\n  # of the usr column\n  mutate(Urban = case_when(usr == \"U\" ~ \"1\", usr != \"U\" ~ \"0\"),\n         Suburban = case_when(usr == \"S\" ~ \"1\", usr != \"S\" ~ \"0\"),\n         Rural = case_when(usr == \"R\" ~ \"1\", usr != \"R\" ~ \"0\"),\n         USR_nas = case_when(usr == \" \" ~ \"1\", usr != \" \" ~ \"0\")\n  ) %>% \n  # AGE: Create 4 columns, one for each of the age ranges of the graph\n  # (from age column)\n  mutate(X18_29 = case_when(age <= 29 ~ 1),\n         X30_49 = case_when(age <= 49 & age >= 30 ~ 1),\n         X50_64 = case_when(age >= 50 & age <= 64 ~ 1),\n         X65. = case_when(age >= 65 & age <= 97 ~ 1)) %>% \n  # EDUCATION: Create 3 columns, one for each of the education ranges of the graph\n  # (from educ2 column)\n  mutate(HS_or_less = case_when(educ2 == 1 ~ 1 ,educ2 == 2 ~ 1, educ2 == 3 ~ 1),\n         Some_College = case_when(educ2 == 4 ~1, educ2 == 5 ~1),\n         College = case_when(educ2 == 6 ~1, educ2 == 7 ~1, educ2 == 8 ~1 )) %>% \n  transform(Urban = as.numeric(Urban), Suburban = as.numeric(Suburban),\n            Rural = as.numeric(Rural), USR_nas = as.numeric(USR_nas)) \n\n\nCompute the percentage of each demographic subgroup by:\n\n\n# Calculating the percentages displayed in the graph\n\n# Function to generate the percentage per category (including weights)\nperc <- function(weight, ind_yesno, ind_var) {\n  round(sum(ind_yesno * ind_var * weight) / sum(ind_var * weight) * 100)\n}\n\nclean_data <- clean_data %>%\n  group_by(Platform) %>%\n  summarise(\n    # TOTAL: Percentage of people in the sample that uses sometimes each platform \n    Total    = perc(weight, YesNo==1, rep(1, n())),\n    # GENDER: Create 2 columns, one for each of the gender categories of the graph\n    # (from gender column)\n    Men      = perc(weight, YesNo==1, gender==1),\n    Women    = perc(weight, YesNo==1, gender==2),\n    # RACE: Create 3 columns, one for each of the race groups of the graph\n    # (from racecmb and hisp columns)\n    White    = perc(weight, YesNo==1, racecmb==1 & hisp!=1),\n    Black    = perc(weight, YesNo==1, racecmb==2 & hisp!=1),\n    Hispanic = perc(weight, YesNo==1, hisp==1),\n    # AGE\n    X18_29   = perc(weight, YesNo==1, !is.na(X18_29)),\n    X30_49   = perc(weight, YesNo==1, !is.na(X30_49)),\n    X50_64   = perc(weight, YesNo==1, !is.na(X50_64)),\n    X65.     = perc(weight, YesNo==1, !is.na(X65.)),\n    # INCOME: Create 4 columns, one for each of the income ranges of the graph\n    # (from income column)\n    `Income_30K`        = perc(weight, YesNo==1, income <= 3),\n    `Income_30K_49.999` = perc(weight, YesNo==1, (income <= 5 & income > 3)),     \n    `Income_50K_74.999` = perc(weight, YesNo==1, income == 6),\n    `Income_75K`        = perc(weight, YesNo==1, (income > 6 & income <= 9)),\n    # EDUCATION\n    HS_or_less          = perc(weight, YesNo==1, !is.na(HS_or_less)),\n    Some_College        = perc(weight, YesNo==1, !is.na(Some_College)),\n    College             = perc(weight, YesNo==1, !is.na(College)),\n    # PLACE\n    Urban    = perc(weight, YesNo==1, Urban==1),\n    Suburban = perc(weight, YesNo==1, Suburban==1),\n    Rural    = perc(weight, YesNo==1, Rural==1) \n  )\n\n\nStoring the new dataframe\nFor future work, it may be convenient to save the new clean and organised\ndataframe: write_csv(clean_data, \"clean_data.csv\").\nReplication: heatmap\nChanging the name and ordering X axis labels\nBefore creating the heatmap, we need to fix some aspects like the names of the\ncolumns. In some cases R has changed the names for dealing with white spaces\nand numbers at the beginning (“X18_19”, “HS_or_less”…). Also, we can order\nnow the name of the platforms according to their value for variable “total”\n(descending order):\n\n\n# Change the names of the columns according to the original plot:\ncolnames(clean_data) <- c(\"Platform\", \"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                      \"Hispanic\", \"Ages 18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                      \"$30K-$49,999\", \"$50K-$74,999\", \"$75K+\", \"HS or less\",\n                      \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n# We arrange platforms' names by their \"total\" values (descending order)\nclean_data <-clean_data %>%\n  arrange(desc(Total)) %>%\n  column_to_rownames(var=\"Platform\") #Column \"platform\" to row names\n\n\nY axis labels order, padding and pre-faceting\nNow let’s work the Y axis labels. We need to:\nCreate a reference vector. We will create and use a reference vector\nwith the desired order of the labels and with the same padding we will applied\nfor the y labels to order them. Regarding padding, we have to set the width of\neach of the elements in the outcome vector. In this case, since the longest y\naxis label has 12 characters, that will be our width.\nPadding the real y axis labels. Now we have to apply the same padding\nused before so both the reference vector and the y labels are equivalent. This\npadding will avoid the horizontal left justification to be applied only\nindividually by facet instead of in all the facets together.\nOrder the y labels. Using the reference vector to order the levels.\nCreating a column for group faceting\n\n\n# REFERENCE VECTOR:\n# Creating a y axis labels reference vector that will be used for ordering within facets\naxisLabels.y <- c(\"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                  \"Hispanic\", \"Ages 18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                  \"$30K-$49,999\", \"$50K-$74,999\", \"$75K+\", \"HS or less\",\n                  \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n# Padding  the vector (as we will do with key/groups)\naxisLabels.y <- str_pad(axisLabels.y, side =\"right\",\n                        width = 12, pad = \" \")\n\n\n# LABELS ORDER AND PADDING:\nrep <- clean_data %>%\n  # Turning the row names to a column \"Platform\"\n  tibble::rownames_to_column(\"Platform\") %>%\n  \n  # Collecting columns (demographic subgroups, excluding platform column)\n  # as one column called \"key\"\n  # Collecting the previous columns' values as one column called \"value\"\n  gather(\"key\", \"value\", -Platform) %>%\n  \n  # PADDING Y-axis labels\n  mutate(key = str_pad(key, side =\"right\", width = 12,\n                       pad = \" \")) %>%\n  \n  # ORDER Y-axis labels using the reference vector to order the levels\n  mutate(key = fct_relevel(key, rev(axisLabels.y))) %>%\n  \n  # CREATING A COLUMN FOR LATTER GROUP FACETTING (total, gender, age, income...)\n  mutate(group = case_when(\n    grepl(\"Total\", key) ~ \"total\",\n    grepl(\"Men|Women\", key) ~ \"gender\",\n    grepl(\"White|Black|Hispanic\", key) ~ \"race\",\n    grepl(\"Ages|30-49|50-64|65\", key) ~ \"age\",\n    grepl(\"30K|50K|75K\", key) ~ \"income\",\n    grepl(\"HS|ollege\", key) ~ \"education\",\n    grepl(\"rban|Rural\", key) ~ \"place\",\n  )\n  )\n\n\nBuilding the plot: geom_tile()\nAmong all the options available to generate a heatmap, I chose geom_tile().\n\n\nrepl <- ggplot(rep, aes(reorder(Platform, value, decreasing=TRUE), key,\n                        fill = value, label = value)) +\n  geom_tile(color = \"white\",\n            lwd = 0.2,\n            linetype = 1)\nrepl\n\n\n\nFacetting\nWe will use column “group” to establish the facets. For this, we create another\nreference vector (as we did for y axis labels) to order the items in column\n“group”. This vector “categories” will act as the levels (and order) of the\ngroup column.\n\n\n# Another reference vector for ordering \"group\"\ncategories <- c('total', 'gender', 'race', 'age', 'income', 'education', 'place')\n\n\nrepli <- repl +\n  # Faceting\n  facet_grid(factor(repl$data$group,\n                    levels= categories) ~ .,\n             scales=\"free\", space=\"free\") \nrepli\n\n\n\nX axis and legend scale\nFor the legend I used scale_fill_stepsn() for selecting individual colors for\neach discrete ranges of values (percentages). In order to add the % symbol to\nthe 0 value only we can create a function called “labeller” that will take the\nbreaks specified in “breaks” argument and will paste the % symbol after the\nvalue when it is equal to 0.\nRegarding the scale color, to select each color code I used the website\nImageColorPicker.com, where you can upload an\nimage (in this case, the original plot) and select the colors to get the color\ncodes.\n\n\n# This function adds a \"%\" to the break label when it is equal to 0\nlabeller <- function(breaks) {\n  if (breaks[1] == 0)\n    breaks[1] <- paste0(breaks[1], \"%\")\n  breaks\n}\nrepli <- repli+\n  scale_fill_stepsn(breaks=seq(20, 80, 20), limits=c(0, 100), # Percentages \n                    labels=labeller, # Applies the above function\n                    space= \"Lab\",\n                    colors=c(\"#c7d9ee\", \"#8ab4df\", \"#5e91cb\", \"#286c9c\", \"#314565\"),\n                    guide=guide_colorsteps(show.limits=TRUE, # 0% and 100 visible\n                                           # We can see the ticks:\n                                           ticks = TRUE, \n                                           direction= \"horizontal\",\n                                           ticks.linewidth= unit(2, 'pt'),\n                                           ticks.colour = \"white\",\n                                           # 1 line legend\n                                           nrow = 1, \n                                           label= TRUE,\n                                           # On top of color values\n                                           label.position = \"top\")\n  )+\n  # Put X axis on top\n  scale_x_discrete(position = \"top\")\n\nrepli\n\n\n\nTitle, subtitle, caption and tag\nIntroducing the title, subtitle, caption and tag with labs(), adding \\n for\nnewlines and \\for special characters (like ““)\n\n\nrepli <- repli+\n  labs(\n    title = \"Use of online platforms, apps varies — sometimes widely — by demographic group\",\n    subtitle = \"\\n% of U.S. adults in each demographic group who say they ever use...\",\n    caption = paste0(\n      'Note: White and Black adults include those who report being only one ',\n      'race and are not Hispanic. Hispanics are of any race. Not all numerical',\n      '\\ndifferences between groups shown are statistically significant (e.g.,',\n      ' there are no statistically significant differences between the shares ',\n      'of\\nWhite, Black or Hispanic Americans who say the use Facebook). ',\n      'Respondents who did not give an answer are not shown.\\nSource: Survey ',\n      'of U.S. adults conducted Jan. 25-Feb. 8, 2021.\\n\\\"Social Media Use in 2021\\\"\\n'),\n    tag = \"PEW RESEARCH CENTER\",\n    # No x or y axis title\n    x=NULL, y = NULL)\nrepli\n\n\n\nFonts and Theme\nRegarding the fonts, initially I used similar fonts by analyzing the typography\nwith whatfontis.com. However, for license\nreasons, I then selected similar Google fonts. In both cases, I had to use a\nmonospace font version (Noto Sans Mono) for a perfect left justification of\nthe y axis text.\nDownload the .ttf files of the correspondent font type, load import it from the\ncorrect path and load them. Then add each font to each label, determining the\n.ttf file path for each face of the font. Finally, render the fonts with\nshowtext_auto().\n\n\nlibrary(extrafont)\nlibrary(showtext)\nlibrary(sysfonts)\n\n## Add the font with the corresponding font faces:\n\n#Title font\nfont_add(\"Libre Franklin Black\",\n         regular = \"./fonts/LibreFranklin-Black.ttf\",\n         bold = \"./fonts/LibreFranklin-Black.ttf\")\n\n# Subtitle font\nfont_add(\"Libre Franklin Medium\",\n         regular = \"./fonts/LibreFranklin-MediumItalic.ttf\",\n         italic = \"./fonts/LibreFranklin-MediumItalic.ttf\")\n\n# Y axis text  (monospaced Google font for left justification between facets)\nsysfonts::font_add_google(\"Noto Sans Mono\")\nfont_add(\"Noto Sans Mono\",\n         regular = \"./fonts/NotoSansMono-Regular.ttf\")\n\n# Geom_text font (values inside matrix), Caption text and and X axis labels\nfont_add(\"Libre Franklin\",\n         regular = \"./fonts/LibreFranklin-Regular.ttf\", # caption and X text\n         bold = \"./fonts/LibreFranklin-SemiBold.ttf\")\n\n# Tag text\nfont_add(\"Libre Franklin Bold\",\n         regular = \"./fonts/LibreFranklin-Bold.ttf\")\n\n## Automatically use showtext to render plots\nshowtext::showtext_auto()\n\n\nAdd the settings of the theme relative to facets, x/y axis, plot, labs and\nlegend:\n\n\nrepli <- repli+\n  theme(\n    # Labels of the facets (no visible)\n    strip.text=element_blank(),\n    # x and y axis\n    axis.ticks.x= element_blank(),\n    axis.ticks.y= element_blank(),\n    axis.text.x.top = element_text(size = 14, color = \"black\",\n                                   margin = margin(10, 10, 10, 10),\n                                   family = \"Libre Franklin\"),\n    axis.text.y = element_text(size = 15, color = \"black\",\n                               hjust= 0, margin = margin(0,-5,0,0),\n                               family = \"Noto Sans Mono\"),\n    # Plot margins\n    plot.margin = margin(17,4,22,4),\n    #Plot labs\n    plot.title = element_text(color = \"black\", size = 22.5,\n                              family = \"Libre Franklin Black\", face = \"bold\"),\n    plot.subtitle = element_text(color = \"grey40\", size = 17, lineheight = 0.2,\n                                 family = \"Libre Franklin Medium\",\n                                 face = \"italic\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    plot.caption = element_text(color = \"grey30\", size= 14, face=\"bold\",\n                                lineheight = 0.8,\n                                family = \"Libre Franklin\",\n                                hjust = 0, vjust = 0, margin = margin(13,0,0,0)),\n    plot.tag.position = c(0, -0.01),\n    plot.tag = element_text(size = 15, family = \"Libre Franklin Bold\", face = \"bold\",\n                            hjust = 0, vjust = 0, lineheight = 10),\n    # Legend \n    legend.position = \"top\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey40\", size = 18)\n    \n  )\nrepli\n\n\n\nAlso, set the theme settings for the background, the grid and the legend (more\ngeneral aesthetics):\n\n\nrepli <- repli+\n  theme(\n    # Panel and plot (spacing and grid)\n    panel.spacing=unit(10, \"pt\"),\n    #transparent panel and plot bg\n    panel.background = element_rect(fill='transparent', color=\"white\"), \n    plot.background = element_rect(fill='transparent', color=\"white\"),\n    panel.grid.major = element_blank(), #remove major gridlines\n    panel.grid.minor = element_blank(), #remove minor gridlines\n    # Legend\n    legend.background = element_rect(color=\"white\"), # white legend bg\n    legend.box.background = element_rect(color=\"white\"),#no legend panel\n    legend.key.width = unit(48, 'pt'),\n    legend.key.height = unit(12, 'pt'),\n    legend.margin = margin(5, 0, 0, 0)\n  )\nrepli\n\n\n\nAnnotation\nThe annotation of the values inside the matrix is applied using geom_text().\nWhen the values are above or equal to 40(%) the font is in white and in bold,\nwhen they are below, they are in black and in plain text. Color selection is\ncreated with an individual scale. Bold/plain font is applied by an ifelse\ncondition.\n\n\nrepli <- repli+\n  # Face, size, family and justification of text\n  geom_text(aes(color = value >= 40), family= \"Libre Franklin\",\n            fontface= ifelse(repl$data$value < 40, \"plain\", \"bold\"),\n            size = 6, vjust = \"center\", hjust = \"center\",\n  )+\n  # Color of the text\n  scale_color_manual(guide = \"none\", values = c(\"grey20\", \"white\"))\n\n# Final version:\nrepli\n\n\n\nAnd this is the version with no Google Fonts (fonts more similar to the\noriginal plot, except for x and y axis text that has to be in a monospaced\nfont):\nReplication 2 with no Google fontsAlternative version: parallel coordinates\nThinking about an alternative version of the original plot, we can say that, in\ngeneral terms, the graph is good. Some minor details could be implemented: some\ncolors of the color scale (legend) could have more extreme values to distinguish\nthem better. Also, the labels for the demographic main groups (age, gender,\nincome…) could be added. Optionally, the logos of the platforms could be\ndisplayed above their names since we tend to recognize even faster the social\nmedia app logos than their names.\nApart from this, the main disadvantage of the plot is the difficulty in visually\ndistinguishing the difference in the tendencies within demographic groups. To\nsolve that, we can use a parallel coordinates plot.\nOnce we have read the clean_data.csv file we generated in the replication plot,\nwe create, as before, new column names (these are slightly different from the\nother plot in the case of age, for space reasons). Also, we adjust the\ndata frame for our parallel coordinate plot’s structure: we order according to\ndescending Total values, we create a column “key” from the demographic group\ncolumn names and another column “value” with their values, we filter the\ndata frame and we create a column for “group” (as before). Then, we pivot wider\nthe Platform column into individual columns.\n\n\ndataK <- read.csv(\"clean_data.csv\")\ncolnames(dataK) <- c(\"Platform\", \"Total\", \"Men\", \"Women\", \"White\", \"Black\",\n                      \"Hispanic\", \"18-29\", \"30-49\", \"50-64\", \"65+\", \"<$30K\",\n                      \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\", \"HS or less\",\n                      \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n\ndataK <- dataK %>% \n  # Order by descending values of \"Total\"\n  arrange(desc(Total)) %>% \n  # Create two columns: key (demo. subgroups) and value (percentages)\n  gather(\"key\", \"value\", -Platform) %>%\n  # Filter\n  filter(key %in% c(\"Total\", \"Men\", \"Women\", \"White\", \"Black\", \"Hispanic\",\n                    \"18-29\", \"30-49\", \"50-64\", \"65+\",\"<$30K\",\n                    \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\", \"HS or less\",\n                    \"Some college\", \"College+\", \"Urban\", \"Suburban\", \"Rural\")\n         ) %>%\n  # Create a \"group\" column\n  mutate(group = case_when(\n    key == \"Total\" ~ \"total\",\n    key %in% c(\"Men\", \"Women\") ~ \"gender\",\n    key %in% c(\"White\", \"Black\", \"Hispanic\") ~ \"race\",\n    key %in% c(\"18-29\", \"30-49\", \"50-64\", \"65+\") ~ \"age\",\n    key %in% c(\"<$30K\",\"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\") ~\"income\",\n    key %in% c(\"HS or less\", \"Some college\", \"College+\") ~ \"education\",\n    key %in% c(\"Urban\", \"Suburban\", \"Rural\") ~ \"place\"\n  )) %>% \n  # Pivot wider\n  pivot_wider(names_from = \"Platform\",\n              values_from = \"value\"\n              ) \n\n\nBuilding the plots: ggparcoord()\nThe idea is to create individual parallel coordinate plots for each of the\ndemographic groups, using an individual color scale for each one (color-hue\nscales). We will use ggparcoord() for this purpose.\nWe will need to discard the percentage values (geom_text()). Otherwise, we\nwouldn’t be able to properly read them.\nWe will repeat almost the same process: filter data frame by the group,\nbuilding the ggplot (x axis the platforms, y axis the percentages) and\nsetting the line size. In some cases, we will need a reference vector to\norder the variables in the legend.\n\n\nlibrary(ggrepel)\nlibrary(GGally)\n\n\nTotal\n\n\ntotal <- dataK%>%\n  # Filter by group\n  filter(group == \"total\") %>% \n  # Generating the plot\n  ggparcoord(dataK,\n             columns= c(3:13), # Platforms\n             groupColumn = \"key\", # Demographic subgroups\n             showPoints = TRUE,\n             order= c(2:21),\n             scale= \"globalminmax\",\n             title= \"Total\"\n  )+\n  # Line thickness\n  geom_line(size= 1.2)\ntotal\n\n\n\nGender\n\n\ngender <- dataK%>%\n  # Filter by group\n  filter(group == \"gender\") %>% \n  # Generating the plot\n  ggparcoord(dataK,\n             columns= c(3:13), # Platforms\n             groupColumn = \"key\", # Demographic subgroups\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Gender\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7\n  )+\n  # Line thickness\n  geom_line(size= 1.2)\ngender\n\n\n\nRace/Ethnicity\n\n\nrace <- dataK%>%\n  filter(group == \"race\") %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Race\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\nrace\n\n\n\nAge\n\n\nage <- dataK%>%\n  filter(group == \"age\") %>% # Filtering by age\n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Age\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7\n  )+\n  geom_line(size=1)\nage\n\n\n\nIncome\n\n\norder_inc <- c(\"<$30K\", \"$30K-49.9K\", \"$50K-74.9K\", \"$75K+\")\nincome <- dataK%>%\n  filter(group == \"income\") %>% # Filtering by income category\n  mutate(key = fct_relevel (key, levels = order_inc)) # Ordering income subgroups\n\nincome <- dataK%>%\n  filter(group == \"income\") %>% \n  mutate(key = fct_relevel (key, levels = order_inc)) %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Income\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\n\nincome\n\n\n\nEducation\n\n\norder_educ <- c(\"HS or less\", \"Some college\", \"College+\") # Ordered levels vector\neducation <- dataK%>%\n  filter(group == \"education\") %>% # Filtering education categories \n  mutate(key = fct_relevel (key, levels = order_educ))  \n  \neducation <- education %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Education\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\neducation\n\n\n\nPlace\n\n\nplace <- dataK%>%\n  filter(group == \"place\") %>% \n  ggparcoord(dataK,\n             columns= c(3:13),\n             groupColumn = \"key\",\n             showPoints = TRUE,\n             order= c(2:21),\n             title= \"Place\",\n             scale= \"globalminmax\",\n             alphaLines = 0.7,\n  )+\n  geom_line(size=1)\nplace\n\n\n\nColor scales and theme\nAt the beginning I tried to use mostly hue-colors palettes with\nscale_color_discrete_sequential(). However, in some cases I had to use\nscale_color_manual() to select the colors and correct the low color value\n(too bright).\nIn relation to the theme, initially, I tried to give more emphasis to the 40%\nvalue (as in the original plot). However, as pointed by the teacher,\nintroducing a horizontal line could give the feeling of a timeline. Therefore,\nI tried to keep the horizontal lines as subtle as possible (but still visible\nfor the easily reader to read the percentages) while giving emphasis to the\nvertical lines (grid).\nTotal\n\n\n# Grid annotations (horizontal, x axis)\ntotal <- total+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\ntotal <- total +\n  # Scales\n  scale_colour_manual(values = c(\"Total\"= \"grey30\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  #Theme\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    # Emphasis to the vertical lines\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    # X and Y axis\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    # legend\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \ntotal\n\n\n\nGender\n\n\ngender <- gender+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\ngender <- gender +\n  scale_colour_manual(values = c(\"Women\"= \"#8ab4df\", \"Men\"= \"#286c9c\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \ngender\n\n\n\nThe rest of demographic groups\nApply the same theme and color scale style to the rest of socioeconomic\ncategories:\n\n\nlibrary(colorspace)\n\n\n\n\n#RACE\n\nrace <- race+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\nrace <- race +\n  scale_color_manual(values = c(\"Black\"= \"#a2d0a8\", \"Hispanic\" = \"#62a086\",\n                                \"White\"= \"#294e5e\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n# AGE\n\nage <- age+\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\nage <- age +\n  scale_color_discrete_sequential(palette= \"Red-Blue\")+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n# INCOME\n\n\nincome <- income +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\nincome <- income +\n  scale_color_discrete_sequential(palette= \"Burg\")+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    legend.spacing.x = unit(3, \"pt\"),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\n# EDUCATION\n\neducation <- education +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\n\neducation <- education +\n  scale_colour_manual(values = c(\"HS or less\"= \"#fdbb84\",\n                                 \"Some college\"= \"#f16914\",\n                                 \"College+\" = \"#a63603\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\n# PLACE\n\nplace <- place +\n  geom_line(aes(y = 40), color = \"grey50\", linetype = \"dotted\")+\n  geom_line(aes(y = 20), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 60), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 80), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 100), color = \"grey80\", linetype = \"dotted\")+\n  geom_line(aes(y = 0), color = \"grey80\", linetype = \"dotted\")\n\nplace <- place +\n  scale_color_manual(values = c(\"Urban\" = \"#213e4b\",\n                                \"Suburban\" = \"#3b809a\", \"Rural\" = \"#99cfd1\"))+\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 101),\n    breaks = c(0, 20, 40, 60, 80, 100),\n    labels = c(\"0\", \"20\", \"40\", \"60\", \"80\", \"100%\"))+\n  labs(x=NULL, y = NULL)+\n  theme(\n    plot.title = element_text(size=15, hjust = 0.5, family=\"Libre Franklin\",\n                              face= \"bold\", color= \"black\"),\n    plot.title.position = \"panel\",\n    axis.ticks.length.x = unit(2, \"pt\"),\n    legend.position = \"top\",\n    legend.box = \"horizontal\",\n    legend.title=element_blank(),\n    legend.text = element_text(color = \"grey30\",family=\"Libre Franklin\",\n                               face= \"plain\", size = 11),\n    panel.spacing = unit(0.5, \"lines\"),\n    panel.border = element_rect(colour = \"white\", fill=NA, size=1),\n    axis.ticks.x.bottom = element_line(color = \"black\"),\n    panel.grid.major.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.grid.minor.x = element_line(colour = \"black\", linetype = \"solid\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    axis.text.y = element_text(color = \"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size = 10),\n    axis.text.x = element_text(color=\"grey30\", family=\"Libre Franklin\",\n                               face= \"plain\", size= 12, angle= 45, hjust= 1),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    legend.box.background = element_rect(fill =  \"white\")\n  ) \n\n\nPatchwork and general theme\nWe need to paste all the individual plots together with {Patchwork}, add the\ntitle, subtitle and caption with plot_annotation() and add the aesthetics with\ntheme(). We should keep some coherence in the aesthetics so we will recycle\nsome elements from the theme of the replication (the plot is expected to be in\nthe article and should match the rest of the plots).\n\n\nlibrary(patchwork)\n\n# Pasting the plots together\nglobal <-gender+race+age+income+\n  education+place+total+\n  # Distribution in 3 lines\n  plot_layout(ncol = 3)+\n  # Labs annotation:\n  plot_annotation(\n    title = \"Use of online platforms, apps varies — sometimes widely — by demographic group\",\n    subtitle = \"% of U.S. adults in each demographic group who say the ever use...\",\n    caption = paste0(\n      'Note: White and Black adults include those who report being only one ',\n      'race and are not Hispanic. Hispanics are of any race. Not all numerical',\n      '\\ndifferences between groups shown are statistically significant (e.g.,',\n      ' there are no statistically significant differences between the shares ',\n      'of\\nWhite, Black or Hispanic Americans who say the use Facebook). ',\n      'Respondents who did not give an answer are not shown.\\nSource: Survey ',\n      'of U.S. adults conducted Jan. 25-Feb. 8, 2021.\\n\\\"Social Media Use in 2021\\\"',\n      '\\n\\nPEW RESEARCH CENTER'),\n    theme= theme(plot.margin = margin(17,4,22,4),\n                 plot.title = element_text(color = \"black\", size = 28,\n                                           family = \"Libre Franklin Black\",\n                                           face = \"bold\"),\n                 plot.subtitle = element_text(color = \"grey40\", size = 21,\n                                              lineheight = 0.2,\n                                              family = \"Libre Franklin Medium\",\n                                              face = \"italic\"),\n                 plot.title.position = \"plot\",\n                 plot.caption.position = \"plot\",\n                 plot.caption = element_text(color = \"grey30\", size= 14, face=\"plain\",\n                                             lineheight = 0.8,\n                                             family = \"Libre Franklin\",\n                                             hjust = 0, vjust = 0)\n                 )\n    )\n\n# Final result of the replication\nglobal\n\n\n\nConclusions\nApart from the put-in-practice opportunity of what was seen during the course of\nData Visualization, I would like to highlight some findings and messages for my\nfuture self:\nIt has been such a great exercise to face a real-world example of dataset and\ndocumentation and learn from mistakes. Always read carefully all the\ndocuments in the documentation, it’s all there and it shows (or it should do)\nthe reasoning behind the author’s choices. The time invested in reading the\ndocumentation will save you tons of time.\nUse RMarkdown from the beginning, especially if you intend to share your\nproject. Comments in .R are ok (if you remember to add them), but adding\ntext and separate your scripts in chunks gives you a more visually organised\nresult. Plus, using chunks allows you to section your work progress in stages\nand it’s easier to control bugs.\nThere must be always an ending, specially when replicating.\nLeave the fonts and the export size for the last stage (even if it’s hard to\nwatch). Otherwise, you may invest too much time in doing this process\niteratively. And don’t forget to render them before trying the next font of the\nlist.\n\n\n\n",
    "preview": "projects/2022/100462872/100462872_files/figure-html5/final-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 2496,
    "preview_height": 2496
  },
  {
    "path": "projects/2022/100488462/",
    "title": "Steph Curry's 3-Point Record in Context: Off the Charts",
    "description": "In this project, I will explain how to replicate a graph of the three-point\nfield goals made over the course of a season for every player in a range of\ntime. The graph shows a relevant difference in cumulative sums between \nthe current seasons and the previous ones.\nFirst, I will clean the dataset according to the variables that I need.\nSecond, I will present step by step how to reproduce the graph using\nggplot2 package.",
    "author": [
      {
        "name": "Nicola Ricciardi",
        "url": {}
      }
    ],
    "date": "2023-01-24",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nReplicating the chart\nImprove the Graph\n\nGetting the data\nRun the below commands to load the libraries we use. We also increase the vroom connection size to accomodate for the large file we read.\n\n\nlibrary(nbastatR)\nlibrary(tidyverse)\n\nSys.setenv(\"VROOM_CONNECTION_SIZE\" = 131072 * 2)\n\n\nSelect the Seasons useful for the graph.\n\n\nselectedSeasons <- c(1978:2017)\n\n\nExtract data from the function game_logs. I used selectedSeason to indicate the range of time, NBA to select the league, player and the type of season as Regular Season.\n\n\nP_gamelog_reg <- suppressWarnings(game_logs(seasons = selectedSeasons,\n                                            league = \"NBA\",\n                                            result_types = \"player\",\n                                            season_types = \"Regular Season\"))\n\n\n\n\naa <- P_gamelog_reg%>%\n  filter(slugSeason>= (\"1979-80\") & slugSeason <= (\"2015-16\"))%>%\n  select(yearSeason,slugSeason, namePlayer, dateGame, slugMatchup, fg3m, fg3a)%>%\n  arrange(slugSeason, namePlayer, dateGame)\n\n\nIt results that Eddie Johnson played in two teams at the same time, for this reason I select only the games when he played in Cleveland.\n\n\nEddie_ATL <- ifelse(aa$namePlayer==\"Eddie Johnson\"& !grepl(\"ATL|CLE\", aa$slugMatchup)==F, 1,0)\n\nEd <- cbind(aa,Eddie_ATL)\n\nEdd <- Ed%>%\n  filter(Eddie_ATL==0)%>%\n  select(-c(Eddie_ATL))\n\n\nI Create a column in which I compute the cumulative sum of the number of three point shoots made.\n\n\nEdd <- Edd%>%\n  group_by(namePlayer, slugSeason)%>%\n  mutate(P3M=sum(fg3m), P3A=sum(fg3a), \"cum_sum\"=cumsum(fg3m))%>%\n  ungroup()%>%\n  group_by(slugSeason)%>%\n  arrange(desc(P3M), .by_group = T)%>%\n  ungroup()\n\n\nI create two new columns, one for ID players and one for the first 20 players in the ID column.\n\n\nplayer_id2 <- Edd%>%\n  select(namePlayer)%>%\n  distinct()%>%\n  mutate(Id_player=row_number())\n\ntop_20_2 <- Edd%>%\n  select(c(slugSeason, namePlayer,P3M))%>%\n  arrange(slugSeason, desc(P3M))%>% \n  distinct()%>%\n  group_by(slugSeason)%>%\n  mutate(top_20=row_number())%>%\n  filter(top_20<=20)%>%\n  select(-c(P3M))%>%\n  ungroup()\n\ntop_20_x <- top_20_2%>%\n  mutate(ID=row_number())\n\n\nI merge three datasets in order to obtain Id_player and top_20 columns\n\n\nmerge.player1 = merge(x=Edd,player_id2,by=\"namePlayer\",all.Edd=TRUE)\nmerge.201 <-  merge(merge.player1, top_20_x, all=TRUE)\n\n\nI select the variables of interest and then I order by slugSeason, top_20 and dategame. I compute the cumulative sum of three points field goals made.\n\n\nmerge.df11 <- merge.201%>%\n  select(yearSeason,slugSeason, namePlayer, dateGame, slugMatchup, P3M, fg3m,\n         Id_player, top_20, ID)%>%\n  arrange(slugSeason, top_20, dateGame,ID)%>%\n  group_by(namePlayer,slugSeason)%>%\n  mutate(P3M=sum(fg3m), \"cum_sum\"=cumsum(fg3m))%>%\n  distinct()%>%\n  filter(!is.na(top_20))%>%\n  filter(top_20<=20)\n\n\nI create the final dataset adding a new column for the number of games (#82 in a season).\n\n\nff <- merge.df11%>%\n  group_by(slugSeason,namePlayer)%>%\n  mutate(\"N_games\"= row_number())\n\n\nThis is the final dataset with another column to annotate the name of the players in the right part of the graph.\n\n\nff1 <- ff%>%\n  mutate(aa = substring(slugSeason, 3, 7))%>%\n  mutate(aa1 = namePlayer)\n\nff <- unite(ff1, col='n-d-3', c('aa1', 'aa'), sep=\" '\")\n\nff <- ff%>%\n  rename(pp = 'n-d-3')\n\n\nSaving dataset:\n\n\nwrite.csv(ff, file = \"ff2.csv\", \n          sep = \"\\t\", \n          row.names = F)\n\n\nReplicating the chart\nIt is a graph from the Sunday Sports cover celebrating 3-point records of Stephen Curry during the last years.\nThe graph has 740 lines, one for each player who was in the top 20 in 3-point shoot made starting from 1980. The best record is established by Stephen Curry with 402 3 pointers.\nThe colors scale highlights a a clear difference in cumulative sum during the range of time.\nFor the regular season 2015 - 2016 Stephen Curry is an outlier compare with the other records.\n\n\nlibrary(tidyverse)\nlibrary(ggrepel)\n\nff <- read.delim(\"ff.csv.gz\", sep =\",\", header=TRUE)\n\n\nHere, I create a function to expand the scale color I select in my favourite colours. In cvi_palettes I select n = 37 according to the range time of the graph. I need to set type as “continuous”.\n\n\ncvi_colours = list(\n  cvi_purples = c(\"#381532\", \"#4b1b42\", \"#5d2252\", \"#702963\",\n                  \"#833074\", \"#953784\", \"#a83e95\"),\n  my_favourite_colours = c(\"#CD9B9B\", \"#EECFA1\",  \"#7CCD7C\", \"#00688B\")\n)\n\ncvi_palettes = function(name, n, all_palettes = cvi_colours, type = c(\"discrete\", \"continuous\")) {\n  palette = all_palettes[[name]]\n  if (missing(n)) {\n    n = length(palette)\n  }\n  type = match.arg(type)\n  out = switch(type,\n               continuous = grDevices::colorRampPalette(palette)(n),\n               discrete = palette[1:n]\n  )\n  structure(out, name = name, class = \"palette\")\n}\n\ncol <- cvi_palettes(\"my_favourite_colours\", type = \"continuous\", n = 37)\n\n\nAt this point, I tried to replicate the graph without the original colors and axis labels, but I encountered some problems related with annotations. In fact, when I plot the names for each player at the top 1 in every season, I have several overlaps. Using the parameter check_overlap = T in the function geom_text I lose a lot of players, for this reason I decided to improve the graph using the function geom_text_repel that plot the labels with rows to avoid overlaps.\n\n\nn1 <- ggplot(ff, xlim=c(0, 97), ylim=c(0, 420)) + \n  \n  geom_segment(\n    aes(\n      x=0, xend=0,\n      y=0, yend=0\n    )\n  ) + geom_segment(\n    aes(\n      x=0, xend=97,\n      y=50, yend=50\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=10, xend=97,\n      y=100, yend=100\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=27, xend=97,\n      y=150, yend=150\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=37, xend=97,\n      y=200, yend=200\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=46, xend=97,\n      y=250, yend=250\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=55, xend=97,\n      y=300, yend=300\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=65, xend=97,\n      y=350, yend=350\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=75, xend=97,\n      y=400, yend=400\n    ), color = \"grey90\"\n  )\n\n\nn1 <- n1 + geom_step(aes(x = ff$N_games, y = cum_sum, group = ID, color = yearSeason),\n                   linetype = \"solid\", alpha = 1, size = 1.08)\n\nn1 <-  n1 + geom_segment(aes(x=0, xend=83, y=0, yend=0), size=1) \n\nn1<-  n1 + coord_fixed(ratio=1/3)\n\nn1 <- n1 + ggtitle(\"Stephen Curry's 3-Point Record in Context: Off the Charts\")\n\nn1 <- n1 +  geom_text(data = ff%>%\n              select(yearSeason,slugSeason, namePlayer, P3M, top_20, N_games, cum_sum, pp)%>%\n              filter(top_20 == 1)%>%\n              group_by(yearSeason, slugSeason, pp,namePlayer, P3M)%>%\n              summarise(\n                P3M1 = sum(cum_sum)\n              )%>%\n              select(-P3M1),\n            aes(x = 82, y = P3M, colour = yearSeason, label=pp), \n            family = \"Palatino\",\n            fontface = \"plain\",\n            size = 2,\n            direction = \"y\",\n            hjust = \"left\",\n            nudge_x = 0\n            )\n\nn1 <- n1 +  guides(colour = guide_colourbar(title = substitute(paste(bold(\"Cumulative \nthree-point field \ngoals made over \nthe course of a \nseason\"))), barwidth = 0.8, barheight = 7))\n\nn1 <- n1 + theme(\n     plot.title = element_text(size = 15, family = \"serif\", face = \"plain\", hjust = 0.8),\n     plot.background = element_rect(fill = \"white\", colour = NA),\n        panel.background = element_rect(fill = \"white\", colour = NA),\n   panel.grid.major.x = element_blank(),\n legend.position=\"left\",\n\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank(),\n  axis.ticks.length.x = unit(-.2, \"cm\"),\n  axis.ticks.y = element_blank(),\n  axis.text.y = element_text(vjust = -1)) \nn1\n\n\n\nImprove the Graph\nHere, I set the coordinates of my graph according to x - axis that represent the number of games in a regular season, and y - axis that marks how many three point shoots made by a player.\n\n\nn <- ggplot(ff, xlim=c(0, 83), ylim=c(0, 420)) + \n  \n  geom_segment(\n    aes(\n      x=0, xend=0,\n      y=0, yend=0\n    )\n  ) + geom_segment(\n    aes(\n      x=0, xend=83,\n      y=50, yend=50\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=10, xend=83,\n      y=100, yend=100\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=27, xend=83,\n      y=150, yend=150\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=37, xend=83,\n      y=200, yend=200\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=46, xend=83,\n      y=250, yend=250\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=55, xend=83,\n      y=300, yend=300\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=65, xend=83,\n      y=350, yend=350\n    ), color = \"grey90\"\n  ) + geom_segment(\n    aes(\n      x=75, xend=83,\n      y=400, yend=400\n    ), color = \"grey90\"\n  )\nn\n\n\n\nI visualize the cumulative sum of three points shoot through geom_step, where for the x - axis there is the number of games, in the y - axis there is the cumulative sum, the group and the colour change according to ID and yearSeason.\n\n\nn <- n + geom_step(aes(x = ff$N_games, y = cum_sum, group = ID, color = yearSeason),\n                   linetype = \"solid\", alpha = 1, size = 1.08)\nn\n\n\n\nHere, I visualize the x - axis representing the number of games in a season.\n\n\nn <-  n + geom_segment(aes(x=0, xend=83, y=0, yend=0), size=1) \nn\n\n\n\nA fixed coordinate system forces a specified ratio between the physical representation of data units on the axes. The ratio is equal to 1/3, it means that one unit on the x - axis is 1/3 of one unit on the y - axis.\n\n\nn <-  n + coord_fixed(ratio=1/3)\nn\n\n\n\nHere, I visualize the title according to the original graph.\n\n\nn <- n + ggtitle(\"Stephen Curry's 3-Point Record in Context: Off the Charts\")\nn\n\n\n\nI use geom_text_repel to annotate the name of the first player for every. This is a good option to increase the visualization of the graph, in fact it is possible to highlight different players with different colours and plot arrows to increase clarity and avoid overlaps.\n\n\nn <- n + geom_text_repel(data = ff%>%\n              select(yearSeason,slugSeason, namePlayer, P3M, top_20, N_games, cum_sum, pp)%>%\n              filter(top_20 == 1)%>%\n              group_by(yearSeason, slugSeason, pp,namePlayer, P3M)%>%\n              summarise(\n                P3M1 = sum(cum_sum)\n              )%>%\n              select(-P3M1),\n            aes(x = 82, y = P3M, colour = yearSeason, label=pp), \n            family = \"Palatino\",\n            fontface = \"plain\",\n            size = 3,\n            direction = \"y\",\n            hjust = \"left\",\n            nudge_x = 9\n            )\nn\n\n\n\nHere I define the color scale I created previously. I have 37 seasons for 37 different shades. According to the visualization, it is possible observe that the cumulative sum increases over the years. The exception is Stephen Curry who is off the charts with more than 400 three points shoots made over the season.\n\n\nn <- n + scale_colour_gradientn(colours = col, breaks = c(1980, 2016), labels =c(\"1979-80\", \"2015-16\"))\nn\n\n\n\nI define the labels for the x - axis and the y - axis. The first axis has a label every 10 games, while y - axis has a label every 50 three - point field goals.\n\n\nn <-  n + scale_x_continuous(expand = c(0,0), \n                     breaks =c(1:82), limits = c(0,110), \n                     labels = c(\"1st game\",\"\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"10th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"20th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"30th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"40th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"50th\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"60th\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"70th\", \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n                                \"80th\",\"\",\"\")\n                     ) + \n  scale_y_continuous(expand = c(0,4),\n                     breaks = c(0,50, 100, 150, 200, 250, 300, 350, 400),\n                     labels = c(\"\", \"50\", \"100\", \"150\", \"200\", \"250\", \"300\", \"350\", \"400\"),\n                     limits = c(0,420))\nn\n\n\n\nIn this part I define the legend title for the plot, customizing the legend’s size.\n\n\nn <- n +  guides(colour = guide_colourbar(title = substitute(paste(bold(\"Cumulative \nthree-point field \ngoals made over \nthe course of a \nseason\"))), barwidth = 0.8, barheight = 7))\nn\n\n\n\nIn this part I use some functions to modify the title, customize the background or set the position of the legend.\nAccording to the original graph I remove the axis title and the ticks from the y - axis.\n\n\nn <- n + theme(\n  plot.title = element_text(size = 15, family = \"serif\", face = \"plain\", hjust = 0.8),\n  plot.background = element_rect(fill = \"white\", colour = NA),\n  panel.background = element_rect(fill = \"white\", colour = NA),\n  panel.grid.major.x = element_blank(),\n  legend.position=\"left\",\n  axis.title.x = element_blank(),\n  axis.title.y = element_blank(),\n  axis.ticks.length.x = unit(-.2, \"cm\"),\n  axis.ticks.y = element_blank(),\n  axis.text.y = element_text(vjust = -1)) \nn\n\n\n\n\n\n\n",
    "preview": "projects/2022/100488462/100488462_files/figure-html5/unnamed-chunk-25-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1728,
    "preview_height": 1728
  },
  {
    "path": "projects/2022/100446823/",
    "title": "Views on Financial Well-Being of Future Generations",
    "description": "In this post I recreate a Pew Research graph and propose an alternative\nvisualization of the data.",
    "author": [
      {
        "name": "Eliseo Garilleti",
        "url": {}
      }
    ],
    "date": "2023-01-23",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData reading\nGraph replication\nThe same graph made more beautiful\nAlternative visualization of the data\n\nData reading\nI load the data, transform it into long format and create a new column that assigns a number to each country to group them into different categories as a preliminary step to the alternative visualisation I will carry out.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\ndataviz <- readxl::read_xlsx(\"data.xlsx\")\n\ndataviz_long <- dataviz %>% \n  pivot_longer(cols = c(2,3),\n               names_to = \"Eco_perception\",\n               values_to = \"Proportion\")  %>% \n  mutate(zone = case_when(Country == \"Poland\" ~ 1,\n                          Country == \"Hungary\" ~ 1,\n                          Country == \"Germany\" ~ 2,\n                          Country == \"Greece\" ~ 3,\n                          Country == \"Italy\" ~ 3,\n                          Country == \"France\" ~ 2,\n                          Country == \"Netherlands\" ~ 2,\n                          Country == \"Sweden\" ~ 2,\n                          Country == \"Spain\" ~ 3,\n                          Country == \"Belgium\" ~ 2,\n                          Country == \"UK\" ~ 4,\n                          Country == \"U.S.\" ~ 4,\n                          Country == \"Canada\" ~ 4,\n                          Country == \"Australia\" ~ 4,\n                          Country == \"Malaysia\" ~ 5,\n                          Country == \"South Korea\" ~ 5,\n                          Country == \"Singapore\" ~ 5,\n                          Country == \"Japan\" ~ 5),\n         Eco_perception = case_when(Eco_perception == \"Eco_good\" ~ \"Good\",\n                                    Eco_perception == \"Eco_bad\" ~ \"Bad\")) \n\ncountry_order <- c(\"Japan\", \"Belgium\", \"Spain\", \"Sweden\", \"Netherlands\", \"Israel\", \n                   \"UK\", \"Australia\", \"France\", \"Canada\", \"Italy\", \"Singapore\", \"Greece\", \n                   \"U.S.\", \"South Korea\", \"Germany\", \"Malaysia\", \"Hungary\", \"Poland\")\n\n\nGraph replication\nHere I replicate, as close as possible, a graph by Pew Research in their 2022 article Large shares in many countries are pessimistic about the next generation’s financial future.\n\n\n\nFigure 1: The original graph by Pew Research\n\n\n\nThrough the graph above, they show the differences between two groups, those who have positive or negative views of the current state of the domestic economy, in different countries, in relation to the economic future that awaits their children. Specifically, it shows how, systematically, the % of individuals who think that their children will have a worse economic situation than their parents is higher among those who think that the economic situation in their country is bad.\nThis graph, while not overly complicated to replicate, presents some difficulty stemming from the fact that it is actually two graphs in one. The main graph was relatively easy to carry out, except for the legend, which presented a challenge to some degree. To carry out the accompanying one (the table showing the difference between the groups) I had to think a bit out the box. The process of putting them together was the most time-consuming part, mainly because I had no prior knowledge of the library patchwork and not much practice in joining graphs. In any case, I consider that the final result has been satisfactory.\nIn my view, they have chosen an almost perfect graph to tell the story they want to tell, one about differences between groups. Representing each group as a dot and showing their differences in terms of percentage points through horizontal distances (by adding a grey line connecting the dots) makes it easy to observe the degree of these differences within the countries. The order in which the countries are shown (according to the differences between groups, in descending order), helps to visualize the differences between countries. It also uses color to make it easier for the reader to distinguish between the two groups, although the choice of colors is not ideal from my point of view, an idea I will develop later.\nThe graph incorporates a table that allows the differences to be consulted numerically. The appropriateness of this table is debatable, is the information it provides really necessary? The main graph already makes it possible to clearly see the differences within and between countries. In any case, I think that the presentation of this table could be improved, which I will also discuss later.\n\n\np1 <- dataviz_long %>% \n  ggplot(aes(x = Country, y = Proportion, fill = Eco_perception,\n             color = Eco_perception, group = Country, label = Proportion)) +\n  geom_line(color = \"gray45\", size = 1.5, alpha = .2) + \n  geom_point(shape = 21, size = 2.7) +\n  geom_text(vjust = 2.5, nudge_x = 0.15, size = 2.9) +\n  coord_flip() +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, color = \"#657032\") +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"situation is good\",\n           size = 2.9, vjust = -1.7, color = \"#657032\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, hjust = .3, color = \"#326296\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"situation is bad\",\n           size = 2.9, vjust = -1.7, hjust = .25,color = \"#326296\") +\n  expand_limits(y = c(0,100),\n                x = c(-.1, 20.5)) +\n  scale_y_continuous(breaks = c(0,100)) +\n  scale_x_discrete(limits = country_order) +\n  scale_fill_manual(values = c(\"#8cb3e6\", \"#d5ddad\")) +\n  scale_color_manual(values = c(\"#326296\", \"#657032\")) +\n  labs(x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray45\", size = .2),\n        panel.grid.minor = element_line(color = \"gray45\", size = .2),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        axis.text = element_text(family = \"Helvetica\", size = 9, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray55\", size = 7.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -3),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7.5,\n                                face = \"bold\", hjust = .4, vjust = 1),\n        plot.margin = unit(c(.7, .25, 1, .5), \"cm\"))\n\np1 \n\n\n\n\n\np2 <- dataviz %>% \n  ggplot(aes(fct_reorder(Country, Diff), Diff, label = Diff)) +\n  geom_point(alpha = 0) +\n  coord_flip() + \n  annotate(\"rect\", xmin = 0.5, xmax = 20.5, ymin = 15.5, ymax = 20, fill = \"#efefe2\") +\n  geom_text(label = paste(\"+\",dataviz$Diff), y=17.5, fontface = \"bold.italic\",\n            size = 3, color = \"gray30\") +\n  ylim (15.5,20) +\n  expand_limits(x = c(-.1, 20.5)) +\n  annotate(\"text\", x = \"Poland\", y = 17.5, label = \"Diff\", size = 3,\n           vjust = -2.5, fontface = \"bold.italic\", color = \"gray30\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\",\n        plot.margin = unit(c(.7, 0.25, 1, 0), \"cm\"))\n\np2 \n\n\n\n\n\np1 + p2 + \n  plot_layout(widths = c(1.7, .3)) +\n  plot_annotation(title = \"People who see economy negatively are \\nmore likely to see a worse financial \\nfuture for the next generation\",\n                  subtitle = \"% who say that when children today in (survey country) \\ngrow up, they will be worse off financially than their \\nparents, among those who say their country's...\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 12.5,\n                                              face = \"bold\", vjust = -3.5),  \n                    plot.subtitle = element_text(family = \"Times\", size = 10.5,\n                                                 color = \"gray25\", face = \"italic\",\n                                                 vjust = -5))) \n\n\n\nThe same graph made more beautiful\nThere were a couple of elements related to the presentation and aesthetics of the graph that did not quite convince me: the colors and the background of the table presenting the differences.\nI think red is a more appropriate color to represent groups that have a negative view on something, so I have replaced blue with this color. I have also replaced the green with a brighter green, because the red stood out too much. I have also removed the background of the column that presents the differences and I have chosen to divide this column from the graph using a vertical line, which contributes to a cleaner presentation.\n\n\np1a <- dataviz_long %>% \n  ggplot(aes(x = Country, y = Proportion, fill = Eco_perception,\n             color = Eco_perception, group = Country, label = Proportion)) +\n  geom_line(color = \"gray45\", size = 1.5, alpha = .2) + \n  geom_point(shape = 21, size = 2.7) +\n  geom_text(vjust = 2.5, nudge_x = 0.15, size = 2.9) +\n  coord_flip() +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, color = \"#025902\") +\n  annotate(\"text\", x = \"Poland\", y = 19, label = \"situation is good\",\n           size = 2.9, vjust = -1.7, color = \"#025902\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"Current economic\",\n           size = 2.9, vjust = -3.1, hjust = .3, color = \"#AB0202\") +\n  annotate(\"text\", x = \"Poland\", y = 63, label = \"situation is bad\",\n           size = 2.9, vjust = -1.7, hjust = .25, color = \"#AB0202\") +\n  expand_limits(y = c(0,100),\n                x = c(-.1, 20.5)) +\n  scale_y_continuous(breaks = c(0,100)) +\n  scale_x_discrete(limits = country_order) +\n  scale_fill_manual(values = c(\"#FA8080\", \"#A7F3A7\")) +\n  scale_color_manual(values = c(\"#AB0202\", \"#025902\")) +\n  labs(x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray45\", size = .2),\n        panel.grid.minor = element_line(color = \"gray45\", size = .2),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.title = element_text(family = \"Helvetica\", size = 11.5,\n                                  face = \"bold\", vjust = 3),  \n        plot.subtitle = element_text(family = \"Times\", size = 10,\n                                     color = \"gray25\", face = \"italic\", vjust = 3),\n        axis.text = element_text(family = \"Helvetica\", size = 9,\n                                 color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.title.position = \"plot\",\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray55\", size = 7.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -3),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7.5,\n                                face = \"bold\", hjust = .43, vjust = 1),\n        plot.margin = unit(c(.7, .25, 1, .5), \"cm\"))\n\n\n\n\np2r <- dataviz %>% \n  ggplot(aes(fct_reorder(Country, Diff), Diff, label = Diff)) +\n  geom_point(alpha = 0) +\n  coord_flip() + \n  geom_text(label = paste(\"+\",dataviz$Diff), y=17.5, fontface = \"bold.italic\",\n            size = 3, color = \"gray30\") +\n  ylim (13,20) +\n  expand_limits(x = c(-.1, 20.5)) +\n  geom_hline(yintercept = 13.5, size = .3, color = \"gray65\") +\n  annotate(\"text\", x = \"Poland\", y = 17.5, label = \"Diff\", size = 3,\n           vjust = -2.5, fontface = \"bold.italic\", color = \"gray30\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        axis.title.x = element_blank(),\n        axis.title.y =  element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"none\",\n        plot.margin = unit(c(.7, 0.25, 1, 0), \"cm\"))\n\n\n\n\ngraphr <- p1a + p2r + \n  plot_layout(widths = c(1.7, .3)) +\n  plot_annotation(title = \"People who see economy negatively are \\nmore likely to see a worse financial \\nfuture for the next generation\",\n                  subtitle = \"% who say that when children today in (survey country) \\ngrow up, they will be worse off financially than their \\nparents, among those who say their country's...\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 12.5,\n                                              face = \"bold\", vjust = -3.5),  \n                    plot.subtitle = element_text(family = \"Times\", size = 10.5,\n                                                 color = \"gray25\", face = \"italic\",\n                                                 vjust = -5))) \n\ngraphr\n\n\n\nAlternative visualization of the data\nThe type of graphic Pew Research uses to tell its story is probably the most appropriate. Below I show a proposal that tells a similar story, using a different type of visualization.\nIn terms of the story, I thought it relevant to group the countries into different graphs. The criteria I have followed to carry out this grouping is geographic and cultural. I have grouped different European countries according to the region in which they are located; I have also grouped Anglo-Saxon countries and Asian countries. As for the way of visualizing the data, I have chosen to show the differences through the slope of the line.\n\n\nalt1 <- dataviz_long %>% \n  filter(zone == 1) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 72.5, label = \"HU\", size = 5.8,  color = \"#1d42ff\") +\n  annotate(\"text\", x = \"Bad\", y = 65.5, label = \"PL\", size = 5.8,  color = \"#ed009c\") +\n  scale_fill_manual(values = c(\"#1d42ff\", \"#ed009c\")) +\n  scale_color_manual(values = c(\"#1d42ff\", \"#ed009c\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"Hungary and Poland\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 9,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        #plot.title.position = \"plot\",\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 7,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 7,\n                                face = \"bold\", hjust = .37, vjust = 2),\n        plot.margin = unit(c(1.5, .5, 1.5, 1), \"cm\"))\n\nalt1\n\n\nalt2 <- dataviz_long %>% \n  filter(zone == 2) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 90.5, label = \"FR\", size = 5.8, color = \"#0079b1\") +\n  annotate(\"text\", x = \"Bad\", y = 84, label = \"BE\", size = 5.8, color = \"#8a76cb\") +\n  annotate(\"text\", x = \"Bad\", y = 78.3, label = \"NL\", size = 5.8, color = \"#e966b0\") +\n  annotate(\"text\", x = \"Bad\", y = 72.5, label = \"DE\", size = 5.8, color = \"#ff706a\") +\n  annotate(\"text\", x = \"Bad\", y = 65.5, label = \"SW\", size = 5.8, color = \"#ffa600\") +\n  scale_fill_manual(values = c(\"#8a76cb\", \"#0079b1\", \"#ff706a\", \"#e966b0\", \"#ffa600\")) +\n  scale_color_manual(values = c(\"#8a76cb\", \"#0079b1\", \"#ff706a\", \"#e966b0\", \"#ffa600\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"France, Belgium, Netherlands, \\nGermany and Sweden\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20,\n                                 color = \"gray30\"),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 9,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 9,\n                                face = \"bold\", hjust = .67, vjust = 1),\n        plot.margin = unit(c(1.5, .5, 1.5, .5), \"cm\"))\n\nalt2\n\n\nalt3 <- dataviz_long %>% \n  filter(zone == 3) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 85.5, label = \"IT\", size = 5.8, color = \"#eaa200\") +\n  annotate(\"text\", x = \"Bad\", y = 79.5, label = \"ES\", size = 5.8, color = \"#ff5441\") +\n  annotate(\"text\", x = \"Bad\", y = 73.5, label = \"GR\", size = 5.8, color = \"#73b600\") +\n  scale_fill_manual(values = c(\"#73b600\", \"#eaa200\", \"#ff5441\")) +\n  scale_color_manual(values = c(\"#73b600\", \"#eaa200\", \"#ff5441\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(19, 90.5), breaks = seq(20, 90, by = 10)) +\n  labs(subtitle = \"Italy, Spain and Greece\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 9,\n                                    face = \"plain\", hjust = -0.05, vjust = -4),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 9,\n                                face = \"bold\", hjust = .67, vjust = 1),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt3\n\n\nalt4 <- dataviz_long %>% \n  filter(zone == 4) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 89.5, label = \"CAN\", size = 5.8, color = \"#003f5c\") +\n  annotate(\"text\", x = \"Bad\", y = 86.5, label = \"AUS\", size = 5.8, color = \"#775193\") +\n  annotate(\"text\", x = \"Bad\", y = 83.5, label = \"UK\", size = 5.8, color = \"#ea5476\") +\n  annotate(\"text\", x = \"Bad\", y = 79.5, label = \"US\", size = 5.8, color = \"#ff9f0f\") +\n  scale_fill_manual(values = c(\"#775193\", \"#003f5c\", \"#ff9f0f\", \"#ea5476\")) +\n  scale_color_manual(values = c(\"#775193\", \"#003f5c\", \"#ff9f0f\", \"#ea5476\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(49, 90), breaks = seq(50, 90, by = 10)) +\n  labs(subtitle = \"Canada, Australia, UK and US\",\n       x = NULL,\n       y = NULL,\n       caption = \"Note: All differences shown are statistically significant. \\nSource: Spring 2022 Global Attitudes Survey. Q2\",\n       tag = \"PEW RESEARCH CENTER\") +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.caption.position = \"plot\",\n        plot.caption = element_text(color = \"gray 45\", size = 17.5,\n                                    face = \"plain\", hjust = -0.05, vjust = -6),\n        plot.tag.position = c(0.175, -0.03),\n        plot.tag = element_text(family = \"Helvetica\", size = 16.5,\n                                face = \"bold\", hjust = .33, vjust = 2.5),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt4\n\n\nalt5 <- dataviz_long %>% \n  filter(zone == 5) %>% \n  ggplot(aes(x = Eco_perception, y = Proportion, group = Country, color=Country)) +\n  geom_vline(xintercept = \"Good\", size = .2, color = \"grey65\") +\n  geom_vline(xintercept = \"Bad\", size = .2, color = \"grey65\") +\n  geom_line(size = .5) +\n  geom_point(size = 5) +\n  annotate(\"text\", x = \"Bad\", y = 87, label = \"JPN\", size = 5.8, color = \"#3e015c\") +\n  annotate(\"text\", x = \"Bad\", y = 77, label = \"MYS\", size = 5.8, color = \"#be004e\") +\n  annotate(\"text\", x = \"Bad\", y = 72, label = \"KOR\", size = 5.8, color = \"#f18000\") +\n  annotate(\"text\", x = \"Bad\", y = 67, label = \"SGP\", size = 5.8, color = \"#98c114\") +\n  scale_fill_manual(values = c(\"#3e015c\", \"#be004e\", \"#98c114\", \"#f18000\")) +\n  scale_color_manual(values = c(\"#3e015c\", \"#be004e\", \"#98c114\", \"#f18000\")) +\n  scale_x_discrete(expand = c(0,0.09),\n                   limits = c(\"Good\", \"Bad\")) +\n  scale_y_continuous(limits = c(33, 88), breaks = seq(35, 85, by = 10)) +\n  labs(subtitle = \"Japan, Malaysia, South Korea and \\nSingapore\",\n       x = NULL,\n       y = NULL) +\n  theme(panel.background = element_rect(fill = 'white'),\n        panel.grid.major = element_line(color = \"gray70\", size = .15),\n        panel.grid.minor = element_blank(),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\",\n        plot.subtitle = element_text(family = \"Helvetica\", size = 23,\n                                     color = \"gray25\", vjust = 3),\n        axis.title = element_text(family = \"Helvetica\", size = 11,\n                                  color = \"gray30\", face = \"bold\"),\n        axis.text = element_text(family = \"Helvetica\", size = 20, color = \"gray30\"),\n        axis.ticks = element_blank(),\n        plot.margin = unit(c(1.5, 1, 1.5, .5), \"cm\"))\n\nalt5\n\n\n\n\n\ngraph_alt <- alt1 + alt2 + alt3 + alt4 + alt5 +\n  plot_annotation(title = \"People who see economy negatively are more likely to see a worse financial future for the \\nnext generation\",\n                  subtitle = \"% who say that when children today in (survey country) grow up, they will be worse off financially than their parents,  \\namong those who say their country's economic situation is good or bad\",\n                  theme = theme(\n                    plot.title = element_text(family = \"Helvetica\", size = 28.5,\n                                              face = \"bold\", vjust = 2, color = \"gray20\"),  \n                    plot.subtitle = element_text(family = \"Helvetica\", size = 23.5,\n                                                 color = \"gray20\", face = \"italic\",\n                                                 vjust = 0))) \n\ngraph_alt\n\n\n\n\n\n\n",
    "preview": "projects/2022/100446823/100446823_files/figure-html5/unnamed-chunk-8-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 739,
    "preview_height": 1536
  },
  {
    "path": "projects/2022/100486421/",
    "title": "Worldwide Top 10 Listened Songs in Spotify",
    "description": "This project is about a visualization of the ten most listened songs between\nJune and August 2022 in Spotify.",
    "author": [
      {
        "name": "Jorge Pascual Segovia",
        "url": {}
      }
    ],
    "date": "2023-01-23",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nData cleaning\nReplicating the plot\nAlternative plot\n\nFor this project, I decided to select Spotify worldwide data about the most listened songs between June and August from Newtral’s webpage.\nAt first, we can find the codes for the data cleaning, the replication plot and the alternative plot. Then I will go step by step explaining each of the decisions I took during the replication plot and the alternative plot.\n\n\n#### Libraries\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(gganimate)\n\n\nData cleaning\n\n\n#### Read the Dataset\nspoti<-read_csv(\"spotify-data.csv\", skip = 2,\n                col_names = c(\"Date\",\n                              \"As It Was\",\n                              \"Despechá\",\n                              \"Me Porto Bonito\",\n                              \"Pink Venom\",\n                              \"Quevedo: Bzrp Music Sessions, Vol. 52\",\n                              \"Tití Me Preguntó\"))\n\n\nHere, I noticed that I needed to create the columns of my variable by pivoting the dataframe so I obtain columns for the date, the ranking position and the name of the song:\n\n\n#Pivot long the Song\nspoti <- spoti %>% \n  tidyr::pivot_longer(-Date,\n               names_to = \"Song\",\n               values_to = \"Ranking\")\nspoti\n\n# A tibble: 294 × 3\n   Date   Song                                  Ranking\n   <chr>  <chr>                                   <dbl>\n 1 06-jul As It Was                                   2\n 2 06-jul Despechá                                   NA\n 3 06-jul Me Porto Bonito                             4\n 4 06-jul Pink Venom                                 NA\n 5 06-jul Quevedo: Bzrp Music Sessions, Vol. 52      NA\n 6 06-jul Tití Me Preguntó                            5\n 7 07-jul As It Was                                   2\n 8 07-jul Despechá                                   NA\n 9 07-jul Me Porto Bonito                             4\n10 07-jul Pink Venom                                 NA\n# … with 284 more rows\n\nThen, I wanted the Date column to be date type so it’s easier to handle.\n\n\n#Transform Date column into \"date type\" \nspoti$Date <- paste(spoti$Date, \"2022\",sep=\"-\")\nspoti$Date<-  gsub(\"jul\",07,spoti$Date)\nspoti$Date<-  gsub(\"ago\",08,spoti$Date)\nspoti$Date <- dmy(spoti$Date)\nspoti\n\n# A tibble: 294 × 3\n   Date       Song                                  Ranking\n   <date>     <chr>                                   <dbl>\n 1 2022-07-06 As It Was                                   2\n 2 2022-07-06 Despechá                                   NA\n 3 2022-07-06 Me Porto Bonito                             4\n 4 2022-07-06 Pink Venom                                 NA\n 5 2022-07-06 Quevedo: Bzrp Music Sessions, Vol. 52      NA\n 6 2022-07-06 Tití Me Preguntó                            5\n 7 2022-07-07 As It Was                                   2\n 8 2022-07-07 Despechá                                   NA\n 9 2022-07-07 Me Porto Bonito                             4\n10 2022-07-07 Pink Venom                                 NA\n# … with 284 more rows\n\nAlso, I realized that the font was Roboto, which is in the Google’s font package, so I loaded it as we learnt in the course.\n\n\n#### First theme settings\ntheme_set(theme_minimal()) #Set the minimal theme\nsysfonts::font_add_google(\"Roboto\") #Adding a google font type\n\n\nReplicating the plot\n\n\np <- ggplot(spoti) +\n  aes(Date, Ranking) + #set x and y axis\n  geom_line(aes(color=Song), size = 1) + #set the visualization mark\n  theme(text = element_text(family=\"Roboto\")) #set the font\np\n\n\n\nTo follow with, I realized that the plot is upside down so I needed to adjust the axis’ scales:\n\n\np <- p +\n  #set the order of y axis guides\n  scale_y_continuous(trans = \"reverse\", n.breaks = 10) +               \n  scale_x_date(\n    #set the date format of the y tickmarks\n    date_labels = \"%d-%b\",                                               \n    breaks = seq(as.Date(\"2022-07-11\"), as.Date(\"2022-08-25\"), by = 6))\np\n\n\n\nThen I introduced the title and subtitle and set the format for them. To get the code of the specific color, I used this very useful webpage: https://imagecolorpicker.com/. The size was guessed by playing with the code until I got the same format.\n\n\n  p <- p +\n  labs(\n    title=\"Evolución diaria del ránking en Spotify\", \n    subtitle = \"Posición de las seis canciones más escuchadas en la plataforma a nivel mundial\") +\n  theme(plot.title = element_text(face = \"bold\", size = 16.5)) + # Format of titles\n  labs(x = NULL, y = NULL, color = NULL) # Remove the labels from the axis\np\n\n\n\nHere is the tricky part, the theme settings to make this graph look identically as the original one, step by step. I didn’t write the code at once. I added things while I was advancing with the plot and realizing of needed theme features.\n\n\np <- p +\n  # size and color of the axis components\n  theme(axis.text.y = element_text(colour = \"#a8a8a8\", size = 10), \n        axis.line.y = element_line(size = 0, color = \"#eeeeee\"),\n        axis.text.x = element_text(colour = \"#a8a8a8\", size = 10),\n        panel.grid.minor.y = element_blank(), # remove some grid lines\n        panel.grid.major.y = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        legend.position=\"none\") #remove the legend\np\n\n\n\nAs I removed the legend, I needed to add information to know which song is represented by each visualization mark. I started trying it with annotations but then figured out that ‘geom_text’ was more simple and easy. Once I got the labels, I only needed to adjust the limits so it fitted:\n\n\n#for the location of the legend annotations\ndf.labs <- spoti %>% \n  filter(Date == \"2022-08-23\") \n\np <- p +\n  geom_text(aes(\n    label=Song, colour = Song), df.labs, hjust=0, nudge_x=0.7) + #Annotations for legend\n  expand_limits(x= as.Date(\"2022-9-1\")) + #Create space for the annotations\n  expand_limits(y= 9) \np\n\n\n\nFinally, I only needed to fit the colors of the original plot.\n\n\np <- p +\n  scale_color_manual(values=c( \n  \"#8dc7ad\", \"#5cb689\", \"#267d59\", \"#54b182\", \"#c71e1d\", \"#4ea07c\"))  \np\n\n\n\nAlternative plot\nAt first, I considered that I could add more information as the color visualization mark was almost not giving information apart of which song is the spanish one. As I didn’t have the resources to get more data from Spotify.\n\n\nspotig <- spoti %>% \n  mutate(\"Genre\" = case_when(\n    endsWith(Song, \"52\") ~ \"Pop\",\n    endsWith(Song, \"As It Was\") ~ \"Pop\",\n    endsWith(Song, \"Pink Venom\") ~ \"K-Pop\",\n    endsWith(Song, \"Me Porto Bonito\") ~ \"Reggaeton/Latino\",\n    endsWith(Song, \"Tití Me Preguntó\") ~ \"Reggaeton/Latino\",\n    endsWith(Song, \"Despechá\") ~ \"Reggaeton/Latino\"\n  ))\nspotig\n\n# A tibble: 294 × 4\n   Date       Song                                  Ranking Genre     \n   <date>     <chr>                                   <dbl> <chr>     \n 1 2022-07-06 As It Was                                   2 Pop       \n 2 2022-07-06 Despechá                                   NA Reggaeton…\n 3 2022-07-06 Me Porto Bonito                             4 Reggaeton…\n 4 2022-07-06 Pink Venom                                 NA K-Pop     \n 5 2022-07-06 Quevedo: Bzrp Music Sessions, Vol. 52      NA Pop       \n 6 2022-07-06 Tití Me Preguntó                            5 Reggaeton…\n 7 2022-07-07 As It Was                                   2 Pop       \n 8 2022-07-07 Despechá                                   NA Reggaeton…\n 9 2022-07-07 Me Porto Bonito                             4 Reggaeton…\n10 2022-07-07 Pink Venom                                 NA K-Pop     \n# … with 284 more rows\n\nCreating an alternative plot that wasn’t like the replication was tough as the best way to visualize a timeline is with a line and the time on the x axis. I decided to use an animation as I realized that the second most common type of timelines were animation with bubbles. Bubbles were okay but I thought that the best visualization mark for the names had to be done with ‘geom_text’ with the name of the song. The time would be represented by each frame of the animation and the Genre by color.\nThe toughest thing to find was how to label the date of each frame until I found the argument ‘frame_time’ between brackets.\nFinally, I wanted the theme to be similar as the last one, so I chose many similar options. Here is the result:\n\n\npa <- ggplot(spotig) +\n  aes(Song, Ranking) +\n  geom_text(aes(color = Genre, label = Song)) + # Assign Genre as the color of the text\n  scale_y_continuous(trans = \"reverse\", n.breaks = 9) +\n  expand_limits(x=c(0, 7)) +\n  labs(\n    title=\"Evolución diaria del ránking en Spotify\", \n    subtitle = \"Evolución de las 6 canciones más escuchadas mundialmente en verano de 2022\",\n    tag = \"Date: \n    {frame_time}\", # To tag the Date variable written\n    x = NULL, y = NULL\n  ) +\n  transition_time(Date) + # Date as the variable represented by the animation \n  ease_aes('linear') + # Make the animation smoother\n  theme(\n    plot.title = element_text(face = \"bold\", size = 16.5),\n    plot.subtitle = element_text(size = 10.5, colour = \"#6f6f6f\"),\n    plot.tag.position = c(0.836,0.65),\n    plot.tag = element_text(face = \"bold\", size = 12, hjust = 0),\n    legend.title = element_text(face = \"bold\", size = 12, hjust = 0),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_line(color = \"light grey\"),\n    axis.text.x = element_blank()\n  ) \n\npa\n\n\n\n\n\n\n",
    "preview": "projects/2022/100486421/100486421_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100490068/",
    "title": "Military Spending",
    "description": "In this article I have a walkthrough on how to create a graph as closely as\npossible that was published by the New York Times with ggplot2, but is it\ngraph or a map paste(graph,map); it is both. It shows the country military\nspending in respect to the geolocation of the country.",
    "author": [
      {
        "name": "Yassin Abdelhady",
        "url": {}
      }
    ],
    "date": "2023-01-19",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nNeeded Libraries\nCreating the main data frame\nInitial Trial\n\nProcessing the data\nAttracting all the countries to the center of their continent\nAttracting all the countries to the center of the map\nFinal adjustment to the plot\n\nCreating the legend\nFinal Results\n\nPasting the map with the legend\n\nThe New York Times was posting couple of articles for people/student to be able to analyze the graph with some session being held to discuss them By The Learning Network and this graphs was one of them with a title of What’s Going On in This Graph? it was posted on Feb. 7, 2019 which i found it really interesting to replicate because the graph was a representation of each country but on a map showing their military spending with their bubble size.\nOriginal plot by NYTGetting the data\nNeeded Libraries\n\n\nlibrary(tidyverse)\nlibrary(ggpubr)\nlibrary(plotly)\nlibrary(bubbles) # jcheng5/bubbles\nlibrary(geosphere)\nlibrary(gganimate)\n\n\nThe 3 files will be used are:\nThe main file where it has all the countries with their spending in 2022 and its poplulation\ncountry_file: which has the latitude and the longitude of each country to be able to plot it on the map\ncountry_cont: has each country and which continent it belongs to for grouping\nadding each csv file to a data frame.\n\n\n# country with spending and population 2022\ncountry_main_file<- data.frame(read_csv(file = \"csvData.csv\"))\n#country telemetaries\ncountry_file<- data.frame(read_csv(file = \"Countries.csv\"))\n#country continant\ncountry_cont<- data.frame(read_csv(file = \"country_continent.csv\"))\n\n\nCreating the main data frame\n\n\n#to change spending from numeric to Billions\nto_billion <- 1000000000\n#choosing the desired columns from the lat and lng data file for each country\n#and joining it to the continent\ncountry_file <-  country_file %>%\n  transmute(country = Country, lat = Latitude,lng = Longitude)%>%\n  left_join(.,country_cont,by = \"country\")\n\n#main data frame\ncountry_main <- country_main_file%>% \n  #changing rhe spending to billions for the text view\n  mutate(spending_text = paste(spending/to_billion,\"Billion\"))%>%\n  mutate(text = paste(\"Country: \", country, \"\\nMilitary Sepnding: \", spending_text, sep=\"\"))%>%\n  #removing the population column\n  select(-c(pop2022))%>%\n  #joining the data frame with lat and lng and continent\n  left_join(.,country_file,by=\"country\")%>%\n  #arrangaing the data set into descending order in respect of military spending \n  arrange(desc(spending))%>%\n  #creating a variable \"graph group\" to be able to differentiate between\n  #the first country then the next 7 and the rest\n  #creating a variable \"color graph\" to assign each group a color\n  #creating a variable \"country_id\" to give a numeric ID to each country\n  #in respect of the military spending\n  mutate(\n    graph_group = ifelse(\n      row_number()==1, paste(country,spending_text,sep=\" \"),\n      ifelse(\n        row_number()>=2 & row_number()<=8, \"Next 7 countries\",\"Rest of The World\")),\n    color_graph = ifelse(\n      row_number()==1, \"#225600\",\n      ifelse(\n        row_number()>=2 & row_number()<=8, \"#7c997c\", \"#bebebe\")),\n    country_id=row_number()\n  ) %>% \n  #changing the military spending for the rest of the world to divide it by 4\n  #to decrease their size in the graph \"spending_extra\"\n  mutate(spending_extra = ifelse(country_id>9,spending/4,spending))%>%\n  #dropping NAs\n  drop_na()%>%\n  #\n  mutate(\n    graph_text = ifelse(\n      country_id == 1, paste(country,\"\\n\",\"$\",spending_text,sep=\"\"),\n      ifelse(\n        country_id>1 & country_id<9, paste(country,\"\\n\",spending/to_billion,sep=\"\"), \"\")), \n    #creating a variable to be able to create the legend\n    legend_group=ifelse(row_number()>=2 & row_number()<=8,country,graph_group),\n    #creating a ratio for the bubble size so the highest spending would be 10\n    #\"the max\" and the rest ratio from the country that spends the most\n    bubble_size = (spending - min(country_main_file$spending)) /\n      (max(country_main_file$spending) - min(country_main_file$spending)),\n    #making north america and south america near the rest of the map\n    lng = ifelse(continent==\"North America\" | continent==\"South America\",lng+35,lng )\n  )%>%\n  #Removing Oceania to make it easier\n  filter(continent!=\"Oceania\")\n\n\nInitial Trial\nPlotting all the point on a graph just to see the output and adding this graph to ggplotly to make it interactive\n\n\np <- ggplot(country_main) + \n  aes( x =lng ,y=lat,color=graph_group , size = spending,text=text,label = country)+\n  geom_point(alpha=1.3)+\n  theme_void()+\n  ggtitle(\"Military Spending by Country 22\") +\n  theme(plot.title = element_text(hjust = 0.5),legend.position=\"none\")\n\np\n\n\n\n\n\nggplotly(p, tooltip=\"text\")\n\n\n\nProcessing the data\nAttracting all the countries to the center of their continent\nThe problem is getting all the points together without making them to over lap.. since there is no package that take into consideration that it is lat and lng of country they do a great job at repelling the point from each other but not the same way we need it, so by getting the center of each continent and drawing a line from each country to the center of its continent then dividing this number into 2 to get\nVariables will use later in equations\n\n\ndivide_num <- 2\nmultiplier <- 10\n\n\n\n\n# To get the continent center by adding the max of the cords with the min\n# and then dividing by 2 \ncontinent_center <- country_main%>%\n  group_by(continent)%>%\n  summarise(top_lat=(max(lat)+min(lat))/2,top_lng=(max(lng)+min(lng))/2)\n# to make all the points go to the center of the continent\nto_continent<-country_main%>% \n  #selecting the desired columns\n  select(country,lat,lng,spending,color_graph,graph_text,continent,\n         bubble_size,graph_group)%>%\n  #joing each country the center of its continent\n  left_join(.,continent_center, by =\"continent\")%>%\n  #calculating the slope between each country and the center of its continent\n  mutate(slope = (lat-top_lat)/(lng-top_lng))%>%\n  #getting the intercept of each country and the center of continent line\n  mutate(intercept = (slope*lng)*-1 + lat)%>%\n  #creating a new Y value \"lat\" and dividing by \"divide_num\" to move the old\n  #value on the same line to the center of the continent \n   mutate(new_lat = (slope*( \n    ifelse(top_lng<0 & lng>top_lng,(abs(top_lng-lng)/divide_num)+top_lng,\n           ifelse(top_lng<0 & lng<top_lng,top_lng-(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           ifelse(top_lng>0 & lng>top_lng,top_lng+(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           ifelse(top_lng>0 & lng<top_lng,top_lng-(abs(top_lng-lng)/ifelse(\n             continent !=\"Europe\",divide_num*1,divide_num)),\n           top_lng))))  ) )+intercept)%>%\n  #generating a new X value \"lng\" \n  mutate(new_lng = (new_lat+(intercept*-1))/slope)%>%\n  mutate(new_lat=ifelse(is.na(new_lat),lat,new_lat),\n         new_lng =ifelse(is.na(new_lng),lng,new_lng) )%>%\n  #selecting only the columns that we need and adding the calculations that\n  #we have made to lat and lng\n  transmute(country,lat=new_lat,lng=new_lng,spending,color_graph,graph_text,\n            continent,bubble_size,graph_group)\n\n# to visualize what happened in the previous part \n to_continent_graph <-country_main%>%\n   #selecting the desired columns from the main data frame and adding a new\n   #column to be able to animate \n   transmute(lat,lng,continent,country,frame_num=1)%>%\n   #appending to_continent dataframe to the normal country data and adding a\n   #column frame_num=2 to indicate to the animation its the second part\n   union(.,to_continent%>%transmute(lat,lng,continent,country,frame_num=2))%>%\n   #plotting the data and coloring each contient to be able to see the transformation\n   ggplot(.,aes(x=lng,y=lat,color=continent))+\n   #decreasing the opacity of the point\n    geom_point(alpha=0.4)+\n   #plotting thr center of each continent to be able to see the movement direction\n   geom_point(data= continent_center,mapping = aes(top_lng,top_lat),color=\"black\")+\n   #applying a void theme \n   theme_void()+\n   #adding a title for the graph\n   ggtitle(\"To the center of the continent\")+\n   #making the plot title centered and removing the legend\n   theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\")+\n   #for the animation the column we have created earlier\n   transition_time(frame_num)\n\nto_continent_graph\n\n\n\nAttracting all the countries to the center of the map\n\n\n# To get the map center by adding the max of the cords with the min\n# and then dividing by 2 \ncenter_map <- to_continent%>%\n  select(lat,lng)%>%\n  summarise(lat=(max(lat)+min(lat))/2,lng=(max(lng)+min(lng))/2)\n\n#creating a data frame to move the countires towards the center of the map\nto_center <- to_continent%>%\n  #adding the lat and lng of the center of the map\n  mutate(top_lat =as.numeric(center_map[1]), top_lng =as.numeric(center_map[2]))%>%\n  #calculating the slope between each country and the center of the map\n  mutate(slope = (lat-top_lat)/(lng-top_lng))%>%\n  #getting the intercept of each country and the center of the map line\n  mutate(intercept = (slope*lng)*-1 + lat)%>%\n  #creating a new Y value \"lat\" and dividing by \"divide_num\"*2 to move the\n  #old value on the same line to the center of the map \n  mutate(new_lat = (slope*( \n    ifelse(top_lng<0 & lng>top_lng,(abs(top_lng-lng)/(divide_num*2))+top_lng,\n           ifelse(top_lng<0 & lng<top_lng,top_lng-(abs(top_lng-lng)/(divide_num*2)),\n           ifelse(top_lng>0 & lng>top_lng,top_lng+(abs(top_lng-lng)/(divide_num*2)),\n           ifelse(top_lng>0 & lng<top_lng,top_lng-(abs(top_lng-lng)/(divide_num*2)),\n           top_lng))))  ) )+intercept)%>%\n  #generating a new X value \"lng\" \n  mutate(new_lng = (new_lat+(intercept*-1))/slope)%>%\n  #error handling\n  mutate(new_lat=ifelse(is.na(new_lat),lat,new_lat),\n         new_lng =ifelse(is.na(new_lng),lng,new_lng) )%>%\n  #selecting only the columns that we need and adding the calculations that we\n  #have made to lat and lng\n  transmute(country,lat=new_lat,lng=new_lng,spending,color_graph,graph_text,\n            continent,bubble_size,new_lat,new_lng,graph_group)\n\n\n# to visualize what happened in the previous part \n to_center_graph <-to_continent%>%\n   #selecting the desired columns from  to_continent data frame and adding\n   #a new column to be able to animate \n   transmute(lat,lng,continent,country,frame_num=1)%>%\n   #appending to_center dataframe to to_continent dataframe and adding\n   #a column frame_num=2 to indicate to the animation its the second part\n   union(.,to_center%>%transmute(lat,lng,continent,country,frame_num=2))%>%\n   #plotting the data and coloring each contient to be able to see the transformation\n   ggplot(.,aes(x=lng,y=lat,color=continent))+\n   #decreasing the opacity of the point\n   geom_point(alpha=0.4)+\n   #plotting the center of the map point to see the movement towards it \n   geom_point(data= center_map ,mapping = aes(lng,lat),color=\"black\")+\n   #applying theme void\n   theme_void()+\n   #adding title to the graph\n   ggtitle(\"To the center of the map\")+\n   #aligning the title to the center of the graph and removing the legend\n   theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\")+\n   #for the animation the column we have created earlier\n   transition_time(frame_num)\n \nto_center_graph\n\n\n\nFinal adjustment to the plot\nManually adjusting just to ensure no overlapping bubbles\n\n\nfinal_country_adj <- to_center%>%\n  #move all north america up and left \n  mutate(\n    top_lat =ifelse(continent==\"North America\",\n                    ((to_center[to_center$country==\"Finland\",2]-lat)/1.1)+lat,lat),\n    top_lng =ifelse(continent==\"North America\",lng+10,lng))%>%\n  # Moving Africa up towards spain\n  mutate(\n    top_lat =ifelse(continent==\"Africa\",\n                    (((to_center[to_center$country==\"Spain\",2]-lat)/1.05)+lat)+2.25,\n                    top_lat))%>%\n  #Moving South America up toward Panama and right manual \n  mutate(\n    top_lat =ifelse(continent==\"South America\",\n                    ((to_center[to_center$country==\"Panama\",2]-lat)/1.1)+lat+8.85,top_lat),\n    top_lng =ifelse(continent==\"South America\",lng+4.7,top_lng))%>%\n  #decreasing the distance between the highest lat and Europe\n  mutate(\n    top_lat =ifelse(continent==\"Europe\",\n                    ((to_center[to_center$country==\"Finland\",2]-lat)/1.5)+lat,top_lat))%>%\n  mutate(\n    #Moving Asia towards Finland and left manual\n    top_lat =ifelse(continent==\"Asia\",\n                    (((to_center[to_center$country==\"Finland\",2]-lat)/1.1)+lat)+0.2,top_lat),\n    top_lng =ifelse(continent==\"Asia\",\n                    ((max(to_center[to_center$continent==\"Europe\",3])-\n                        min(to_center[to_center$continent==\"Asia\",3]))+lng)-2,top_lng))%>%\n  transmute(country,lat=top_lat,lng=top_lng,spending,color_graph,graph_text,continent,\n            bubble_size= ifelse(country!=\"United States\",\n                                bubble_size*3,bubble_size*1.2),graph_group)\n\n\n\n\nfinal_plot<- ggplot(final_country_adj,aes(x=lng,y=lat,text=country))+\n  ggforce::geom_mark_ellipse(\n    aes(filter = country == \"United States\", \n        description = \"Proposed Increase\\n +$54 billion\"),\n    con.linetype = 4,con.size=0.3,label.fontsize = 6,\n    label.fill = \"transparent\",con.cap = 0)+\n  ggforce::geom_mark_ellipse(\n    aes(filter = graph_group == \"Next 7 countries\" , description = graph_text),\n    con.linetype = 4,con.size=0.3,label.fontsize = 6,label.fill = \"transparent\",\n    con.cap = 0,expand = unit(1, \"mm\"))+\n  geom_point(data = final_country_adj%>%\n               filter(country==\"United States\") ,\n             aes(x = lng,y=lat, size = bubble_size*multiplier*2 ,\n                 stroke = bubble_size*multiplier*1.7),color=\"black\")+\n  geom_point(data=final_country_adj ,\n             aes(size = bubble_size*multiplier*2 ,\n                 stroke = bubble_size*multiplier*1.6,color=color_graph))+\n  scale_color_identity()+\n  annotate(\"text\", x=final_country_adj[final_country_adj$country==\"United States\",'lng'],\n           y=final_country_adj[final_country_adj$country==\"United States\",'lat'],\n           label=final_country_adj[final_country_adj$country==\"United States\",'graph_text'],\n           hjust=0.5, color=\"white\",size=3)+\n  ggtitle(\"Military Spending by Country 22\") +\n  theme_void()+\n  theme(plot.title = element_text(hjust = 0.5),\n        legend.position = \"none\",\n        panel.grid = element_blank(),\n        panel.border = element_blank())\nfinal_plot\n\n\n\nCreating the legend\n\n\n#creating a Dataframe from the main Dataframe to make the legend\nlegend_df <- country_main%>%\n  mutate(graph_group = ifelse(country_id==1,country,graph_group))%>%\n  group_by(legend_group,graph_group)%>%\n  summarise(spending=sum(spending),nr = max(country_id))%>%\n  arrange(nr)%>%mutate(text_color = ifelse(nr<9,\"#FFFFFF\", \"#000000\"))\n\n#Legend column color\nlegend_colors <-country_main%>%\n  arrange(desc(spending))%>%\n  group_by(legend_group)%>%\n  summarise(bar_color = max(color_graph))%>%select(bar_color)\n# in column text\nlegend_ann <-legend_df%>%\n  group_by(graph_group)%>%\n  summarise(spending = sum(spending),rn = max(nr))%>%\n  arrange(rn)%>%\n  mutate(spending_ann =ifelse(\n    rn==1,paste(\"$\",spending/to_billion,\" billion\",sep=\"\"),\n    round(spending/to_billion)) )\n\n\n#Legend plot\nlegend_plot <- ggplot(\n  legend_df%>%\n    left_join(.,y=legend_ann%>%\n                select(graph_group,spending_ann),by=\"graph_group\"))+\n  aes(x = spending,y=reorder(graph_group,-nr), fill = legend_group )+ \n  geom_bar(stat = \"identity\",color =\"#FFFFFF\",\n           position = position_stack(reverse = TRUE),width = 0.9)+\n  scale_fill_manual(values =  legend_colors[['bar_color']]  )+\n  theme(legend.position = \"none\")+\n  geom_text(aes(x=15000000000,label=spending_ann,hjust=0),\n            color = legend_df[['text_color']] )+\n  theme_void()+\n    theme(legend.position = \"none\",\n          axis.text.x=element_blank(),\n          axis.text.y=element_text(hjust=0,size=12)\n  )\n\nlegend_plot\n\n\n\nFinal Results\nIn summary, so far we have\nBuild steps:\nInitial plot to visualize the map;\nMoving all the countries to the center of the continent;\nMoving all the continents to the center of the map;\nPlotting the final map;\nCreating the legend.\nPasting the map with the legend\n\n\nggarrange(\n  final_plot,\n  ggarrange(\n    ggplot()+theme_void(),\n    legend_plot\n    ,ggplot()+theme_void()\n    ,hjust=10,ncol = 3, nrow = 1,widths = c(0.3,1,0.3) \n    ),\n  hjust=10,\n  ncol = 1, \n  nrow = 2, \n  widths = c(1,0.5),\n  heights = c(5,1)\n)\n\n\n\n\n\n\n",
    "preview": "projects/2022/100490068/original_graph.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 3372,
    "preview_height": 1740
  },
  {
    "path": "projects/2022/100385545/",
    "title": "Searches of common jobs: women tends to appear lower than men",
    "description": "A replication of the graph made by Pew Research Center about the topic and another proposal.",
    "author": [
      {
        "name": "Mario Yanes",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGender equality on online search of jobs?\nLet’s start with the replication\nAdding tiles\nPlot again\nRearrange y-axis\nAesthetic and themes\nProblems\nSolving the x-axis\n\n\nAlternative visualization or improvements\nFinal alternative visualization\n\n\nGender equality on online search of jobs?\nA research conducted by the Pew Research Center on December 2018 showed that inequalities also exist on online search. They represented the obtained data in several graphs, such as the underrepresentation or overrepresentation of women depending on the profession, with a several gap between the results of the search and the actual proportion of women in each occupation.\nBut the graph we are going to replicate on this project is the one that shows the average position obtained by the first male or female depending on the profession. Such graph is the following:\n\n\n\nFigure 1: Original graph from Pew Research Center\n\n\n\nLet’s start with the replication\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\nsysfonts::font_add_google(\"Poppins\", family=\"poppins\")\nsysfonts::font_add_google(\"Tinos\", family=\"tinos\")\nsysfonts::font_add_google(\"Arimo\", family=\"arimo\")\nshowtext::showtext_auto()\n\n\nAfter importing (and installing, if necessary) the libraries needed for this project, the next step is to import the data of the plot. Besides the Pew Research Center didn’t publish the dataset they used to the article alongside it, it’s pretty simple to generate ourselves a dataframe, as they are integers numbers (the position on a search results page) and 20 professions.\n\n\ndf <- data.frame(\n  Profession = c(\"CEO\", \"Professor\", \"Electrical engineer\", \"Security guard\",\n                 \"Banker\", \"Clergy\", \"Industrial engineer\", \"Bartender\", \"Musician\",\n                 \"Chef\", \"Movie director\", \"Police\", \"Athlete\", \"Medical scientist\",\n                 \"Physician\", \"Pharmacist\", \"Nurse\", \"Clerk\", \"Customer service rep.\",\n                 \"Housekeeper\"),\n  Male = c(2, 2, 3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 3, 3, 2, 3, 4, 4, 4, 6),\n  Female = c(16, 13, 10, 8, 9, 8, 7, 7, 6, 6, 6, 5, 5, 4, 3, 3, 4, 3, 2, 2)\n)\n\n\nAs for now, we have the data we want to plot. Let’s focus on generating the plot. Following the original graph, the position of the first male/female that appears on a web search of a certain job is plotted as a tile. The tile is #eb9f2e if it’s a male, #83669f if it’s a female.\n\n\np <- ggplot(df, aes(y=Profession)) + \n  geom_tile(aes(x=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.35, height = 0.7) + \n  geom_tile(aes(x=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.35, height =0.7)\n\np\n\n\n\nAt this time, we have one major issue: we only plotted the female/male tiles, but the original graph has another 14 white tiles (or 15, on Pharmacist and Nurse, where both gender have the same value), as they represent all the possible values.\nAdding tiles\nThe way of adding the blank tiles that represent all the possible values was tricky. First of all, my intention was trying to generate them automatically with a given R function, but I was not capable of. Instead, I added to the dataset 16 new variables, one per column, that would fit on the x-axis and be the “empty” tiles. In order from 1 to 16, I added the positions that were left. So the entire and final dataframe resulted on the following:\n\n\ndf <- df %>%\n  mutate(\n    position = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),\n    position2 = c(3, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 4, 2, 2, 2, 3, 3),\n    position3 = c(4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 4, 3, 5, 5, 4),\n    position4 = c(5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 5, 5, 6, 6, 5),\n    position5 = c(6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 7, 7),\n    position6 = c(7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7, 8, 8, 8),\n    position7 = c(8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9),\n    position8 = c(9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 10, 10, 10),\n    position9 = c(10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 11, 11, 11),\n    position10 = c(11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 12, 12, 12),\n    position11 = c(12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 13, 13, 13),\n    position12 = c(13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 13, 14, 14, 14),\n    position13 = c(14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 14, 14, 15, 15, 15),\n    position14 = c(15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 16),\n    position15 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 16, 16, NA, NA, NA)\n)\n\n\nPlot again\nDone that, the plot should have now all the needed tiles, both of the gender variable and all the possible positions. So we add to the first code we plotted the geom_tile() for each new variable we added to the dataset, as the following:\n\n\np <- ggplot(df, aes(y=Profession)) + \n  geom_tile(aes(x=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.35, height = 0.7) + \n  geom_tile(aes(x=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.35, height =0.7) +\n  geom_tile(aes(x=position), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position2), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position3), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position4), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position5), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position6), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position7), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position8), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position9), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position10), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position11), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position12), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position13), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position14), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) +\n  geom_tile(aes(x=position15), fill=\"white\", color = \"grey\", width = 0.35, height = 0.7) \n\np\n\n\n\nRearrange y-axis\nThis graph has the essential parts of the original one. Nonetheless, the order of the y-axis is not the same, besides we created the dataframe following, from top to bottom, the graph of the Pew Research Center. To fix that, we can use the function scale_y_discrete(limits = rev(df$Profession). We also use the scale_y_discrete() function to add some space at the top of the grid, as we will needed it for the title and the subtitle:\n\n\np <- p + scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_y_discrete(limits = rev(df$Profession), expand = expansion(mult = c(0, 0.1))) \n\np\n\n\n\nAesthetic and themes\nNow we have a graph that follows the original one in its factor form, but we have to modify the appearance to achieve a replica.\nFirst of all, they removed the axis title of both y and x-axis. Also, the title and the subtitle and the attribution of the plot, and one important thing: the legend. The legend is added to the graph in a particularly way: Male and Female are not together in a traditional box or something like that, as they are on top of the corresponding first tile. So, instead of using labs or another related function, we insert “Male” and “Female” as an annotation. With the extra space we gave to the top of the grid, the words are not cut by the space of the subtitle.\n\n\np <- p + labs(\n    x = \"\",\n    y = \"\",\n    title = \"Women appear lower in image\\nsearch results for common jobs\\nacross countries\",\n    subtitle = \"\\nAverage position of the first man or woman\\nin image search results for ...\\n \"\n  ) +\n  annotate(\"text\", x = 2, y = 21, label = \"Male\", size = 3, color = \"#eb9f2e\",\n           fontface = 2, family = \"arimo\") +\n  annotate(\"text\", x = 16, y = 21, label = \"Female\", size = 3, color = \"#83669f\",\n           fontface = 2, family = \"arimo\") \n\np\n\n\n\nThe trickiest thing we tended to solve is the tiles of Pharmacist and Nurse, the only ones where Male and Female have the same value. The closest approach was generating an annotation with a rectangle (instead of a triangle, as it was impossible to achieve):\n\n\np <- p +\n  annotate(\"rect\", xmin = 3.05, xmax = 3.2, ymin = 4.725, ymax = 5.3, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"rect\", xmin = 4.05, xmax = 4.2, ymin = 3.725, ymax = 4.3, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") \n\np\n\n\n\nFinally, we adjust the things related to the themes. The grid has to be completely white and without borders, the axis ticks and line disappear and we try to have the same font family as the original one, as well of adjusting on the horizontal axis the title and the subtitle. This results in the final graph.\n\n\np <- p + theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  panel.border = element_blank(),\n  axis.text = element_text(family = \"tinos\"),\n  axis.text.x = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"arimo\", hjust = 0),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"tinos\",\n                               hjust = 0, vjust = 4),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np\n\n\n\nProblems\nIf we compare the original graph and the replica one, we see three main differences. The first difference is the width of the plot and the distance between the columns of tiles. Through different manners we tried to narrow the grid, but these actions tended to deform the tiles and the graph.\nThe second difference is located at the tiles of Pharmacist and Nurse, where the original one plotted the tiles half #eb9f2e and half #83669f with each color in a triangle. The closest approach was generating an annotation with geom_rect(), as geom_polygon() couldn’t be printed in a annotation, besides several tries.\nThe third difference is the x-axis. While seemed to be an easy way to modify the breaks of the axis in order to show 1, 4, 8, 12 and 16, at the moment we introduced to the code the scale_x_discrete(breaks = c(1, 4, 8, 12, 16)) or scale_x_discrete(limits = c(1,16), breaks = c(1, 4, 8, 12, 16)), the x-axis disappears and also some data is not plotted correctly.\nSolving the x-axis\nThe solution I found to solve the problem with the breaks of the x-axis was to expand the bottom of the graph and introducing the labels as regular text with anotate.\n\n\np <- p + expand_limits(y = -1.5) +\n  annotate(\"text\", x = 1, y = -.9, label = \"1st\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 4, y = -.9, label = \"4th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 8, y = -.9, label = \"8th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 12, y = -.9, label = \"12th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 16, y = -.9, label = \"16th\", size = 3.25, color = \"#76777a\",\n           fontface = 1, family = \"tinos\") +\n  annotate(\"text\", x = 1, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 4, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 8, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 12, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\") +\n  annotate(\"text\", x = 16, y = 0.4, label = \"|\", size = 2, color = \"#76777a\",\n           fontface = 1, family = \"arimo\")\np\n\n\n\nAlternative visualization or improvements\nWhen thinking about another ways of plotting the same data while maintaining the essence and the meaning of the graph, the first thing that came to my mind was to plot the searches individually and in a vertically way. The goal is to keep a familiar look and feel to an actual web search engine. The spirit is the same, but instead of tiles, rectangles figures that tend to be similar to the boxes that Google, DuckDuckGo and other search engines use to organize the results.\nThe first step was to recreate the dataset inverting the position of the tiles, as 1 being 16, 2 being 15 and so on, as we want to plot the first positions on top, instead from bottom to top. We also introduced two empty professions, “Blank”, that will help us later in order to clean the view and insert the legend.\n\n\na_df <- data.frame(\n  Profession = c(\"CEO\", \"Professor\", \"Electrical engineer\", \"Security guard\",\n                 \"Banker\", \"Blank\", \"Clergy\", \"Industrial engineer\", \"Bartender\",\n                 \"Musician\", \"Chef\", \"Movie director\", \"Police\", \"Athlete\",\n                 \"Medical scientist\", \"Physician\", \"Blank\", \"Pharmacist\", \"Nurse\",\n                 \"Clerk\", \"Customer service rep.\", \"Housekeeper\"),\n  Male = c(15, 15, 14, 15, 14, NA, 15, 15, 15, 15, 15, 15, 15, 14, 14, 15, NA, 14, 13, 13, 13, 11),\n  Female = c(1, 4, 8, 9, 7, NA,  9, 10, 10, 11, 11, 11, 12, 12, 13, 14, NA, 14, 13, 14, 15, 15),\n  position = c(16, 16, 16, 16, 16, NA, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, NA, 16, 16, 16, 16, 16),\n  position2 = c(14, 14, 15, 14, 15, NA, 14, 14, 14, 14, 14, 14, 14, 15, 15, 13, NA, 15, 15, 15, 14, 14),\n  position3 = c(13, 13, 13, 13, 13, NA, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, NA, 13, 14, 12, 12, 13),\n  position4 = c(12, 12, 12, 12, 12, NA, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, NA, 12, 12, 11, 11, 12),\n  position5 = c(12, 12, 12, 12, 12, NA, 12, 12, 12, 10, 10, 11, 11, 11, 11, 11, NA, 12, 12, 11, 11, 11),\n  position6 = c(11, 11, 11, 11, 11, NA, 11, 9, 9, 9, 9, 9, 9, 9, 9, 9, NA, 11, 11, 9, 9, 9),\n  position7 = c(9, 9, 9, 8, 9, NA, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, NA, 9, 9, 8, 8, 8),\n  position8 = c(8, 8, 7, 7, 8, NA, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, NA, 8, 8, 7, 7, 7),\n  position9 = c(7, 7, 6, 6, 6, NA, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, NA, 7, 7, 6, 6, 6),\n  position10 = c(6, 6, 5, 5, 5, NA, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, NA, 6, 6, 5, 5, 5),\n  position11 = c(5, 5, 4, 4, 4, NA, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, NA, 5, 5, 4, 4, 4),\n  position12 = c(4, 3, 3, 3, 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, NA, 4, 4, 3, 3, 3),\n  position13 = c(3, 2, 2, 2, 2, NA, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, NA, 3, 3, 2, 2, 2),\n  position14 = c(2, 1, 1, 1, 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, NA, 2, 2, 1, 1, 1),\n  position15 = c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 1, 1, NA, NA, NA)\n) \n\n\nThe next step is to create dataframes for every graph we want to plot (and join at the last steps). As there are 22 positions (twenty professions and two empty columns), we divide them in 2 different dataframes. We use the entire dataframe we’ve just created and divide it maintaining the positions and adding another column to fix the empty tiles.\n\n\nf_df <- a_df %>% slice(1:(n()-11)) %>% \n  mutate(position15 = c(10, 10, 10, 10, 10, NA, 10, 11, 11, 10, 10))\n\nfo_df <- a_df %>% slice(12:n()) %>% \n  mutate(position15 = c(10, 10, 10, 10, 10, NA, 10, 10, 10, 10, 10)) %>% \n  mutate(position5 = c(NA, NA, NA, NA, NA, NA, 12, 12, 11, 11, NA)) %>% \n  mutate(position16 = c(1, 1, NA, NA, NA, NA, 1, 1, NA, NA, NA))\n\n\nWith the two dataframes, we set the variable Profession as a factor and we indicate the order in we want it to be plotted with the levels option.\n\n\nf_df$Profession <- factor(f_df$Profession, levels = c(\n  \"Professor\", \"CEO\", \"Electrical engineer\", \"Banker\", \"Security guard\", \"Blank\", \n  \"Clergy\", \"Industrial engineer\", \"Bartender\", \"Musician\", \"Chef\" ))\n\np1 <- ggplot(f_df, aes(x = Profession)) + \n  geom_tile(aes(y=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.7, height = 0.8, size = 1) + \n  geom_tile(aes(y=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.7, height = 0.8, size = 1) +\n  geom_tile(aes(y=position), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position2), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position3), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position4), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position5), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position6), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position7), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position8), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position9), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position10), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position11), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position12), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position13), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position14), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position15), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_x_discrete(position = \"top\", guide = guide_axis(n.dodge=2)) +\n  annotate(\"text\", x = 6, y = 15, label = \"Male\", size = 3.5, color = \"#eb9f2e\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 6, y = 9.05, label = \"Female\", size = 3.5, color = \"#83669f\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 16, label = \"1st\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 13, label = \"4th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 9, label = \"8th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 5, label = \"12th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 1, label = \"16th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 16, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 13, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 9, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 5, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 1, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 1, y = 17.2, label = \"Professor\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 2, y = 18.2, label = \"CEO\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 3, y = 17.2, label = \"Electrical eng.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 4, y = 18.2, label = \"Banker\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 5, y = 17.2, label = \"Security guard\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 7, y = 17.2, label = \"Clergy\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 8, y = 18.2, label = \"Industrial eng.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 9, y = 17.2, label = \"Bartender\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 10, y = 18.2, label = \"Musician\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 11, y = 17.2, label = \"Chef\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  expand_limits(x = c(-.5, 12.5), y = c(0, 18)) +\nlabs(\n    title = \"Women appear lower in image search results\\nfor common jobs across countries\\n\",\n    subtitle = \"Average position of the first man or woman in image search results for ... \"\n  ) +\n  theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  axis.text = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"poppins\", hjust = 0.5),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"poppins\",\n                               hjust = .5, vjust = 4),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np1\n\n\n\nIn this case, we also rename the profession “Customer service rep.” to “Cust. serv. rep.” in order to make the name shorter and avoid overlapping.\n\n\nfo_df[fo_df$Profession == \"Customer service rep.\", \"Profession\"] <- \"Cust. serv. rep.\"\n\nfo_df$Profession <- factor(fo_df$Profession, levels = c(\n  \"Movie director\", \"Police\", \"Athlete\", \"Medical scientist\", \"Physician\",\n  \"Blank\", \"Pharmacist\", \"Nurse\", \"Clerk\", \"Cust. serv. rep.\", \"Housekeeper\"))\n\n\np2 <- ggplot(fo_df, aes(x = Profession)) + \n  geom_tile(aes(y=Male), fill=\"#eb9f2e\", color = \"#eb9f2e\", width = 0.7, height = 0.8, size = 1) + \n  geom_tile(aes(y=Female), fill=\"#83669f\", color = \"#83669f\", width = 0.7, height = 0.8, size = 1) +\n  geom_tile(aes(y=position), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position2), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position3), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position4), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position5), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position6), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position7), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position8), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position9), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position10), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position11), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position12), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position13), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position14), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position15), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  geom_tile(aes(y=position16), fill=\"white\", color = \"black\", width = 0.7, height = 0.8, size = 0.2) +\n  scale_fill_manual(values=c(position =\"white\",\n                             Male =\"#eb9f2e\",\n                             Female = \"#83669f\")) +\n  scale_x_discrete(position = \"top\", guide = guide_axis(n.dodge=2)) +\n  annotate(\"rect\", xmin = 7, xmax = 7.35, ymin = 13.6, ymax = 14.4, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"rect\", xmin = 8, xmax = 8.35, ymin = 12.6, ymax = 13.4, alpha = 1,\n           color = \"#eb9f2e\", fill = \"#eb9f2e\") +\n  annotate(\"text\", x = 6, y = 15, label = \"Male\", size = 3.5, color = \"#eb9f2e\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 6, y = 14.05, label = \"Female\", size = 3.5, color = \"#83669f\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 16, label = \"1st\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 13, label = \"4th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 9, label = \"8th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 5, label = \"12th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.1, y = 1, label = \"16th\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 16, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 13, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 9, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 5, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 0.5, y = 1, label = \"—\", size = 3.25, color = \"#6d6e71\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 1, y = 17.2, label = \"Movie director\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 2, y = 18.2, label = \"Police\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 3, y = 17.2, label = \"Athlete\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 4, y = 18.2, label = \"Medical scientist\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 5, y = 17.2, label = \"Physician\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 7, y = 17.2, label = \"Pharmacist\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 8, y = 18.2, label = \"Nurse\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 9, y = 17.2, label = \"Clerk\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 10, y = 18.2, label = \"Cust. serv. rep.\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  annotate(\"text\", x = 11, y = 17.2, label = \"Housekeeper\", size = 3.25, color = \"black\",\n           fontface = 1, family = \"poppins\") +\n  expand_limits(x = c(-.5, 12.5), y = c(-.5, 18)) +\n  theme_light() +\n  theme(\n  panel.background = element_blank(),\n  panel.grid = element_line(size = 0.25, color = \"white\"),\n  axis.ticks = element_blank(),\n  axis.line = element_blank(),\n  axis.text = element_blank(),\n  plot.title = element_text(face = \"bold\", family = \"poppins\", hjust = 0.5),\n  plot.subtitle = element_text(color = \"grey\", face = \"italic\", family = \"poppins\",\n                               hjust = .5, vjust = 2),\n  plot.caption = element_text(hjust = 0),\n  axis.title = element_blank()\n)\n\np2\n\n\n\nFinal alternative visualization\nAnd finally, here we have our alternative visualization, composed by the two previous plots:\n\n\np1 / p2\n\n\n\n\n\n\n",
    "preview": "projects/2022/100385545/100385545_files/figure-html5/unnamed-chunk-11-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100385586/",
    "title": "Restrictions on religion among the most populated countries across time",
    "description": "A replication of a graph from Pew Research Center on the \nrestrictions on religion among the 25 most populous countries.",
    "author": [
      {
        "name": "Alejandro Aísa",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original graph\nSet up and libraries\nPrerequisites for the graph\nAdapting the database\nElements and labels\n\nGraph construction\nTechnical features of the graph\n\nThe Graph(s)\nVisual features and information transmitted\nUnachieved features\nInteractive options with plotly\nProposed enhacements\nSecond alternative\n\n\nThe original graph\nThe graph to replicate was originally created by the Pew Research Center.\nIt is an interactive graph depicting the evolution in time of two measures related to religious conflicts: Goverment Restrictions Index (GRI) and Social Hostilities Index (SHI). The 25 most populous countries are included in the graph. Our goal: to replicate it as closely as possible.\nSet up and libraries\nAs with any other project, we have to load some the libraries that will be needed to complete the graph.\n\n\nlibrary(tidyverse)\nlibrary(gganimate)\nlibrary(plotly)\nlibrary(ggtext)\nlibrary(RColorBrewer)\nlibrary(showtext)\n\n\nPrerequisites for the graph\nAdapting the database\nFirst, we have to load the data. In this case, it has been directly compiled from the Pew Research Center.\nSome columns are going to be renamed and/or modified to make easier the coding. Also, a new variable is created to give later the colour to the bubbles (geom_point()) via the case_when() function.\n\n\nreligion.df <- read_delim(\"rel.csv\", show_col_types = FALSE)\n\nreligion <- religion.df %>% transmute(\n  year = as.integer(`Year `), \n  GRI = GRI, \n  SHI = SHI,\n  Country = Country, \n  Pop = `Population Size `) %>% \n  mutate(\n# The position is numerically defined according to the score in the variables\n  pos = case_when( \n    (GRI < 2.3 & SHI < 1.4) ~ 1, \n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 1.4) ~ 2, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 1.4) ~ 3, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 1.4) ~ 4,\n    ((GRI >= 0 & GRI < 2.3)   & SHI < 3.6) ~ 2,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 3.6) ~ 3, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 3.6) ~ 4, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 3.6) ~ 5, \n    ((GRI >= 0 & GRI < 2.3)   & SHI < 7.2) ~ 3,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI < 7.2) ~ 4, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI < 7.2) ~ 5, \n    ((GRI >= 6.6 & GRI < 10)  & SHI < 7.2) ~ 6,\n    ((GRI >= 0 & GRI < 2.3)   & SHI <= 10) ~ 4,\n    ((GRI >= 2.3 & GRI < 4.5) & SHI <= 10) ~ 5, \n    ((GRI >= 4.5 & GRI < 6.6) & SHI <= 10) ~ 6, \n    ((GRI >= 6.6 & GRI < 10)  & SHI <= 10) ~ 7)) %>% \n  mutate(\n    pos = as.factor(pos), \n    Country = as.factor(Country))\n\n\nElements and labels\nAt this preliminary stage, some elements of the graph, such as the breaks, titles and subtitles are defined for the same purpose of making the code easier and more understandable.\nText elements\n\n\ntitle <- paste (\"Restrictions on religion among the 25 most populous countries,\",  \n                \"2007-2020\", sep = \"\\n\")\n\nsubtitle  <- paste ( \n\"Among the 25 most populous countries, India, Egypt, Pakistan, Indonesia and Nigeria had the highest levels of overall restrictions on\", \n\"religion in 2020, while Japan, the United States, Italy, the Democratic Republic of the Congo and Tanzania had the fewest restrictions.\", \n\"Click play to see how restrictions have changed in each country since 2007. Read the full report.\", \n\"Year: {closest_state}\", \nsep = \"\\n\") # The phrases have to be written independently and separated with the \\n function. \n\n\nX <- \"Government Restrictions Index (GRI)\"\nY <- \"Social Hostilities Index (SHI)\"\n\ncaption <- paste(\n\"Note, Population data comes from United Nations 2020 population estimates.\", \n\"Source of the original graph: Pew Research Center, 2022\", \nsep = \"\\n\")\n\n\nBreaks and aesthetics\n\n\nbreaks_x <- c(0.1, 1.1, 3.35, 5.55, 8.3, 10)\nbreaks_y <- c(0.1, 1.35, 4.1, 6, 9.9, 10)\n\nlabels_x <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\nlabels_y <- c(\"0\", \"Low\", \"Moderate\", \"High\", \"Very High\", \"10\")\n\n\npal <-c(\"#f7f3d7\",\"#f6e9c8\",\"#f4dbbd\",\"#f5c6ac\",\"#f2b0a2\",\"#e89389\",\"#d48379\")\n\nsysfonts::font_add_google(\"Playfair Display\", family = \"playfair display\")\nshowtext::showtext_auto()  \n\n\nGraph construction\nTechnical features of the graph\nFirst, we include the main aesthetics of the graph; the two variables of the X (GRI) and Y (SHI) axis. The main visual representation is the geom_point(), labelled by country. Sizes depending on population and colour depending on position are also included.\nAt this stage, all the points, regardless of the year are included in the graph.\n\n\np <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 20)+\n  geom_text(aes(label=Country), size = 1.6)\np\n\n\n\nLet’s include the scales!\nWith respect to the colour, we have already defined the palette of colour at the beginning of the construction. Then, we only have to mention it in the scale_colour_manual().\nThe graph is also limited between 0 and 10 in both axis, under a continuous scale (scale_x_continuous). We take advantage of using this function by already including the breaks and labels that would define the levels of religious conflicts.\n\n\np <- p + scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y, \n    labels = labels_y)\n\np  \n\n\n\nIn the next step we add the text elements that will be included in the graph, from the title to the caption. As they were defined before, we only have to specify them in the labs() function.\n\n\np <- p + labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) \np\n\n\n\nNow that we have all the elements that should be included, we have to customize them and bring some order. With a theme_classic() we can have the axis removed. Only some custom horizontal and vertical lines will be needed. The particular features of each element_text() are specified also at this stage.\n\n\np <- p + theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 21),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 11),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())\n\np \n\n\n\nThe final step in constructing the static graph involves the removal of the the guides providing the legend for different aesthetics. Finally, we include the custom lines (geom_vline() and geom_hline()).\nNow we have the fixed graph built, but we have to include a last aesthetic. The one that will be needed to create the animation: the frame. (one per year).\n\n\np <- p + guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\") + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year) \n\np \n\n\n\nThe Graph(s)\nVisual features and information transmitted\nThe graph consist in a basic scatter plot accounting for the relationship between two variables: GRI and SHI. However, more information is included on it.\nOn the one hand, the size of the geom_points is going to be determined by the population of each country. On the other hand, the colour of the bubble is given by the position in the graph. Each quadrant has its own colour. These combination of factors makes possible that, visually, the amount of religious constraints for each country is rapidly comprehend. The darker the point, the more conflicts related to religion. Technically speaking, it was achieved with the case_when() function at the beginning.\nLastly, we have to include the most important characteristics of the graph. While the interactive part had to be forfeited due to logistical and time constraints, it possesses the animation depicting the evolution in time.\nThis evolutionary feature is provided by GGanimated. Notice how each country change the colour depending on the position within the graph.\n\n\np <- p + transition_states(year) \n\np\n\n\n\nUnachieved features\nApart from the interactivity, there are some issues that could not not be fully replicated:\nThe fonts for the titles are not exactly the same as the original.\nThe spacing between lines is smaller than the original.\nThe orientation of the 0 and the 10 of the Y axis is not the correct. The “very high” label is also wrongly positioned.\nIt was not possible to include the link in the last part of the subtitle.\nInteractive options with plotly\nThe library that may be used to provide interactivity to the graph is Plotly via ggplotly(p). However, some technical issues arise when we include this option:\nFirst, dimensions of the chart can not be properly modelled. Fig.height() and fig.weight do not work the same way. As a consequence, the title and subtitle disappear from the graph, some labels move along the axis, etc.\nMore importantly, when the time animation is included, some geom_points get lost, moving along the chart without sense. Thus, as plotly was not the scope of the work, and due the time that would have to be invested to solve these problems, it was decided to forfeit this version of the graph.\n\n\nfig <- ggplotly(p) %>% \nconfig(displayModeBar = FALSE) %>% \nanimation_slider(currentvalue = {\"year\"}) \nfig\n\n\n\nProposed enhacements\nThe first alternative of the graph involve re-scaling the graph. As the two main variables are measured in the same scale, it would be suitable to have both axis on the same scale.\nTo do that, we only have to do small changes, such as changing the position of the breaks in the Y axis and the sizes of the fonts.\n\n\nbreaks_y1 <- c(0.1, 1.3, 3.7, 6, 9.9, 10)\n\nThe_graph2 <- ggplot(religion) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 16)+\n  geom_text(aes(label=Country), size = 1.6)+\n  scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y1, \n    labels = labels_y)+\n  labs(\n    title = title,  \n    subtitle = subtitle,\n    caption = caption, \n    x = X, \n    y = Y) +\n  theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 12),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 6),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 6.5), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())+\n  guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\", \n   ) + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+\n  aes(frame = year)\n\n\nFinally, in the chunk options we specify that the height of the graph is the same as the width, to maintain equal proportions.\n\n\nThe_graph2 <- The_graph2 + \n  transition_states(year) \nThe_graph2\n\n\n\nSecond alternative\nAn additional option involves discarding the animated part, and faceting the display in four different graphs. For each facet we would be showing a particular year (2007-2012-2012-2016).\nThe main objective of this alternative is about focusing on the evolution in time of the linear relationship between these variables. Then, we add the regression line via geom_smooth() along with other minor changes in breaks and labels.\n\n\nyears <- c(2007, 2012, 2016, 2020)\n\nreligion_2 <- religion %>% filter(year %in% years)\n\nbreaks_y2 <- c(0.1, 1.35, 5, 6, 9.9, 10)\n\nThe_graph3 <- ggplot(religion_2) + \n  aes(GRI, SHI) + \n  geom_point(aes(size = Pop, colour = pos, group = Country)) + \n  scale_size_area(max_size = 8)+\n  geom_text(aes(label=Country), size = 1)+\n  scale_colour_manual(values = pal, l = 20)+\n  scale_x_continuous(   \n    limits =  c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_x, \n    labels = labels_x)+ \n  scale_y_continuous(\n    limits = c(0, 10), \n    expand = c(0, 0), \n    breaks = breaks_y2, \n    labels = labels_y)+\n  labs(\n    title = title,  \n    subtitle = \"Years: 07', 12', 16' and 20'\",\n    caption = caption, \n    x = X, \n    y = Y) +\n  theme_classic()+  \n  theme( \n    plot.title = element_text(face = \"bold\", \n                              family = \"playfair display\", size = 15),\n    plot.subtitle = element_text(face = \"italic\", \n                              family = \"playfair display\", size = 12),\n    plot.caption =  element_text(hjust = 0, size = 8), \n    axis.title.x = element_text(face = \"bold\", size = 8), \n    axis.title.y = element_text(face = \"bold\", hjust = 0.45, size = 8), \n    axis.text.x = element_text(size = 6.5), \n    axis.text.y = element_text(angle = 90, hjust = 1.9, size = 7), \n    axis.line.x = element_blank(), \n    axis.line.y = element_blank(),\n    axis.ticks.x = element_blank(), \n    axis.ticks.y = element_blank())+\n  guides(   \n    size = \"none\", \n    alpha = \"none\", \n    colour = \"none\", \n   ) + \n  geom_vline(xintercept = c(2.3, 4.5, 6.6), alpha = 0.2)+  \n  geom_hline(yintercept = c(1.4, 3.5, 7.2, 10), alpha = 0.2)+\n  geom_hline(yintercept = 0, alpha = 0.3)+ \n  facet_wrap(~year)+\n  geom_smooth(method = lm, se = FALSE, col = \"burlywood\", \n              alpha  = .3, linetype = \"dotted\")\n\n\n\n\nThe_graph3\n\n\n\n\n\n\n",
    "preview": "projects/2022/100385586/100385586_files/figure-html5/unnamed-chunk-14-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100386498/",
    "title": "The World Bank's Richer Countries Tend to Have Higher National Poverty Lines Chart",
    "description": "The aim of this project is to recreate and improve a chart from the first Atlas of Sustainable Development Goals.",
    "author": [
      {
        "name": "Isabela Zeberio",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nSustainable Development Goals\nGetting the data\nLibraries\nCountry groups\n\nBuilding the chart\nData\nScale transformation\nAxes and panel grid\nColor of dots\nCountry labels\nText\nLegend\nBackground\n\nFinal chart\nInteractive chart\n\n\nDiagram listing the 17 Sustainable Development Goals. Figure from un.orgThe Atlas of Sustainable Development Goals is a compilation of statistics from over 200 economies about global development and the quality of people’s lives. The Atlas is a visual guide to the trends, challenges and measurement issues related to each of the 17 Sustainable Development Goals (SDGs). The SDGs are an urgent call for action by all countries in a global partnership. The Atlas was first created in 2017 and since then two more editions have been published, 2018 and 2020. From 2017 to 2020 there has been a big change in the visualization of the data.. Therefore, for this project I have decided to focus on recreating a chart from the first Atlas and improve some elements to better represent the idea that richer countries tend to have higher national poverty lines.\nSustainable Development Goals\n\n1. No poverty\n2. Zero hunger\nEnd poverty in all its forms everywhere\nEnd hunger, achieve food security and improved nutrition, and promote sustainable agriculture\n3. Good health and well-being\n4. Quality education\nEnsure healthy lives and promote well-being for all at all ages\nEnsure inclusive and equitable quality education and promote lifelong learning opportunities for all\n5. Gender equality\n6. Clean water and sanitation\nAchieve gender equality and empower all women and girls\nEnsure availability and sustainable management of water and sanitation for all\n7. Affordable and clean energy\n8. Decent work and economic growth\nEnsure access to affordable, reliable, sustainable, and modern energy for all\nPromote sustained, inclusive, and sustainable economic growth, full and productive employment, and decent work for all\n9. Industry, innovation, and infrastructure\n10. Reduced inequalities\nBuild resilient infrastructure, promote inclusive and sustainable industrialization, and foster innovation\nReduce inequality within and among countries\n11. Sustainable cities and communities\n12. Responsible consumption and production\nMake cities and human settlements inclusive, safe, resilient, and sustainable\nEnsure sustainable consumption and production patterns\n13. Climate action\n14. Life below water\nTake urgent action to combat climate change and its impacts by regulating emissions and promoting developments in renewable energy\nConserve and sustainably use the oceans, seas and marine resources for sustainable development\n15. Life on land\n16. Peace, justice and strong institutions\nProtect, restore and promote sustainable use of terrestrial ecosystems, sustainably manage forests, combat desertification, and halt and reverse land degradation and halt biodiversity loss\nPromote peaceful and inclusive societies for sustainable development, provide access to justice for all and build effective, accountable and inclusive institutions at all levels\n17. Partnership for the goals\n\nStrengthen the means of implementation and revitalize the global partnership for sustainable development\n\n\nThe chart I have chosen is from the first SDGs: No poverty. In the section on Reducing poverty in all its dimensions according to national definitions, the figure 1c is introduced to represent how richer countries tend to have higher national poverty lines than poorer ones, and in some cases a richer country may even have a higher national poverty rate than a poorer country.\nThe World Bank’s Chart. Figure from worldbank.orgGetting the data\nThe data consist on country observations of national poverty lines and household final consumption expenditure (HFCE). I retrieved the data from the Jolliffe & Beer Prydz (2016) paper on Estimating International Poverty Lines from Comparable National Thresholds. In the Appendix 2: Poverty lines and economic variables, used in main specifications, there is a table with the data required to replicate the chart.\nLibraries\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(janitor)\nlibrary(showtext)\nlibrary(ggtext) \n\n\nI created the csv file coping the data from the Appendix 2 table. The variables needed to recreate the chart are the following:\n\n\nworld_bank <- read_delim(\n  \"povertyline.csv\", delim = \";\", escape_double = FALSE,\n  col_types = cols(`National poverty line 2011 PPPs` = col_number(),\n                   `Household survey mean 2011 PPPs` = col_number(),\n                   `HFCE (2011 PPPs)` = col_number(),\n                   `GNI (2011 USD, Atlas)` = col_number()),\n  trim_ws = TRUE, skip = 1)\n\n\nworld_bank <-  world_bank %>% \n  janitor::clean_names() %>% \n  select(-c(source_of_national_poverty_rate)) %>% \n  rename(\"country\" = country_territory,\n         \"national_povt_line\" = national_poverty_line_2011_pp_ps,\n         \"household_survey\" = household_survey_mean_2011_pp_ps,\n         \"HFCE\" = hfce_2011_pp_ps,\n         \"GNI\" = gni_2011_usd_atlas) \n\n\n\n\nglimpse(world_bank)\n\nRows: 126\nColumns: 6\n$ country            <chr> \"Zambia\", \"West Bank and Gaza\", \"Vietnam\"…\n$ year               <dbl> 2007, 2009, 2012, 2006, 2011, 2010, 2011,…\n$ national_povt_line <dbl> 1.83, 6.06, 3.35, 6.28, 6.92, 21.70, 21.2…\n$ household_survey   <dbl> 2.66, 10.76, 8.07, 11.63, 23.09, 62.38, 4…\n$ HFCE               <dbl> NA, 9.72, 7.83, 20.99, 30.49, 92.57, 59.1…\n$ GNI                <dbl> 2.62, 5.91, 4.23, 18.59, 32.90, 136.28, 1…\n\n\n\nsummary(world_bank)\n\n   country               year      national_povt_line\n Length:126         Min.   :2001   Min.   : 1.270    \n Class :character   1st Qu.:2009   1st Qu.: 2.203    \n Mode  :character   Median :2011   Median : 4.585    \n                    Mean   :2010   Mean   : 7.872    \n                    3rd Qu.:2011   3rd Qu.: 8.290    \n                    Max.   :2012   Max.   :35.120    \n                                                     \n household_survey       HFCE             GNI        \n Min.   :  1.450   Min.   : 1.220   Min.   :  0.43  \n 1st Qu.:  3.865   1st Qu.: 5.635   1st Qu.:  2.77  \n Median :  9.335   Median :15.880   Median : 11.04  \n Mean   : 22.403   Mean   :22.083   Mean   : 33.57  \n 3rd Qu.: 20.523   3rd Qu.:30.915   3rd Qu.: 35.51  \n Max.   :800.000   Max.   :92.570   Max.   :247.32  \n                   NA's   :11       NA's   :2       \n\nCountry groups\nThe World Bank has an income classification by which it separates countries into four categories based on per capita gross national income (GNI): low-income, lower-middle, upper-middle, and high-income countries. To create the categories, I first calculated the GNI per capita quartile:\n\n\nquantile(world_bank$GNI, na.rm=TRUE)\n\n     0%     25%     50%     75%    100% \n  0.430   2.770  11.040  35.505 247.320 \n\nAfter calculating GNI per capita quartile, I create a new column to group each country in its corresponding category:\n\n\nqntile <-  world_bank %>% \n  mutate(GNI = replace_na(GNI, 0)) %>% \n  mutate(country_class = \n           case_when(GNI <= 2.770  ~ \"Low income\",\n                     GNI > 2.770  & GNI <= 11.040 ~ \"Lower middle income\",\n                     GNI > 11.040 & GNI <= 35.505   ~ \"Upper middle income\",\n                     GNI > 35.505 ~ \"High income\")) \n\n\nqntile %>% group_by(country_class) %>% \n    summarise(country = n_distinct(country)) %>% \n    arrange(desc(country))\n\n# A tibble: 4 × 2\n  country_class       country\n  <chr>                 <int>\n1 Low income               33\n2 High income              31\n3 Lower middle income      31\n4 Upper middle income      31\n\nDespite grouping the countries following the indications from the article by Jolliffe & Beer Prydz (2016), I obtained a slightly different classification. These differences mean that in my final chart some countries (dots) are colored differently than in the original chart.\nTable 2: International Poverty Lines: Median and mean national lines, by group. Figure from Jolliffe & Beer Prydz (2016)In order to maintain the order in which the categories are shown in the legend I used the function factor:\n\n\nqntile$country_class <- factor(\n  qntile$country_class,levels = c(\"Low income\",\"Lower middle income\",\n                                  \"Upper middle income\", \"High income\"))\n\n\nBuilding the chart\nData\nThe World Bank’s chart is a scatterplot in which each dot represents a country, they are colored by income group. The idea is to create a scatterplot with points that have different colors and fills depending on the value of the country_class variable.\nThe variable country_class will be used to determine the color and fill of the plotted points by using these arguments through aes().\nThe y axis has a blank space as label because in the original it is displayed under the title.\nShape 21 of geom_point allows us to use the outline and fill arguments for the dots, which will be important later on.\nstroke enables us to change the line’s width. I will recreate the dots from the original chart by setting a thick outline and filling the dots in white.\n\n\np<-ggplot(qntile) +\n  aes(x=HFCE, y=national_povt_line, \n      color=country_class,\n      fill=country_class) + \n  ylab(\"\") + \n  xlab(\n    \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\"\n    ) +\n  geom_point(size=3, shape=21, stroke=3) \np\n\n\n\nScale transformation\nIn the original chart what is plotted is the log of HFCE and the log of the national poverty line. The limit of the x axis is 100 and the limit of the y axis is 40, and the origin is 1. The breaks of both axes are really specific, thus I specified all of them.\n\n\np <- p + scale_y_log10(\n  limits=c(1, 40),\n  expand=expansion(0),\n  breaks=c(1,1.5,2,3,4,5,7,10,15,20,30,40),\n  labels=c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\"30\",\"40\"))+\n  scale_x_log10(\n    limits = c(1, 100),\n    expand = expansion(0),\n    breaks= c(1,1.5,2,3,4,5,7,10,15,20,30,40,50,70,100),\n    labels = c(\"1\",\"1.5\",\"2\",\"3\",\"4\",\"5\",\"7\",\"10\",\"15\",\"20\",\n               \"30\",\"40\",\"50\",\"70\",\"100\"))\np\n\n\n\nThe other major difference with respect to the distribution and classification of the data is that in my chart the relationship between the national poverty line and HFCE starts lower than in the original. I have not been able to figure out why this happens or how to fix it.\nAxes and panel grid\nAs the theme of the original graph is quite peculiar and very different from R’s aesthetics, I will be changing every element to make it as similar as the original instead of using a complete theme.\nI used the theme function to customize the panel and the axes. After specifying the colors of the panel background and lines, and also removing the lines in between the numbers with element_blank, I specified the style of the axes’ numbers and removed the its ticks.\n\n\np <- p + theme(panel.background = element_rect(fill=\"#f8f8f8\"), \n        panel.grid.major = element_line(\n          color = \"#dbddde\",size = 0.5,linetype = 1),\n        panel.border = element_rect(\n          fill = \"transparent\",color = \"#d5d7d8\",size = 0.5), \n        panel.grid.minor = element_blank(),\n        axis.text = element_text(face=\"bold\",\n                                 color=\"#58595b\",size=12),\n        axis.ticks = element_blank())\np\n\n\n\nColor of dots\nThe color of the dots are what made this graph more difficult to recreate. By combining stroke aesthetic with scale_manual, I created a unique scale to specify the World Bank’s aesthetic values. I filled the dots from the Low income and Lower middle income categories in white and those from Upper middle income and High income with its respective color to create the impression that they are solid.\n\n\np <- p +\n  scale_fill_manual(values=c(\"Low income\" =\"white\",\n                             \"Lower middle income\" =\"white\",\n                             \"Upper middle income\" =\"#e28e8e\", \n                             \"High income\" = \"#cd1349\")) +\n  scale_colour_manual(values=c(\"Low income\" =\"#58595b\",\n                               \"Lower middle income\" =\"#939598\",\n                               \"Upper middle income\" =\"#e28e8e\", \n                               \"High income\" = \"#cd1349\")) \np\n\n\n\nCountry labels\nWith the function annotate we can add geoms to the plot passed as vectors which is very useful to display the countries’ labels.\nIn the original chart some dots have a label which indicates the country and the reference year in which data was collected. It is not stated why these countries should be highlighted over the others. In addition, in some cases it is not very clear to which dot the label refers to as some are really close to each other. I specified the position of each label with hjust and vjust which control the alignment of the labels.\nHorizontal(hjust) and vertical(vjust) justification have the same parameterisation, either a string (“top”, “middle”, “bottom”, “left”, “center”, “right”) or a number between 0 and 1. Although it is recommended not to use number outside the range (0, 1), in order to recreate the country labeling of the original chart, I used numbers outside the range.\nTop = 1, middle = 0.5, bottom = 0\nLeft = 0, center = 0.5, right = 1\n\n\np <- p + annotate(\"text\",\n  x=c(1.44, 1.9, 1.58, 2.72, 2.76, 5.96, 5.31, 4.4, 3.79, 5.2, 6.48, 9.28,\n        9.47, 13.9,7.96, 13.36, 12.52, 17.91, 29.61, 22.88,16.46,15.88,\n        28.99, 26.12, 31.85, 35.4, 33.95, 29.28, 27.98, 35.52,35.9,46.8,\n        39.98, 49.03, 63.41),\n  y=c(1.27, 1.45, 1.86, 2.1, 2.53, 1.76, 2.75, 3.7, 3.89, 4.46, 5.19,6.43,\n        7.63, 6.32,2.97, 2.14, 2.60, 3.08, 2.82, 3.38, 3.8, 3.87,5.24, 6.06,\n        7.17, 8.01, 9.16, 9.62,11.07, 12.98, 15.69, 18.63,19.37, 20.33, \n        35.12), \n  label=c(\"Malawi (2010)\",\"Mozambique (2009)\",\"Niger (2011)\",\"Togo (2011)\",\n          \"Guinea (2012)\",\"Lesotho (2010)\",\"Cong, Rep. (2011)\",\n          \"Mauritania (2008)\",\"Comoros (2004)\",  \"Tajikistan (2009)\",\n          \"Azerbaijan (2001)\",\"Honduras (2011)\",\"Bolivia (2011)\",\"Paraguay (2011)\",\n          \"Bhutan (2012)\",\"Namibia (2010)\",\"Sri Lanka (2010)\",\"Swaziland (2010)\",\n          \"Turkey (2011)\",\"Malaysia (2009)\",\"Albania (2012)\",\"Armenia (2011)\",\n          \"Romania (2011)\",\"Montenegro (2011)\",\"Chile (2011)\",\"Poland (2011)\",\n          \"Lithuania (2011)\",\"Croatia (2011)\",\"Estonia (2011)\",\"Czech Rep (2011)\",\n          \"Slovak Rep. (2011)\",\"Spain (2011)\",\"Slovenia (2011)\",\"Ireland (2011)\", \n          \"Norway(2011)\"),\n  hjust = c(0.5, 0.15, 0.5, 1.2, 1.2, 0.65, 1.2, 0.5, 1.25, 1.25, 1.2,1.25,\n            -0.2, 0.5, -0.25, -0.2, -0.15, 0.5,0.3, -0.15, 0.65, -0.2, -0.2,\n            -0.1, -0.15, -0.15, -0.1, 1.15, -0.15, 1.15,-0.15, -0.15, 1.15, \n            0.95, 1.15),\n  vjust = c(2, 2, 2, 0.45, 0.45, 2.5, -1.5, 2.5, 0.35, 0.5, 0.15, 0.1,0,-1.5,\n            0.15, 0.2, 1.15, 3, 3, 0.25, 2, -1.6,0.55, 0, 0.5,0.25, 0.3, \n            0.25, 0.35, 0.5, 0.35, 2.5,0.45, -2, 0.25),\n  size= 3.5,\n  color = \"#58595b\") \np\n\n\n\nText\nIn this segment I add to the chart the title, the subtitle, and the caption. I used a <span> element to set the two colors of the title.\n\n\np <- p +\n  labs(title = \"<span style='color: #cd1449;'>1c<span><span style=\n  'color: #444444;'> Richer countriestend to have higher national poverty lines<span>\",\n       subtitle = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n       x = \"Household final consumption expenditure per capita per day, 2000-12 (2011 PPP $)\",\n       y = \"\",\n       caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, \n       Estimating International Poverty Lines from Comparable National Thresholds,\n       Policy Research Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  theme(text = element_text(size = 12),\n        plot.title = element_markdown(face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(hjust=0),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1))\np\n\n\n\nLegend\nThe legend of the original chart is located on the upper left corner of the panel, to move it out there I used the argument of legend.position. Because the legend does not have a title or a key I used element_blank to remove them.\n\n\np <- p + theme(legend.text=element_text(size=10),\n        legend.position = c(0.095,0.91), \n        legend.title = element_blank(),  \n        legend.key = element_blank())\np\n\n\n\nBackground\nThe last touch to replicate the original chart is to color the background in light grey with plot.background. To do this, I first use plot.margin to control the margins around the plot. This code sets top margin to 1 cm, the right margin to 4 cm, the bottom margin to 1 cm, and the left margin to 4 cm. Despite setting the caption to the left of the plot, I could not figure put how to align it with the title and the subtitle.\n\n\np <- p + theme(plot.margin = unit(c(1,4,1,4),\"cm\"),\n          plot.background = element_rect(fill=\"#f8f8f8\"),\n          plot.title = element_markdown (hjust =-0.35),\n          plot.subtitle = element_markdown(hjust=-0.25),\n          plot.caption.position = \"plot\",\n          plot.caption = element_markdown(hjust= -0.25))   \np\n\n\n\nFinal chart\nThe World Bank’s chart is trying to represent the relationship between the HFCE and the national poverty line to showcase how richer countries have higher national poverty lines. The visual channels I will focus on to build an alternative chart are the xy position and the hue.\nTo represent this relationship it is important that the dots of the scatterplot inform us about the values of each country and the global pattern. One possible way to deal with overplotting faceting: the same plot is repeated, each time highlighting another group. A nice way to keep the global and the between groups comparisons is to plot the non-group dots in the background and in light grey (general context data).\nMoreover, I have decided to keep the logarithmic transformation because it helps the visualization of the data. It also helps to the representation of the information that the axes are not shown in logarithmic scale, and are rather displayed in the original scale.\nAs in the original graph it was a bit confusing to know precisely which dot the label was referring to, by now having four facets, there is more space to specify each country. To do this I used library(ggrepel).\nIn addition, to enhance the colors of the dots I used the color scheme by Carto to make more visible the different groups.\n\n\nsapply(qntile, function(x) sum(is.na(x)))\n\n           country               year national_povt_line \n                 0                  0                  0 \n  household_survey               HFCE                GNI \n                 0                 11                  0 \n     country_class \n                 0 \n\nqntile <- qntile %>% filter(!is.na(HFCE))\n\n\n\n\np1 <- ggplot(qntile, \n             aes(HFCE, national_povt_line, color=country_class, label=country)) + \n  geom_jitter(data = transform(qntile,\n     country_class = NULL), colour = \"grey80\") + \n  geom_point(alpha=0.7) +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\"))+\n  facet_grid(~country_class, scales = \"free\") + \n  theme_bw() + \n  labs(title = \"<span style='color: #CC503E;'>1c<span><span style='color: #000000;'> \n  Richer countries tend to have higher national poverty lines<span>\",\n  subtitle=\"Class country\",\n  x = \"Household final consumption expenditure per capita per day, 2000-12 \n  (2011 PPP $)\",\n  y = \"National per capita per day poverty line, 2000–12 (2011 PPP $)\",\n  caption = \"Source: Jolliffe, D. M., and E. B. Prydz. 2016, Estimating \n  International PovertyLines from Comparable National Thresholds, Policy Research \n  Working Paper WPS 7606, Washington, DC: World Bank Group.\") +\n  scale_x_log10()+\n  scale_y_log10()+\n  theme(text = element_text(size = 8),\n        legend.position = \"none\",\n        plot.title = element_markdown (face = \"bold\", hjust = 0),\n        plot.subtitle = element_markdown(face = \"bold\",hjust = 0.5),\n        axis.title.x  = element_markdown(),\n        axis.title.y = element_markdown(),\n        plot.caption = element_markdown(face = \"bold\",hjust = 0.1)) +\n  guides(color = guide_legend(override.aes = list(size = 3)))\n\np1 <- p1 + ggrepel::geom_text_repel(size=2, box.padding = 0.1, max.overlaps = 6)\n\np1\n\n\n\nInteractive chart\nAnother alternative visualization is to plot an interactive scatterplot by using ploytly. This way more information is added to every dot without increasing data density:\nCountry\nYear\nNational poverty line\nHousehold final consumption\nGNI\n\n\nlibrary(plotly)\n\np2 <- qntile %>%\n   mutate(text = paste(\"Country: \", country, \"\\nYear: \", \n                       year, \"\\nNational poverty live: \", national_povt_line,\n                       \"\\nHousehold final consumption: \", \n                       HFCE, \"\\nGNI: \", GNI,sep=\"\")) %>% \n  ggplot(aes(x=HFCE, y=national_povt_line, color = country_class, text=text)) +\n  geom_point(alpha=0.7) +\n  scale_size(range = c(1.4, 19), name=\"Dollars ($)\") +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\")) +\n  theme(legend.position=\"none\") +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_minimal() \n\np2\n\n\n\n\n\np_int <- plotly::ggplotly(p2, tooltip=\"text\", type='scatter', mode='markers')\n\np_int <- p_int %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_int <- p_int %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_int\n\n\n\nThis new visualization of the data allow us to see that Low income and Lower middle income countries follow a different trend than Upper middle income and High income countries. In order to better see these patterns I use the function geom_smooth().\nSubgroups:\n\n\nlow_income <- qntile %>% filter(country_class == \"Low income\" | country_class == \"Lower middle income\")\nhigh_income <- qntile %>% filter(country_class == \"Upper middle income\" | country_class == \"High income\")\n\n\nTrend line of each group:\n\n\np3 <- qntile %>%\n  # text is not a standard aesthetic for this geom_smooth()\n  ggplot(aes(x=HFCE, y=national_povt_line, color = country_class, label=country)) + \n  geom_point(alpha=0.7) +\n  scale_size(range = c(1.4, 19), name=\"Dollars ($)\") +\n  scale_color_manual(values = c(\"#5F4690\",\"#38A6A5\", \"#73AF48\", \"#E17C05\")) +\n  theme(legend.position=\"none\") +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_minimal() \n\np_group <-  p3 + geom_smooth(method = \"lm\", se = FALSE, size=0.5) \n\np_group <- plotly::ggplotly(p_group)\n\np_group <- p_group %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_group <- p_group %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_group\n\n\n\nTrend line of the two subgroups, Low income (Low income & Lower middle income) and High income (Upper middle income & high income):\n\n\np_subgroup <- p3 + geom_smooth(data=low_income, method=\"lm\",se=FALSE, color = 'red')\np_subgroup <- p_subgroup + geom_smooth(data=high_income, method=\"lm\",se=FALSE, color = \"blue\")\n\np_subgroup <- plotly::ggplotly(p_subgroup)\n\np_subgroup <- p_subgroup %>% layout(legend = list(x = 0.02, y = 0.9,title=\n                                    list(text='<b> Country class <\/b>')))\n\n\np_subgroup <- p_subgroup %>%  layout(xaxis = list(autotypenumbers = 'strict', title =\n                                    'Household final consumption expenditure',\n                                  ticks=\"inside\",showline=TRUE), \n                     yaxis = list(title = 'National poverty line',ticks=\"inside\",\n                                  showline=TRUE),\n                     title=\"1c Richer countries tend to have higher national poverty lines\")\np_subgroup\n\n\n\n\n\n\n",
    "preview": "projects/2022/100386498/100386498_files/figure-html5/unnamed-chunk-17-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 748
  },
  {
    "path": "projects/2022/100482798/",
    "title": "Social Dissent in China by ‘The Economist’: How Frequent are Protests in the Country?",
    "description": "An explanation of my layer-by-layer construction of a chart representing\nsocial dissent in China geospatially and by issue. This article consists in\nthe replication of a plot made by The Economist's, continuing with an\nalternative representation using similar data. The critique of the strengths\nand weaknesses of the original chart and the successive transformations of\nthe chart are fundamented in data visualization theory.",
    "author": [
      {
        "name": "Gabriel Rodríguez Molina",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nStep One: Replication of the chart\nData collection and processing\nBuilding the plot\nCriticsms to the plot\n\nStep Two: New visualization of the chart\nManaging data\nMaking an alternative representation: First attempt\nManaging data II\nMaking an alternative representation: Second attempt\n\n\nThe current social and political environment in China is complex and dynamic. The Land of the Dragon is usually misunderstood by the Western countries whose vision is usually biased or distorted due to all the contradictory narratives hiding international political dynamics of power. Differently to what many people think, protests are very usual in the People’s Republic. However, due to the lack of transparency it’s not such an easy thing to measure. This is a subject that is worth exploring for those who are interested in gaining a deeper understanding about the controversial economic giant. Studying the trends of the protests in China and the motivations behind them, it is possible to acquire insight about the current state of affairs in the country. Additionally, understanding the role that China’s government plays in responding to and facilitating protests can provide further knowledge about the country’s current political and social environment.\nI will work on the next chart extracted from the article “How common are protests in China?” by The Economist, which aims to represent the different demonstrations of discontent in the country. It is made of two charts which assess popular manifestations geographically and depending on the issue. Scores are calculated using the data supplied by the China Dissent Monitor, a webpage owned by the neo-liberal think thank Freedom House. The data lists one by one all the monitored cases of dissent and different variables including dates, provinces, issues, descriptions, number of participants…\n\n\nStep One: Replication of the chart\nData collection and processing\n\n\n# Load libraries\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(ggtext)\nlibrary(patchwork)\n\n\nAs it was explained, the data has been obtained from the China Dissent monitor, made by the Freedom House. The second data set is a .shp document that allow us to geospatially reproduce the whole map of china, including cities and provinces.\n\n\n# Read data\n\nchinacsv <- read_delim(\"dissent.csv\", delim=\",\", skip=0)\nchina_map <- st_read(\"province.shp\", quiet=TRUE)\n\n\nTo represent the data it’s necessary to first merge both data sets. In order to accomplish that it is necessary to create a similar ID code for each of the provinces.\n\n\nchinacsv <- chinacsv %>%\n  rename(code = province)\n\nchina_map <- china_map %>%\n  mutate(code = sub(\" Sheng\", \"\", NAME_PINGY)) %>%\n  mutate(code = sub(\"Guangxizhuangzu Zizhiqu\", \"Guangxi\", code)) %>%\n  mutate(code = sub(\"Neimenggu Zizhiqu\", \"Inner Mongolia\", code)) %>%\n  mutate(code = sub(\"Xizang Zizhiqu\", \"Tibet\", code)) %>%\n  mutate(code = sub(\"Xinjiangweiwu'erzu Zizhiqu\", \"Xinjiang\", code)) %>%\n  mutate(code = sub(\"Ningxiahuizu Zizhiqu\", \"Ningxia\", code)) %>%\n  filter(NAME_PINGY != \"Taiwan Sheng\")\n\n\nBefore combining both data frames, a few transformations have to be done. First, the “code” column is changed to numeric value and then the “count” function is used to score and group the cases of dissent by province. As a result we have only two columns left related to each object: the province with an ID code assigned to it and the number of cases in each province.\n\n\nchina_dissent <- chinacsv %>%\n  select(code) %>% \n  count(code) \nchina_dissent\n\n# A tibble: 28 × 2\n   code             n\n   <chr>        <int>\n 1 Anhui            9\n 2 Fujian          21\n 3 Gansu            8\n 4 Guangdong       83\n 5 Guangxi         31\n 6 Guizhou          8\n 7 Hainan           8\n 8 Hebei           91\n 9 Heilongjiang    14\n10 Henan           99\n# … with 18 more rows\n\nIt’s time to join both data frames using left_join function. We only keep the code representing the provinces and the geospatial information about each of these provinces.\n\n\njoin_map_data <- china_map %>% \n  left_join(china_dissent, by=\"code\") %>% \n  select(n, geometry)\n\n\nIt is also necessary to modify the data for the second chart. As there are many different variations of each of the issues introduced in the data set we have to group them in wider categories. For example, to represent the variable “Fraud,” we are using “fraud, building quality”, “fraud corruption”…etc.\n\n\nx <- c(\"Others\", \"Corruption\", \"State violence\", \"Fund withdrawal freeze\",\n       \"Land rights\", \"School disputes\", \"Building disputes\", \"Fraud\",\n       \"COVID-19 pandemic policies\", \"Pay and benefits\", \"Delayed housing project\")\n\nchina_data <- chinacsv %>%\n  transmute(\n    Date = `beginning date`,\n    Issue = issue,\n    reason_dissent = case_when(\n      grepl(\"^fraud\", issue) ~ \"Fraud\",\n      grepl(\"^delayed\", issue) ~ \"Delayed housing project\",\n      grepl(\"^pay\", issue) ~ \"Pay and benefits\",\n      grepl(\"^COVID-19\", issue) ~ \"COVID-19 pandemic policies\",\n      grepl(\"^school\", issue) ~ \"School disputes\",\n      grepl(\"^building\", issue) ~ \"Building disputes\",\n      grepl(\"^fund\", issue) ~ \"Fund withdrawal freeze\",\n      grepl(\"^land\", issue) ~ \"Land rights\",\n      grepl(\"^state\", issue) ~ \"State violence\",\n      grepl(\"^corruption\", issue) ~ \"Corruption\",\n      TRUE ~ \"Others\"\n    )\n  )\n\n\nSubsequent changes include creating a new column counting the number of cases for each case of dissent. The column “reason_dissent” is changed into a factor so labels can be ordered when building the plot. It wouldn’t be necessary to use factors if the data had just to be ordered alphabetically or in a descendant/ascendant order. However, the original plot locates the “Others” label in last place even though it’s not the least frequent variable.\n\n\nchina_data_n <- china_data %>% \n  group_by(reason_dissent) %>%\n  count() %>%  \n  transmute(\n      reason_dissent = factor (reason_dissent, levels = x),\n      n_cases= n) %>% \n  drop_na()\nchina_data_n\n\n# A tibble: 11 × 2\n# Groups:   reason_dissent [11]\n   reason_dissent             n_cases\n   <fct>                        <int>\n 1 Building disputes               47\n 2 Corruption                      10\n 3 COVID-19 pandemic policies     162\n 4 Delayed housing project        272\n 5 Fraud                          105\n 6 Fund withdrawal freeze          21\n 7 Land rights                     26\n 8 Others                         144\n 9 Pay and benefits               163\n10 School disputes                 49\n11 State violence                  14\n\nBuilding the plot\nWe start by filling our geom_sf using the values in n, which provides data about the amount of protests by province. We locate the map in the center reducing the background using the “ylim” and “xlim” functions. Borders are changed to white and its thickness can be controlled with “lwd” function.\n\n\nfinal_map <- join_map_data %>% \n  ggplot() +\n    geom_sf(aes(fill=n), color=\"white\",lwd=0.2, )  + \n    coord_sf(ylim=c(-1.7e+06, 2e+06), xlim=(c(-3.3e+06, 2e+06)))\nfinal_map\n\n\n\nThe title and a subtitle are included in this part. We use the R Markdown language to generate two lines in the subtitle. It is a very useful tool in the case it’s necessary to change the color, size or type of letter, however in this case that is not required. To use it correctly we must include element markdown in the theme.\n\n\nfinal_map <- final_map +\n  labs(\n    fill=quote(bold(\"By province\")),\n    title = quote(bold(\"Do you hear the people sing?\")),\n    subtitle =(\"<span style='font-size: 10pt; font-family:Helvetica;'>China, number of protests<\/font><br>\n                <span style='font-size: 9pt; font-family:Helvetica;'> September 1st to December 31th, 2022<\/font>\")\n  ) + \n  theme(\n    plot.title = element_text(size = 12, family=\"Calibri\", hjust=-0.015),\n    plot.subtitle = element_markdown(lineheight=1.5, hjust=-0.01),\n  )\nfinal_map\n\n\n\nOur variable and the scale to represent it is not discrete nor continuous but binned. “Scale_fill_binned” also allow us to change colors and establish breaks for the legend.\n\n\nfinal_map <- final_map +\n    scale_fill_binned(\n        breaks = c(20, 40, 60, 80),\n        low = \"#C7E6FD\", high = \"#004776\", \n        limits=c(0, 100)\n    )\nfinal_map\n\n\n\nThe plot is very minimalist so in both charts we are removing the background, the grids and the ticks and text of the axis. Many different features are modified here to change sizes and type of letters, the position of the legend and the title and spacing between different objects. In this case we are not adding the NAs in the legend because we don’t have any.\n\n\nfinal_map <- final_map + \n  theme(\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    legend.direction = \"horizontal\",\n    legend.text = element_text(size=9, family=\"Helvetica\"),\n    legend.key.height = unit(0.18, 'cm'),\n    legend.key.size = unit(0.6, 'cm'),\n    legend.position = c(0.125,0.89),\n    legend.title = element_text(size=9, family=\"Helvetica\"),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    legend.spacing.x = unit(8.0, 'cm')\n  ) +\n  guides(fill = guide_colorbar(title.position = \"top\"))\nfinal_map\n\n\n\nThe second plot is an horizontal bar chart which can be build using “geom_col”. The x axis represents the number of issues and the y axis each of those issues.\n\n\nfinal_plot <- china_data_n %>% \n  ggplot() +\n    aes(n_cases, reason_dissent) +\n    geom_col(fill=\"#195B87\", width = 0.45)\nfinal_plot\n\n\n\nIn this step title and caption are added and the labels for the y axis are explicitly named to put “COVID-19 pandemic policies” in bold.\n\n\nfinal_plot <- final_plot +\n  labs(\n    x=NULL,\n    y=NULL,\n    title=quote(bold(\"By reason for dissent\")),\n    caption = (\"Source: Freedom's House China Dissent Monitor\")\n    ) +\n  scale_y_discrete(labels = c(\"Others\",\n                              \"State violence\",\n                              \"Corruption\",\n                              \"Fund withdrawal freeze\",\n                              \"Land rights\",\n                              \"School disputes\",\n                              \"Building disputes\",\n                              expression(bold(\"COVID-19 pandemic policies\")),\n                              \"Fraud\",\n                              \"Pay and benefits\",\n                              \"Delayed housing project\"))\nfinal_plot\n\n\n\nFollowing the minimalist aesthetic, the background and the axis ticks are eliminated; word’s size, type and colour is modified; and the x axis is placed on top. The “aspect.ratio” function allows us to make the plot longer and fit the previous one. The breaks for the x axis are also made explicit with “scale_x_continuous”.\n\n\nfinal_plot <- final_plot +\n  theme(\n    plot.title = element_text(size = 9, family=\"Helvetica\"),\n    panel.background = element_blank(),\n    panel.grid.major.x = element_line(color= \"grey\"),\n    plot.title.position = \"plot\",\n    axis.ticks= element_blank(),\n    axis.text.y = element_text(hjust=0, size=8, family=\"Helvetica\", color=\"black\"),\n    axis.text.x = element_text(size=8, family=\"Helvetica\", color=\"black\"),\n    aspect.ratio = 2.2,\n    plot.caption = element_text(hjust = 1.3, size=9, color=\"grey\")\n    ) +\n  scale_x_continuous(breaks = c(0,50,100,150,200,250), position = \"top\")\nfinal_plot\n\n\n\nIf we compare this plot with the original one made by The Economist we can realize the data doesn’t match accurately. This is because Freedom House eventually updates the data for the graph. It has been attempted to filter earlier dates or reduce the case ID but none of them are giving us the exact same pattern than the one presented. What’s more, filtering until November 22nd gives a much more different output in relation to the original chart than in the present case. Doing a general filtering in the data set does not allow us to replicate the chart, it would be necessary to exclude some cases one by one. However, even though the values are not the exact same, the essential aspects of its visual representation are not really affected and the message is the same. In our case NAs label was not added because all provinces have more than 0 cases.\nIn order to plot the charts together patchworks deformed too much the final result. In our case we are just placing one chart over the next one and adjusting all parameters correctly make them match. This is the final replication:\n\n\n\n\n\n\nCriticsms to the plot\nI think the main message these two charts plotted together are sending is that China’s regime is not as robust as we usually think. Western imaginary tends to conceive the pros and cons of their political system taking into account two sides of the same coin: On the one had, their lack of political and individual rights in an autocratic environment is negative, while the absence of popular grievances, open public debates and other democratic procedures allows the country to be more efficient and united in order to achieve common goals and an exponential economic growth. However, this plot tell us that political claims and cases of dissent are much more frequent than we think, and these popular demonstrations are widespread all over the country concerning many different issues. I think this charts perfectly accomplish this purpose.\nThe original chart, which has been presented at the beginning, was published by The Economist on November 28th. It is an update of a previous plot which contained less data and was exactly the same visually. Besides this, the only change which was made is putting “Covid-19 pandemic policies” in bold, a change that makes sense taking into account the whole article in which this plot is included, where they explain the undergoing situation in the country. Nevertheless, I think the graph is not informative in this context. Visual representation aims to communicate a message by itself regardless of the information beyond the plot. The Economist wanted to express how numerous anti-lockdown protests were being due to the general questioning of zero-Covid strategy, which has resulted to be an absolute failure. Using a barplot does not seem to be useful to show this huge exponential increase of covid-19 protests, and someone who hasn’t been aware of this political dynamics would not understand why that concrete label is in bold being the 4th issue in the ranking.\nI will propose a modification taking into account this argumentary.\nStep Two: New visualization of the chart\nManaging data\nMy first approach consisted on exploring the best way of showing the difference in cases of Covid-19 between the two plots made by The Economist. Filtering the data I could manage to represent the previous plot (the one which was launched by The Economist but is no longer uploaded) and the current update.\n\n\nchina_data_filter <- chinacsv %>%\n  filter(`Case ID`<669) %>% \n  transmute(\n    Issue = issue,\n    reason_dissent = case_when(\n      grepl(\"^fraud\", issue) ~ \"Fraud\",\n      grepl(\"^delayed\", issue) ~ \"Delayed housing project\",\n      grepl(\"^pay\", issue) ~ \"Pay and benefits\",\n      grepl(\"^COVID-19\", issue) ~ \"COVID-19 pandemic policies\",\n      grepl(\"^school\", issue) ~ \"School disputes\",\n      grepl(\"^building\", issue) ~ \"Building disputes\",\n      grepl(\"^fund\", issue) ~ \"Fund withdrawal freeze\",\n      grepl(\"^land\", issue) ~ \"Land rights\",\n      grepl(\"^state\", issue) ~ \"State violence\",\n      grepl(\"^corruption\", issue) ~ \"Corruption\",\n      TRUE ~ \"Others\" \n    )\n  ) %>% \n  group_by(reason_dissent) %>%\n  count() %>%  \n  transmute(\n        reason_dissent = factor (reason_dissent, levels = x),\n        n_cases= n) %>%\n  arrange(reason_dissent) %>% \n  drop_na()\n\n\nIn this context, the filtered data set and the full one can be merged, each one containing a different amount of cases per issue to be represented.\n\n\ndiff_data <- china_data_n %>% \n  full_join (china_data_filter, by = \"reason_dissent\") %>% \n  transmute(\n    reason_dissent,\n    before = n_cases.y,\n    after = n_cases.x\n  )\ndiff_data\n\n# A tibble: 11 × 3\n# Groups:   reason_dissent [11]\n   reason_dissent             before after\n   <fct>                       <int> <int>\n 1 Building disputes              30    47\n 2 Corruption                      8    10\n 3 COVID-19 pandemic policies     37   162\n 4 Delayed housing project       214   272\n 5 Fraud                          85   105\n 6 Fund withdrawal freeze         21    21\n 7 Land rights                    18    26\n 8 Others                         95   144\n 9 Pay and benefits              109   163\n10 School disputes                38    49\n11 State violence                 13    14\n\nMaking an alternative representation: First attempt\nLollipops seem to be a good way to show the differences between both data sets representing at the same time the absolute values as the previous chart did. In this case, I repeated all geoms twice filtering it the second time to give covid-19 protest a different colour.\n\n\nfinal_plot <- diff_data %>% ggplot() +\n  aes(after, reorder(reason_dissent, after, sum)) +\n  geom_segment(\n              aes(\n                xend=before, yend=reason_dissent), \n                color=\"#195B87\", \n                size=0.7) +\n  geom_segment(\n    aes(xend=before, yend=reason_dissent), \n        color=\"#B10000\", size=1, data = diff_data %>% \n        filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  geom_point(size=2, color=\"#195B87\") +\n  geom_point(aes(before), size=0.7, color=\"#195B87\") +\n  geom_point(\n    aes(before, reason_dissent), size=1, \n    color=\"#B10000\", data = diff_data %>% \n    filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  geom_point(\n    aes(after, reason_dissent), size=2.3, \n        color=\"#B10000\", data = diff_data %>% \n        filter(reason_dissent == \"COVID-19 pandemic policies\")) +\n  labs(\n    y=NULL,\n    x=NULL,\n    title=quote(bold(\"By reason for dissent\")),\n    caption = (\"Source: Freedom's House China Dissent Monitor\")\n    ) +\n  scale_x_continuous(position = \"top\", breaks = c(0,50,100,150,200,250)) +\n  theme(plot.title = element_text(size = 11, family=\"Helvetica\"),\n        panel.background = element_blank(),\n        panel.grid.major.x = element_line(color= \"grey\"),\n        plot.title.position = \"plot\",\n        axis.ticks= element_blank(),\n        axis.text.y = element_text(hjust=0, size=9, family=\"Helvetica\", color=\"black\"),\n        axis.text.x = element_text(size=9, family=\"Helvetica\", color=\"black\"),\n        aspect.ratio = 2.5,\n        plot.caption = element_text(hjust = 2, size=7, color=\"grey\")\n        )+\n  expand_limits(x=0)\nfinal_plot\n\n\n\nThe result of the two charts merged together look like this:\n\n\n\n\n\n\nThe main problem of this chart is that dates are not shown, but even if they were added it would be quite arbitrary to just represent two dates corresponding to two different releases of The Economist. Also the map above is problematic as the lollipops are representing two absolute values and its difference, but a map can not show all these features and the interpretation can be misleading. What should be added to the map? Only the data concerning the difference? The absolute value of the second date?\nThis is why a second attempt was made, representing this time how the cases for each issue change through time and showing at the same time the exponential covid-19 rise of dissent.\nManaging data II\nIn this case we calculated the cumulative of the protests depending on the dates and the reason for dissent, so we can represent what’s the number of protest each day depending on the issue. As we want to incise in the high number of anti-lock down covid-19 protests we are filtering information after September. Taking a very long time lapse hides this change, so both charts are being filtered.\n\n\nx <- c(\"COVID-19 pandemic policies\", \"Delayed housing project\", \"State violence\",\n       \"Fund withdrawal\", \"Pay and benefits\", \"Building disputes\",\n       \"School disputes\", \"Land rights\", \"Corruption\", \"Fraud\", \"Others\")\n\nchina_data_n <- china_data %>% \n      group_by(reason_dissent,Date) %>%\n      count() %>%\n      filter(Date >=\"2022-09-01\") %>% \n      group_by(reason_dissent) %>% \n      mutate(cumulative_n = cumsum(n)) %>% \n      transmute(\n          reason_dissent = factor (reason_dissent, levels = x),\n          cumulative_n,\n          Date)\nchina_data_n\n\n# A tibble: 214 × 3\n# Groups:   reason_dissent [10]\n   reason_dissent    cumulative_n Date      \n   <fct>                    <int> <date>    \n 1 Building disputes            1 2022-09-03\n 2 Building disputes            3 2022-09-05\n 3 Building disputes            4 2022-09-17\n 4 Building disputes            7 2022-09-18\n 5 Building disputes            8 2022-09-24\n 6 Building disputes            9 2022-09-28\n 7 Building disputes           10 2022-10-02\n 8 Building disputes           12 2022-10-09\n 9 Building disputes           13 2022-10-12\n10 Building disputes           14 2022-10-26\n# … with 204 more rows\n\nMaking an alternative representation: Second attempt\nIn this case it was possible to represent this data using a linear chart, but using a stream in a proportional way seemed to be an even better option to show the rise in covid-19 protests. In this context, “geom_stream” from ggstream package was used.\n\n\nfinal_plot <- ggplot(china_data_n) +\n  aes(Date,cumulative_n) +\n  ggstream::geom_stream(\n      aes(fill=reason_dissent),\n      type=\"proportional\")\nfinal_plot\n\n\n\nIn this part we use titles not just in a descriptive way but trying to help interpretation in terms of the centrality we want covid-19 to have. The map chart is very long, so having the legend at the right is not an option if we want both charts to fit well together. Besides, colours seem to be very confusing.\n\n\nfinal_plot <- final_plot + labs(\n      title=quote(bold(\"Anti-lockdown protests boost due to zero-Covid strategy\")),\n      fill=quote(bold(\"By Issue\")),\n      caption = (\"Source: Freedom's House China Dissent Monitor\"),\n      y = quote(bold(\"Percentage of protests\")))\nfinal_plot\n\n\n\nAs always, the theme is used to adjust many different things. The most challenging aspect here was to adjust all parameters to make both charts fit, as this one looked better horizontally but has to substitute a vertical one.\n\n\ncols <- c(\"#146c9b\", \"#eacbab\", \"#d49c4c\", \"#acdbdb\" , \"#040404\",\"#9c947c\",\n          \"#ce9f5d\", \"#498caa\", \"#546466\", \"#729499\")\n\nfinal_plot <- final_plot +  theme(\n      plot.title = element_text(size = 12, family=\"Calibri\", \n                                margin=margin(0,0,5,0)),\n      panel.background = element_blank(),\n      plot.margin=unit(c(0,0,0,0),\"cm\"),\n      plot.title.position = \"plot\",\n      axis.text.y = element_text(hjust=0, size=11, family=\"Helvetica\", color=\"black\"),\n      axis.text.x = element_text(size=11, \n                                 family=\"Helvetica\", color=\"black\"),\n      axis.title.x = element_blank(),\n      aspect.ratio = 0.68,\n      plot.caption = element_text(hjust = -1.25, size=10, color=\"grey\"),\n      legend.text = element_text(size=9, family=\"Helvetica\"),\n      legend.key.height = unit(0.27, 'cm'),\n      legend.key.width  = unit(0.27, 'cm'),\n      legend.key.size = unit(0.9, 'cm'),\n      legend.position = \"bottom\",\n      legend.title = element_text(size=9, family=\"Helvetica\"))+\n  scale_x_date(date_breaks = \"months\", date_labels = \"%m-%Y\", expand = c(0.01, 0))+\n  scale_y_continuous(labels= c(\"0%\", \"25%\", \"50%\", \"75%\", \"100%\"), expand = c(0.10, 0))+\n  guides(fill = guide_legend(title.position = \"top\"))+\n  scale_fill_manual(values = cols)\nfinal_plot\n\n\n\nAs we can observe, the map also suffered many modifications to fit well the second chart. I think the final result allows a better comprehension of the data as we have included the dimension of transformation of the data over time. This way it’s not just about the different issues and their total frequency but about how the social demands are proportionally changing depending on the matter. In this context, understanding the recent rise of covid-19 protests is also easier to analyze.\n\n\n\n\n\n\n\n\n\n",
    "preview": "projects/2022/100482798/100482798_files/figure-html5/final_map-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100485232/",
    "title": "Percentage of elders feeling lonely",
    "description": "Visualizing and comparing loneliness percentage among elders between \ndifferent countries, through barplots and maps.",
    "author": [
      {
        "name": "Raquel Sánchez-Hermosilla García",
        "url": {}
      }
    ],
    "date": "2023-01-16",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nChosen graph\nInitial graph replicated\nInitial graph enhanced\nAlternative visualization of the graph\nChoropleth map\nInteractive map\n\n\n\n\nlibrary(tidyverse)\nlibrary(corrplot)\nlibrary(sf)\nlibrary(leaflet)\nlibrary(rnaturalearth)\n\nsysfonts::font_add_google(\"Playfair Display\", family = \"Playfair Display\")\nsysfonts::font_add_google(\"Arimo\", family = \"arimo\")\nshowtext::showtext_auto()\n\n\nChosen graph\nSource: Our World in DataThe graph I have chosen is a bar plot that shows the percentage of loneliness\namong elders in different countries, from Our World in Data, and it is part of\nan article that tries to prove and explain the importance that social\nconnections and personal relationships have in our health.\nRegarding the data gathering process to improve, enhance and do alternative\nvisualizations, I had to download the CSV file that is available\non the “Download” bottom tab of the above graph.\nInitial graph replicated\n\n\n#Open data set\nworldsadness <- read_csv(\"self-reported-loneliness-older-adults.csv\", \n                          show_col_types = FALSE)  %>% dplyr::select(-Code)  %>% \n                          dplyr::rename( Country = Entity)\n                    \nworldsadness$Country <- factor(worldsadness$Country, \n                               levels=c(\"Denmark\",\"Switzerland\", \"Sweden\",\n                                        \"United States\", \"England\",\n                                        \"Netherlands\",\"Germany\", \"Finland\",\n                                        \"Spain\", \"Belgium\",\"France\", \"Austria\",\n                                    \"Italy\",\"Israel\", \"Greece\"))\n\n#Graph\nggplot(worldsadness)+\n  #establecer los ejes\n  aes(x=Country, y= Sadness, fill=Country )+\n  #quitar las etiquetas del eje x\n  scale_x_discrete(NULL) + \n  #specify a color for each bar\n  geom_col( width = 0.75,#width of bars in relation to the x-axis\n            fill = c(\"#4982C5\",#Austria\n                     \"#C69F73\",#Belgium\n                     \"#719461\",#Denmark\n                     \"#E98473\",#England\n                     \"#CA6B7D\",#Finland\n                     \"#9A5057\",#France\n                     \"#3B6334\",#Germany\n                     \"#835CA2\",#Greece\n                     \"#CA723A\",#Israel\n                     \"#72B99E\",#Italy\n                     \"#A96C4A\",#Netherlands\n                     \"#274A74\",#Spain\n                     \"#B06FAB\",#Sweden\n                     \"#56B7C5\",#Switzerland\n                     \"#B06FAB\"#USA\n                     ))+\n  coord_flip()+\n  theme_minimal()+\n  #now texts content \n  labs(y= NULL,\n       title= \"Self-reported loneliness among older adults\",\n        subtitle = \"Share of survey respondents who report feeling lonely at least some of the time. For all countries estimates \\n correspond to population ages 65+, except in the following cases: US (ages 72+); UK (ages 65-74); and \\n Finland (ages 75+).\",\n       caption = \"Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\\nNote: Estimates correspond to people who report feeling lonely \\\"some of the time\\\", \\\"most of the time\\\", or \\\"almost all the\\n time\\\". This is in contrast to those that report feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\", or \\\"never\\\".\\nCC BY\")+\n  #now texts characteristics\n  theme(\n    plot.title = element_text(size=32, family = \"Playfair Display\",\n                              color = \"#555555\"),\n    plot.subtitle = element_text(size=18, family = \"arimo\", color = \"#555555\",\n                                 lineheight = 0.8, margin= margin(0,0,20,0)),\n    plot.caption = element_text(size = 15, family = \"arimo\", color = \"#555555\",\n                                lineheight = 0.7,  margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 0))+\n  theme(plot.caption =  element_text(hjust = 0))+\n  theme(plot.caption.position = \"plot\")+\n  #add label at the end of the bar\n  geom_text(aes(label = paste(Sadness, Year, sep= \"% in \")), vjust = 0.7,\n            hjust=-0.1, colour = \"#555555\", size= 6, family= \"arimo\")+\n  #change the grid\n  theme(panel.grid.major.x = element_line(color = \"lightgrey\",\n                                          size = 0.4, linetype = 2))+\n  theme(panel.grid.minor.x = element_blank())+\n  theme(panel.grid.major.y = element_blank())+\n  #ticks del eje y bien puestos\n  scale_y_continuous(limits = c(0,70), \n                     labels = c(\"0%\",\"10%\",\"20%\",\"30%\",\"40%\",\"50%\",\"60%\"),\n                     breaks = c(0,10,20,30,40,50,60))+\n                    \n   #both axis text characteristics modified\n  theme(axis.text.x = element_text(size = 20, family = \"arimo\",\n                                   color = \"#555555\"))+\n  theme(axis.text.y = element_text( size = 17, family = \"arimo\", \n                                    face = \"bold\", color = \"#555555\", \n                                    hjust=1, vjust= 0.5))\n\n\n\nOn one hand, this visualization has two main weaknesses, the first and most\nobvious one is the use of colors inside bars, because it seems randomly chosen\nand it is non-informative. And at the same time, the visualization has too many\ntext explaining information displayed on the graph, like the difference among\ncountries regarding year of data collection and respondents age.\nOn the other hand, as a strength, the hierarchical bars position is truly\ninformative, because we can easily see that Greece is the country with the\nhighest percentage of loneliness among elders, while Denmark has the lowest,\nand the rest of the countries are positioned following that hierarchy.\nInitial graph enhanced\n\n\n#above code chunk to extend graph height, and make it longer\n\n#Open data set\nworldsadness2 <- read_csv(\"remake2-self-reported-loneliness-older-adults.csv\",\n                          show_col_types = FALSE)  %>% select(-Code)  %>%\n                          rename( Country = Entity)\n\nworldsadness2$Country <- factor(worldsadness2$Country, \n                               levels=c(\"Denmark\",\"Switzerland\", \"Sweden\",\n                                        \"United States\", \"England\",\n                                        \"Netherlands\",\"Germany\", \"Finland\",\n                                        \"Spain\", \"Belgium\",\"France\", \"Austria\",\n                                        \"Italy\",\"Israel\", \"Greece\"))\nworldsadness2$Age <- factor(worldsadness2$Age, \n                               levels=c(\"65+\", \"65-74\", \"72+\", \"75+\"))\n#Graph\nggplot(worldsadness2)+\n  #establecer los ejes\n  aes(x=Country, y= Sadness, fill= Age)+\n  geom_col(width = 0.75)+#width of bars in relation to the x-axis\n  coord_flip()+\n  #the legend characteristics\n  scale_fill_manual(name = \"Respondents age and \\n data collection year\",\n                      labels = c(\"65+ & 2005\",\n                                 \"65-74 & 2018\",\n                                 \"72+ & 2018\", \n                                 \"75+ & 2002\"),\n                      values = c(\"#BEBEBE\",#Austria and all\n                                \"#4169E1\",#England\n                                \"#A020F0\",#USA\n                                \"#2E8B57\"))+#Finland\n  theme(legend.position = c (.8,.4))+\n  theme(legend.title =  element_text(size = 8, family = \"Playfair Display\",\n                                     hjust=0.4))+\n  theme(legend.text =  element_text(size = 7, family = \"Arimo\"))+\n  #quitar las etiquetas del eje x\n  scale_x_discrete(NULL)+\n  #remove the grid\n  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),\n  panel.background = element_blank())+\n\n  #now texts content\n  labs(y= NULL,\n       title= \"Self-reported loneliness among older adults\",\n       subtitle = \"Percentage of respondents who reported feeling lonely \\\"some of the time\\\",\\\"most of the time\\\", or \\\"almost \\nall the time\\\", contrary to those who reported feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\" or\\\"never\\\".\",\n       caption = \"Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\")+\n  #now texts characteristics\n  theme(\n    plot.title = element_text(size=17, family = \"Playfair Display\",\n                              color = \"black\"),\n    plot.subtitle = element_text(size=9, family = \"Arimo\", color = \"#555555\",\n                                 lineheight = 0.9, margin= margin(0,0,10,0)),\n    plot.caption = element_text(size = 7, family = \"Arimo\", color = \"#555555\",\n                                lineheight = 0.5, margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 0))+\n  theme(plot.caption =  element_text(hjust = 0))+\n  theme(plot.caption.position = \"plot\")+\n  #add label at the end of the bar\n  geom_text(aes(label = paste(Sadness, \"%\", sep = \"\")), vjust = 0.7, hjust=-0.1,\n            colour = \"#555555\", size= 3, family= \"Arimo\")+\n    #ticks del eje y bien puestos\n  scale_y_continuous(limits = c(0,70), labels = c(\"\",\"\",\"\",\"\",\"\", \"\",\"\"),\n                     breaks = c(0,10,20,30,40,50,60))+  \n   theme(axis.ticks.y = element_blank())+\n  theme(axis.ticks.x =  element_blank())+\n  #both axis text characteristics modified\n  theme(axis.text.x = element_text(size = 10, family = \"Arimo\",\n                                   color = \"#555555\"))+\n  theme(axis.text.y = element_text(size = 9, family = \"Arimo\", face = \"bold\",\n                                   color = \"#555555\", hjust=1, vjust= 0))\n\n\n\nIn order to enhance the chosen graph I worked on the weakness and took advantage\nof its strength.\nAs color was the main problem, I changed the color of the bars to make color\ninformative about the differences between countries in relation to respondents\nage and data collection year. To do so, I used grey as baseline, and three\ndifferent colors: green, purple and blue, to show that most of the countries had\nthe same year of data gathering and respondents age, but there are three\ncountries that differ from the rest. That is why I used four different colors,\nto remark that difference, even though using a color hue would have been more\naesthetically pleasing.\nTherefore, this bars color difference and the legend that explains them,\nallowed me to remove text from the graph subtitle and caption. I have\njust kept information about how the data gathering process took place, and moved\nit from the caption to the subtitle, besides, I have kept the graph reference in\nthe caption. Furthermore, the color legend also allowed me to remove the\ndata gathering year from the end of the bars next to the loneliness proportion.\nThus, the enhanced graph has just the concrete percentage of loneliness next\nto the bar, in order to make it clearer and easier to spot and compere that data.\nMoreover, the x axes percentages have been removed because as I have mentioned,\nthe hierarchical position of bars is already informative about how the\nloneliness percentage varies among the different countries. And at the same time,\nthe percentage labels at the end of the bars provide the concrete differences,\ntherefore, there is no need for percentages from 0% to 60% to appear in the x\naxis, because it is repeating information that is already in the graph.\nAlternative visualization of the graph\nThe graph shows a ranking categorical variable, thus, alternative visualizations\nsuch as lollipop chart, a radar chart or a wordcloud where considered, but they\ndid not have any advantage compared to the bar plot.\nHence, as the categorical variables are country names, and 13 out of 15 are\nEurope countries, I decided to plot the Europe map and add the information about\nIsrael and United States as a reference.\nHowever, one of those countries is England and I really struggled to find a\nEurope map data that included England as a country, until I reread the\ndocumentation of the graph and realized they were talking about data gathered in\nUnited Kingdom, besides the fact that the label on the chosen graph to represent\nthis data, was England. Therefore, from now on the territory represented is\nUnited Kingdom and not England.\nChoropleth map\n\n\n#The data\nworldsadness3 <- read_csv(\"map-self-reported-loneliness-older-adults.csv\", \n                          show_col_types = FALSE)  %>% select(-Code)  %>% \n                          rename( Country = Entity)\n#The map\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nEurope <- world[which(world$continent == \"Europe\"),]\n#To join the data frames, map and data\nmapdata<- Europe %>% left_join(worldsadness3, by = c(\"admin\" = \"Country\"))\n#data as map\nmapdata <- st_as_sf(mapdata)\n# Project the map data into a different coordinate system\nmapdata <- st_transform(mapdata, crs = \"+proj=longlat +datum=WGS84\")\n#The graph\n ggplot(mapdata) +\n  geom_sf(aes(fill= Sadness),color = \"white\",\n          linetype = 1,\n          lwd = 0.25) +\n  coord_sf(xlim = c(-15,50), ylim = c(35,73), expand = FALSE)+\n#Without grid\n  theme_void()+\n#scale color and legend\n   scale_fill_gradient(low=\"yellow\", high =\"red\", limits = c(20,70), name=NULL,\n                      labels = c(\"30%\",\"40%\", \"50%\",\"60%\"),\n                      breaks = c(30,40,50,60),\n                      guide = guide_colourbar(reverse = TRUE))+\n#now texts content\nlabs(\n     title= \"Percentage of elders \\n feeling sad\",\n     subtitle= \"Other countries: \\n USA 30% \\n Israel 48%\",\n     caption = \"Displayed respondents reported feeling lonely \\\"some of the time\\\",\\n \\\"most of the time\\\", or \\\"almost all the time\\\", contrary to those who \\n reported feeling lonely \\\"rarely\\\", \\\"almost none of the time\\\" or \\\"never\\\"\\n \\n Source: Our World in Data based on Sundström et al. (2009), Savikko et al (2005), ONS (2019) and CIGNA (2018)\")+\n#now texts characteristics\n  theme(\n    plot.title = element_text(size=19, family = \"Playfair Display\",\n                              color = \"black\", lineheight = 0.9),\n    plot.subtitle = element_text(size = 9, family = \"public sans\",\n                                 color = \"#555555\",\n                                 lineheight = 0.8, margin= margin(10,0,0,0)),\n    plot.caption = element_text(size = 8, family = \"public sans\",\n                                color = \"#555555\", \n                                lineheight = 0.8, margin= margin(10,0,0,0)))+\n  #now text position\n  theme(plot.title.position = \"plot\")+\n  theme(plot.title = element_text(hjust = 0.5))+\n  theme(plot.caption =  element_text(hjust = 0.5))+\n  theme(plot.caption.position = \"plot\")+\n  theme(plot.subtitle = element_text(hjust = 1))\n\n\n\nA choropleth map is an eye catching visualization that allows to get a general\nidea about the information displayed with just one look.\nThat is due to the fact that size and position inform about the country, and the\nheat map color gradient chosen represent the increasing percentage of sadness\namong countries being yellow the lowest, orange the middle one and red the\nhighest.\nNevertheless, if we compare this map to the enhanced graph, a lot of information\nhas been dropped: the concrete percentage of loneliness for each country, the\ndata collection year and the age of the respondents.\nAs a consequence, I decided to do an interactive map, which will keep all the\nchoropleth map advantages, and at the same time, will display information\nabout the country name, the concrete percentage, the data collection year and\nthe age of the respondents, when moving the pointer over the map.\nInteractive map\n\n\n#The data\nworldsadness4 <- read_csv(\"map-self-reported-loneliness-older-adults.csv\",\n                          show_col_types = FALSE)%>%\n                          select(-Code)  %>%\n                          rename( Country = Entity)\n#The map\nworld <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nEurope <- world[which(world$continent == \"Europe\"),]\n#To join the data frames, map and data\nmapdata<- Europe %>% left_join(worldsadness4, by = c(\"admin\" = \"Country\"))\n#data as map\nmapdata <- st_as_sf(mapdata)\n# Project the map data into a different coordinate system\nmapdata <- st_transform(mapdata, crs = \"+proj=longlat +datum=WGS84\")\n#ANIMATED GRAPH\n#Color gradient another function, \ncolor_gradient2 <- colorNumeric(c(\"white\", \"yellow\",\n\"red\", \"darkred\"), 1:65)\nmy_colors3 <- color_gradient2(mapdata$Sadness)\n#labels content\nmylabels <- paste(ifelse(is.na(mapdata$name), \"\", mapdata$name), \"<br/>\",\n                  ifelse(is.na(mapdata$Sadness), \"\", paste(mapdata$Sadness,\"%\")),\n                  \"<br/>\",ifelse(is.na( mapdata$Year), \"\",\n                  paste(\"Data collection:\", mapdata$Year)), \"<br/>\",\n                  ifelse(is.na(mapdata$Age), \"\", \n                         paste(\"Respondents age:\", mapdata$Age)))%>%\n  lapply(htmltools::HTML)\n#title and reference\nhtmltitle <- \"<h5> <b> Percentage of elders feeling sad <b> <\/h5>\"\nEEUU <- \"<h5> USA 30%  <br /> Data collection: 2018 <br /> Respondents age: 72+\n<\/h5>\"\nIsrael <- \"<h5> Israel 48% <br /> Data collection: 2005 <br /> Respondents age: \n65+ <\/h5>\"\n\n#THE GRAPH\nleaflet(mapdata) %>%\n  setView( lat=55, lng=20 , zoom=3)%>%\n  addPolygons(\n    fillColor = my_colors3,\n    stroke = TRUE,\n    color = 'White', \n    weight = 1.5,\n    label = mylabels,\n    labelOptions = labelOptions( \n      style = list(\"font-weight\" = \"normal\", padding = \"3px 8px\"), \n      textsize = \"13px\", \n      direction = \"auto\")) %>%\n  \n  addLegend(\n            position = \"bottomright\", \n            pal= color_gradient2, \n            values = ~mapdata$Sadness,\n            na.label = \"No data\",\n            opacity = 0.4,\n            labFormat = labelFormat(suffix=\"%\"),\n            title = \"\") %>%\n  addControl(html=Israel, position = \"topright\") %>%\n  addControl(html=EEUU, position = \"bottomright\") %>%\n  addControl(html=htmltitle, position = \"topleft\")\n\n\n\n\n\n\n",
    "preview": "projects/2022/100485232/100485232_files/figure-html5/unnamed-chunk-3-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100348375/",
    "title": "New York Times market share graph",
    "description": "In this article I explain how I replicated a New York Times chart in R and the \nprocess of creating a different chart with ggplot2 with the same data. I'll \nalso explain the limitations of replication and alternative visualization, and\ndiscuss the strengths and weaknesses of both charts, based on data \nvisualization theory.",
    "author": [
      {
        "name": "Isabel Molero Lopez",
        "url": {}
      }
    ],
    "date": "2023-01-13",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nFirst step: replicate the graph\nOriginal graphic source: New York Times\n1. Read and prepare the data\n2. Create the first part of the plot\n3. Create the second part of the plot\n4. Arranging plots\nLimitations of the replication of the graph\n\nChart evaluation based on data visualization theory\nSecond step: create a new visualization with the same data\nPrepare the data\nCreate the static graph\nAdd interactivity with the package ggiraph\n\n\nFirst step: replicate the graph\nOriginal graphic source: New York Times\nThe American newspaper “The New York Times” published in November 2018 an\nopinion article written by columnist David Leonhardt. This journalist explained\nhow in recent years monopolies have increased in the United States despite the\nreluctance of many Americans who consider them a threat to market competition\nand individual freedom. This article is accompanied by a graph showing how the\ncombined market share has changed for the top two companies in many industries.\nThe Monopolization of America\n\n\n\nFigure 1: Source: New York Times\n\n\n\nIn this tutorial I will show how to replicate this data visualization step by\nstep with R and the package ggplot2.\nFirst we have to load the two basic libraries that we will use throughout the\ntutorial: tidyverse and ggplot2\n\n\n# Load libraries:\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n\n1. Read and prepare the data\nSince the chart’s data source was not directly accessible, I created a csv file\nwith the data. This file contains data for three different variables: the type\nof industry, the market share in the year 2000, and the current market share.\nAlso, since in the original graph the positive and negative increases over time\nin the market share are differentiated, I create a new variable (increase)\nwith this information.\n\n\ndata <- read.csv(\"data_graph.csv\", sep = \";\") %>% \n  mutate(increase = market_share_now - market_share_2000,\n         increase2 = case_when(increase > 0 ~ \"positive\",\n                              T ~ \"negative\")) %>%\n  group_by(increase2) %>% \n  arrange(desc(increase))\n\n\nLet’s see how the data is!\n\n\nglimpse(data)\n\nRows: 26\nColumns: 5\nGroups: increase2 [2]\n$ industry          <chr> \"Hardware stores\", \"Shipbuilding\", \"Privat…\n$ market_share_2000 <int> 42, 24, 19, 51, 30, 35, 39, 79, 22, 35, 34…\n$ market_share_now  <int> 84, 62, 55, 82, 61, 61, 60, 99, 41, 52, 49…\n$ increase          <int> 42, 38, 36, 31, 31, 26, 21, 20, 19, 17, 15…\n$ increase2         <chr> \"positive\", \"positive\", \"positive\", \"posit…\n\n\n\nsummary(data)\n\n   industry         market_share_2000 market_share_now\n Length:26          Min.   :19.00     Min.   :23.00   \n Class :character   1st Qu.:31.00     1st Qu.:42.00   \n Mode  :character   Median :38.50     Median :56.50   \n                    Mean   :42.73     Mean   :55.88   \n                    3rd Qu.:51.75     3rd Qu.:62.75   \n                    Max.   :79.00     Max.   :99.00   \n    increase       increase2        \n Min.   :-25.00   Length:26         \n 1st Qu.:  5.50   Class :character  \n Median : 11.50   Mode  :character  \n Mean   : 13.15                     \n 3rd Qu.: 20.75                     \n Max.   : 42.00                     \n\n2. Create the first part of the plot\nThe chosen graph has two distinct parts. The first one shows the evolution of\nthe market share since the early 2000s (2002 to 2007 depending on data\navailability) and the second since 2012. For this reason, I will do the upper\nplot first and then the lower one.\nThe first step, therefore, is to filter the data to use only those that\ncorrespond to the industries included in the first graph. Also, I need to create\na new variable that allows me to order the categorical variable industry from\nthe highest to lowest increase in market share over time (industry_order)\n\n\nupper_plot <- data %>%\n  filter(industry != \"Smartphones\" & industry != \"Social networks\" \n         & industry != \"Cellphone service\") %>% \n  mutate(industry_order = fct_reorder(industry, increase)) \n\n\nCoordinates and axes\nThe graph has Cartesian coordinates, where x is the market share (continuous\nvariable ranging from 0 to 100) and y is the type of industry (categorical\nvariable with 25 different categories). However, in this graph for each y (for\neach industry) we have to plot two points on the x-axis: the market share in the\nearly 2000s and now. But we will see this after in the “Data” section.\n\n\nupper_plot <- upper_plot %>%\n  ggplot() +\n  (aes(x = market_share_2000, \n       y = industry_order))\n\nupper_plot\n\n\n\nAlso, we want the x scale to go from 10% to 100% in steps of 10 and to be at the\ntop of the graph. We achieve all this with the arguments of the\n“scale_x_continuous” function. In the case of the y-axis, we only need to expand\nit slightly at the top to accommodate the labels that need to be entered on the\nchart later.\n\n\nupper_plot <- upper_plot +\n  scale_x_continuous(position = \"top\", \n                     breaks = c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(10, 100),\n                     labels = c(\"10%\", \"20\", \"30\", \"40\", \"50\", \"60\", \"70\", \n                                \"80\", \"90\", \"100\"),\n                     name = NULL,\n                     expand = c(0,0)) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.4, 1.5)))\n\nupper_plot\n\n\n\nLabels\nThe next step is to put the labels we need: the chart title, the subtitle and\nthe tag. For this I use the “labs” function. Later, within the “theme” function,\nI will be able to adjust its characteristics: font size and type, position…\n\n\nupper_plot <- upper_plot +\n    labs(title = \"Dominance of Corporate Behemoths\",\n       subtitle = paste0(\"The combined market share of the two largest companies\",\n       \" in many industries has grown\\n\",\n       \"in recent years, often because of mergers.\"),\n       tag = \"MARKET SHARE:\")\n\nupper_plot\n\n\n\nTheme\nLabel settings\nSince the original graphic uses the “Noto Serif” font, the first thing I do is\ndownload it from Google Fonts\nand install it on my computer. Then I use the function “font_add_google” from\nthe R package “sysfonts” to be able to use it in the graph. Also, in the R\nmarkdown chunk you have to put the following: “fig.showtext= TRUE”.\nNow with the “theme” function I establish the characteristics of the labels that\nI have created before (font size and color, font family, font face…). With the\n“margin” argument I can set the margins (top, bottom, left and right) of each\nlabel. For example, I have added a bottom margin to both the title and the subtitle.\nEven though the “market share” tag now looks like it’s not positioned correctly,\nsince it overlaps the x-axis text, later when I add the margins it will look\nfine.\nOn the other hand, the argument “plot.title.position =”plot” allows both the\ntitle and the subtitle to start at the top corner of the entire plot and not at\nthe beginning of the plot pane.\n\n\nsysfonts::font_add_google(\"Noto Serif\")\n\nupper_plot <- upper_plot +\n    theme(legend.position = \"none\",\n          plot.title = element_text(size = 12, \n                                  face = \"bold\", \n                                  family = \"Noto Serif\", \n                                  margin = margin(0, 0, 5, 0)),\n          plot.subtitle = element_text(size = 9.5, \n                                     colour = \"#636363\", \n                                     family = \"Noto Serif\", \n                                     margin = margin(0, 0, 20, 0)),\n          plot.title.position = \"plot\",\n          plot.tag.position = c(0.12, 0.878),\n          plot.tag = element_text(size = 8.7, family = \"sans\", \n                                colour = \"#a7a7a7\"))\n  \nupper_plot\n\n\n\nPanel grid and panel background\nThe next step is to configure the grid and the background panel, also with\narguments inside the “theme” function. I change the type of line and the color of\nthe line with “element_line” function and I set the background of the chart to\nwhite with “element_rect”.\n\n\nupper_plot <- upper_plot +\n    theme(panel.grid.major.y = element_line(linetype = \"dotted\", \n                                            colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        panel.background = element_rect(fill = \"white\"))\n        \nupper_plot\n\n\n\nAxis text, axis ticks and margins\nThe last step before finishing the theme of the chart is to adjust the ticks of\neach axis (x and y), the titles of the axes and the margins of the chart.\nIn order to bold the “50” on the x-axis I create a vector inside the function\n“element_line”, with the argument “linewidth”. This type of function is not\nofficially supported, so a “warning” appears. However, it works and it’s the\nonly way I’ve found to do it.\n\n\nupper_plot <- upper_plot +\n    theme(axis.ticks.y = element_blank(),\n        axis.ticks.x = element_line(colour = \"#c9c9c9\", \n                                    linewidth = c(0.3, 0.5, 0.5, 0.5, 0.8,\n                                                  0.5, 0.5, 0.5, 0.5, 0.4)),\n        axis.ticks.length.x = unit(0.2, \"cm\"),\n        axis.text.y = element_text(size = 10, family = \"sans\", \n                                   hjust = 0, vjust = 0.5),\n        axis.text.x = element_text(size = 9, family = \"sans\", \n                                   colour = \"#a7a7a7\",\n                                   face = c('plain', 'plain', 'plain', \n                                            'plain', 'bold', 'plain', \n                                            'plain', 'plain', 'plain', 'plain')),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\"))\n  \nupper_plot\n\n\n\nData\nNow is the time to put the data on the chart. To plot the arrows from the 2000’s\nmarket share data to now I use “geom_segment”. In this type of geom you have to\ngive it 4 aesthetics (x, xend, y, y-end). In addition, you can configure the type\nof line (an arrow in this case) and the color, which in this graph depends on\nwhether the increase is positive or negative (variable increase2 created\npreviously). Then, with the “scale_color_manual” function, the colors associated\nwith each category of this variable are set.\nLastly, I’ve also added a thicker vertical line highlighting the 50, using the\n“geom_vline” function.\n\n\nupper_plot <- upper_plot +\n  geom_vline(xintercept = 50, color = \"gray\", linewidth = 0.8) + \n  geom_segment(aes(x = market_share_2000, \n                   xend = market_share_now, \n                   y = industry_order, \n                   yend = industry_order, \n                   color = increase2), \n               arrow = arrow(length = unit(0.15, \"cm\"), \n                             type = \"closed\"), linewidth = 1) +\n  scale_color_manual(values = c(\"#575757\", \"#DB3B27\"))\n\nupper_plot\n\n\n\nAnnotations\nFinally, to finish the first graph, we must add the two annotations. To do this,\nI have used the “annotate” function, using the x and y arguments to get the\nproper final position within the plot area.\n\n\nupper_plot <- upper_plot +\n  annotate(\"text\", x = 34.8, y = 23.9, label = \"Early 2000s\", \n           size = 3, fontface = \"bold\") +\n  annotate(\"text\", x = 86.2, y = 23.9, label = \"Now\", \n           size = 3, fontface = \"bold\") +\n  annotate(\"text\", x = 42, y = 23.4, label = \"|\", \n           size = 3.2, fontface = \"bold\") +\n  annotate(\"text\", x = 84, y = 23.4, label = \"|\", \n           size = 3.2, fontface = \"bold\")\n\nupper_plot\n\n\n\n3. Create the second part of the plot\nTo make the second part of the graphic I have used a very similar code. I have\nfiltered the data to keep only the three industries starting in 2012.\nIn addition, I have removed the title, put a different subtitle and added a\ncaption with the argument “caption” inside the “theme” function.\n\n\nlibrary(grid)\n\nbottom_plot <- data %>%\n  filter(industry == \"Smartphones\" | industry == \"Social networks\" | \n           industry == \"Cellphone service\") %>% \n  mutate(industry = case_when(industry %in% c(\"Cellphone service\") ~ \n                                \"Cellphone service  \",\n                              T ~ industry),\n         industry_order = fct_reorder(industry, increase)) %>% \n  ggplot() +\n  geom_vline(xintercept = 50, color = \"gray\", size = 0.8) +\n  geom_segment(aes(x = market_share_2000, \n                   xend = market_share_now, \n                   y = industry_order, yend = industry_order, \n                   color = increase2), \n               arrow = arrow(length = unit(0.15, \"cm\"), \n                             type = \"closed\"), size = 1) +\n  scale_color_manual(values = c(\"#DB3B27\")) +\n  scale_x_continuous(position = \"bottom\", \n                     breaks = c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(10, 100),\n                     labels = c(\"10%\", \"20\", \"30\", \"40\", \"50\", \n                                \"60\", \"70\", \"80\", \"90\", \"100\"),\n                     name = NULL,\n                     expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 0.8))) +\n  labs(subtitle = \"Technology companies since 2012\",\n       caption = paste0('By The New York Times | Source: IbisWorld and Open',\n       'Markets Institute; \"Early 2000s\" ranges\\n', 'from 2002 to 2007',\n       'depending on data availability')) +\n  theme(legend.position = \"none\",\n        plot.title.position = \"plot\",\n        plot.subtitle = element_text(size = 9.5, family = \"Noto Serif\", \n                                     face = \"bold\", margin = margin(0, 0, 0, 0)),\n        plot.caption = element_text(size = 9, colour = \"#636363\", \n                                    family = \"Noto Serif\", \n                                    hjust = 0, margin = margin(20, 0, 0, 0)),\n        plot.caption.position = \"plot\",\n        panel.grid.major.y = element_line(linetype = \"dotted\", \n                                          colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.ticks.x = element_line(colour = \"#c9c9c9\", \n                                    size = c(0.3, 0.5, 0.5, 0.5, 0.8, \n                                             0.5, 0.5, 0.5, 0.5, 0.3)),\n        axis.ticks.length.x = unit(0.2, \"cm\"),\n        axis.text.y = element_text(size = 10, family = \"sans\", \n                                   hjust = 0, vjust = 0.5),\n        axis.text.x = element_text(size = 9, family = \"sans\", \n                                   colour = \"#a7a7a7\",\n                                   face = c('plain', 'plain', 'plain', \n                                            'plain', 'bold',\n                                            'plain', 'plain', 'plain', \n                                            'plain', 'plain')),\n        panel.background = element_rect(fill = \"white\"),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\")) +\n  annotation_custom(grob = textGrob(label = \"Now\", \n                                    gp = gpar(fontsize = 8.5, fontface = \"bold\", \n                                              fontfamily = \"sans\")),\n                    ymin = 3, xmin = 94.3) +\n  annotation_custom(grob = textGrob(label = \"2012\", \n                                    gp = gpar(fontsize = 8.5, fontface = \"bold\", \n                                              fontfamily = \"sans\")),\n                    ymin = 3, xmin = 52) \n\nbottom_plot\n\n\n\n4. Arranging plots\nNow I am going to show the two plots created previously to see the replication\nof the graph from the New York Times. To join the two graphics I have used the\npatchwork library, specifying that I want them in a single column, with a space\nbetween both graphics and with different heights. All this is configured with\nthe “plot_layout” function.\n\n\nlibrary(patchwork)\n\nupper_plot + plot_spacer() + bottom_plot +\n  plot_layout(ncol = 1,\n              heights = c(11.5, 0.35, 1.5))\n\n\n\nLimitations of the replication of the graph\nThe replication of the plot, created with the R package ggplot2, is very close\nto the original plot. There is a detail that I have not been able to replicate\nexactly. In the lower chart annotations (“2012” and “Now”) I had to expand the\ny-axis to fit them, as they were above the last industry category. Expanding\nthis axis with the “expand” argument of the “scale_y_discrete” function also\nexpanded the grid major x lines. In the original chart, however, these lines do\nnot go as far as the x-axis ticks, but intersect at the first category of the\nindustry variable. For that reason I have also put them closer to the arrow\nthan in the original graph and I have not had to put a line joining the arrow\nwith the annotation (with the geom_segment function).\nChart evaluation based on data visualization theory\nGiven the data the graph represents and the content of the New York Times\narticle it is a good graph. This is a chart called a “lollipop chart” which\nconsists, in short, of a bar chart in which the bar is a line and the end of the\nline is a point (a triangle in this case since they are arrows). Unlike typical\nbar charts, in this chart the bars (or lines) do not start at the same point on\nthe x-axis.\nAt first glance, the colors and size of the arrows already make clear the\nincrease in market share in the vast majority of industries. Positioning on a\ncommon scale is the most effective visual communication channel together with\nthe length, so the choice of this type of representation is a wise one and they\nhave used this highest ranked channels for the most relevant information of the\nplot (the change of the market share and the comparison between industries).\nIn addition, adding the shape of an arrow makes it possible to identify whether\nit is an increase or a decrease in market share. The choice of two colors to\nrepresent the positive and negative values in the difference between years is\nalso very useful as the hue color is a very effective identification channel. It\nis true that it is striking that the positive values are represented in red,\nsocially related to the negative values. However, this may be related to the\ncontent of the article, which seeks to highlight this growth in market share (as\nopposed to the gray assigned to the negative values) and which, in a way, sees\nthis growth as something negative for society.\nAnother positive element to highlight is the order of the industries on the\ny-axis, placed from highest to lowest market share growth. The authors of the\ngraph have also decided to highlight the line on the x-axis that marks 50% of\nthe market share, allowing the observer to identify more quickly which\nindustries have reached a market share above this figure.\nAs for the titles of the axes, the authors have decided to eliminate the y-axis\ntitle since it is easy to know from the labels of each industry which variable\nis represented. The x-axis title is also correctly represented, since it is\nplaced before the first tick, to which they add the “%” symbol so that the\nreader knows what the scale on which it is measured looks like. As soon as you\nlook down at the subtitle, you know that the x-axis measures the market share,\nwhich starts at 10 and is measured as a percentage.\nFinally, the chart has a brief but clear title, which lets the reader know what\nhe or she will find in the chart. The subtitle is also very useful because it\nexpands on the information given in the title, explaining that the graph\nrepresents the market share of two large companies. It also gives a brief\nanalysis to the reader, saying that this share has grown and that it may be a\nconsequence of the mergers. It also adds a second title to help the reader\nunderstand what the second part of the graph is about and a brief, explanatory\ncaption.\nSecond step: create a new visualization with the same data\nIn this section I will explain the process of creating an alternative\nvisualization of the New York Times chart with the same data.\nSince the data to be represented contains one categorical variable (with a large\nnumber of categories) and two continuous variables (ranging from 0 to 100) a bar\nchart is a good idea to represent them. However, as I have explained in the\nprevious section, the original graph is, de facto, a bar chart (with slight\nmodifications of the traditional ones).\nAt first I thought of making a bar chart in which to represent only the\ndifference between the market share of each industry in the early 2000s and now.\nHowever, I think that relevant information would be lost (where was the market\nshare before and now). I also thought about the possibility of making a grouped\nbar chart like these from R Graph Gallery,\nrepresenting on the x or y axis each industry, and on the other axis a bar for\nthe market share in the 2000’s and another for the current market share (each\nwith a different color). However, since the data consists of 25 different\nindustries (50 bars in total) I thought it would be unattractive and difficult\nto understand.\nI finally decided on the option of making a graph of parallel coordinates.\nNormally, in this type of graphs, time series are not represented, but a set of\nvariables are placed on the x-axis and a y-axis (a vertical line) is graphed for\neach variable. According to graphic perception theory, this type of graphic\nwould be slightly less visually effective than the one created by the New York\nTimes. This is because angles are less effective in conveying visual information\nthan position on a common scale (as in the original graphic) and length. However,\nI think it’s also a good way to represent this data in a different way.\nIn this case I have represented the variable industry on the y axis and on\nthe x axis I have made two parallel lines with the data related to the market\nshare of the 2000s and today. Subsequently, I have joined the points between the\ntwo lines of the x axis with a line. Also, I have set two colors in the\naesthetics of the segments: green when the increment is positive and red when it\nis negative. In the case of the green ones, I have put a slightly higher alpha\nin those increases that exceed 40% (value in which the average of the increases\nis), in order to highlight them in the graph. I have decided to put these colors\nbecause we socially associate green with positive or increase and red with\nnegative or decrease.\nOn the other hand, I have labeled the type of industries that exceed that 40%,\nsince labeling all of them was impossible due to overlapping problems. For those\nreaders who want to expand the information, I have added interactivity in such a\nway that if you put the mouse over the lines you can see what type of industry\nit is and the percentage of increase.\nInstead of making two graphs to represent the technology industries starting in\n2012, I have decided to include them by highlighting them with a yellow dot and\na label explaining the difference with the rest of the lines. I thought it\nconvenient to do so in order to be able to compare at a glance the percentage of\ncurrent market share of these industries with that of the rest of the industries.\nFinally, I have kept the same original title, which I think is concise and\nexplicit, and slightly changed the subtitle to highlight information about\nthose industries that have grown proportionally the most.\nNow I will show the code and the steps to follow to create this new\nvisualization!\nPrepare the data\nThe first step is to prepare the data. For this I have created two different\ndata frames. In the first, taking the original dataset, I have created four new\nvariables:\nperc_increase, which is the percentage increase in market share between the\ntwo years.\nperc_increase_label, to add a “+” to the previous variable in case the\nvalue is positive.\nincrease2, with three categories to differentiate positive increases below\n40%, positive increases above 40% and negative.\nindustry_labels, keeps the industry label only in case the percentage\nincrease is greater than 40%.\nThe second data frame contains the market share data for the three technology\nindustries starting in 2012 and an additional column with a 1. This data frame\nwill serve to draw the three dots that indicate that these data are slightly\ndifferent from the rest.\n\n\n# First data frame:\n\nalternative_plot_data <- data %>%\n  ungroup() %>% \n  mutate(perc_increase = round(increase/market_share_2000*100, 1),\n         perc_increase_label = case_when(perc_increase > 0 ~ \n                                           paste0(\"+\", perc_increase),\n                       T ~ as.character(perc_increase)),\n         increase2 = case_when(perc_increase > mean(perc_increase) ~ \n                                 \"high_increase\",\n                               T ~ increase2),\n         industry_labels = case_when(increase2 != \"high_increase\" ~ \"\",\n                              T ~ industry),\n         \"Early 2000s\" = 1,\n         Now = 2) %>% \n  arrange(desc(increase2))\n\nhead(alternative_plot_data)\n\n# A tibble: 6 × 10\n  industry     marke…¹ marke…² incre…³ incre…⁴ perc_…⁵ perc_…⁶ indus…⁷\n  <chr>          <int>   <int>   <int> <chr>     <dbl> <chr>   <chr>  \n1 Smartphones       79      99      20 positi…    25.3 +25.3   \"\"     \n2 Sanitary pa…      53      63      10 positi…    18.9 +18.9   \"\"     \n3 Truck and b…      52      62      10 positi…    19.2 +19.2   \"\"     \n4 Railroads         49      58       9 positi…    18.4 +18.4   \"\"     \n5 Amusement p…      60      69       9 positi…    15   +15     \"\"     \n6 Credit cards      26      35       9 positi…    34.6 +34.6   \"\"     \n# … with 2 more variables: `Early 2000s` <dbl>, Now <dbl>, and\n#   abbreviated variable names ¹​market_share_2000, ²​market_share_now,\n#   ³​increase, ⁴​increase2, ⁵​perc_increase, ⁶​perc_increase_label,\n#   ⁷​industry_labels\n\n\n\n# Second data frame:\n\ndata.frame.points <- data %>%\n  ungroup() %>% \n  filter(industry == \"Smartphones\" | industry == \"Social networks\" \n         | industry == \"Cellphone service\") %>% \n  select(market_share_2000, industry) %>% \n  mutate(x = 1)\n\nhead(data.frame.points)\n\n# A tibble: 3 × 3\n  market_share_2000 industry              x\n              <int> <chr>             <dbl>\n1                79 Smartphones           1\n2                75 Social networks       1\n3                65 Cellphone service     1\n\nCreate the static graph\nData, coordinates and axes\nParallel coordinate plots can be easily created with the ggplot2 extension\n“ggally”, as explained here.\nHowever, in this case I have had to do it with a combination of geom_segment and\n“geom_vline” because the ggally functions don’t support interactivity with either\nggplotly or ggiraph. The function used from the ggiraph package is called\n“geom_segment_interactive”.\nWith “geom_vline” I have created the two vertical and parallel lines where the\nvalues of the market share in 2012 and currently are represented.\nSubsequently, with the geom_segment function I have created the lines that join\nthe values between one date and another.\nIn the geom_segment aesthetic I have specified that I want the color and alpha\nto be associated with the previously created variable increase2 that\ndifferentiates between positive, negative and positive values above 40%\nincrement. To set the values of both aesthetics I have used the\n“scale_color_manual” and “scale_alpha_manual” functions.\n\n\nlibrary(ggiraph)\nlibrary(grid)\nlibrary(ggrepel)\nsysfonts::font_add_google(\"Catamaran\", family = \"catamaran\")\n\nalternative_plot <- alternative_plot_data %>% \n  ggplot() + \n  geom_segment_interactive(aes(x = `Early 2000s`, xend = Now, \n                               y = market_share_2000, yend = market_share_now, \n                               col = increase2,\n                               alpha = increase2,\n                               tooltip = paste0(industry, \" \", \n                                                perc_increase_label, \"%\"),\n                               data_id = industry), \n               size = 0.71, show.legend = F) +\n  geom_vline(xintercept = 1, size = 0.5, color = \"gray\") + \n  geom_vline(xintercept = 2, size = 0.5, color = \"gray\") +\n  scale_color_manual(values = c(\"#006400\", \"#d3101e\", \"#006400\")) +\n  scale_alpha_manual(values = c(0.9, 0.6, 0.5)) +\n  scale_y_continuous(breaks = c(20, 30, 40, 50, 60, 70, 80, 90, 100),\n                     limits = c(15, 100),\n                     labels = c(\"20\", \"30\", \"40\", \"50\", \n                                \"60\", \"70\", \"80\", \"90\", \"100%\"),\n                     name = \"Market share\",\n                     expand = c(0,0)) +\n  scale_x_discrete(name = \"Now\", position = \"top\", \n                   expand = expansion(add = c(0.02, 0.32))) \n\nalternative_plot\n\n\n\nTheme and labels\nWith the “labs” function I have created the title, the subtitle, the tag, and\nthe caption. I used the “tag” argument to create the “Early 2000s” tag because\nunlike the “annotation” function it allowed me to place it outside the chart\narea without expanding the grid lines. In order to create the parallel label\n“Now” that names the second vertical line, I have used the title of the x axis\nitself.\nWith the “theme” function I have configured all these labs and I have\nestablished a very minimalist theme, with dotted grid lines of the y-axis and a\nwhite background. I also wanted to highlight the “50” of the “y” scale by\nputting it in bold.\nTo put the industry type labels at the end of each line I have used the\n“geom_label_repel” function, thus making sure that they do not overlap each\nother. With the “direction” argument I have specified that in case of\noverlapping I wanted them to move in the y axis, never in the x axis, in such a\nway that they would be aligned.\n\n\nalternative_plot <- alternative_plot +\n  labs(title = \"Dominance of Corporate Behemoths\",\n       subtitle = paste0('The combined market share of the two largest ', \n                         'companies in many industries\\n','has grown in recent', \n                         ' years, often more than 40%.'),\n       tag = c(\"Early 2000s\", \"Now\"),\n       caption = paste0('By Isabel Molero López | Source: New York Times; \"Early 2000s \"',\n       'ranges from 2002 to 2007.\\n', 'Lines that begin with a yellow dot ', \n       'correspond to the data of technology companies since 2012.')) +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = 13.5, face = \"bold\", family = \"catamaran\", \n                                  margin = margin(0, 0, 5, 0)),\n        plot.subtitle = element_text(size = 11.5, colour = \"#636363\", \n                                     family = \"catamaran\", \n                                     margin = margin(0, 0, 30, 0)),\n        plot.title.position = \"plot\",\n        plot.tag.position = c(0.11, 0.88),\n        plot.tag = element_text(size = 11.5, family = \"catamaran\", \n                                colour = \"#636363\", face = \"bold\"),\n        plot.caption = element_text(size = 9.5, colour = \"#636363\", \n                                    family = \"catamaran\", \n                                    margin = margin(15, 0, 0, 0),\n                                    hjust = 0),\n        plot.caption.position = \"plot\",\n        panel.grid.major.y = element_line(linetype = \"dotted\", \n                                          colour = \"#a7a7a7\"),\n        panel.grid.major.x = element_line(colour = \"#c9c9c9\"),\n        panel.grid.minor = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.text.y = element_text(size = 10, family = \"catamaran\", \n                                   hjust = 0.7, vjust = 0.5, \n                                   face = c('plain', 'plain', 'plain', \n                                            'bold', 'plain','plain', \n                                            'plain', 'plain', 'plain')),\n        axis.title.x = element_text(hjust = 0.78, margin = margin(0, 0, 20, 0), \n                                    size = 11.5, family = \"catamaran\", \n                                    colour = \"#636363\",\n                                   face = \"bold\"),\n        axis.title.y = element_text(size = 11, family = \"catamaran\", \n                                    colour = \"#636363\", margin = margin(r = 7)),\n        axis.title.x.top = element_text(vjust = 7.6),\n        panel.background = element_rect(fill = \"white\"),\n        plot.margin = margin(0, 1.7, 0, 0, \"cm\")) +\n     geom_label_repel(aes(x = 2, y = market_share_now, label = industry_labels,\n                         segment.alpha = 0),\n                    inherit.aes = FALSE, \n                    color = c(\"#505050\"), \n                    alpha = 2, hjust = 1,\n                    size = 3.2,\n                    force = 0.0016,\n                    force_pull = 10,\n                    direction = \"y\",\n                    xlim = c(2, NA),\n                    label.size = NA,\n                    box.padding = 0.002,\n                    family = \"catamaran\")\n\nalternative_plot\n\n\n\nAnnotations and other aditional settings\nFinally, I have added with the “annotate_interactive” function a label that\nindicates the lines that correspond to the technological industries. Also, I’ve\nused the “geom_point” function to put a point at the beginning of these lines so\nthat the reader can quickly identify them. With the “geom_segment” function I\nhave joined the point with the annotation by means of a line. Finally, the\n“geom_hline” function has allowed me to overlay a thicker, black line at 50%,\nthus highlighting industries that have a market share above this value.\n\n\nalternative_plot <- alternative_plot +\n  geom_hline(yintercept = 50, size = 0.7, color = \"black\", linetype = \"dotted\") +\n  geom_segment_interactive(aes(x = 1.01, xend = 1.07,\n                   y = 80, yend = 83.5,\n                   tooltip = \"\",\n                   data_id = 1),\n               size = 0.17,\n               color = \"#E6B400\") +\n  geom_point_interactive(data = data.frame.points, \n                         aes(x, market_share_2000,\n                             tooltip = paste0(industry, \", since 2012\"),\n                             data_id = 1),\n             colour = \"#E6B400\") +\n  annotate_interactive(\"text\", x = 1.09, y = 84.7, label = \"2012\", \n                       size = 3.4, color = \"#E6B400\", \n                       fontface = \"bold\", family = \"catamaran\",\n                       tooltip = \"\", data_id = 1) +\n  annotate_interactive(\"text\", x = 1.11, y = 88, label = \"Technology\", \n                       size = 3.1, color = \"#E6B400\", \n                       fontface = \"bold\", family = \"catamaran\", \n                       tooltip = \"\", data_id = 1) +\n  annotate_interactive(\"text\", x = 1.11, y = 86.5, label = \"companies\", \n                       size = 3.1, color = \"#E6B400\",\n                       fontface = \"bold\", family = \"catamaran\",\n                       tooltip = \"\", data_id = 1)\n\nalternative_plot\n\n\n\nAdd interactivity with the package ggiraph\nInteractivity can be added to the graph previously created to expand information.\nIn this case I have decided that when placing the mouse over each line the rest\nlower their alpha, in such a way that it stands out. In addition, a label\nappears with the name of the industry that corresponds to that line along with\nthe percentage increase or decrease in market share between the different years.\nTo add interactivity I have used the R package “ggiraph”. When making the graph\nitself I have used the geoms from this library (for example,\n“geom_segment_interactive”). Finally, with the “girafe” function the\ninteractivity is added to the created graph and with “girafe_options” the\noptions are set. For example, I have selected the color and background of the\nlabels that appear and the font with “opts_tooltip”. With “opts_hover_inv” I\nhave set the opacity of the rest of the lines when I pass the mouse over one in\nparticular.\nBelow you can see the final result!\n\n\nalternative_plot_interactive <- girafe(ggobj = alternative_plot, width_svg = 6, \n                                       height_svg = 7)\nalternative_plot_interactive <- girafe_options(x = alternative_plot_interactive,\n                    opts_tooltip(\"background-color:gray;color:white;\n                                 font-style:italic;padding:6px;\n                                 border-radius:7px;\"),\n                    opts_hover_inv(css = \"opacity:0.1;\"),\n                    opts_hover(css = \"opacity:1;\"),\n                    opts_sizing(rescale = TRUE, width = 0.75))\n\nalternative_plot_interactive\n\n\n\n\n\n\n",
    "preview": "projects/2022/100348375/100348375_files/figure-html5/unnamed-chunk-16-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1209,
    "preview_height": 1728
  },
  {
    "path": "projects/2022/100483851/",
    "title": "Car fleet by antiquity in Spain",
    "description": "Car accident rate is directly related to the antigüity of the vehicle.\nThe graph represents car fleet and its age along 10 years.\nI will replicate it as closely as possible, as weel as providing a \nvisualization alternative.",
    "author": [
      {
        "name": "Maria del Mar Escalas Martorell",
        "url": {}
      }
    ],
    "date": "2023-01-13",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nLoading libraries and letter type\nGetting the data\nBuilding the chart\nCoordinates and axes\nLabels and theme\n\nFinal step: creating an interaction\nAlternative graph\n\nLoading libraries and letter type\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggiraph)\nlibrary(showtext)\nlibrary(ggfittext)\nlibrary(dplyr)\nlibrary(patchwork)\n\nfont_add_google(\"Encode Sans\", family = \"encodesans\")\nfont_add_google(\"Chivo\", family = \"chivo mono\")\nshowtext_auto()\n\n\nThis graph is from an online newspaper article from “El Motor” (El País).\nThe author talks about the higher mortality rate when older cars are involved in\nthe accident.\nOriginal plot by El Motor / El País.Getting the data\nThe data is not openly available, we should have a look at the source mentioned\nin the plot: Traffic General Direction. In this case, data needs to be\ntransformed into percentages and organized in a dataframe manually.\n\n\ndata <- data.frame(Año = c(2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019,\n                           2020),\n                   \"0-4 años\" = c(\"22%\", \"18%\", \"16%\", \"15%\", \"15%\", \"16%\", \n                                  \"18%\", \"20%\", \"21%\", \"20%\"),\n                   \"5-9 años\" = c(\"31%\", \"32%\", \"31%\", \"28%\", \"25%\", \"21%\", \n                                  \"16%\", \"14%\", \"14%\", \"14%\"),\n                   \"10-14 años\" = c(\"24%\", \"26%\", \"27%\", \"27%\", \"27%\", \"28%\", \n                                    \"28%\", \"27%\", \"24%\", \"22%\"),\n                   \"Más de 15 años\" = c(\"23%\", \"25%\", \"26%\", \"29%\", \"33%\", \n                                        \"36%\", \"37%\", \"39%\", \"41%\", \"44%\"),\n                   check.names = FALSE)\n\nmygraph <- data %>% pivot_longer(-\"Año\", \n                                 names_to = \"Antigüedad\",\n                                 values_to = \"Valor\") \n\nmygraph <- mygraph %>%  mutate(Año = as.factor(Año),\n                               Antigüedad = as.factor(Antigüedad),\n                               Valor = as.numeric(str_sub(mygraph$Valor, 1, 2)))\n\nmygraph <- mygraph %>% mutate(Año = fct_reorder(Año, desc(Año)),\n                              Antigüedad = fct_relevel(Antigüedad, \n                                                       \"Más de 15 años\", \n                                                       \"10-14 años\", \"5-9 años\", \n                                                       \"0-4 años\"))\n\n\nBuilding the chart\nCoordinates and axes\nHere we set x and y variables. We introduce “Antigüedad” to differentiate\nsegments in the bar according to age of the vehicles.\n\n\np <- mygraph %>% ggplot(aes(x=Año, y=Valor, fill=Antigüedad)) +\n        geom_bar(stat=\"identity\")\n\np\n\n\n\nAssigning colour to each level of “Antigüedad” and flip coordinates.\n\n\np <- p + scale_fill_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                                    rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) + \n         coord_flip()\n\np\n\n\n\nLabels and theme\nNow, we label the plot, remove both axis labels and background, and organize the\nlegend.\n\n\np <- p + labs(title = \"El parque automovilístico por antigüedad\",\n              caption = \"Fuente: Dirección General de Tráfico. EL MOTOR\") +\n         theme(plot.title = element_text(family = \"encodesans\", face = \"bold\",\n                                         size = 22),\n               plot.title.position = \"plot\",\n               plot.caption = element_text(family = \"encodesans\", \n                                           color = \"gray\", hjust = 1, \n                                           size = 14,\n                                           margin = margin(20,0,0,0)),\n               axis.title.x = element_blank(),\n               axis.text.x = element_blank(),\n               axis.ticks.x = element_blank(),\n               axis.title.y = element_blank(),\n               axis.text.y = element_text(family = \"chivo mono\", size = 20),\n               axis.ticks.y = element_blank(),\n               legend.position = \"top\",\n               legend.title = element_blank(),\n               legend.justification = c(-0.36,1),\n               legend.text = element_text(family = \"encodesans\", size = 18),\n               legend.key.size = unit(0.7, \"cm\"), \n               panel.grid.major = element_blank(),\n               panel.grid.minor = element_blank(),\n               panel.background = element_blank()\n         ) +\n         scale_x_discrete(expand = c(0,0)) + \n         scale_y_discrete(expand = c(0,0)) + \n         guides(fill = guide_legend(reverse=TRUE))\n\np\n\n\n\nOnce we have the basic structure of the plot, it is time to introduce labels\ninside each segment of the bars. This is the most tricky part, as we have to\nbear in mind several aspects:\nTo put labels inside each segment of the bars we should use geom_bar_text().\nIt is similar to geom_text() and it is contained in library(ggfittext).\nAt the time when presenting this work (January 2023) ggfittext package is in\n“maturing” lifecycle, this means that some functions are in an experimental\nphase and may suffer changes and updates.\nIn this particular case, there was not specific documentation for dealing\nwith independent label color changes inside bars. So, I assigned default colors\nfor “Antigüedad” and then changed them manually relating “Values” with the\ndifferent levels of “Antigüedad”.\ngeom_bar_text has a contrast option (TRUE or FALSE) which gives black or\nwhite color to the label based on its background. The problem that I had was\nthat R assigned white labels only for the two darker blues in our plot, leaving\n“10-14 años” with black number labels.\n\n\np <- p + geom_bar_text(aes(label = paste0(`Valor`, \"%\"), colour = Antigüedad),\n                           position = \"stack\", \n                           reflow = TRUE, \n                           place = \"left\",\n                           family = \"chivo mono\",\n                           size = 20) + \n         scale_colour_manual(values = c(`0-4 años` = \"White\", \n                                        `5-9 años` = \"White\", \n                                        `10-14 años` = \"White\", \n                                        `Más de 15 años` = \"Black\"), \n                             guide = \"none\")\n\np\n\n\n\nFinal step: creating an interaction\nTo make the graph interactive I have used the package ggiraph(). Because it is\nvery recent and there is not much documentation and users’ feedback, it has some\nfunctions that are difficult to use or are not extended a lot.\nThe idea that ggiraph proposes is to redefine ggplot functions with the suffix\n_interactive. At the same time, key data has to be provided inside each function\nin order to ggiraph make the interaction. With this mechanism, ggiraph\nidentifies which parts of the plot have to interact and adds this movement to\nthe plot.\nParticularly for this graph, I find the presence f interactivity very important.\nThe way that information inside bars is plotted does not allow to see clearly\nincreases or decreases of percentages all along years (in the case of the two\ncentral columns: “5-9 años” and “10 -14 años”). Interactivity allows the reader\nto select individually these segments and makes them more easy to read.\n\n\ninteractive <- ggplot(mygraph, aes(Año, Valor, fill = Antigüedad, \n                                   data_id = Antigüedad)) +\n  geom_bar_interactive(stat = \"identity\", aes(`data-id`= Antigüedad), \n                       extra_interactive_params = \"data-id\") +\n  scale_fill_manual_interactive(extra_interactive_params = \"data-id\",\n                                 `data-id`= unique(mygraph$Antigüedad),\n                                 values=c(rgb(0.43, 0.89, 0.99), \n                                          rgb(0, 0.66, 0.91), \n                                          rgb(0.02, 0.4, 0.67), \n                                          rgb(0, 0.2, 0.53)),\n                                 guide = guide_legend_interactive(reverse=TRUE),\n                                 data_id = function(breaks) as.character(breaks)) +\n  coord_flip() + \n  labs(title = \"El parque automovilístico por antigüedad\",\n       caption = \"Fuente: Dirección General de Tráfico. EL MOTOR\") +\n  theme(plot.title = element_text(family = \"encodesans\", \n        face = \"bold\", \n        size = 22),\n        plot.title.position = \"plot\",\n        plot.caption = element_text(family = \"encodesans\", \n          color = \"darkgray\",\n          face = \"bold\",\n          size = 14,\n          hjust = 1,\n          margin = margin(20,0,0,0)), \n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.y = element_text(family = \"chivo mono\", size = 20), \n        axis.ticks.y = element_blank(),\n        legend.position = \"top\",\n        legend.title = element_blank(),\n        legend.justification = c(-0.36,1),\n        legend.text = element_text(family = \"encodesans\", size = 18), \n        legend.key.size = unit(0.7, \"cm\"), \n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        panel.background = element_blank()) +\n  scale_x_discrete(expand = c(0,0)) + \n  scale_y_discrete(expand = c(0,0)) +\n  guides(guide_legend_interactive(reverse=TRUE)) +\n  geom_bar_text(aes(label = paste0(`Valor`, \"%\"),\n                    colour = Antigüedad),\n                    position = \"stack\", \n                    reflow = TRUE, \n                    place = \"left\",\n                    family = \"chivo mono\",\n                    size = 20) + # cambiar tipo de letra\n  scale_colour_manual(values = c(`0-4 años` = \"White\", `5-9 años` = \"White\", \n                                 `10-14 años` = \"White\", \n                                 `Más de 15 años` = \"Black\"), guide = \"none\")\n\nfinal <- girafe(ggobj = interactive,\n                width_svg = 10, \n                height_svg = 6,\n                options = list(\n            opts_hover(css = girafe_css(\"stroke-width: 1; opacity: 1;\")),\n            opts_hover_key(css = girafe_css(\"stroke-width: 1; opacity: 0.6;\")),\n            opts_hover_inv(css = girafe_css(\"stroke-width: 1; opacity: 0.1;\"))\n               ))\n\nfinal\n\n\n\nAlternative graph\nThe original graph has some aspects to improve that can be solved with another\ntype of graph. Especially, I am trying to improve readability of data and\ninformation organisation.\nThe original graph has some problems that need to be solved. First, and most\nimportant, is the data itself used. As it can be visually appreciated, there are\nseveral bars which are longer, and others fall short. This is due to a fail in\nthe rounding of data: 2012 and 2016 account for 101%, and 2014 and 2017 only\nreach 99%.\nSo, first step is to recalculate data, adjusting roundings properly. I have also\ntaken the opportunity to translate it into English.\n\n\nalternative <- data.frame(Year = \n               as.factor(c(\"2011\", \"2011\", \"2011\", \"2011\", \"2012\", \"2012\", \n                    \"2012\", \"2012\", \"2013\", \"2013\", \"2013\", \"2013\", \"2014\", \n                    \"2014\", \"2014\", \"2014\", \"2015\", \"2015\", \"2015\", \"2015\", \n                    \"2016\", \"2016\", \"2016\", \"2016\", \"2017\", \"2017\", \"2017\", \n                    \"2017\", \"2018\", \"2018\", \"2018\", \"2018\", \"2019\", \"2019\", \n                    \"2019\", \"2019\", \"2020\", \"2020\", \"2020\", \"2020\")), \n                          Antiquity = \n               as.factor(c(\"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\", \"0-4 years\", \"5-9 years\", \n                    \"10-14 years\", \"More than 15 years\", \"0-4 years\", \n                    \"5-9 years\", \"10-14 years\", \"More than 15 years\", \n                    \"0-4 years\", \"5-9 years\", \"10-14 years\", \n                    \"More than 15 years\")),\n                           Value = c(22, 31, 24, 23, 18, 32, 26, 24, 16, 31, 27, \n                                     26, 15, 28, 27, 30, 15, 25, 27, 33, 16, 20,\n                                     28, 36, 19, 16, 28, 37, 20, 14, 27, 39, 21, \n                                     14, 24, 41, 20, 14, 22, 44))\n\n\nThen, I decided to make an alternative that allowed the reader to see the\nchanges all along years, which was one of the objectives that were expressed in\nthe news from where the original graph was taken. For this reason, firstly, I\ndecided to make a simple line graph. I changed axis, so that years are shown in\nthe x axis and the reader can see clearly the tendency that all age groups are\nfollowing. In addition, I assigned darker colors to older age groups, instead of\nwhat the original graph shows (going from dark to bright).\n\n\nfullgraph <- alternative %>% mutate(Antiquity = fct_relevel(Antiquity, \n                                                      \"0-4 years\", \n                                                      \"5-9 years\", \n                                                      \"10-14 years\", \n                                                      \"More than 15 years\")) %>% \n  ggplot(aes(x = Year, y = Value, group = Antiquity, color = Antiquity)) +\n  geom_line(linewidth= 1.2) + \n  labs(title = \"Car park by age in Spain\") +\n  theme_minimal() +\n  theme(\n    plot.title.position = \"plot\",\n    plot.title = element_text(face = \"bold\"),\n    legend.position = c(0.25, 0.87),\n    legend.title = element_blank(),\n    legend.margin = margin(c(0,8,5,5), \"pt\"), \n    axis.title.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    axis.text.x = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"), \n    axis.ticks.y = element_blank(),\n    legend.background = element_rect(fill = \"white\")) +\n  scale_y_continuous(labels = function(x) paste0(x, \"%\"), limits = c(0, 50)) +\n  scale_color_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                              rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) +\n  scale_x_discrete(expand = c(0.01, 0.05)) +\n  guides(color=guide_legend(nrow=2, byrow=TRUE))\n\nfullgraph\n\n\n\nI also created facets to plot individually each group of age, in order for\nthe reader to have an individual view of each of the age segments.\n\n\nalternative2 <- alternative %>% mutate(Antiquity2 = Antiquity)\n\nfacetsalternative <- alternative %>% ggplot(aes(x = Year, \n                                                y = Value, \n                                                group = 1)) +\n  geom_line(data = alternative2 %>% select(-Antiquity), aes(group = Antiquity2), \n            color = rgb(1, 0.65, 0.31), size = 0.7, alpha = 0.3) +\n  ylim(0,50) +\n  geom_line(aes(color = Antiquity),  size = 1.2) +\n  theme(\n    axis.title.x = element_blank(),\n    axis.text.x = element_text(face = \"bold\"),\n    axis.title.y = element_blank(),\n    axis.text.y = element_text(face = \"bold\"),\n    axis.ticks = element_blank(),\n    panel.background = element_blank(),\n    panel.grid.major = element_line(color = rgb(0.97, 0.97, 0.97)),\n    panel.grid.minor = element_line(color = rgb(0.97, 0.97, 0.97)),\n    legend.position = \"none\"\n  ) +\n  scale_y_continuous(labels = function(x) paste0(x, \"%\"), limits = c(0, 50)) +\n  scale_x_discrete(expand = c(0.04, 0.04)) +\n  scale_color_manual(values=c(rgb(0.43, 0.89, 0.99), rgb(0, 0.66, 0.91), \n                              rgb(0.02, 0.4, 0.67), rgb(0, 0.2, 0.53))) +\n  facet_wrap(~factor(Antiquity, levels = c(\"0-4 years\", \"5-9 years\", \n                                          \"10-14 years\", \"More than 15 years\")))\n\nfacetsalternative\n\n\n\nWith patchwork it is easy to join both graphs together.\n\n\ndefinitive_alternative <- fullgraph / facetsalternative\n\ndefinitive_alternative\n\n\n\n\n\n\n",
    "preview": "projects/2022/100483851/100483851_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "projects/2022/100376720/",
    "title": "Education Attainment Graph",
    "description": "This project consists in the replicaion and alternative representation of a\ngraph from a New York Times article called \"Where Education Drives Mobility\".",
    "author": [
      {
        "name": "Edgar Chicurel",
        "url": {}
      }
    ],
    "date": "2023-01-12",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nGraph to replicate (two graphs in one)\nLoad libraries and read the database\nAdjusting the data\nFirst graph\nAdjusting the data for second graph\nSecond graph\nMerge both graphs into one\nAlternative Representations\nGraph 1:\nGraph 2\nMerge them together\n\nConclusion\n\nIntroduction\nThe graph for this project was inspired by a New York Times article about education mobility and gender differences in education. The first part of the article talks about how young students’ highest level of education compares to their parents’ highest level of education. Students who achieved a higher level than their parents are considered upwardly mobile, those who achieved the same level are considered to have experienced status quo mobility, and those who achieved a lower level are considered downward mobile. The second part of the article examines gender differences in education at a specific level. You can find the full article here.\nGraph to replicate (two graphs in one)\nThe graph that needs to be replicated is actually two graphs in one. The first graph (on the left) shows the differences in education mobility among OECD countries for students aged 25-34. The graph uses a dark purple color for students who achieved a higher education level than their parents, a light grey color for students who achieved the same level, and a yellow color for students who achieved a lower level. The second graph (on the right) shows the difference for the same countries, except for Russia and Japan (for which data is not available), but by country and gender for students who achieved a highest education level higher than high school. The first graph is a stacked percentage bar graph, and the second graph consists of dotted lines and points. Both graphs have annotations to label the categories. At first glance, the graphs do not appear to be complicated. Here is a link to the original graph:\nGraph to replicateLoad libraries and read the database\nThe first step was to load the libraries, in this case I only used two: tidyverse and patchworks. The second step was to read the database which was on a csv file.\n\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\ndf <- read_csv(\"Data_on_intergenerational_mobility.csv\")\n\n\nAdjusting the data\nIn this part, the data for the first graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Mobility_type” column. After this I created 3 different databases, each one of them containing only one category, this was done in order to arrange the graph in descending order of a specific category inside the “Mobility_type” column.\n\n\neduc <- df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\"\n  ) %>%\n  pivot_longer(cols = ends_with(\"ility\"), \n               names_to = \"Mobility_type\", \n               values_to = \"Mobility_perc\") \n\ndf_order <- educ[educ$Mobility_type == \"Upward_mobility\", ]\ndf_order2 <- educ[educ$Mobility_type == \"Status_quo_Mobility\",]\ndf_order3 <- educ[educ$Mobility_type == \"Downward_Mobility\",]\n\n\nFirst graph\nThe code for this visual representation can be divided into six parts:\nPlotting the data as vertical columns (“stack”) and arranging it in descending order based on the Upward_mobility category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adding a percent symbol or adding extra space).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) + \n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        plot.background = element_rect(fill = \"white\", colour = NA), \n        panel.background = element_rect(fill = \"white\", colour = NA),\n        legend.background = element_rect(fill = \"white\", colour = NA),\n        legend.key = element_rect(fill = \"white\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x))+\n geom_text(data = df_order, \n            aes(x=12, label = ifelse(\n              Country == \"South Korea\", paste0(Mobility_perc, \"%\"), \n              ifelse(\n              Country != \"South Korea\", paste0(Mobility_perc, \"    \"), \n              Mobility_perc))), \n           size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=150, label = ifelse(\n              Country != \"South Korea\", \n              paste0(Mobility_perc, \"       \"), Mobility_perc)), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, \n            aes(x=200, label = Mobility_perc), size=3, \n            position = position_stack(vjust = 0.485)) +\n  labs(\n  subtitle = \"\\nPercentage of people who got more, the same or\\nless education than their parents, as of 2012.\") +\n  theme(\n        plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\", \n                                  margin=margin(0,0,-20,0)),\n        plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                                     margin=margin(0,0,70,0)),\n axis.text.y = element_text(margin=margin(0,-15,0,0))) +\n  annotate(\"text\", x=7.5, y=28, label=\"MORE\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=8, y=26.7, label=\"  (upwardly\\nmobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=3, xend=3, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=60, y=28, label=\"SAME\",fontface = \"bold\",size=3) +\n   annotate(\"text\", x=60,  y=26.7, label=\"(status\\n   quo)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=66, xend=66, y = 23.6, yend = 25.2, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"text\", x=97, y=28, yend = 32, label=\"         LESS\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=97,  y=26.7, label=\"(downardly\\n       mobile)\",\n            colour = \"grey30\", size=3) + \n  annotate(\"segment\", x=99.9, xend=99.9, y = 23.6, yend = 25.2, \n           color=\"grey30\",alpha = 0.5) +\n  coord_cartesian(xlim = c(0, 200), ylim = c(0, 22), clip = \"off\")\n\n\nAdjusting the data for second graph\nIn this part, the data for the second graph is adjusted by erasing rows that are not contained in the graph and pivoting the categories that we are interested into one single column. In this cases, into “Beyond_Sex” column. After this I created 1 different database, containing only one category, this was done in order to arrange the graph in descending order of that specific category inside the “Beyond_Sex” column, in this case by female.\n\n\nbeyond =  df %>%\n  drop_na(Downward_Mobility) %>% \n  filter(Country != \"Northern Ireland\" &\n         Country != \"England\" &\n         Country != \"Sub-national entities\" &\n         Country != \"Partners\" &\n         Country != \"Average\" &\n         Country != \"Russia\" &\n         Country != \"Japan\"\n  ) %>%\n  pivot_longer(\n    cols= starts_with(\"Beyond\"),\n    names_to = \"Beyond_Sex\",\n    values_to = \"Beyond_perc\"\n  ) \n\n\n  bey_ordered = beyond %>% \n    filter(Beyond_Sex == \"Beyond_highscool_2014_F\") %>%\n    arrange(desc(Beyond_perc))\n\n\nSecond graph\nThe code for this visual representation can be divided into seven parts:\nPlotting the data points using “geom_point” and arranging them in descending order based on the Female category.\nChanging the theme by removing elements such as axis.ticks, axis.texts, and background.\nAdding numbers to the graph using geom_text and adjusting their positions and formatting (e.g., adjusting the position of the first numbers to the left and the position of the second numbers to the right).\nAdding a subtitle and adjusting its position and margin to make room for annotations.\nChanging the panel.grid composition to include horizontal dotted lines and solid vertical lines with the correct measures and positions.\nAdding annotations, including both text annotations and line (“segment”) annotations.\nAdjusting the plot coordinates to make it easier to combine it with the second graph.\n\n\np2 = beyond %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_point(size=3, color = \"#5e4c5f\", aes(\n    color = Beyond_Sex), data = bey_ordered) + \n  geom_point(size=3, color = \"#b8bdd0\", aes(color = Beyond_Sex), \n             data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",\n                           ]) +\n  labs(y=NULL) +\n  theme(plot.background = element_rect(fill = \"white\",colour = NA), \n        panel.background = element_rect(fill = \"white\",colour = NA),\n        legend.background = element_rect(fill = \"white\",colour = NA),\n        legend.key = element_rect(fill = \"white\"),\n        legend.position = \"none\",\n        axis.title.x = element_blank(),\n        axis.text.x = element_text(size = 8.5),\n        axis.ticks.x = element_blank(),\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0, \n                                   margin=margin(0,-10,0,0))) +\n  geom_text(data = subset(bey_ordered, \n                          Country %in% c(\n                            \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = 2, nudge_y = 0.1, size=3) +\n  geom_text(\n    data = subset( beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n                           Country %in% c(\n                             \"South Korea\", \"United States\", \"Italy\", \"Germany\")),\n            aes(label = Beyond_perc), nudge_x = -2, nudge_y = 0.1, size= 3) +\nlabs(\n  subtitle = \"Percentage of people who attained\\neducation beyond high scool, as of 2014.\",\n     caption = \"Gender data for Russia and Japan not available.\") +\ntheme(\n  plot.caption = element_text(hjust = 0, size = 7.5, color = \"grey30\", \n                              margin = margin(20,0,0,0)),\n  plot.caption.position = \"plot\",\n  panel.grid.major = element_line(color = '#80808066', linetype = 'dotted'),\n  panel.grid.major.x = element_line(color = '#80808066', linetype = 'solid'),\n  plot.subtitle = element_text(colour = \"grey30\", size = 10, \n                               margin = margin(-30,0,0,0)),\n  plot.title = element_text(colour = \"grey30\"),\n  plot.title.position = \"plot\",\n) +\ncoord_cartesian(xlim = c(3.3, 71.2),ylim = c(1.3, 22), clip = 'off') +\nscale_x_continuous(breaks = c(0, 25, 50), \n                   position = \"top\", \n                   labels = c(\"0\", expression(paste(\"25\",\"%\", \"\")),\"50\"))+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n  annotate(\"text\", x=72, y=25, label=\"WOMEN\",\n           fontface = \"bold\",size=3) +\n   annotate(\"text\", x=64, y=23.5, label=\"MEN\",\n            fontface = \"bold\",size=3) +\n  annotate(\"segment\", x=64, xend=64, y = 21.3, yend = 22.9, \n           color=\"grey30\", alpha = 0.5) +\n  annotate(\"segment\", x=72, xend=72, y = 21.3, yend = 24.4, \n           color=\"grey30\", alpha = 0.5)\n\n\nMerge both graphs into one\nIn the final part, I had to merge both graphs into one.This part was the most tricky for me because the dimensions of the plot were different and a lot of editing of the margins, plot_layout had to be done so they merged correctly. I also added a common title as a plot_annotation and a line in the middle just as the original graph.\n\n\np + p2 + plot_layout(ncol=2,widths=c(6,5)) + \n  annotate(\"segment\", x = -25, xend = -25, y = -15, \n           yend = 30, color = \"grey30\", alpha = 0.3) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nAlternative Representations\nI thought of creating different visual representations to display data. I first tried a tree map, but the values were difficult to read. I then considered using a multi-level circular packing, but this made it difficult to see the relative magnitudes of the values, and there were too many categories because each country was treated as a separate category. As a result, I chose to use the facet_wrap option and split the plot into categories based on the type of mobility for the first plot and sex for the second, with the same y-axis for all categories. I created two separate plots and combined them.\nGraph 1:\nTo create the first graph of the alternative representation, I followed these steps:\nI created a labeller argument to change the titles of each facet.\nI used geom(col) to add the data and arrange it in descending order of Upward_mobility value.\nI used facet_wrap to separate the data by type of mobility.\nIn the theme function, I removed some elements and adjusted others to achieve the desired aesthetics.\nI finally added numbers to the graph by using geom_text and adjusting their size.\n\n\neduc_names <- list(\n  'Downward_Mobility'=\"Downward mobile\",\n  'Upward_mobility'=\"Upward mobile \",\n  'Status_quo_Mobility'=\" Status quo mobile\"\n)\n\n\neduc_labeller <- function(variable,value){\n  return(educ_names[value])\n}\n\na1 = educ %>%\n  group_by(Country, Mobility_perc) %>%\n  ggplot() +\n  aes(Mobility_perc, reorder(Country, Mobility_perc)) +\n  geom_col(data = df_order, position = \"stack\") +\n  scale_fill_manual(values = c(\"#ffc96f\", \"#b8bdd0\", \"#5e4c5f\")) + \n  geom_col(data = educ[educ$Mobility_type != \"Upward_mobility\", ], \n           position = \"stack\") +\n  geom_col(aes(fill = Mobility_type)) +\n    facet_wrap(~Mobility_type, labeller = educ_labeller )+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\",expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = df_order, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), \n        Mobility_perc))), size=3,position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(data = df_order2, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", \n         paste0(Mobility_perc, \"  \"), Mobility_perc))), size=3,\n            position = position_stack(vjust = 0.44)) +\n  geom_text(data = df_order3, aes(x=7, \n                                  label = ifelse(Country == \"South Korea\", \n                                    paste0(Mobility_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Mobility_perc, \"  \"), Mobility_perc))), \n  size=3, position = position_stack(vjust = 0.485)) +\n  labs(\n    subtitle = \"Percentage of people who got more, the same or less education than their parents, as of 2012.\") +\n  theme(\n        plot.subtitle = element_text(colour = \"grey30\", size = 11, \n                                     margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5), plot.title.position = \"plot\")\n\na1\n\n\n\nGraph 2\nThe Second graph of the alternative representation followed similar steps as the alternative graph 1 with the only difference being that now there are two categories that the facet wrap is done by: Female and Male.\n\n\neduc_names2 <- list(\n  \"Beyond_highscool_2014_M\"=\"Beyond higschool males\",\n  'Beyond_highscool_2014_F'=\"Beyond higschool females\"\n)\n\n\neduc_labeller2 <- function(variable,value){\n  return(educ_names2[value])\n}\n\na2 = beyond %>%\n  group_by(Country, Beyond_perc) %>%\n  ggplot() +\n  aes(Beyond_perc, reorder(Country, Beyond_perc)) +\n  geom_col(data = bey_ordered, position = \"stack\") +\n  scale_fill_manual(values = c(\"#5e4c5f\", \"#b8bdd0\")) + \n  geom_col(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\", ], \n    position = \"stack\") +\n  geom_col(aes(fill = Beyond_Sex)) +\n    facet_wrap(~Beyond_Sex, labeller = educ_labeller2)+\n  labs(y = NULL) +\n  theme(legend.position = \"none\",\n        axis.ticks.y = element_blank(),\n        axis.text.y = element_text(hjust = 0),\n        axis.title.x = element_blank())+\n  scale_y_discrete(labels = function(x) ifelse(\n    x == \"United States\", expression(bold(\"United States\")),x)\n                                              )+\n geom_text(data = bey_ordered, \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n        Beyond_perc))), size=3,\n            position = position_stack(vjust = 0.5), \n            color = \"#ffffff\", fontface = \"bold\") +\n  geom_text(\n    data = beyond[beyond$Beyond_Sex != \"Beyond_highscool_2014_F\",], \n            aes(x=7, label = ifelse(Country == \"South Korea\", \n                                    paste0(Beyond_perc, \"%\"), \n  ifelse(Country != \"South Korea\", paste0(Beyond_perc, \"  \"), \n         Beyond_perc))), size=3,position = position_stack(vjust = 0.44)) +\n  labs(\n    subtitle = \"Percentage of people who attained education beyond high scool, as of 2014.\") +\n  theme(\n        plot.subtitle = element_text(\n          colour = \"grey30\", size = 11, \n          margin = margin(0,0,20,0)))+\n  scale_x_continuous(breaks = c(0, 20, 40, 60,80), \n                   labels = c(\"0%\", \"20%\" ,\"40%\",\"60%\",\"80%\"))+\ntheme(\n      strip.text.x = element_text(size = 10, \n                                  color = \"black\", face = \"bold\"),\n      strip.background = element_rect(\n        color=\"black\",  size=1, linetype=\"solid\"),\n      panel.border = element_rect(\n        color = \"black\", fill = NA, size = 1.5),\n      plot.title.position = \"plot\")\n\na2\n\n\n\nMerge them together\nIn this part the two alternative graphs are merged together specifying the correct width and height so they look nice and adding a general title for both.\n\n\na2 + a1 + plot_layout(ncol=1) +\n   plot_annotation(\n    title = \"Education attainment in selected countries for 25-34 year old.\",\n    theme = theme(plot.title.position = \"plot\", \n        plot.title = element_text(face = \"bold\")\n  ))\n\n\n\nConclusion\nReplicating these graphs involved some challenges, such as arranging the data in the desired order of the category and adding specific elements to only a few values like axis titles or geom texts. While the rest of the process was relatively straightforward, the most difficult part for me was merging the two graphs together. Determining the correct dimensions, aspect ratios, plot layout, coordinate limits, etc. was challenging. The final result may not have the exact desired dimensions, but it is similar to the original. I chose the facet_wrap option for the alternative representation because, in my opinion, it was a clear and tidy way to view the data, although it may not have been the most complex method I am satified with the end result.\n\n\n\n",
    "preview": "projects/2022/100376720/original.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 832,
    "preview_height": 871
  },
  {
    "path": "projects/2022/100483841/",
    "title": "Population Perspectives",
    "description": "A graph about population in 2017 and 2100 will be replicated and an\nalternative way of visualizing this graph will be presented.",
    "author": [
      {
        "name": "Victoria Costas Salamanca",
        "url": {}
      }
    ],
    "date": "2023-01-12",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGraph to replicate\nDataframe\nGraph outline\nPlotting the graph: annotations, text and labels\nAlternative graph: plotting the graph\n\nFirst of all, the libraries required for plotting the graph need to be loaded, or if necessary install the packages.\n\n\n#Libraries needed\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggalluvial)\nlibrary(showtext)\nlibrary(ggtext)\n\n\nGraph to replicate\nThis is the original graph.This graph was made by Vollset SE, Goren E, Yuan W. in Fertility, mortality, migration, and population scenarios for 195 countries and territories from 2017 to 2100: a forecasting analysis for the Global Burden of Disease Study. The Lancet 2020. Published online July 14.It shows the ranking by population of the countries in two years 2017 and 2100. Besides it gives some brief insights of the three main populous countries in 2100. It is remarkable that the ranking is from 1 to 10, but 4 other countries are added (the ones which are expected to have huge growth in 20100).\nDataframe\nAs the source of the graph doesn´t provide us with the dataframe we need to create it, since all the data are in the graph is easy to do it, as it follows:\n\n\n#Create my database:\ndf <- read.csv(\"database.csv\")\n\ngroup_colors <- c(China = \"#009ee5\", India = \"#0973cb\", U.S = \"#384aae\",\n                Indonesia = \"#603c9c\", Pakistan = \"#893e9b\", Brazil =\"#be388f\", \n                Nigeria = \"#e75c93\", Bangladesh = \"#e53e48\", Russia = \"#f96439\",\n                Japan = \"#f78c24\", VIRTUAL = \"#FFFFFF\", Ethiopia = \"#f5b314\",\n                Egypt = \"#98b245\", DRC =\"#40b87b\", Tanzania = \"#25a99b\")\n\n\nGraph outline\nWe prepare the outline of the graph, removing the axes, legend and everything that is not the lines. The lines are matched to the population, that is the reason why their width is variable. We match also the lines to the specific color of each country. We code that first line in order to use Constantia font. One of the most important facts of these lines is that the y limits are really big since they match the population, so we need to take this into account.\n\n\n#Needed to use \"Constantia\" Font\n#windowsFonts(\"Constantia\" = windowsFont(\"Constantia\"))\nfont_add(family = \"Constantia\", regular = \"constan.ttf\")\nshowtext_auto()\n\n#Schema of the graph, data and geoms\np <- ggplot(df) +\n  aes(x, y, alluvium=group, fill=group) +\n  geom_alluvium(decreasing=FALSE, alpha=1, width=30, show.legend = FALSE) +\n  scale_fill_manual(values = group_colors) +\n  theme(legend.position = \"none\")+\n  xlim(min(df$x) - 43, max(df$x) + 43) + \n  ylim(min(df$y) - 0.1e9, max(df$y) + 3.7e9) +\n  theme_void()\np\n\n\n\nPlotting the graph: annotations, text and labels\nThe legend in this plot is substituted by side annotations in the right and the left with the value of the population and the ranking, a part from the country. We manually set their position, using horizontal and vertical adjustments (notice that the y axis is really big and we need to use very large numbers). As only one part of the text is modified (with bold, color or size) we use html annotation to do this.\n\n\n#Plotting completely the graph\np +\n  geom_curve(x = 2003, y = 0.40e9, xend = 2114, yend = 0.5e9, linetype=\"dashed\",\n             color = \"black\", size = 0.5, angle = 20, curvature = 0) +\n  #adding labels and text\n  labs(title = \"Here's how IHME projects the most populous \\n countries will change by 2100.\",\n       subtitle = \"Top 10 Countries \\n by Population\") +\n  theme(text = element_text(family = \"Constantia\"),\n        plot.subtitle = element_text(hjust = 0.5, size = 35, face = \"bold\"),  # Center subtitle\n        plot.title = element_text(hjust = 0.5, size = 16)) +\n  annotate(\"text\", x=2025, y = max(df$y) + 3.65e9, label = \"2017\", size = 4) +\n  annotate(\"text\", x=2090, y = max(df$y) + 3.65e9, label = \"2100\", size = 4) +\n  annotate(\"richtext\", x=1988, y = 4.10e9, label = paste0(\n    \"<span style='color: #009ee5; '>#1<\/span> China \",\n    \"<span style='font-size: 20px '><b>1.4B<\/b><\/span>\"),\n    fill = NA, label.color = NA)+\n  annotate(\"richtext\", x=1988, y = 2.75e9, label = paste0(\n    \"<span style='color: #0973cb; '>#2<\/span> India \",\n    \"<span style='font-size: 20px '><b>1.38B<\/b><\/span>\"), \n    fill = NA, label.color = NA)+\n  annotate(\"richtext\", x=1992, y = 1.90e9, label = paste0(\n    \"<span style='color: #384aae;font-size: 10px '>#3<\/span> \",\n    \"<span style='font-size: 10px '> U.S.<b>325M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 1.65e9, label = paste0(\n    \"<span style='color: #603c9c;font-size: 10px '>#4<\/span> \",\n    \"<span style='font-size: 10px '> Indonesia <b>258M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 1.40e9, label = paste0(\n    \"<span style='color: #893e9b;font-size: 10px '>#5<\/span> \",\n    \"<span style='font-size: 10px '> Pakistan <b>214M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 1.20e9, label = paste0(\n    \"<span style='color: #be388f;font-size: 10px '>#6<\/span> \",\n    \"<span style='font-size: 10px '> Brazil <b>212M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 1e9, label = paste0(\n    \"<span style='color: #e75c93;font-size: 10px '>#7<\/span> \",\n    \"<span style='font-size: 10px '> Nigeria <b>206M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1988, y = 0.80e9, label = paste0(\n    \"<span style='color: #e53e48;font-size: 10px '>#8<\/span> \",\n    \"<span style='font-size: 10px '> Bangladesh <b>157M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1990, y = 0.65e9, label = paste0(\n    \"<span style='color: #f96439;font-size: 10px '>#9<\/span> \",\n    \"<span style='font-size: 10px '> Russia <b>146M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0.50e9, label = paste0(\n    \"<span style='color: #f78c24;font-size: 10px '>#10<\/span> \",\n    \"<span style='font-size: 10px '> Japan <b>128M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0.30e9, label = paste0(\n    \"<span style='color: #f5b314;font-size: 10px '>#13<\/span> \",\n    \"<span style='font-size: 10px '> Ethiopia <b>103M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 0.20e9, label = paste0(\n    \"<span style='color: #98b245;font-size: 10px '>#14<\/span> \",\n    \"<span style='font-size: 10px '> Egypt <b>96M<\/b> <\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1991, y = 0.10e9, label = paste0(\n    \"<span style='color: #40b87b;font-size: 10px '>#18<\/span> \",\n    \"<span style='font-size: 10px '> DRC <b>81M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=1989, y = 0, label = paste0(\n    \"<span style='color: #25a99b;font-size: 10px '>#24<\/span> \",\n    \"<span style='font-size: 10px '> Tanzania <b>54M<\/b><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2122, y = 45e8,\n           label = \"<span style='font-size: 14px'><b>1.09B<\/b><\/span>\",\n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2133, y = 42e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #009ee5;'>#1 <\/span><b>India<\/b> \",\n    \"emerges at the top<br>of the leaderboard, despite<br>\",\n    \"an overall decline in numbers.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2121, y = 36.5e8,\n           label = \"<span style='font-size: 14px'><b>791M<\/b><\/span>\", \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2133.5, y = 33e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #e75c93;'>#2 <\/span><b>Nigeria<\/b> \",\n    \"leads Sub-Saharan<br>Africa as the only region that<br>\",\n    \"will continue to see population<br>growth in 2100.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2121, y = 28e8,\n           label = \"<span style='font-size: 14px'><b>732M<\/b><\/span>\", \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2132, y = 25e8, label = paste0(\n    \"<span style='text-align: left; font-size: 10px'>\",\n    \"<span style='color: #384aae;'>#3 <\/span><b>China's<\/b> \",\n    \"total population<br>will contract by almost<br>half by 2100.<\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124.5, y = 20.7e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>336M<\/b><\/span> \",\n    \"U.S. <span style='color: #384aae;'>#4<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127, y = 18.2e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>248M<\/b><\/span> \",\n    \"Pakistan <span style='color: #893e9b;'>#5<\/span><\/span>\"), \n           fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124, y = 15.7e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>246M<\/b><\/span> \",\n    \"DRC <span style='color: #40b87b;'>#6<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127, y = 13.2e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>229M<\/b><\/span> \",\n    \"Indonesia <span style='color: #603c9c;'>#7<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2126.5, y = 11e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>223M<\/b><\/span> \",\n    \"Ethiopia <span style='color: #f5b314;'>#8<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2125, y = 8.8e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>199M<\/b><\/span> \",\n    \"Egypt <span style='color: #98b245;'>#9<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2127.5, y = 6.8e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>186M<\/b><\/span> \",\n    \"Tanzania <span style='color: #25a99b;'>#10<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2125.5, y = 3.6e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>165M<\/b><\/span> \",\n    \"Brazil <span style='color: #be388f;'>#13<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2126, y = 2.28e8, label = paste0(\n    \"<span style='font-size: 10px '><span><b>106M<\/b><\/span> \",\n    \"Russia <span style='color: #f96439;'>#19<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2128, y = 10e7, label = paste0(\n    \"<span style='font-size: 10px '><span><b>81M<\/b><\/span> \",\n    \"Bangladesh <span style='color: #e53e48;'>#25<\/span><\/span>\"), \n    fill = NA, label.color = NA) +\n  annotate(\"richtext\", x=2124.5, y = 5e4, label = paste0(\n    \"<span style='font-size: 10px '><span><b>60M<\/b><\/span> \",\n    \"Japan <span style='color: #f78c24;'>#38<\/span><\/span>\"), \n    fill = NA, label.color = NA)\n\n\n\nAlternative graph: plotting the graph\nThe alternative graph is a diverging lollipop chart showing the percentage change in the population of the countries shown between 2017 and 2100. It clearly shows the difference in population from one year to the next and, moreover, how the general trend is one of population decline.\nThis alternative visualisation is based on the fact that the main idea of the graph is not to show the ranking of countries in terms of population, but rather to visualise the evolution of the population between these years (2017 and 2100). About the data we are going to use (created in the dataframe section) we must say that these are values formed from those of the previous graph, with the amount of population of 2100 and 2017 the percentage variation is calculated and from there the graph begins.\n\n\n#Create the dataset\ndf <- read.csv(\"database_alternative.csv\")\n\n# Reorder the rows of the data frame based on the variation values and establish categories\ndf <- df[order(df$variation), ]\ndf$pos_neg <- ifelse(df$variation < 0, \"negative\", \"positive\")\n\n\n\n\n#Create the plot\n\nggplot(df, aes(x = country1, y = variation, color = group_colors)) + #basic plot\n  geom_hline(yintercept = 0, color = \"red\", linetype = \"solid\", size = 2) + #to remark the 0\n  geom_segment(aes(x = country1, xend = country1, y = 0, yend = variation, color = pos_neg), size = 1) + \n  geom_point(size = 8.25, shape = 21, aes(fill = pos_neg, color = pos_neg)) +\n  geom_text(aes(label = variation), color = \"black\", hjust = 0.5, vjust = 0.5,\n            size= 2, fontface = \"bold.italic\")+\n  coord_flip() + #to change axis position\n  theme(legend.position = \"none\",\n        plot.background = element_blank(),\n        panel.background = element_blank()) +\n  #Adding labels and text\n  labs(x= \"Country\") +\n  labs(y = \"Variation (%)\") +\n  labs(title = \"Percentage Change in Population between 2017 and 2100\", size = 20) +\n  labs(subtitle = \"Top 10 Countries by Population in 2017 and 2100 respectively.\", size = 10) +\n  annotate(\"text\", x = 9, y = 246,\n           label = \"Ranking 2017 vs. 2100\", fontface = \"bold.italic\") +\n  annotate(\"text\", x = 8, y = 246,\n           label = \"1. China 1.4B       1. India 1.09B\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 7.25, y = 246,\n           label = \"2. India 1.38B       2. Nigeria 791M\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 6.5, y = 250,\n           label = \"3. U.S. 325M        3. China 732M \",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 6.15, y = 250,\n           label = \"- - - - - - - - - - - - - - -\") +\n  annotate(\"text\", x = 5.7, y = 250,\n           label = \"8. Bangladesh 157M         8. Ethiopia 223M\",\n           size = 3, fontface = \"italic\") +\n  annotate(\"text\", x = 4.95, y = 248,\n           label = \"9. Russia 146M            9. Egypt 199M\",\n           size = 3, fontface =\"italic\") +\n  annotate(\"text\", x = 4.20, y = 250,\n           label = \"10. Japan 128M         10. Tanzania 186M\",\n           size = 3, fontface =\"italic\")\n\n\n\n\n\n\n",
    "preview": "projects/2022/100483841/100483841_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1536,
    "preview_height": 2150
  },
  {
    "path": "projects/2022/100385774/",
    "title": "Social Media Use in 2021",
    "description": "Social Media Use evolution in the USA for 11 major platforms: step-by-step replication of the graph, possible enhancements and alternative visualization.",
    "author": [
      {
        "name": "Álvaro Sanz",
        "url": {}
      }
    ],
    "date": "2023-01-11",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nAbout the graph\nPlot construction\nInitial settings, getting the data\nFont preparation and color setting\nCoordinates, axes and scales\nAdding the data\nTheme settings\nAdding side annotations and last values\n\nEnhancements and alternative visualizations\nPossible changes in the plot\nAlternative visualizations\n\n\nAbout the graph\nBrooke Auxier and Monica Anderson published an article in the Pew Research Center in which they analyzed Social Media Use in 2021 for the Northamerican context, through data collected by the same organization and depicted by them in several graphs. One of them, the objective of this project, visually presents the evolution of use of eleven Social Networks since 2012 (although only 5 of them have available data for the whole time series).\nOriginal graph. Source: Auxier and Anderson, 2021.With it, their objective was to show how despite all controversies and negative feelings towards them, a majority of Northamericans still use at least one, and how their usage has increased through the last years. The goal of this project is to replicate the plot as closely as possible and to offer feasible enhancements and alternative visualizations.\nPlot construction\nInitial settings, getting the data\nFirst of all, we should load into R the necessary libraries to develop our work. In our case, we need the following three:\n\n\nlibrary(tidyverse) #To use the pipe operator and filter data\nlibrary(ggplot2) #To produce the graph\nlibrary(showtext) #To include alternative fonts\n\n\nOnce we prepared our environment, it’s time for us to work with the data. In this case, the Pew Research Center uploaded a PDF file with the specific questions and answers used for the report, from which we created a CSV file. We anticipated our future needs and introduced the different variables in a long format, as we would later need it to develop the plot.\n\n\nread_delim(\"Data/database.csv\")\n\n# A tibble: 53 × 3\n    Year `Social media`   Use\n   <dbl> <chr>          <dbl>\n 1  2012 Twitter           13\n 2  2013 Twitter           14\n 3  2014 Twitter           19\n 4  2015 Twitter           20\n 5  2016 Twitter           21\n 6  2018 Twitter           24\n 7  2019 Twitter           22\n 8  2021 Twitter           23\n 9  2012 Instagram          9\n10  2013 Instagram         14\n# … with 43 more rows\n\nSo, we store our CSV file as a dataframe, also renaming the ‘Social media’ variable into just ‘Social’ for simplicity purposes. Additionally, we filter the first and last data values for each Social Network into another dataframe, as we later will need it to display the points in each side of the lines.\n\n\ndata <- read_delim(\"Data/database.csv\")\n\ndata <- data %>% rename(\n  \"Social\" = `Social media`\n)\n\nfiltered <- data %>% \n  group_by(Social) %>% \n  filter(Year==min(Year)|Year==max(Year))\n\n\nFont preparation and color setting\nIn this step, we start by adding into our document the fonts used by the authors. Note that we included the same font two times, the regular and the bold version; this is because we had some issues while trying to compute the bold aspect manually (with double asterisk at each side of the text).\n\n\nfont_add(family = \"Franklin Gothic\", regular = \"FRAMD.ttf\")\nfont_add(family = \"Franklin Gothic Demi\", regular = \"FRADM.ttf\")\nfont_add(family = \"Georgia\", regular = \"GEORGIAI.ttf\")\nshowtext_auto()\n\n\nThen, we create a vector assigning each possible Social Network to its displayed color in the graph, to then apply it to the lines setting.\n\n\ncolors <- c(\"Youtube\" = \"#bf4538\", \"Facebook\" = \"#23689a\", \n            \"Instagram\" = \"#6c9acf\", \"Pinterest\" = \"#747a46\",\n            \"Linkedin\" = \"#c2c88e\", \"Snapchat\" = \"#746a7c\", \n            \"Twitter\" = \"#d1aa42\", \"Whatsapp\" = \"#253a5c\",\n            \"TikTok\" = \"#e9a03f\", \"Reddit\" = \"#92885a\", \n            \"Nextdoor\" = \"#e28377\" )\n\n\nCoordinates, axes and scales\nOur panel base depends on two axis, years and usage rate (%).\n\n\np <- data %>% ggplot() +\n  aes(Year, Use)\n\np\n\n\n\nPrevious to mapping the data inside the plot, we need to set properly the labels, axes and scales.\n\n\np <- p +\n  scale_x_continuous(\n    name = NULL,\n    limits=c(2012, 2021.9),\n    n.breaks = 10,\n    labels = function(x) paste0(\"'\", substr(x, 3, 4)),\n    expand=c(0,0)\n  ) +\n  scale_y_continuous(\n    name = NULL,\n    limits=c(0, 100),\n    breaks = c(20, 40, 60, 80),\n    labels = c(\"20\" = \"20\", \"40\" = \"40\", \"60\" = \"60\", \"80\" = \"80\"),\n    expand = c(0,0)\n  ) \n\np\n\n\n\nNow, the first year is ‘12, just as the original plot, and we’ve set the y limits to 100%. We didn’t add the last vertical label, “100%”: this is because it’s placed slightly to the right, as the top grid is shorter than the rest, so we’ll later set it as an individual annotation. We can also check how the x axis doesn’t ’strictly’ end in ’21: this is because we’ve left some space to connect the last values to their labels through segments.\nOne characteristic aspect of this graphic is that it requires a lot of annotations in order to display its elements correctly. As our first one, we’ll set the grid lines (although we’ll not see them properly until applying the theme). The reason behind this is to avoid them extending 2021 when we leave space to connect the last points of data with the labels.\n\n\np <- p +\n  annotate(\"segment\", x=2012, xend = 2021, y=10, yend=10, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=20, yend=20, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=30, yend=30, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=40, yend=40, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=50, yend=50, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=60, yend=60, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=70, yend=70, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=80, yend=80, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=90, yend=90, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012.25, xend = 2021, y=100, yend=100, \n           color = \"grey\", linetype=\"dotted\") +\n  annotate(\"segment\", x=2012, xend = 2021, y=0, yend=0, \n           color = \"grey\", alpha = 0.4) \n\np\n\n\n\nAdding the data\nNow that we’ve prepared the plot’s ‘skeleton’, it’s time for us to add the data. It’s important to do it after adding the grid annotations: if not, they would overlap the geom_line().\n\n\np <- p +  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  scale_color_manual(values = colors) \n\np\n\n\n\nTheme settings\nWe’ll now prepare the theme for previous and further changes. As seen in the original image, the background and plot margins are all white, vertical grid lines are not displayed, there are some margins we need to adjust at the right (to leave space for the labels and values) and at the bottom (to leave space for the last caption, “PEW RESEARCH CENTER”) and there are no axis ticks but for the years. Another important aspect is that the default legend is not included: we will create it manually as a kind of secondary axis, with side annotations.\n\n\np <- p +\n  theme(\n    axis.ticks.x.bottom = element_line(color = \"lightgrey\"),\n    panel.grid.major.y = element_line(colour = \"transparent\"),\n    panel.grid.minor.y = element_line(colour = \"transparent\"),\n    panel.background = element_rect(fill = \"transparent\"),\n    legend.position = \"none\",\n    axis.text.x.bottom = element_text(color=\"grey64\", \n                                    family = \"Franklin Gothic\"),\n    axis.text.y.left = element_text(color=\"grey64\", \n                                    family = \"Franklin Gothic\", hjust=-0.5, size=10),\n    axis.line.x.bottom = element_line(color=\"transparent\"),\n    axis.ticks.length = unit(0, \"pt\"),\n    axis.ticks.length.x.bottom = unit(5, \"pt\"),\n    plot.caption = element_text(family = \"Franklin Gothic\", \n                                color = \"grey64\", hjust = 0),\n    plot.caption.position = \"plot\",\n    aspect.ratio = 1.1,\n    plot.subtitle = element_text(family = \"Georgia\", \n                                 color = \"grey64\", hjust = 0.02, size=11),\n    plot.title = element_text(family = \"Franklin Gothic Demi\", hjust = 0, size=14.4),\n    plot.title.position = \"plot\",\n    plot.margin = margin(t=0,\n                         r=17,\n                         b=18,\n                         l=0)\n  ) +\n  annotate(\"text\", label=\"100%\", x=2012, y=100, color = \"grey64\", \n           family=\"Franklin Gothic\", size=3.5, hjust=1) +\n  coord_fixed(xlim=c(2012,2021), clip = 'off') \n\np\n\n\n\nWe also delete the previous grids and set the correct text settings, along with the “100% annotation” (it will display correctly after adding the title and subtitle) and a fixed coordinate system ending in 2021 (with clip = ‘off’ to allow us to annotate outside the plot limits).\nOur next step is to set the title, subtitle, caption and bottom annotation (this last one acting as a tag, but avoiding some placement problems). Note that now the plot space is complete and the “100%” mark does not appear as cut in half.\n\n\np <- p +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of U.S. adults who say they ever use ...\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown. Pre-2018 telephone poll\",\n       \"data is not available for Youtube, Snapchat and Whatsapp; pre-2019 telephone poll data is\",\n       \"not available for Reddit. Pre-2021 telephone poll data is not available for TikTok. Trend\",\n       \"data is not available for Nextdoor.\",\n       \"Source: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\"Social media use in 2021\"',  sep=\"\\n\")) +\n  annotate(\"text\", label= \"PEW RESEARCH CENTER\", x=2012, y=0, vjust=16.5, \n           hjust=0.15, family = \"Franklin Gothic\", size=2.8)\n\npbase <- p\n\np\n\n\n\nAdding side annotations and last values\nAs we previously mentioned, the legend in this plot is substituted by side annotations with the last value for each series. We manually set their position, using horizontal and vertical adjustments.\n\n\np <- p +\n  annotate(\"text\", label=\"YouTube\", y=81, x=2021, hjust=-0.8, size=3.5, \n           family = \"Franklin Gothic\", color = \"#bf4538\") +\n  annotate(\"text\", label=\"Facebook\", y=69, x=2021, hjust=-0.73, size=3.5, \n           family = \"Franklin Gothic\", color = \"#23689a\") +\n  annotate(\"text\", label=\"Instagram\", y=46, x=2021, hjust=-0.68, size=3.5, \n           family = \"Franklin Gothic\", color = \"#6c9acf\") +\n  annotate(\"text\", label=\"Pinterest\", y=40, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#747a46\") +\n  annotate(\"text\", label=\"LinkedIn\", y=34.5, x=2021, hjust=-0.82, size=3.5, \n           family = \"Franklin Gothic\", color = \"#c2c88e\") +\n  annotate(\"text\", label=\"Snapchat\", y=29, x=2021, hjust=-0.72, size=3.5, \n           family = \"Franklin Gothic\", color = \"#746a7c\") +\n  annotate(\"text\", label=\"Twitter\", y=24.5, x=2021, hjust=-0.96, size=3.5, \n           family = \"Franklin Gothic\", color = \"#d1aa42\") +\n  annotate(\"text\", label=\"WhatsApp\", y=19, x=2021, hjust=-0.65, size=3.5, \n           family = \"Franklin Gothic\", color = \"#253a5c\") +\n  annotate(\"text\", label=\"TikTok\", y=15, x=2021, hjust=-1.03, size=3.5, \n           family = \"Franklin Gothic\", color = \"#e9a03f\") +\n  annotate(\"text\", label=\"Reddit\", y=11, x=2021, hjust=-1.05, size=3.5, \n           family = \"Franklin Gothic\", color = \"#92885a\") +\n  annotate(\"text\", label=\"Nextdoor\", y=6, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#e28377\") +\n  \n  annotate(\"text\", label=\"81\", y=81, x=2021, hjust=-6.6, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=69, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=46, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=40, x=2021, hjust=-6.5, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=34.5, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=29, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=24.5, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=19, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=15, x=2021, hjust=-6.7, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=11, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=6, x=2021, hjust=-7, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\")\n\np\n\n\n\nAnd finally, we set the lines that join each last point with its Social Network, using the expanded limits we set a few steps ago and also manually adjusting their position via hjust and vjust.\n\n\np <- p +\n    #YouTube\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=81, yend=81, color=\"grey\") +\n  #Facebook\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=69, yend=69, color=\"grey\") +\n  #Instagram\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=40, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=40, yend=46, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=46, yend=46, color=\"grey\") +\n  #Pinterest\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=31, yend=31, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=31, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=40, yend=40, color=\"grey\") +\n  #LinkedIn\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=28, yend=28, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=28, yend=34, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=34, yend=34, color=\"grey\") +\n  #Snapchat\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=25, yend=25, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=25, yend=29, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=29, yend=29, color=\"grey\") +\n  #Twitter\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=24, yend=24, color=\"grey\") +\n  #Whatsapp\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=23, yend=23, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=23, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=18, yend=18, color=\"grey\") +\n  #TikTok\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=21, yend=21, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=21, yend=15, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=15, yend=15, color=\"grey\") +\n  #Reddit\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=18, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=18, yend=10, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=10, yend=10, color=\"grey\") +\n  #Nextdoor\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=13, yend=13, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=13, yend=6, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=6, yend=6, color=\"grey\")\n\np\n\n\n\nEnhancements and alternative visualizations\nPossible changes in the plot\nWhen looking at the graph by Auxier and Anderson, the first thing that can come to our minds is that, although the evolution through the last 9 year appears to be clear, the discriminability could be better. There are categories with the same color as others, and the distribution seems to be only ‘reasonable’ for the top two Social Networks, YouTube and Facebook, as they are depicted with their corporative colors. This is specially problematic if we take a look at the mid-bottom part of the chart, which compiles a lot of values very close to each other, resulting into some potential confusion at identifying each line or point with their respective category.\nAnother way of improving each category’s identification with the lines could be expanding the plot margins a little bit to the bottom, to avoid the excessive proximity between points that also results into very close reference lines, but we didn’t attempt to do it because excessive height for temporal series plots may distort the evolution shown, making it too difficult to visually see.\n\n\np <- pbase +\n  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  \n  annotate(\"text\", label=\"YouTube\", y=81, x=2021, hjust=-0.8, size=3.5, \n           family = \"Franklin Gothic\", color = \"#bf4538\") +\n  annotate(\"text\", label=\"Facebook\", y=69, x=2021, hjust=-0.73, size=3.5, \n           family = \"Franklin Gothic\", color = \"#23689a\") +\n  annotate(\"text\", label=\"Instagram\", y=46, x=2021, hjust=-0.68, size=3.5, \n           family = \"Franklin Gothic\", color = \"#d50167\") +\n  annotate(\"text\", label=\"Pinterest\", y=40, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#911821\") +\n  annotate(\"text\", label=\"LinkedIn\", y=34.5, x=2021, hjust=-0.82, size=3.5, \n           family = \"Franklin Gothic\", color = \"#0a63bc\") +\n  annotate(\"text\", label=\"Snapchat\", y=29, x=2021, hjust=-0.72, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f7ce2c\") +\n  annotate(\"text\", label=\"Twitter\", y=24.5, x=2021, hjust=-0.96, size=3.5, \n           family = \"Franklin Gothic\", color = \"#189ef3\") +\n  annotate(\"text\", label=\"WhatsApp\", y=19, x=2021, hjust=-0.65, size=3.5, \n           family = \"Franklin Gothic\", color = \"#25ca45\") +\n  annotate(\"text\", label=\"TikTok\", y=15, x=2021, hjust=-1.03, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f70079\") +\n  annotate(\"text\", label=\"Reddit\", y=11, x=2021, hjust=-1.05, size=3.5, \n           family = \"Franklin Gothic\", color = \"#f74301\") +\n  annotate(\"text\", label=\"Nextdoor\", y=6, x=2021, hjust=-0.75, size=3.5, \n           family = \"Franklin Gothic\", color = \"#8ace00\") +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of U.S. adults who say they ever use ...\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown. Empty values represent\",\n       \"not available data for that Social Network in that specific year.\",\n       \"Source: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\"Social media use in 2021\"',  sep=\"\\n\")) +\n    #YouTube\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=81, yend=81, color=\"grey\") +\n  #Facebook\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=69, yend=69, color=\"grey\") +\n  #Instagram\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=40, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=40, yend=46, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=46, yend=46, color=\"grey\") +\n  #Pinterest\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=31, yend=31, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=31, yend=40, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=40, yend=40, color=\"grey\") +\n  #LinkedIn\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=28, yend=28, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=28, yend=34, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=34, yend=34, color=\"grey\") +\n  #Snapchat\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=25, yend=25, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=25, yend=29, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=29, yend=29, color=\"grey\") +\n  #Twitter\n  annotate(\"segment\", x=2021.15, xend= 2021.9, y=24, yend=24, color=\"grey\") +\n  #Whatsapp\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=23, yend=23, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=23, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=18, yend=18, color=\"grey\") +\n  #TikTok\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=21, yend=21, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=21, yend=15, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=15, yend=15, color=\"grey\") +\n  #Reddit\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=18, yend=18, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=18, yend=10, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=10, yend=10, color=\"grey\") +\n  #Nextdoor\n  annotate(\"segment\", x=2021.15, xend= 2021.45, y=13, yend=13, color=\"grey\") +\n  annotate(\"segment\", x=2021.45, xend= 2021.6, y=13, yend=6, color=\"grey\") +\n  annotate(\"segment\", x=2021.6, xend= 2021.9, y=6, yend=6, color=\"grey\") +\n  \n  annotate(\"text\", label=\"81\", y=81, x=2021, hjust=-6.6, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=69, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=46, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=40, x=2021, hjust=-6.5, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=34.5, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=29, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=24.5, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=19, x=2021, hjust=-6.95, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=15, x=2021, hjust=-6.75, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=11, x=2021, hjust=-6.8, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=6, x=2021, hjust=-7.05, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\")\n\np\n\n\n\nWe also abbreviated the plot’s note, only mentioning that not shown data is not available and reducing the total amount of text shown in the graph.\nOne of the article’s objectives was to show that although there is a certain degree of negative feelings towards social media, a high percentage of the Northamerican population still uses at least one. If we added some context underneath the evolution lines, that also showed evolution of other types of media (TV, Newspaper, Radio…), the viewer could easily contextualize the information, while making the graph richer. We understand this is a limitation of the used data, but they could use some alternative surveys also indicating in the caption that it comes from a different source.\nLet’s make some fictitious data in our CSV, adding TV usage, in order to see how it would look:\n\n\nread_delim(\"Data/database2.csv\") %>% \n  rename(\n  \"Social\" = `Social media`\n) %>% \n  filter(Social==\"TV\")\n\n# A tibble: 10 × 3\n    Year Social   Use\n   <dbl> <chr>  <dbl>\n 1  2012 TV        54\n 2  2013 TV        52\n 3  2014 TV        53\n 4  2015 TV        50\n 5  2016 TV        45\n 6  2017 TV        43\n 7  2018 TV        42\n 8  2019 TV        37\n 9  2020 TV        35\n10  2021 TV        33\n\nTV <- read_delim(\"Data/database2.csv\") %>% \n  rename(\n  \"Social\" = `Social media`\n) %>% \n  filter(Social==\"TV\")\n\n\n\n\np <- p +\n  geom_col(data = TV, aes(Year, Use), alpha=0.35, width = 0.8) +\n  geom_line(aes(group=Social, color=Social), linewidth= 1) +\n  geom_point(data = filtered, aes(color=Social),\n             size = 1.75, shape = 21, fill=\"white\", stroke = 1) +\n  annotate(\"text\", label=\"TV usage\", x=2016.3, y=56,  color=\"grey\", \n           size = 3.5, family = \"Franklin Gothic\") +\n  annotate(\"segment\", x=2015, xend=2015.8, y=50, yend=55, color=\"grey\")\n\np\n\n\n\nAlternative visualizations\nApart from these potential enhancements on the same graph, we could also imagine of new ways of representing the data, maybe more aligned with the objective of the article and the title itself. The way we see it, the importance remains in the current distribution of usage between different Social Media, which tells the reader that there is a high percentage of Northamerican consumers who use them despite bad social perceptions.\nThe evolution since 2012 (temporal mark when the graphic has no data for more than half of the categories) is also important, but can be transformed to make it more adequate, maybe taking 2018 as starting point.\n\n\nnew <- data %>%\nfilter(\n  Year>2017 & Year<2022\n) %>% \n  group_by(Social) %>% \n  filter(Year == max(Year) | Year == min(Year))\n\n\nWe set our last values, create a new column with the evolution since 2018 for each Social Media and leave only the 2021 value, also creating a zero column that will be the starting point.\n\n\nnew <- new %>% group_by(Social) %>% \n  mutate(\n    evo = last(Use) - first(Use),\n    zero = 0\n  ) %>% \n  filter(Year == max(Year))\n\n\nThe idea is to give more importance to the current ranking position (y position) and the latest evolution (x position), using a lollipop graph displaying the last trend.\nWe could also add the logos from each Social Network next to every name, to improve the understanding of the graph for those readers who are not very familiar with Internet.\n\n\nnew %>% ggplot() +\n  aes(zero, reorder(Social, Use)) +\n  geom_segment(aes(xend=evo, yend = Social), color = colors) +\n  scale_x_continuous(limits = c(-10,10), n.breaks = 10) +\n  geom_point(aes(evo), size = 2, shape = 21, fill=colors, stroke = 1, color = colors) +\n  scale_color_manual(values = colors) +\n  theme_light() +\n  theme(\n    panel.grid.major.y = element_line(colour = \"lightgrey\", linetype = \"dotted\"),\n    panel.grid.minor.y = element_blank(),\n    panel.grid.major.x = element_line(colour = \"lightgrey\", linetype = \"dotted\"),\n    panel.grid.minor.x = element_line(colour = \"grey\", linetype = \"dotted\"),\n    axis.title.x.bottom = element_text(),\n    plot.subtitle = element_text(family = \"Georgia\", \n                                 color = \"grey64\", hjust = 0.02),\n    plot.title = element_text(family = \"Franklin Gothic Demi\", hjust = 0, size= 17),\n    plot.caption = element_text(family = \"Franklin Gothic\", \n                                color = \"grey64\", hjust = 0),\n    panel.border = element_blank(),\n    axis.text.y.left = element_text(color = \"gray30\", family = \"Franklin Gothic\", size = 10),\n    axis.title.y.left = element_blank(),\n    plot.margin = margin(t=0,\n                         r=0,\n                         b=20,\n                         l=0)\n  ) +\n  labs(title = paste(\" Growing share of Americans say that they use YouTube;\\n\", \n\"Facebook remains one of the most widely used online\\n\",\n\"platforms among U.S. adults\"),\n       subtitle = \"% of growth of Social Media Usage for ... ('18-'21)\",\n       caption = paste(\"Note: Respondents who did not give an answer are not shown.\",\n       \"Temporal series start in 2018\\nfor all Social Media except for\",\n       \"TikTok and Nextdoor (2021)\",\n       \"\\nSource: Survey of U.S. adults conducted Jan. 25-Feb. 8, 2021.\", \n       '\\n\"Social media use in 2021\"'),\n        x = \"% evolution\") +\n  annotate(\"text\", label = \"PEW RESEARCH CENTER\", family = \"Franklin Gothic\", \n           x=-10, y = 0, vjust = 12.5, hjust=0.16, size = 3.5) +\n  coord_fixed(clip = \"off\") +\n  annotate(\"text\", label=\"81\", y=\"Youtube\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\", color=\"gray30\") +\n  annotate(\"text\", label=\"69\", y=\"Facebook\", x=10, hjust=-2.2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"40\", y=\"Instagram\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"31\", y=\"Pinterest\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"28\", y=\"LinkedIn\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"25\", y=\"Snapchat\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=\"Whatsapp\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"23\", y=\"Twitter\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"21\", y=\"TikTok\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"18\", y=\"Reddit\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"13\", y=\"Nextdoor\", x=10, hjust=-2, size=3.5, \n           family = \"Franklin Gothic\",color=\"gray30\") +\n  annotate(\"text\", label=\"% in 2021:\", y=\"Youtube\", x=10, hjust=-0.15, vjust=-2, size=4, \n           family = \"Franklin Gothic\", color=\"gray30\")\n\n\n\nSo, with less complexity we’ve displayed the most important information that the article makes reference to, also reducing the used years to the last 4, that are also the most relevant ones, as the title says. We’ve also avoided the excessive dependence on the original graph on annotations and lines, so you can easier identify all values and labels with the segments.\n\n\n\n",
    "preview": "projects/2022/100385774/100385774_files/figure-html5/unnamed-chunk-13-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1152,
    "preview_height": 1152
  },
  {
    "path": "projects/2022/100484017/",
    "title": "Effect of the introduction of the polio vaccine in the US",
    "description": "This project has two purposes: to reproduce the plot published in 2015 in the Wall Street Journal article 'Battling Infectious Diseases in the 20th Century: The Impact of Vaccines', and to propose an improved visualization.",
    "author": [
      {
        "name": "Juan Diego Mendez",
        "url": {}
      }
    ],
    "date": "2023-01-11",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nPolio Vaccine in the US\nOriginal Plot - WSJ\nReproducing de Original Plot\nData Source –> tycho.pitt.edu\nCleaning Data\nColors\nOriginal Plot\n\nImproved plot\n\nPolio Vaccine in the US\nThe polio vaccine is an important tool in the fight against polio, a highly infectious disease that can cause paralysis and death. Polio is caused by a virus that spreads through contaminated food and water and can attack the nervous system, leading to paralysis in some cases.\nThe first polio vaccine was developed in the 1950s by Dr. Jonas Salk. The first mass vaccination campaign against polio was launched in April of 1995 in the US. The oral polio vaccine was introduced in the US in 1961 and became the primary vaccine used for routine polio vaccination in the US in the 1970s.\nSince the introduction of the polio vaccine in the US, the incidence of polio has decreased dramatically. The last case of wild poliovirus was reported in 1979, and the disease has been considered eradicated in the US since 2000. The success of the polio vaccine in the United States and around the world has been one of the greatest public health achievements of the 20th century.\nOriginal Plot - WSJ\nThe original plot was created by Tynan DeBold and Dov Friedman and published in February 2015 in an article in the Wall Street Journal, and is part of a series of graphics showing the effect of vaccines on different diseases such as measles, heaptitis A, mumps, pertussis, rubella, among others.\nOriginal Plot. Source: WSJ.The visualization was so good that it had a great impact on social networks…\nBill Gates’ reaction.Reproducing de Original Plot\n\n\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(forcats)\nlibrary(scales)\nlibrary(viridis)\nlibrary(grDevices)\nlibrary(plotly)\nlibrary(systemfonts)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(RColorBrewer)\nlibrary(showtext)\n\n\nData Source –> tycho.pitt.edu\nThe data in the original plot is from tycho.pitt.edu, a research project aimed at improving the standards, machine readability and availability of global health data, which is sponsored by the University of Pittsburgh in the US.\nHowever, when we consulted the historical records of polio cases registered in the USA, we found that there are several polio viruses: Acute nonparalytic poliomyelitis, Acute paralytic poliomyelitis, Acute poliomyelitis.\nThe original plot does not specify which of the three viruses it refers to, so it was decided to use the information of all the viruses that make up the polio disease.\nAcute nonparalytic poliomyelitis\n\n\nPolio  <- read_csv(\"tycho_20221212-145444.csv\",\n                    col_types = cols_only(Admin1Name = col_guess(),\n                                          PeriodStartDate = col_guess(), \n                                        CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nAcute paralytic poliomyelitis\n\n\nPolio1 <- read_csv(\"tycho_20221215-094815.csv\",\n                   col_types = cols_only(Admin1Name = col_guess(),\n                                         PeriodStartDate = col_guess(), \n                                         CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nAcute poliomyelitis\n\n\nPolio2 <- read_csv(\"tycho_20221215-095240.csv\",\n                   col_types = cols_only(Admin1Name = col_guess(),\n                                         PeriodStartDate = col_guess(), \n                                         CountValue = col_guess()))%>% \n  mutate(PeriodStartDate = ymd(PeriodStartDate)) %>% \n  arrange(Admin1Name, by=\"name\") %>%\n  count(Admin1Name,lubridate::floor_date(PeriodStartDate, \"year\")) %>% \n  rename(State =Admin1Name, \n         Date = `lubridate::floor_date(PeriodStartDate, \"year\")`,\n         Cases = n)\n\n\nCleaning Data\nWe now have the three clean data sets with the number of cases by State and by date.\nNext we will merge the three data sets into one and then add up all the cases so that we have a consolidated file.\n\n\nAbb <- read_delim(\"US State Abbreviations.csv\", \n    delim = \";\", escape_double = FALSE, trim_ws = TRUE)\n\nPoliojoint <- full_join(Polio2, Polio1, by = c(\"State\" = \"State\", \"Date\" =\"Date\"))\n\nPoliojoint1 <- full_join(Poliojoint, Polio, by = c(\"State\" = \"State\", \"Date\" =\"Date\"))\n\nPoliojoint2 <- left_join(Poliojoint1, Abb, by = c(\"State\" = \"States\"))\n\nPolio_sum <- Poliojoint2 %>%  mutate_at(c('Cases.x', 'Cases.y', \"Cases\"), as.numeric) %>% \n  mutate(sum_cases = rowSums(across(where(is.numeric)), na.rm=T), .keep = \"unused\") %>% \n  filter(Date >= '1928-01-01') %>% rename(States = Abb) %>% select(-State)\n\n\nColors\nTo copy the colors of the original plot, I used the website “html-color-codes.info” which allows to upload the image and obtain all the codes present in the image.\n\n\ncols <- c(colorRampPalette(c(\"#e7f0fa\", \"#c9e2f6\", \"#95cbee\", \"#0099dc\",\"#BAC843\", \n                            \"#4ab04a\", \"#ffd73e\", \"#eec73a\", \"#e29421\", \"#e29421\", \n                            \"#f05336\",\"#ce472e\"),bias=1)(11))\n\n\nOriginal Plot\nThe original graph is a heat map showing the number of polio cases reported in each U.S. state over time. For that reason, the x-axis will be the US states, and the y-axis will be the years and the plot will be filled by the number of cases.\n\n\np <- Polio_sum %>% ggplot() +\n  aes(x=Date, y=fct_rev(States),fill=sum_cases)\np\n\n\n\nAs this is a heatmap, to add rectangles we will use the geom_tile function. Additionally, the original plot has white spaces between the rectangles, so we are going to specify this inside the function.\n\n\np <- p + geom_tile(colour=\"white\", lwd = 0.2, linetype = 1)\np\n\n\n\nNext we are going to use the scale_fill_gradientn() function to set the fill color of the rectangles in a continuous gradient. The colors argument specifies the colors to use in the gradient, for which we will use the color palette defined above (“cols”). Then we define the minimum and maximum limits, which correspond to the minimum and maximum number of polio cases in a year. We include the breaks at which the gradient should change color, and specify the labels for these values.\nAdditionally, we use the guide argument to control the appearance of the color bar displayed next to the plot. For this purpose we define gradient marks, number of intervals to use for the gradient, and the color bar height and width arguments, respectively.\n\n\n p <- p+theme_minimal()+\n  scale_fill_gradientn(colours=cols,limits=c(0, 300),\n                       breaks=seq(0, 300, by=50),\n                       labels=c(\"0\", \"50\", \"100\", \"150\", \"200\", \"250\", \"300\"),\n                       guide=guide_colourbar(ticks=T, \n                                             nbin=50,\n                                             barheight=.6, \n                                             label=T, \n                                             barwidth=8, \n                                             ticks.colour= \"grey\", \n                                             ticks.linewidth = 0.5))\np\n\n\n\nWe use scale_x_date() function to set the scale of the x-axis to a date format. Then we need to specify the amount of space to add around the data. A value of c(0,0) means no space is added.\nThe breaks argument specifies the positions of the tick marks on the x-axis. In this case, the seq() function is used to generate a sequence of dates at 5-year intervals from 1930 to 1965.The date_labels argument specifies the format to use for the labels of the tick marks. In this case, the format “%Y” is used, which displays the year in four digits.\n\n\np <- p+ scale_x_date(expand=c(0,0), \n                     breaks = (seq(ymd(\"1930-01-01\"), ymd(\"1965-01-01\"), \n                                   by = \"5 years\")), \n                     date_labels = \"%Y\") \np\n\n\n\nTo include the line indicating the time at which the vaccine was introduced, we will use the function geom_segment(). In this case, the line segment will start at the date “1955-01-01” and end at the same date, so it will be a vertical line.\n\n\n p <- p + geom_segment(x=as.Date(\"1955-01-01\"), xend=as.Date(\"1955-01-01\"), \n                       y=0, \n                       yend=52.5, \n                       size=.9)\np\n\n\n\nNow we want to find the right font. For that we use the website “What the Font” which tells us the font used. However, the exact font has a high cost and is not available. Therefore, we searched Google fonts for the closest possible match, and found the Tajawal family font.\nTo use this font we make use of the “showtext” package, then we select the Google font we want using font_add_google(“Tajawal”), and then we call showtext_auto() to indicate that showtext is going to be automatically invoked to draw text whenever the plot is created.\n\n\nfont_add_google(\"Tajawal\")\nshowtext_auto()\n\n\nNow we use different functions to modify the appearance of the chart to make it resemble the original. The labs() function is used to remove the x-axis, y-axis and fill legend labels. The ggtitle() function is used to set the chart title. The theme() function is used to customize various aspects of the chart appearance, for example the aspect ratio, legend position, and axis labels and markings.\n\n\n p <-  p + labs(x=\"\", y=\"\", fill=\"\")+\n  ggtitle(\"Polio\") +\n  theme(    legend.position= \"bottom\",\n        legend.direction=\"horizontal\",\n        legend.text=element_text(colour=\"grey20\"),\n        axis.text.y=element_text(size=8, family=\"Tajawal\", \n                                 hjust=1),\n        axis.text.x=element_text(size=6),\n        axis.ticks.y=element_blank(),\n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5),\n        panel.grid=element_blank(),\n        title=element_text(hjust=-.07, face=\"bold\", vjust=1, \n                           family=\"Tajawal\"),\n        text=element_text(family=\"Tajawal\"))\np\n\n\n\nFinally, we add a label with the text “Vaccine introduced” to the plot at the specified x and y coordinates, using the specified font size and font family. The label will be aligned top left and the aspect ratio of the plot will be set.\n\n\n  p <- p+ annotate(\"text\", x=as.Date(\"1955-01-01\"), y=55, label=\"Vaccine introduced\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\")\np\n\n\n\nAs can be seen, the plots are not identical because the data set used is not the same.\nAn attempt was made to use the same data set to replicate the original plot as closely as possible, but the same dataset was not found. For this reason, it was decided to use the three datasets with the three viruses that make up the polio, resulting in a slightly different plot.\nIn this version, we can see that after the introduction of the vaccine in 1955 there was no drastic decrease in the number of cases, but on the contrary there was a slight increase in 1956. In addition, we can see that the number of cases actually dropped significantly after 1961, which coincides with the date when an improved version of the vaccine was introduced in the US.\nImproved plot\nIt is a great challenge to make an improvement of a plot so well done and with so many recognitions. In fact, I personally consider that the original plot is the best way to visualize the effect of a vaccine in reducing the number of positive cases of contagion.\nTherefore, I am not going to propose a new plot. Instead, I am going to improve the original plot by adding more useful information.\nFirst, as the most important thing is to see the effect of the vaccine, let’s reduce the number of years exposed. To do this we will start in the year 1940 and end in the year 1970. For this purpose we will reduce the dataset.\n\n\nPolio_sum1 <- Polio_sum %>% filter(Date >= \"1940-01-01\" & Date <= \"1966-01-01\")\n\np1 <- Polio_sum1 %>% ggplot() +\n  aes(x=(Date), y=fct_rev(States),fill=sum_cases) + \n  geom_tile(colour=\"white\", lwd = 0.2, linetype = 1)+\n  theme_minimal()+\n  scale_x_date(expand=c(0,0), \n               breaks = (seq(ymd(\"1930-01-01\"), ymd(\"1970-01-01\"), \n                             by = \"5 years\")), date_labels = \"%Y\")+\n  labs(x=\"\", y=\"\", fill=\"\")+\n  theme(aspect.ratio = 6.5/12.5,\n        legend.position= \"bottom\",\n        legend.direction=\"horizontal\",\n        legend.text=element_text(colour=\"grey50\"),\n        axis.text.y=element_text(size=6, family=\"Tajawal\"),\n        axis.text.x=element_text(size=6),\n        axis.ticks.y=element_blank(),\n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5),\n        panel.grid=element_blank(),\n        title=element_text(hjust=-.07, vjust=1, \n                           family=\"Tajawal\"),\n        text=element_text(family=\"Tajawal\"))\n\n\nI want to change the palette color to a color with more visual impact. That is why I want to choose a palette that makes it easier to see the years with the highest polio cases. That’s why I chose the YlGnBu palette from the RColorBrewer package, which gives a very interesting effect.\n\n\np1 <- p1 + scale_fill_gradientn(colours=brewer.pal(n=9, \"YlGnBu\"),limits=c(0, 300))\np1\n\n\n\nI want also to include a new line distinguishing between the two types of vaccines that were introduced in the U.S.: the injected vaccine invented and licensed in 1955 by Jonas Salk, and the improved oral vaccine invented by Albert Sabin that was introduced in 1961, targeting all types of polio.\nThis shows that it was only after the introduction of the second vaccine in 1961 that there was a real decrease in polio cases in the United States.\n\n\np1 <- p1 + geom_segment(x=as.Date(\"1955-01-01\"), xend=as.Date(\"1955-01-01\"), \n               y=0, yend=52.5, size=.9, color=\"grey50\", alpha=0.5)+\n  annotate(\"text\", x=as.Date(\"1952-01-01\"), y=56, label=\"First vaccine\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\", color=\"grey50\")+\n   geom_segment(x=as.Date(\"1961-01-01\"), xend=as.Date(\"1961-01-01\"), \n                y=0, yend=52.5, size=.9, color=\"grey50\", alpha=0.5)+\n  annotate(\"text\", x=as.Date(\"1960-01-01\"), y=56, label=\"Second vaccine\", \n           vjust=1, hjust=0, size=I(3), family=\"Tajawal\", color=\"grey50\")\np1\n\n\n\nNow, we will introduce a more explanatory title and subtitle about the plot.\n\n\np1 <- p1 + labs(title=\"Effect of the introduction of the two polio vaccines in the US\",\n       subtitle=paste(\"The heat map represents a visualization of the positive cases of Polio\",\n                      \"in the USA during the years 1928 and 1971 for the three existing virus\",\n                      \"\\ntypes (Nonparalytic poliomyelitis, Paralytic poliomyelitis, poliomyelitis),\",\n                      \"where the decrease of positive cases due to the introduction of the\",\n                      \"\\ntwo vaccines can be clearly seen.\"))+\n  theme(plot.subtitle=element_text(size=6), plot.title=element_text(size=10))\np1\n\n\n\nNow I want to include to the plot the number of cases presented in each of the states in order to easily visualize which of the states was the most affected by the polio virus.\nIn that sense, we are going to modify the dataset to obtain the cases presented in each state during the years 1928 and 1971.\n\n\nCasesxstate <- Polio_sum %>%  group_by(States) %>% summarise(total_cases = sum(sum_cases))\n\n\nNext, we are going to make a Barplot using the geom_col function, filling the bars with the colors representing the number of cases per state.\n\n\ncasebars <- ggplot(Casesxstate) + \n  aes(x=total_cases, y=fct_rev(States), fill=total_cases)+\n  geom_col(show.legend=FALSE)+\n  theme_minimal()+\n  scale_fill_gradientn(colors = brewer.pal(n=9, \"YlGnBu\"),\n                       limits=c(1000, 6000))+\n  scale_x_continuous()+\n  theme( aspect.ratio = 3/1, panel.grid=element_blank(),\n    axis.title.y=element_blank(),\n    axis.title.x=element_blank(),\n    axis.line.y=element_blank(), \n    axis.text.y=element_blank(),\n        axis.ticks.y=element_blank(), \n    axis.text.x=element_text(size=6, colour=\"grey50\"), \n    axis.ticks.x=element_line(color = \"grey50\", size = 0.5),\n    axis.line.x =element_line(color = \"grey50\", size = 0.5))\ncasebars\n\n\n\nNext, we will use the patchwork package to assemble different plots. In our case, we are going to use the “inset_element” function to assemble the original plot with the new plot so that they are in the same plot. Let’s see.\n\n\np1+ inset_element(casebars, \n                       left=0.95, \n                       bottom=-0.1, \n                       right=1.22, \n                       top=0.965,\n                       align_to=\"panel\", \n                  clip = TRUE)\n\n\n\nWith these improvements to the plot we can more easily see the change of colors in relation to the number of polio cases, we can see the effect of the introduction of the second vaccine in the US and finally we can see the states that suffered the most from Polio during the years recorded.\nIn conclusion, this plot uses everything that a heat map is good for as it provides an initial view of the data and allows us to explore the information in a wide visual range. Additionally, it allows you to easily analyze the data, which allows you to find patterns and trends.\n\n\n\n",
    "preview": "projects/2022/100484017/Polio Vaccine - WSJ.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1056,
    "preview_height": 733
  },
  {
    "path": "projects/2022/100383017/",
    "title": "Country Convergence",
    "description": "This project enables the user to recreate a specific graph in OurWorldinData on GDP per capita layer by layer. It also introduces two alternative representations resorting to the same data.",
    "author": [
      {
        "name": "Nacho Pulido Ruiz",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nOn the topic of Economics and Country Convergence\nGraph enhancement\nAlternative representation 1\nAlternative representation 2\n\nOn the topic of Economics and Country Convergence\nOur aim will be to resort to visual tools in R studio and ggplot to study the topic of country economic growth and convergence. Classical Solow-Swan models of growth predict convergence as a function of the deviation of a country from its stationary state (natural level) such that we should expect convergence between LEDC´S and MEDC´s. Our point of departure will be to launch the libraries we will use and to obtain the data from the Maddison Project Database.\nOriginal plot:\n\n\n\nlibrary(tidyverse)\nlibrary(scales)\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                delim = \";\"))\n\n\nA prior step to develop our plot will be to clean and sort the data to prepare it for our ggplot() operations. We will filter for rows containing data for 1950 and 2016 and reshape the data to have two columns accounting for GDP per capita for each country and for each year. This enables the analyst to depict a different axis for each of the years containing observations on GDP per capita.\n\n\ngdp <- gdp %>% \n  rename(gdp_capita = gdp_per_capita) %>% \n  select(country, year,gdp_capita, ) %>% \n  filter(year %in% c(1950,2016)) %>% \n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>% \n  drop_na(\"1950\", \"2016\") %>% \n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\")\n\n\nIt will be useful for us to categorize our countries in three groups (poor, medium and rich countries) by generating a factor column using the ifelse() command in the following way:\n\n\ngdp <- gdp %>% \n  mutate(type = ifelse(gdp_capita_2016<6000,\n                       \"poor\",\n                       ifelse(gdp_capita_2016<40000,\n                              \"medium\",\n                              \"rich\")))\n\n\nIt will be convenient for later (at the labelling stage) to generate a new column indicating the amount of growth an economy has undergone.\n\n\ngdp <- gdp %>% \nmutate(fold = round(gdp_capita_2016/gdp_capita_1950,1)) %>%\n  mutate(fold = paste(fold,\"-fold\"))\n\n\nSince we will have many observations for each of the countries (especially for those with middle income), we will filter for a subset of the data by selecting a random sample of middle income countries and then binding the resulting dataframe to the original one:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n  slice(sample(1:73,35,replace = FALSE))\ngdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nNow we have everything we need to start depicting our graph! We will call our gdp data and pipe it into the ggplot() function, defining the aesthetics desired. The advantage of having previously pivoted our data is that now we have 2 columns which account for the desired variables to be plotted:\n\n\nplot <- gdp %>% \n  ggplot()+\n  aes(gdp_capita_1950,gdp_capita_2016)\nplot\n\n\n\nNow we will add some geometry to our plot. We will choose shape 21 in order to be able to fill the points with a different color from the one we will use for the contouring of it.\n\n\nplot <- plot +\n  geom_point(shape = 21,color = \"red\", size = 1.5, fill = \"aquamarine3\")\nplot\n\n\n\nOur plot requires a lot of labels inside the graph, both for lines and for points. We will take advantage of geom_text() and add some label to the geometry including a subheading accounting for the amount of growth each economy has undergone. We will later work on our annotations to the diagonal lines.\n\n\nplot <- plot +\ngeom_text(aes(label = country), size = 1, nudge_y = -0.02)+\n    geom_text(aes(label = fold), size = 1, nudge_y = -0.05)\nplot\n\n\n\nIt is time to choose appropriately the scales of our plot. A logarithmic scale will we used for both axis and we will have to introduce the dollar symbol to account for the unit of measurement. The breaks have to be manually provided by the analyst to mimic as much as possible the original plot.\n\n\nplot <- plot +\n   scale_x_log10(label = label_number(prefix = \"$\"), \n                 breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                            7000,10000,15000,20000,30000,40000,50000,70000))+\n   \n  scale_y_log10(label = label_number(prefix = \"$\"),\n                breaks = c(400,500,700,1000,1500,2000,3000,4000,5000,\n                           7000,10000,15000,20000,30000,40000,70000))\nplot\n\n\n\nTo stick with the original plot as much as possible, we will introduce some text in our axis and title (including a subtitle) and use a bold font for the latter.\n\n\nplot <- plot +\n  labs(x=\"GDP per capita in 1950\",\n       y = \"GDP per capita in 2016\",\n       title = \"GDP per capita in 1950 and 2016\",\n       subtitle = paste0(\n         \"GDP per capita is expressed in international -$. \",\n         \"This means that it is adjusted for price changes over \",\n         \"time (inflation) and for price differences between countries.\"))\nplot\n\n\n\nThere are many informative lines in our plot used to depict the growth rate of a country in comparison to 1950.. We will use the geom_abline() to choose the slope and intercept of each one and change the color to stick to the original plot. The RGB technique will be used to determine the color of interest and the fourth argument of this function refers to the transparency (alpha), which we will set for the diagonal lines. The intercepts with the y-axis have to be transformed by the logarithm.\n\n\nplot <- plot +\ngeom_abline(slope = 1,intercept = 0, color = \"darkblue\")+\n    geom_abline(slope=1,\n                intercept=log10(c(0.5, 2, 3,\n                                  4.4, 10, 15, 30)), linetype=\"dotted\",\n                color = rgb(0,0,0.5,0.3))\nplot\n\n\n\nIn this section we will work on the theme (appearance of the plot). Notice that each of the axis has some specific color associated with it (in accordance with the horizontal and vertical grid lines). In this case, the background lines are faded and we will resort to the RGB mixture of colors providing an alpha for each color. These kind of lines will be chosen as linetype “dotted to achieve the desired dashed effect. The aspect.ratio will be set to 1 inside the theme to ensure that the proportions of the final plot obey the ones of the original graph.\n\n\nplot <- plot +\ntheme(axis.text.x = element_text(colour = \"darkorchid3\", size = 2.9),\n      axis.title.x = element_text(colour = \"darkorchid3\", size = 9,family = \"serif\"),\n      axis.text.y = element_text(colour = \"cyan3\", size = 4,family = \"serif\"),\n      axis.title.y = element_text(colour = \"cyan3\", size = 9, family = \"serif\"),\n      plot.subtitle = element_text(size = 5, colour = rgb(0,0,0,0.6),hjust = 0.4,\n                                   vjust = 5,family = \"serif\"),\n      panel.background = element_rect(fill = \"white\"),\n      panel.grid.major.x = element_line(color = rgb(0.6,0.196,0.8,0.4),\n                                        linetype = \"dotted\"),\n      panel.grid.major.y = element_line(color = rgb(0,1,1,0.4), linetype = \"dotted\"),\n      plot.title = element_text(size = 14,hjust = -0.2, vjust = 1, family = \"serif\"),\n      aspect.ratio = 1)\nplot\n\n\n\nCoordinates will be kept ass Cartesian but we will employ the use of some limits to mimic the ones from the original plot.\n\n\nplot <- plot +\ncoord_cartesian(xlim = c(400,70000), ylim = c(400,70000))\nplot\n\n\n\nWe will now work on the annotations accompanying the vertical lines which will indicate the amount of growth that each of the countries have experienced since 1950, thus, conveying the idea of convergence/divergence among them.\n\n\nplot <- plot +\nannotate(\"text\", label = \"Countries above this line had positive growth\",\n         color = \"darkgreen\", x = 22000, y = 25000, angle = 45, size = 2.3,\n         family = \"serif\") +\n    annotate(\"text\", label = \"Countries below this line had negative growth\",\n             color = \"red\", x = 26000, y = 23000, angle = 45, size = 2.3,\n             family = \"serif\")\nplot\n\n\n\nIn addition to these annotations, we will add the final text annotations pertaining to the rest of diagonal lines adding a smaller size and accounting them with a different color. The 45 degree angle will be held constant since all lines hold a slope equal to unity but with different intercepts.\n\n\nplot<- plot+\n  annotate(\"text\", label = \"2x poorer\", color = rgb(0,0,0.6,1), \n           x = 61000, y = 36000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"2x richer\", color = rgb(0,0,0.6,1),\n             x = 30000, y = 65000, angle = 45, size = 1.7,family = \"serif\") +\n    annotate(\"text\", label = \"3x richer\", color = rgb(0,0,0.6,1),\n             x = 19000, y = 65000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"Global average \\n growth (4.4x)\",\n             color = rgb(0,0,0.6,1),  x = 11000, y = 63000, angle = 45, \n             size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"10x richer\", color = rgb(0,0,0.6,1),\n             x = 5700, y = 67000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"15x richer\", color = rgb(0,0,0.6,1),\n             x = 4000, y = 68000, angle = 45, size = 1.9,family = \"serif\") +\n    annotate(\"text\", label = \"30x richer\", color = rgb(0,0,0.6,1),\n             x = 2000, y = 68000, angle = 45, size = 1.9,family = \"serif\")\nplot\n\n\n\nAs a final note, we will recall all the problems we encounter on this plot and use this to propose an enhancement:\nEven with a subset of countries, there is a lot of geometry text overlapping -> We will improve the labelling\nIt is difficult to account for convergence across countries since all countries are plotted independent of their nature -> We will distinguish between groups of countries\nIn order to enable the reader extract information on both the country and the level of growth rate, we will provide to distinctive plots such that one contains country labels whereas the other one will resort to quantitative (regression analysis) information\nConvergence is difficult to observe due to axis selection -> We will modify the vertical axis to depict growth rate and help the reader check for convergence with ease\nGraph enhancement\nWe will use the same graph to propose some enhancements or changes in the way the data is presented in an attempt to ease reader´s comprehension. We will reload the data to our Rstudio code:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\", \n                                  delim = \";\"))\n\n\nThe same technique employed before to clean and prepare our data will be recycled. Recall we are just proposing an improvement of the visualization, an alternative graph will be proposed in the last section of the project. Once again, we categorize our countries into rich, medium and poor:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nThe main difference with the first plot is that, this time, we will resort to the inclusion of a new column which will summarize the average annual growth rate that each economy has undergone since 1950.\n\n\ngdp <- gdp %>% \n mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100)%>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nAs we mentioned previously, the plot will be the same but we will just change the way the data is presented, so the random filter to select countries will be preserved:\n\n\nsubset <- gdp %>% \n    filter(type == \"medium\") %>% \n    slice(sample(1:73,35,replace = FALSE))\n  gdp <- gdp %>% \n    filter(type != \"medium\") %>% \n    rbind(subset)\n\n\nWe can begin with our enhanced graph! The aesthetics provided now will be set to the gdp per capita in 1950 and the annual growth rate we computed before. We will make use of our geom_label() again but we will omit supplying R with geom_point() this time. The color of the text will be set to white in order to generate a comfortable contrast with the “filling” by type of economy we had established in our aesthetics.\n\n\nlibrary(ggrepel)\nplot_1 <-gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)+\n    geom_label_repel(aes(label = country), size = 2,\n                     segment.color = 'transparent', max.overlaps = 40,\n                     force = 1, color = \"white\",\n                     show.legend = FALSE)\n    plot_1\n\n\n\nWe will add some labels to our axis and set the title to convey the idea that we are working with convergence. The word “conditional” here refers to the fact that we are going one step further and categorizing our data between types of economies and we will finally visualize the concept of “conditional convergence” presented in the classical Solow model of growth.\n\n\nplot_1 <- plot_1 +\nlabs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_1\n\n\n\nWe will provide a continuous y scale with the percentage suffix to make it obvious that we are working with growth rates here. We will also begin by applying a minimal theme to our plot which will be modified later with slight changes.\n\n\nplot_1 <-\nplot_1 + theme_minimal()+\n    scale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)\n    plot_1\n\n\n\nWe will work on the themes by providing some font in the type of “serif” and eliminating any background grid which may distract the reader. We will not devote much effort into changing the theme appearance because we are just modifying some changes of the original plot, not changing the graph completely. The aspect ratio will be set again to 1 to keep the original proportions.\n\n\nplot_1 <- plot_1 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid = element_blank(),\n      plot.title = element_blank(),\n      aspect.ratio = 1)\nplot_1\n\n\n\nFinally, let´s change the limits on the plot to make it more readable by modifying the arguments of the coordinate system:\n\n\nplot_1 <- plot_1+\n  coord_cartesian(xlim = c(0,10000), ylim = c(-2,7))\nplot_1\n\n\n\nNow we will generate the second plot required for our enhancement resorting to a similar analyis as the one depicted above but focusing on the quantitative side. We will append next to plot_1 the corresponding representation of each linear regression accounting for our three country groups. As usual, we will have to read again our data to make from scratch the desirable transformations:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nOne again, we will have to split our country in three categories and generate our “Growth” column accounting for the rate of increase of GDP per capita that each economy experiences. Factor levels will be reset to obtain the desired order:\n\n\ngdp <- gdp %>%\n    rename(gdp_capita = gdp_per_capita) %>%\n    select(country, year,gdp_capita, ) %>%\n    filter(year %in% c(1950,2016)) %>%\n    pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n    drop_na(\"1950\", \"2016\") %>%\n    rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n    mutate(type = ifelse(gdp_capita_2016<6000,\n                         \"Poor\",\n                         ifelse(gdp_capita_2016<30000,\n                                \"Medium\",\n                                \"Rich\"))) %>%\n    mutate(Growth = (((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950)))-1)*100) %>%\n    mutate(type = factor(type, levels = c(\"Poor\",\n                                          \"Medium\",\n                                          \"Rich\")))\n\n\nNow we can start depicting the second part of our enhancement graph! The first part will consist of piping our already filtered data into ggplot() and select the appropriate aesthetics in which we will feed our argument “fill” with our country type.\n\n\nplot_2 <-  gdp %>%\n    ggplot()+\n    aes(gdp_capita_1950,Growth, fill = type)\nplot_2\n\n\n\nNotice that, different to plot_1 in which we mapped a text geometry into the plot to be able to spot each of the countries, our task now is to account for types of countries regardless of their label. Therefore, we will change the geometry to geom_point() and let the point be filled with the type of country while contouring it with a white color:\n\n\nplot_2 <- plot_2 +\ngeom_point(shape = 21, color = \"white\", size = 3)\nplot_2\n\n\n\nWe will add some labels to the axis (the same that we had for our previous plot):\n\n\nplot_2 <- plot_2 +\n labs(x=\"GDP per capita in 1950\",\n         y = \"Average GDP Growth Rate\")\nplot_2\n\n\n\nLet´s change the label of the vertical axis by adding a percentage symbol to indicate that it is a measure of percentage growth rate. This has been computed as the average annual growth rate, which is the growth rate required for a country to portray year by year (constant) to achieve the final level of GDP per capita:\n\n\nplot_2 <- plot_2+\nscale_y_continuous(label = label_number(suffix = \"%\"), n.breaks = 6)+\n  theme_minimal()\nplot_2\n\n\n\nNext, we will change the appearance of our plot by modifying slightly the theme layout. Family “serif” will be chosen for the font in order to mimic the one used in the replication of the original plot and the background will be fill with grey. Panel grid lanes will be removed by setting the corresponding argument into element_blank().\n\n\nplot_2 <- plot_2 +\ntheme(axis.text.x = element_text( size = 7),\n      axis.title.x = element_text( size = 12,family = \"serif\"),\n      axis.text.y = element_text(size = 7,family = \"serif\"),\n      axis.title.y = element_text( size = 12, family = \"serif\"),\n      panel.background = element_rect(fill = \"grey\"),\n      panel.grid= element_blank(),\n      legend.position = \"bottom\",\n      legend.background = element_rect(size = 2),\n      aspect.ratio = 1)\nplot_2\n\n\n\nFinally, a linear regression line will be passed through each of the country groups to account for conditional convergence. The negative relationship which can be easily spotted once the line of best fit is included shows that, within groups of similar countries holding similar characteristics (depreciation rates, population growth rates etc.), there is convergence. However, the transition of a country from one group to another one is rarely seen.\n\n\nplot_2 <- plot_2 +\ngeom_smooth(method = \"lm\", size = 1, color = rgb(1,1,1,0.3))\nplot_2\n\n\n\nWe will change some limits of this plot to enable the reader focus on the inside and not get distracted with a hughe portion of unused plot:\n\n\nplot_2 <- plot_2 +\n coord_cartesian(xlim = c(0,15000), ylim = c(-2,7))\nplot_2\n\n\n\n\n\nlibrary(ggpubr)\nenhancement <- ggarrange(plot_1,plot_2,  common.legend = TRUE, legend=\"bottom\")\nannotate_figure(enhancement,\n                top = text_grob(\"Gdp per Capita Conditional Convergence\",\n            color = \"red\", size = 19))\n\n\n\nAlternative representation 1\nNow that we have resorted to an enhancement of the original plot in order to provide a measure of within group convergence, we will propose an alternative graphical analysis to show between group divergence. In other words, we will see, for each year, how the distribution of income holds for each of our country groups to highlight the difficulty of an economy of jumping from one group to another one.\nWe will have to read again the data to start from scratch our alternative plot:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                  delim = \";\"))\n\n\nWe will only keep data from 1950 onwards and we will filter for any NA´s present (missing observations). The difference with our previous plots is that we will now use all of our economies (no filter selection) and we will plot, for each year, how income per capita is distributed among our countries (the evolution of distribution of wealth).\n\n\ngdp <- gdp %>%\n    select(country,year,gdp_per_capita) %>%\n    filter(year>=1950) %>%\n    drop_na(gdp_per_capita)\n\n\nWe will pivot our data into wide format because we desire a column indicating the GDP per capita and the corresponding year in order to enable the analyst to generate the new column assigning the type of economy (factor).\n\n\ngdp <- gdp %>% \npivot_wider(names_from = \"year\",\n                values_from = gdp_per_capita,\n                names_prefix = \"Year\") %>%\n    mutate(type = ifelse(Year2016<6000,\n                         \"Poor\",\n                         ifelse(Year2016<30000,\n                                \"Medium\",\n                                \"Rich\")))\n\n\nNow we will reshape our data back to long format for the sake of our alternative representation. This is a different route we are taking with respect to the original plots, but it will be useful for operating with all years and not just 2 specific ones (as earlier). We separate the pivoted columns to eliminate the unnecesary ones and keep just a year and a gdp per capita column:\n\n\ngdp <- gdp %>% \npivot_longer(starts_with(\"Year\"),\n                 names_to = \"Year\",\n                 values_to = \"gdp_per_capita\") %>%\n    separate(Year, c(\"Yeard\", \"Year\"), remove = TRUE, sep =4) %>%\n    select(-Yeard) %>%\n    drop_na(everything())\n\n\nFinally, we will reorder the levels of our factor for a more appealing representation of our faceting and we will generate a new dataframe which contains all information that our original dataset contained with the exception of country type. We do this because we will use both dataframes in our plot to work with the faceting.\n\n\ngdp <- gdp %>%\n   mutate(type = factor(type, levels = c(\"Poor\",\n                                         \"Medium\",\n                                         \"Rich\")))\n gdp_2 <-\n  gdp %>%\n  select(-type)\n\n\nWe pipe our gdp dataset into ggplot() and define our desired aesthetics:\n\n\nplot <-\ngdp %>%\n  ggplot()+\n    aes(Year,gdp_per_capita)\nplot\n\n\n\nNow we will add two geometries which correspond, in this case, to lines that account for the distribution of income per capita each year and for each economy. First we do this with the original data frame and then we mimic the code with the filtered dataframe and we add some alpha in order to achieve this effect in which the important segment of the data is being highlighted.\n\n\nplot<-\nplot+\ngeom_line(data = gdp_2, color = rgb(0,1,0,0.3))+\n  geom_line(color= rgb(0,1,0,1))\nplot\n\n\n\nNow we facet by type of economy…\n\n\nplot <- plot+\nfacet_wrap(~factor(type))\nplot\n\n\n\nLet´s add some labels to our plot. We will improve the readings of the axis and set a title to account for the divergence between countries. This is the case because we see that, although we did see within group (conditional) convergence in our enhancement plot, now one observes that, if we treat countries as a whole by groups, there is some divergence taking place.\n\n\nplot <-\n  plot+\nlabs(y = \"GDP per capita\", x = \"Time\",\n       title = \"Between Group Divergence\")\nplot\n\n\n\nOnce again, we work the scaling of our graph and change the label of the vertical axis to dollars. Timing will only display some years to avoid overlapping and improve readability.\n\n\nplot <- plot +\nscale_x_discrete(breaks = c(1950,1960,1970,1980,1990,2000,2010))+\n  scale_y_continuous(labels = label_dollar())\nplot\n\n\n\nThe final theme will be set now. We begin with a general dark theme and then make some final adjustments. Years in the horizontal axis will be given some angle to enable us to fit more information and the title will be set in the center of our plot. This will be our first proposal for an alternative representation.\n\n\nplot <- plot +\ntheme_dark()+\n  theme(axis.text.x = element_text(size = 10, angle = 90),\n        strip.text.x =element_text(face = \"bold\"),\n        plot.title = element_text(hjust = 0.5, size =14))\nplot\n\n\n\nAlternative representation 2\nOur previous plot operated with the distribution of income per capita within groups to be able to compare across our three types of economies (e.g. variance and overal growth). Our second proposal for alternative visualization will focus on the between-group convergence and reinforce the idea of the set of hardships involved in the process of an economy evolving from a lower class to a higher one. We load again our data to start from scratch, as usual:\n\n\ngdp <- as.data.frame(read_delim(\"gdp per capita.csv\",\n                                delim = \";\"))\n\n\nNext, we will have to perform similar operations we resorted to in previous sections by filtering only those years corresponding to 1950 and 2016 and arranging each country into its corresponding group.\n\n\ngdp <- gdp %>%\n  rename(gdp_capita = gdp_per_capita) %>%\n  select(country, year,gdp_capita, ) %>%\n  filter(year %in% c(1950,2016)) %>%\n  pivot_wider(names_from = \"year\", values_from = gdp_capita) %>%\n  drop_na(\"1950\", \"2016\") %>%\n  rename(gdp_capita_1950 = \"1950\", gdp_capita_2016 = \"2016\") %>%\n  mutate(Class = ifelse(gdp_capita_2016<6000,\n                       \"Poor\",\n                       ifelse(gdp_capita_2016<30000,\n                              \"Medium\",\n                              \"Rich\")))\n\n\nThe difference with previous plots is that we will now use the overall average annual growth rate from 1950 to 2016 which is the average growth an economy has yearly undergone to achieve their gdp per capita level in 2016. We also attach a measure of the mean average growth for each of our classes to enable the reader to spot the first differences:\n\n\ngdp <- gdp %>%\n  mutate(AAGR = ((gdp_capita_2016/gdp_capita_1950)^(1/(2016-1950))-1)*100)\ngdp %>%\n  group_by(Class) %>%\n  summarise(av_AAGR = mean(AAGR))\n\n# A tibble: 3 × 2\n  Class  av_AAGR\n  <chr>    <dbl>\n1 Medium   2.79 \n2 Poor     0.917\n3 Rich     3.27 \n\ngdp <- gdp %>%\n  filter(Class != \"Rich\") %>%\n  mutate(AAGR_diff = 3.26 - AAGR)\n\n\nWe can now start building our plot layer by layer. We pipe in our already filtered data into ggplot() and set the aesthetics such that the horizontal axis accounts for each of the economies and the vertical one measures the growth rate difference between each country and the average one for rich countries. Therefore, high figures for the vertical axis correspond to countries that need to inject a considerable amount of per capita growth rate (annually) in order to catch up with rich economies and viceversa. The argument introduced in geom_bar() will be set to identity because the default for a bar plot is to count th enumber of observations in a column, and we want to plot the column corresponding to the growth rate difference. Notice that we have reordered from lowest to highest to achieve a visually more attractive graph.\n\n\nplot <- gdp %>%\n  ggplot()+\n  aes(reorder(country,AAGR_diff), AAGR_diff, fill = Class)+\n  geom_bar(stat = \"identity\")\nplot\n\n\n\nNow we will set a void theme for our plot because we want to eliminate any axis text and clean the general appearance (we will work in the themes at the end) and add some labels for the acknowledge the reader with a better understanding of the plot:\n\n\nplot <- plot +\ntheme_void()+\n  labs(title = \"The Spiral of convergence\",\n       subtitle = paste0(\n         \"Countries contained inside the white circle are already growing \",\n         \"at the rate of a rich economy\"),\n       caption = paste0(\n         \"Countries falling in the dark regions require an additional \\n\",\n         \"annual average growth rate to catch up with leading economies\"))\nplot\n\n\n\nNow its time to work on the appareance of our graph. The panel grid lines will be removed by setting an element_blank() argument and the aspect ratio will be set so that we can observe a wider spiral in the final graph. The colors chosen for the bar plots are green and purple which contrast among then whereas the background layers will be set in black as a final step:\n\n\nplot <- plot +\nscale_fill_discrete(type = c(\"purple\", \"green\"))+\n  theme(legend.background = element_rect(color = \"black\"),\n        plot.title = element_text(hjust = 0.5, vjust = 3, size =16),\n        panel.background = element_rect(fill = \"white\"),\n        panel.grid.major.x = element_blank(),\n        panel.grid.major.y = element_blank(),\n        aspect.ratio = 0.8,\n        plot.subtitle = element_text(size = 9,hjust = 0),\n        plot.caption = element_text(size = 9,hjust = 0),\n        legend.key = element_rect(color = \"white\", size = 2),\n        legend.key.width = unit(2,\"lines\"),\n        legend.title = element_text(hjust = 0.5))\nplot\n\n\n\nWe will have to add some annotations in our plot to point the amount of growth injection each economy needs. These lines and annotations will make more sense once the polar coordinates have been applied. We encourage the reader to come back to these steps after the plot is over to understand how each of our elements gets settled in the final spiral.\n\n\nplot <- plot +\ngeom_abline(slope = 0,\n            intercept = c(-2,-1,0,1,2,3,4),\n            color = rgb(0,0,0,0.3), linetype = \"dotted\")+\n  annotate(geom=\"text\", x=-10,\n           y=c(-2,-1,0,1,2,3,4), label=c(\"-2%\",\"-1%\",\"0%\",\"1%\",\"2%\",\"3%\",\"4%\"),\n           color=\"black\",size =3,angle = 28)\nplot\n\n\n\nFinally, we have to add some rectangular geometries for different segments of the plot which will be given some alpha (transparency) to account for best to worse layers. These layers mimic the level curves of a three dimensional bowl in which each layer projected in the floor corresponds to a circle. We will see this once we apply our polar coordinates.\n\n\nplot <- plot +\nannotate(\"rect\", ymin = -2, ymax = -1,\n         xmin = -10, xmax = 110, fill = \"black\", alpha = 0.1)+\n  annotate(\"rect\", ymin = -1, ymax = 0,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.2)+\n  annotate(\"rect\", ymin = 0, ymax = 1,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.3)+\n  annotate(\"rect\", ymin = 1, ymax = 2,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.4)+\n  annotate(\"rect\", ymin = 2, ymax = 3,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.5)+\n  annotate(\"rect\", ymin = 3, ymax = 4,\n           xmin = -10, xmax = 110, fill = \"black\", alpha = 0.6)\nplot\n\n\n\nWe can now apply our polar coordinates!\n\n\nplot <- plot +\ncoord_polar()\nplot\n\n\n\nThe first alternative representation deals with the evolution of the distribution of GDP per capita whereas the second one conveys this information in terms of differences in average growth rates with respect to rich economies. The results arising from the first section of the paper point at the existence of conditional convergence between similar economies and we highlight the difficulties an economy faces in jumping from one class to another in the outcome stemming from our alternative plots.\n\n\n\n",
    "preview": "projects/2022/100383017/images/original_plot.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 898,
    "preview_height": 897
  },
  {
    "path": "projects/2022/100481925/",
    "title": "Bump chart: How Americans spend their money",
    "description": "Code to replicate the graph in `ggplot2` and some improvements.",
    "author": [
      {
        "name": "Carolina Cornejo Castellano",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nIntroduction\nBackground\nWhat is it for? Representing how Americans distributed their spending in 2021\nWhat can be seen here? Encodings, channels and strengths\nReplication in R\n\nHow can it be improved? Enhancements\nDesigning the enhancements proposal\n\nAlternative visualization(s)\nDesigning the bar plot\nDesigning the lollipop plot\nDesigning the treemap\n\n\nIntroduction\nOn September 25, 2022, the Visual Capitalist, a digital media focused on generating data-centric visual content, published the article How Do Americans Spend Their Money, By Generation? The author of the visualization is Preethi Lodha, and the author of the article is Carmen Ang.\nThis report aims to discuss Preethi Lodha’s (Lodha 2022) graphic in the light of data visualization theory. Thus, some questions that will guide this narrative are: What information does it intend to show? Does it achieve it? How and through what encodings and channels? What are its strengths and points of improvement? Likewise, improvements and alternative visualizations are proposed, which are also not without their own room for improvement.\nBackground\nThe article collected data from the 2021 Consumer Expenditure Surveys (CES) from the U.S. Bureau of Labor Statistics. Specifically, the data used for the visualization was that published in PDF format in Table 2602. Generation of reference person: Annual expenditure means, shares, standard errors, and coefficients of variation.\nThe source of the article and the original graphic can be accessed here. This report was written in December 2022.\nWhat is it for? Representing how Americans distributed their spending in 2021\nFirst, the context and intentionality must be understood. The graphics must be understandable by themselves, and also in their context.\nAs for the article on the Visual Capitalist website, it has as newsworthiness —in Spanish journalist jargon we call it “la pepa”— to show the distribution of Americans’ spending in 2021. Although the title of the article does not specify that the information is from the previous year —it was written and published in 2022—, but the information is from 2021- this type of generalization or omissions are common in the titles and/or in the headlines of journalistic articles: they are licenses that journalists give themselves to attract the reader’s attention. The content of the article clearly specifies the source of information—the PDF—and that it refers to 2021. So it’s not a time series, it’s just a picture of that moment.\nScreenshot of the public Tableau dashboard How Americans spend their money, by Preethi Lodha. Published in: https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/As for the graphic, the author used Tableau to build a bump chart that includes interactive elements when hovering over the dots; but for the purposes of this report, those elements will not be taken into account: only what is seen in the screenshot above is considered.\n\nNote that we use the term bump chart because this type of visualization is commonly found with that name on the Internet. However, in the article of the Visual Capitalist they refer to it as a “graph” and in this report we try to call the other visualizations as “graphic,” as proposed by Wilkinson and Wills (2005).\nBump charts are useful for exploring changes in rank over time across different categories. That is, they usually do not show the actual values of the categories —which in this case would be the money spent by each generation for each spending category—, but the positions in the ranking. In this case, the ranking moves of 14 spending categories are shown, based on the birth year range from the Silent generation (the oldest) to Generation Z.\nAt first glance, this and, in general, all bump charts shows three variables in an easy-to-understand way: category, time and position. That’s especially true in cases of graphics where the only important thing is the ranking. For example, this image from The Washington Post from 2015 shows the “favorite” dog breeds, according to the American Kennel Club, where the three important variables are breed of dog, year, and position in the ranking (Bump 2021).\nArticle published by Philip Bump in The Washington Post: https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/However, there is another important piece of information in Preethi Lodha’s graph, which is the dollar amount spent by each generation for each expenditure category. This is presented within each point and is undoubtedly important if one wants to know how spending is distributed; however, that oscillation is not displayed with any other visual mark and can be misleading. This point will be discussed later.\nWhat can be seen here? Encodings, channels and strengths\nThere are 14 spending categories represented on the Y axis and 5 generations or age ranges showed on the X axis, above the graph and below the title and subtitle, from the Silent generation (the oldest) to the Generation Z.\nAccording to Cleveland (1985), graphs encode data in distinct elements, such as symbols, colors, position, etc. When we study a graphic we perform several mental-visual tasks to extract quantitative information. Some of the basic judgements we perform to decode quantitative information are 1) angle, 2) area, 3) color hue, 4) color saturation, 5) density, 6) length, 7) position along a common scale, 8) position along identical, nonaligned scales, 9) slope, and 10) volume (Cleveland 1985).\nIn consideration of this, the information in the bump chart can be extracted by judgements of position along the vertical scale, which represents the spending categories; the color of each line, which represents the categories of expenditure; the position of each point on the X axis, which represents the generation; and the thickness of the lines, which represents the money spent in each category (the thicker the line the more money has been spent). The closeness of the dots stands for the closeness in the ranking positions. The size of the points does not represent anything.\nCleveland also discusses detection, which he qualifies as the most fundamental perception issue, because before executing any graphical perception task, we must be able to detect the graphical element (Cleveland 1985). Lodha’s bump chart does not show overlaps in the dots, which together with color and position is the most important symbol. The jumps in the ranking are well understood. In broad terms, the graphic is very readable, which is not the same as effective.\nReplication in R\nAn almost exact replica was created using ggplot2,\nThe libraries used were as follows:\n\n\n# Import libraries\nlibrary(tidyverse) # for data manipulation\nlibrary(ggplot2) # for data graphics.\nlibrary(ggtext) # provides markdown and HTML text rendering\nlibrary(grid) # for adding the two white lines at the top and bottom\n\n\nThen, the data was imported. As mentioned above, the data is only a PDF, so the values had to be transcribed manually. After that, we made some transformations.\n\n\ndf <- read_csv(\"data.csv\")\nhead(df)\n\n# A tibble: 5 × 15\n  generation  housing healthcare  food trans…¹ cash_…² enter…³ insur…⁴\n  <chr>         <dbl>      <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 silent        16656       7053  5487    5263    4045    2027    1213\n2 boomers       21273       6594  7651    9327    2876    3476    6309\n3 gen_X         26385       5550 10388   13956    2747    4694   11656\n4 millennials   24052       4026  8463   11052    1163    3457    9249\n5 gen_Z         15449       1354  5529    7929     760    1693    3871\n# … with 7 more variables: miscellaneous <dbl>, apparel <dbl>,\n#   personal_care <dbl>, education <dbl>, alcohol <dbl>,\n#   reading <dbl>, smoking <dbl>, and abbreviated variable names\n#   ¹​transportation, ²​cash_contributions, ³​entertainment, ⁴​insurance\n\n\n\n# Pivot longer, add ranks and order chronologically\ndf <- df %>%\n  pivot_longer(-generation, names_to = \"variables\", values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Manually renaming\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \n  \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance and pensions\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n\n\n# Formatting the dollars' column\ndf$dollars <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars <- paste0(\"$\", df$dollars)\n\n\nCharacter vectors were created to 1) sort the generation names chronologically because ggplot2 displayed them in alphabetical order, 2) format them in HTML language that will later be rendered by the ggtext package, and 3) to add as tag the description of the X-axis.\n\n\nx_names_ordered <- c(\"Silent\", \n                     \"Boomers\", \n                     \"Generation X\", \n                     \"Millennials\", \n                     \"Generation Z\")\n\n\n\n\nx_names_full = c(\n  \n  paste(\"<span style='font-size: 9.55pt'>**Silent**<\/span>\",\n        \"1945 or earlier\",\n        \"**$44,683**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\"<span style='font-size: 9.55pt'>**Boomers**<\/span>\",\n        \"1946 to 1964\",\n        \"**$62,203**\",\n        sep = \"<br>\"),\n\n\n  paste(\"<span style='font-size: 9.55pt'>**Generation X**<\/span>\",\n        \"1965 to 1980\",\n        \"**$83,357**\",\n        sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Millennials**<\/span>\",\n    \"1981 to 1996\",\n    \"**$69,061**\",\n    sep = \"<br>\"),\n  \n  \n  paste(\n    \"<span style='font-size: 9.55pt'>**Generation Z**<\/span>\",\n    \"1997 or later\",\n    \"**$41,636**\",\n    sep = \"<br>\")\n\n                )\n\n\n\n\nx_lab <- paste(\n  \"<span style='font-size: 10pt'>**Generation**<\/span>\",\n  \"Birth Year Range\",\n  \"**Average Annual Expenditure**\",\n  sep = \"<br>\"\n              )\n\n\nThen the theme was built. We call this theme theme_bump. Before that, we saved as objects the codes of the two main colors: the one of the background and the one of the text.\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nThe textual elements were changed from element_text to element_markdown of the ggtext package. This allows to use markdown or HTML to design text strings.\n\n\ntheme_bump <- function() {\n\n  # Begin construction of the theme\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n}\n\n\nWe then proceeded to build the bump chart. Note that the following chunk must start with {r fig.width = 8.29, fig.height = 6.88} to display the replica in the same proportions as the original.\n\n\nreplica <- ggplot(\n  data = df,\n  aes(x = generation, \n      y = ranking, \n      group = variables)) +\n  # Add the custom theme just designed\n   theme_bump() +\n  # Add the horizontal lines per generation\n     geom_line(aes(color = variables, \n                   alpha = 1, \n                   # Change line thickness accordingly:\n                   linewidth = rev(ranking))) + \n  # Add the points. The white ones are for the border  \n   geom_point(size = 11.85, \n                color = \"white\") +\n     geom_point(aes(color = variables), \n                size = 11.3) +\n     scale_y_reverse(breaks = 1:nrow(df)) +\n  # Order and \n     scale_x_discrete(\n       limits = x_names_ordered,\n       labels = x_names_full,\n       position = \"top\",\n       expand = expansion(mult = c(0.356, 0.1))\n                    ) +\n  # Titles, subtitle, caption and tag \n  labs(\n    title = \"HOW AMERICANS SPEND THEIR MONEY\",\n    subtitle = \"By Age Group | 2021\",\n    caption = \"Author: Preethi Lodha\",\n    tag = x_lab\n  ) +\n  # Add the two horizontal white lines at the top and the bottom\n    coord_cartesian(clip = \"off\") +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(1.11, 1.11), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n      annotation_custom(linesGrob(x = c(0, 0.99), \n                                  y = c(-0.05, -0.05), \n                                  gp = gpar(col = \"#f0eae8\", \n                                            lwd = 2.8, \n                                            lineend = \"square\"))) +\n  # Add the Y axis text     \n  geom_text(data = df %>% \n                    filter(generation == \"Silent\"), \n                  aes(label = variables, \n                      x = 0.72236), \n                  hjust = \"outward\", \n                  fontface = \"bold\", \n                  color = \"#272727\", \n                  size = 2.4) +\n  # Add the amount money spent.\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.25, \n                fontface = \"bold\") +\n      geom_text(data = df, \n                aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.253, \n                fontface = \"bold\") +\n      geom_text(data = df, aes(label = dollars), \n                hjust = \"center\", \n                color = \"white\", \n                size = 2.257, \n                fontface = \"bold\") +\n  # Add line colors\n      scale_color_manual(values = c(\n        \"#9c6255\",\n        \"#a0d4ee\",\n        \"#9d8379\",\n        \"#8f93b5\",\n        \"#494c4d\",\n        \"#2f634a\",\n        \"#ed444a\",\n        \"#8a8887\",\n        \"#a13b5d\",\n        \"#87a7a0\",\n        \"#af9e2e\",\n        \"#6d1f29\",\n        \"#466f9d\",\n        \"#3896c4\"\n      )) \nreplica\n\n\n\nTo save the plot:\nggsave(\"replica.png\", \nplot = last_plot(), \npath = \"images\", \nwidth = 8.29, \nheight = 6.88, \nunits = \"in\", \ndpi = 120)\nAs can be seen below, only the small icons at the bottom left and the interactive box at the top right were not reproduced. Since these are interactive elements in the original dashboard, we did not consider it necessary.\nOriginal bump chart created by Preethi Lodha.My replica in ggplot2.How can it be improved? Enhancements\nFrom the start, one might question the need to design a graphic to display these data. Tufte (2013) points out that “[t]ables usually outperform graphics in reporting on small data sets of 20 numbers or less” and that “[t]he special power of graphs comes in the display of large data sets.” This case is not a large data set: in fact, the source is a PDF. This peculiarity has pros and cons: on the one hand, to represent expenditure by generation and expenditure category, it is unnecessary to perform many transformations; but on the other hand, it limits the options for alternative graphics.\nIn terms of features, notwithstanding its goodness, it is noted that this bump chart —and indeed, all of them— give readers the feeling that the difference between each category is about the same because the channels used —width of the lines and distance between them— are the same. Although in this case the thickness of the lines has been manipulated to represent each amount of money, its effect in counteracting that feeling is limited.\nUsing labels within the circles to show the money spent per category and per generation could have been a wise move, following the postulates of Tufte (2013), who points that “[c]lear, detailed and thorough labeling should be used to avoid graphic distortion and ambiguity […].” But, in this case, such labels add an extra layer of information and if the bump chart represents jumps in ranking, these were already encoded in the position of the dots and the jumps in the lines. Moreover, there are examples that even though spending in a certain category decreases from one generation to the next, its position in the ranking goes up and vice versa: just look at the jump from Millennials to Generation Z in the category Personal care products and services; and the jump from Boomers to Generation X in the Food category. Tufte himself would call it “a lying graphic” (Tufte 2013).\n\n“A second defense of the lying graphic is that, although the design itself lies, the actual numbers are printed on the graphic for those picky folks who want to know the correct size of the effects displayed. […]” (Tufte 2013)\n\nSo, if the purpose is to represent the spending distribution of Americans, showing rankings can be misleading. For this reason, the main point of improvement would be to represent spending rather than ranking. This implies to change the type of graph to one where the data items are the money spent and the data attributes are the generation and the category of spending. Tufte (2013), in this regard, postulates that “[t]he representation of numbers, as physically measured on the surface of the graph itself, should be directly proportional to the numerical quantities represented” (Tufte 2013). What visual marks would be the most efficient?\nIn order to continue using lines and dots to represent the data, the proposed enhancements are in a line plot:\nA line plot based on Preethi Lodha’s bump chart. This enhancements proposal also has much room for improvement in concept and implementation. Own elaboration.This is not exempt from problems, both in terms of conception and execution. First, the category with the highest expenditure by far is Housing, but the other categories are very close, which caused problems with overlapping labels. That was the driving force behind plotting only the first 6 expenditure categories. Even so, overlapping continued to exist and the ggrepel package, which would help to solve it, did not really avoid them; it only helped to eliminate the labels that were too close at the cost of dislocating others. Another problem is that, according to Healy (2018), lines illustrate “connection and common fate in that the lines joining the shapes tend to be read left-to-right as part of a series” (Healy 2018). He mentions this when explaining Gestalt rules, which are “the strong inferences we make about relationships between visual elements from relatively sparse visual information.” The author emphasizes that line graphs suggest that the underlying variable is continuous and that is not necessarily advantageous for our data, since the X axis contains the generations, but it is not a continuous variable over time.\nThe Gestalt inferences. Extracted from: Data vizualization: a practical introduction, by Kieran Healy. Published by the author in https://socviz.co/One option was to make a Sankey diagram. These visualize flows of quantities through a process and, as an opinion, are more eye-catching. With a Sankey diagram, we would have split the amount spent by each generation in 2021 into 14 categories of data —or fewer, if we also decide to show only the top categories or to group several ones into “Others”—, and each generation would be a breakdown. However, this would give the false sense that the flow of money changes over a period of time and, in stricto sensu, it is not: spending does not change over time: all the data represented is from 2021. What does change is another categorical variable: generation.\nAn example of a Sanky diagram from Wikimedia Commons:\nWikimedia Commons.In addition, in data visualization, clarity should be privileged over the pomposity: Healy (2018) quotes Tufte about graphical excellence, commenting that it “consists of complex ideas communicated with clarity, precision, and efficiency.” Thus, the idea of a Sankey, despite being relatively simple to execute with the ggsankey package, was discarded. A cleaner, clearer and closer option to Lodha’s original graph is the line plot.\nDesigning the enhancements proposal\n\n\n#Libraries, most of them already used in the replica\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel) # To (try to) avoid label overlappings\n\n\nThe following pipes were useful for obtaining a suitable dataframe:\n\n\ndf <- read_csv(\"data.csv\") %>% \n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  #group_by(generation) %>%\n  arrange(desc(dollars))\n\n\nThen, the data was manipulated. Those code chunks will not be showed here as are the same than in the replica (renaming variables using indexing and generating the same character vectors).\nThe theme was a bit edited. This new version is called theme_lines().\n\n\n# Colors\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\n\n\ntheme_lines <- function() {\n\n  theme_bw(base_size = 15) +\n\n    # Background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_blank()) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Legend\n    theme(legend.position = \"bottom\") +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_rect(\n      fill = color_background)) +\n    theme(legend.text  = element_markdown(\n      color = color_text, \n      size = 6.5, \n      face = \"bold\")) +\n    theme(legend.title = element_blank()) +\n    theme(legend.direction = \"horizontal\") +\n    theme(legend.spacing.x = unit(0.3, 'cm')) +\n      \n    # Caption\n    theme(plot.caption = element_text(\n      hjust = 0.6, \n      vjust= 0.1, \n      size = 5.45)) +\n\n    # Title and axis labels\n    theme(plot.title = element_text(\n      color = color_text, \n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_text(\n      color = color_text, \n      size = 11, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Arial Narrow\", \n      size=7.5)) +\n    theme(axis.text.y = element_markdown()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Arial Narrow\", \n      lineheight = 0.1, size = 8)) +\n    theme(plot.tag.position = \n            c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = \n            unit(c(0.5, 0.4, 0.5, 0.65), \"cm\")) # top, right, bottom, left\n\n}\n\n\nHere, we started the construction of the line plot. Note that each ggplot2 chunk must start with {r fig.width = 8.29, fig.height = 6.88} for it to be displayed with the same proportions of the original bump chart.\n\n\n# Used by the `ggrepel`. Ensures reproducibility of the same labels disposition\nset.seed(78)\n\n#Select only the head categories:\ndf <- \n  subset(df, variables %in% \n           c(head(unique(df$variables)))) \n\nenhan <- df %>% \nggplot() +\n  aes(x = generation, \n      y =dollars, \n      group = variables, \n      color= variables) + \n # Add lines\n   geom_line(\n    alpha = 0.6, \n    linewidth = 1.4) + \n  # Add points and their border:\n  geom_point(size = 4, \n           shape = 20, \n           alpha = 0.6) +\n  geom_point(size = 3, \n             shape = 1, \n             color=\"white\", \n             alpha = 0.7, \n             stroke = 0.7) +\n  # Order the axis x text\n  scale_x_discrete(\n     limits = x_names_ordered,\n     labels = x_names_full,\n     position = \"top\",\n     expand = expansion(mult = c(0.09, 0.1))\n                  ) +\n  scale_y_discrete(\n    expand = expansion(mult = c(0.001, 0.001))\n                  ) +\n  # Title, subtitle and caption. No tag this time.\nlabs(\n  title = \"HOW AMERICANS SPEND THEIR MONEY\",\n  subtitle = \"Top 6 categories by age group | 2021\",\n  caption = \"Author: Preethi Lodha\"\n) +\n\n# Format dollars spent labels\n   geom_text_repel(\n    aes(label = \n          paste0(\"$\", (format(df$dollars, \n                              big.mark=\",\", \n                              trim=TRUE))), \n      segment.square  = TRUE,\n      segment.inflect = TRUE\n    ),\n    # Max labels overlappings allowed:\n    max.overlaps  = 2, \n    size          = 2.5,\n    fontface      = \"bold\",\n    direction     = \"y\"\n    ) +\n  guides(colour = guide_legend(nrow = 1)) +\n  scale_color_manual(values = c(\n                                \"#ab3a6b\",\n                                \"#494c4d\",\n                                \"#3896c4\",\n                                \"#2f634a\", \n                                \"#af9e2e\",\n                                \"#ed444a\")) +\n  # Add the 2 horizontal white lines\n  coord_cartesian(clip = \"off\") +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(1.13, 1.13), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n      annotation_custom(\n        linesGrob(\n          x = c(0, 0.99), \n          y = c(-0.05, -0.05), \n          gp = gpar(col = \"#f0eae8\", \n                    lwd = 2.8, \n                    lineend = \"square\"))) +\n  # Add the custom theme \n  theme_lines()\n\nenhan\n\n\n\nThere are 9 unlabeled data points, according to the warning message of the ggrepel package. We save the plot with the following code:\n# Save the plot\nggsave(\"enhancements.png\", \n       plot = last_plot(), \n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,\n       units = \"in\", \n       dpi = 120) # Resolution\nAlternative visualization(s)\nAn attempt was made to design an alternative graphic—and an alternative to the alternative. These, although better, still have some flaws.\nThe design of an alternative graph with the same data involved a nonlinear flow. Cleveland explains that data graphing should be an iterative process: “Iteration and experimentation are important for all of data analysis, including graphical data display. Most times when we make a graph it is immediately [sic] clear that some aspect is inadequate and we regraph the data. In many other cases we make a graph, and all is well, but we get an idea for studying the data in a different way with a different graph; one successful graph often suggests another” (Cleveland 1985).\nThe purposes that the new graph should follow were to make the data stand out and eliminate superfluity (Cleveland 1985). Another important point is ease of understanding. Heer and Bostock (2010) replicated previous studies on graphical perception by evaluating charts that encoded data in different ways. Basically, the best way to represent data is with comparison on a common scale —such as grouped bar charts— and the worst is to show it in areas like treemaps do (these performed even worse than pie charts!) (Heer and Bostock 2010). Given this, the theory suggests simplicity, cleanliness and clarity rather than fancy design details and pomposity. In this case, we went for simplicity even in contradiction to Cleveland, who argues that “[t]he important criterion for a graph is not simply how fast we can see a result; rather, it is whether through the use of the graph we can see something that would have been harder to see otherwise […]” (1985). We believe that it is very important that the graphic shows its main idea at first glance, especially in these days when we have so many visual stimuli on the Internet and they all fight for our attention.\nThus, visual cleanliness is a must, but for those intended for publication in websites such as the Visual Capitalist that target a wide and not necessarily expert audience, it is also a challenge. In addition, there are also studies that suggest that visual embellishment has a positive effect on the comprehension and memorability of graphics (Bateman et al. 2010). How to balance aesthetic taste and graphical excellence and integrity? We had to achieve all this without creating a chartjunk, as Tufte would call it, and without losing the purpose of the data, of the original bump chart and its context, and with a data that is only a small table.\nFor these reasons, the safe bet was to develop a grouped bar chart that shows spending categories, generation and amounts in a clear, simple and uncluttered way, but with a custom theme.\nA grouped bar chart, colorblind-friendly. This is the proposed alternative visualization. Own elaboration.The underlying cause why it is flipped is mainly to avoid label overlappings, which were the major problem in all the visualizations we tried with this data. A colorblind-friendly color palette was made. Also, the grid was eliminated according to Tufte: “one of the most sedate graphical elements, the grid, should usually be muted or completely suppressed so that its presence is only implicit—lest it compete with the data […]. Dark grid lines are chartjunk” (Tufte 2013). We do not agree that much with him in that regard, but we must accept that, at least in this case, they are not necessary: that information is already provided by the labels, which Tufte endorses. The choice of font was a personal choice.\nThis graphic has, however, some flaws: we find that the number of bars make it look bloated even though we reduced their number by including several in the “Others” category.\nAlso, the presence of a legend is not bad per sé, but in this case there are still several categories and the audience would have to constantly go back and forth from the legend to the plot to decipher what represents which bar. However, positioning the name of each spending category instead of the name, birth year range and total spent would make it even more bloated.\nAs the display of multiple bars seemed a bit cluttered even if, in our opinion, the plot delivers the correct visualization, a similar visualization was made. We considered that a lollipop plot could be an even better option, and is a close relative of bar plots.\nA grouped lollipop, also colorblind-friendly. Own elaboration.Clarity was the guideline for this lollipop graphic, too. However, some drawbacks arose: the overlapping labels made us decide to remove any geom_text or geom_label from our code and, contravening Tufte, plot a grid as an alternative. Only minor grids are shown and we set a number of grids that we felt was not exaggerated. We also it dashed and used a very subtle color so that it does not overload the plot too much. Still, it exists.\nBoth plots, even if simple, show the expenses per generation more clearly than the bump chart and have visual encodings, according to Heer and Bostock (2010), capable of being better interpreted than stacked bar charts, bubble charts, pie charts and treemaps, the latter being even less effective than pie charts. This last case caught our attention, as treemaps are quite common in all types of publications and are, in our personal opinion, visually appealing. See here an example of a treemap published by Le Monde newspaper.\nSo, we made one, just for comparison (and learning how-to) purposes:\nA treemap just for clarity comparison. Authors argue that it is not a good option due that areas are hard to compare, even more than angles (like the case of pie charts). Own elaboration.As can be seen, the bar plot is simpler and easier to understand than the treemap, as it uses a single visual mark, the bar, to represent the data. That specific visual mark is always of the same width, so the viewer decodes only the height of the bar to interpret the quantity it encodes. For that reason, the proposed bar plot is more effective at conveying the patterns of the data and to compare the values of different categories.\nWhat cannot be denied about the treemap is that it is visually more attractive, at least to our personal taste. Unfortunately, with this one it is more complicated to interpret the differences in the money spent by each generation in a single category. For example, if there were no money spent labels added, it would be difficult to compare Generation X and Generation Z spending on Housing. Besides, it was way more difficult to design. We could have designed one treemap with 5 subgroups —and not 5 invidivual treemaps and then paste them— and the result would have been more or less similar, but without the spaces between each subgroup and with problems to add specific colors for each generation. The code is at the end of this report.\nDesigning the bar plot\n\n\n# Libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(ggrepel)\nlibrary(ggpubr)\n\n\nWe first computed the rankings just for the selecting the first categories.\n\n\ndf <- \n  read_csv(\"data.csv\") %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\n# Rename categories lower in the ranking as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\n\nThen, the data was manipulated, and variables renamed.\n\n\n# Format the dollar column\n\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nA character vector for ordering the generations:\n\n\ngen_order <- c(\n  \"Generation Z\",\n  \"Millennials\",\n  \"Generation X\",\n  \"Boomers\",\n  \"Silent\"\n      )\n\n\nWe used the same colors:\n\n\n# Theme colours\ncolor_background <- \"#e5d9cf\"\ncolor_text <- \"#333333\"\n\n\nLater, the custom theme was built. This was called theme_bar().\n\n\ntheme_bar <- function() {\n\n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_blank()) +\n\n    # Format the legend\n    theme(legend.position = \"top\") +\n    theme(\n       legend.text = element_markdown(\n        color = color_text,\n        family = \"Consolas\",\n        size = 7.5,\n        face = \"bold\",\n        hjust = 0)) + \n    theme(legend.title = element_blank()) +\n    theme(legend.background = element_blank()) +\n    theme(legend.key = element_blank()) +\n\n    # Format de caption\n      theme(plot.caption = element_markdown(\n        hjust = 1, \n        family = \"Consolas\",\n        size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5,\n      margin=margin(4,0.2,4,0.2))) +\n    theme(plot.title.position = \"plot\") +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(4,0.2,4,0.2))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.y = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size = 8.5\n    )) +\n    theme(axis.text.x = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    \n    # Plot margins\n      theme(plot.margin = \n              unit(c(0.2, 0.7, 0.2, 0.7), \"cm\")) # top, right, bottom, left\n}\n\n\nThis is the colorblind friendly palette:\n\n\n#Colorblind friendly palette\ncolorblind <- c(\n                \"#5d3686\",\n                \"#c3a939\",\n                \"#6c7ed7\",\n                \"#b95336\",\n                \"#74a344\",\n                \"#a19f9f\",\n                \"#ba496b\",\n                \"#43c9b0\",\n                \"#c26abb\",\n                \"#ae853d\"\n                )\n\n\nThen the bar plot was designed:\n\n\ntag_house <- \"$26,385\"\n\nbar <- ggplot(df, aes(\n                      fill = reorder(variables, \n                                     desc(dollars)), \n                      y    = dollars,\n                      x    = generation)) +\n    geom_bar(position  = \"dodge\", # for groups\n             stat      = \"identity\",\n             linewidth = 0.05,\n             color     = color_background) +\n  # Add dollars' labels\n geom_text(aes(label = dollars2),\n            position      = position_dodge(0.9),\n            color         = color_text,\n            family        = \"Consolas\",\n            #vjust         = 0.5,\n            hjust         = -0.3,\n            size          = 2.5\n            ) +\n  # Order of the x Axis text\n  scale_x_discrete(\n    limits = gen_order,\n    labels = c(\n       \"**Generation Z**<br>1997 or later<br>**$41,636**\",\n       \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n       \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n       \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n      \"**Silent**<br>1945 or earlier<br>**$44,683**\"\n                )\n    ) +\n  # To manipulate the width of the graphic:\n  scale_y_continuous(\n        expand = c(0.005,0), #0.0632\n                    ) +\n  scale_fill_manual(\n    values = colorblind #colorblind-friendly palette\n                    ) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n   # As one of the bars was too large, we added its label manually as a tag\n    tag = tag_house \n       ) +\n  theme_bar() +\n  theme(\n    legend.box.margin = margin(0.2,2,0.2,0.1, unit = \"cm\"),\n    legend.spacing.x = unit(0.4, 'cm'),\n    plot.title.position = \"plot\",\n    plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 7.5,\n      color = color_background),\n    plot.tag.position = c(0.965, 0.332)) + #horizontal, vertical\n  coord_flip() \n  \nbar\n\n\n\nCode for saving the plot:\nggsave(\"alternative_bar.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the lollipop plot\nThe same bar plot theme was used.\n\n\ngen_order <- c(\n        \"Silent\",\n       \"Boomers\",\n       \"Generation X\",\n       \"Millennials\",\n       \"Generation Z\")\n\n\n\n\nlol <-\nggplot(df)+\n    geom_linerange(aes(\n      x = generation,\n      ymin = 0, \n      ymax = dollars, \n      colour = reorder(variables, desc(dollars))), \n      position = position_dodge(0.8))+\n    geom_point(\n      aes(\n        x = generation,\n        y = dollars,\n        colour = reorder(variables, desc(dollars)),\n      ),\n      size = 4,\n      position = position_dodge(0.8)\n    ) +\n    scale_x_discrete(\n    limits = gen_order,\n    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\",\n               \"**Boomers**<br>1946 to 1964<br>$**62,203**\",\n               \"**Generation X**<br>1965 to 1980<br>**$83,357**\",\n               \"**Millennials**<br>1981 to 1996<br>**$69,061**\",\n               \"**Generation Z**<br>1997 or later<br>**$41,636**\")\n               ) +\n  scale_y_continuous(\n        expand = c(0.03,0),\n        n.breaks = 8\n        ) +\n  scale_color_manual(values = colorblind) +\n  labs(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n      \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\"\n       ) +\n  theme_bar() +\n    theme(\n          legend.box.margin = margin(0.2,1,0.2,0.2, unit = \"cm\"),\n          legend.spacing.x = unit(0.4, 'cm'),\n          axis.text.x = element_markdown(\n                                        color = \"#3b3b3a\", \n                                        family = \"Consolas\", \n                                        size=7.5\n                                      ),\n          plot.title.position = \"plot\",\n          panel.grid.major.y = element_line(color = \"#b0aeae\",\n                                          linewidth = 0.25,\n                                          linetype = \"dashed\"))\nlol\n\n\n\nThe plot was saved with:\nggsave(\"alternative_lol.png\", \n       plot = last_plot(),\n# Edit the following path to save the plot:\n       path = \"images\", \n       width = 8.29, \n       height = 6.88,   \n       units = \"in\", \n       dpi = 300)\nDesigning the treemap\nFinally, just for learning and comparison purposes, the treemap code is shown below. As said before, authors do not recommend this kind of visualizations because differences in areas are hard to perceive. Besides, when compared with the bar plot or the lollipop, looks way more bloated and less effective.\n\n\n# Import libraries\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggtext)\nlibrary(grid)\nlibrary(treemapify)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(ggpubr)\n\n\n\n\n# Import data\ndf <- read_csv(\"data.csv\")\n\n# Data wrangling\n\ndf <- df %>%\n  pivot_longer(-generation, \n               names_to = \"variables\", \n               values_to = \"dollars\") %>%\n  group_by(generation) %>%\n  arrange(generation, \n          desc(dollars)) %>%\n  mutate(ranking = row_number())\n\ndf$generation[df$generation == \"silent\"] <- \"Silent\"\ndf$generation[df$generation == \"boomers\"] <- \"Boomers\"\ndf$generation[df$generation == \"gen_X\"] <- \"Generation X\"\ndf$generation[df$generation == \"millennials\"] <- \"Millennials\"\ndf$generation[df$generation == \"gen_Z\"] <- \"Generation Z\"\n\ndf$variables[df$variables == \"alcohol\"] <- \n  \"Alcoholic beverages\"\ndf$variables[df$variables == \"apparel\"] <- \n  \"Apparel and services\"\ndf$variables[df$variables == \"cash_contributions\"] <- \n  \"Cash contributions\"\ndf$variables[df$variables == \"education\"] <- \n  \"Education\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"food\"] <- \"Food\"\ndf$variables[df$variables == \"entertainment\"] <- \n  \"Entertainment\"\ndf$variables[df$variables == \"healthcare\"] <- \n  \"Healthcare\"\ndf$variables[df$variables == \"housing\"] <- \n  \"Housing\"\ndf$variables[df$variables == \"insurance\"] <- \n  \"Personal insurance\"\ndf$variables[df$variables == \"miscellaneous\"] <- \n  \"Miscellaneous expenditures\"\ndf$variables[df$variables == \"personal_care\"] <- \n  \"Personal care products \\n and services\"\ndf$variables[df$variables == \"reading\"] <- \n  \"Reading\"\ndf$variables[df$variables == \"smoking\"] <- \n  \"Tobacco products and smoking \\n supplies\"\ndf$variables[df$variables == \"transportation\"] <- \n  \"Transportation\"\n\n\n# Categorize observations with a ranking <= 9 as \"Others\"\ndf$variables[df$ranking >= 8] <- \"Others\"\n\n#Aggregation in order to have all \"Others\" in the same row\n\ndf <- df %>%\n  group_by(generation, variables) %>%\n  summarise(dollars = sum(dollars))\n\ndf$ranking <- NULL\n\n\n\n\ntheme_tree <- function() {\n  \n  # Begin construction of chart\n  theme_bw(base_size = 15) +\n\n    # Format background colors\n    theme(panel.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(plot.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n    theme(panel.border = element_rect(\n      color = color_background)) +\n    theme(strip.background = element_rect(\n      fill = color_background, \n      color = color_background)) +\n\n    # Format the grid\n    theme(axis.ticks = element_blank()) +\n    theme(panel.grid = element_line(\n      colour = color_background)) +\n\n    # Format the legend\n    #theme(legend.position = \"none\") +\n\n    # Format de caption\n    theme(plot.caption = element_markdown(\n      hjust = 1, \n      family = \"Consolas\",\n      size = 5.5)) +\n\n    # Format title and axis labels\n    theme(plot.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 17.5, \n      face = \"bold\", \n      hjust = 0.5, \n      margin=margin(0,0,10,0))) +\n    theme(plot.subtitle = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 9, \n      hjust = 0.5, \n      face = \"bold\", \n      margin=margin(0,0,22,0))) +\n    theme(axis.title.x = element_blank()) +\n    theme(axis.title.y = element_blank()) +\n    theme(axis.text = element_markdown()) +\n    theme(axis.text.x = element_markdown()) +\n    theme(axis.text.x.top = element_markdown(\n      color = \"#3b3b3a\", \n      family = \"Consolas\", \n      size=7.5)) +\n    theme(axis.text.y = element_blank()) +\n    # theme(strip.text = element_text(face = \"bold\")) +\n    theme(plot.tag = element_markdown(\n      family = \"Consolas\",\n      lineheight = 0.1, \n      size = 8)) +\n    theme(plot.tag.position = c(0.10, 0.85)) +\n\n    # Plot margins\n    theme(plot.margin = unit(c(0.5, 0.5, 0.2, 0.5), \"cm\")) # top, right, bottom, left\n}\n\n\n\n\n# Format the dollars column.\ndf$dollars2 <- format(df$dollars, big.mark=\",\", trim=TRUE)\n\ndf$dollars2 <- paste0(\"$\",df$dollars2)\n\n\nDesigning the 5 treemaps:\n\n\nx <- ggplot(df %>% filter(generation==\"Generation X\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#717342\",\n                              \"#4b4d27\",\n                              \"#a4a671\",\n                              \"#717342\",\n                              \"#717342\"))\n\nmillennials <- ggplot(df %>% filter(generation==\"Millennials\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.), \"cm\")) + # top, right, bottom, left\n        scale_fill_manual(values=c(\"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#c49350\",\n                              \"#805b28\",\n                              \"#e3af6b\",\n                              \"#c49350\",\n                              \"#c49350\"))\n                              \n\nboomers <- ggplot(df %>% filter(generation==\"Boomers\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left        \n    scale_fill_manual(values=c(\"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#be7c4d\",\n                              \"#96592d\",\n                              \"#e39762\",\n                              \"#be7c4d\",\n                              \"#be7c4d\"))\n                              \n\nsilent <- ggplot(df %>% filter(generation==\"Silent\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n    scale_fill_manual(values=c(\"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#9a7447\",\n                              \"#63431d\",\n                              \"#ba9a73\",\n                              \"#9a7447\",\n                              \"#9a7447\"))\n                              \nz <- ggplot(df %>% filter(generation==\"Generation Z\"),\n            aes(area = dollars,\n                fill = variables,\n                label = paste(variables, dollars2, sep = \"\\n\")\n                )) +\n    geom_treemap(\n                layout = \"srow\",\n                 radius = unit(0, \"pt\")) +\n    geom_treemap_text(\n                layout = \"srow\",\n                colour = \"#fbf2dd\",\n                size = 9,\n                fontface = \"bold\",\n                family = \"Consolas\",\n                min.size = 3,\n                reflow = TRUE,\n                padding.x = unit(2, \"mm\"),\n                padding.y = unit(2, \"mm\")) +\n    theme_tree() +\n    #theme(aspect.ratio=1) +\n    theme(legend.position = \"none\") +\n    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), \"cm\")) + # top, right, bottom, left\n      scale_fill_manual(values=c(\"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#897d65\",\n                              \"#61563f\",\n                              \"#baac91\",\n                              \"#897d65\",\n                              \"#897d65\"))\n\n\nThe treemap was, in fact, five glued treemaps. For that reason, the legend could not be displayed properly, so we made a very simple bar plot containing a legend, and the get_leyend function extracted it. Then, we converted it into an ggplot2 element with the as_ggplot function. This procedure allowed us to use the patchwork package and paste the 5 treemaps plus the legend. The ggpubr and cowplot packages were used for these purposes.\n\n\n# Summarize the spendings per generation\ndf_summ <- df %>%\n    group_by(generation) %>%\n    summarise(total_per_generation = sum(dollars))\n\n\n\n\ngen_order <- c(\"Silent\", \n       \"Boomers\", \n       \"Generation X\", \n       \"Millennials\", \n       \"Generation Z\")\n\n\n\n\n# Set custom colors\nbar_colors <- c(\"#9a7447\",\n                          \"#be7c4d\",\n                          \"#717342\",\n                          \"#c49350\",\n                          \"#897d65\"\n)\n\nbar2 <- ggplot(df_summ) +\n  aes(\n    x = generation,\n    fill = generation,\n    weight = total_per_generation) +\n  geom_bar() +\n  scale_fill_manual(breaks=gen_order, \n                    values = bar_colors,\n                    name = \"\",\n                    labels = c(\"**Silent**<br>1945 or earlier<br>**$44,683**\", \n                               \"**Boomers**<br>1946 to 1964<br>$**62,203**\", \n                               \"**Generation X**<br>1965 to 1980<br>**$83,357**\", \n                               \"**Millennials**<br>1981 to 1996<br>**$69,061**\", \n                               \"**Generation Z**<br>1997 or later<br>**$41,636**\")) +\n  scale_x_discrete(\n    limits = gen_order) +\n  theme_minimal() +\n  theme(plot.margin = unit(c(0,0,0,0), \"pt\")) +\n  theme(legend.text = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) + # top, right, bottom, left\n  theme(legend.title = element_markdown(\n      color = color_text,\n      family = \"Consolas\",\n      size = 7, \n      hjust = 0.5)) +\n  theme(legend.position = \"bottom\") +\n  theme(legend.spacing.x = unit(0.5, 'cm'))\n\nbar2\n\n\n\n\n\n# Extract the legend\nlegend_extract <- get_legend(bar2) \n\n\n\n\n# Turn the legend into a ggplot2 object\nlegend <- as_ggplot(legend_extract)\n\n\nPaste all graphics:\n\n\ntree <- legend + ((silent / boomers) | (x / millennials) + z) + \n  plot_layout(\n              nrow = 2,\n              ncol = 1,\n              heights = c(0.5, 6)) +\n  plot_annotation(\n    title = \n      paste(\"<span style='color: #3d2309; font-size: 15pt'>\",\n            \"_Housing_: more than 30% of Americans' expenditures in 2021\",\n            \"<\/span>\",\n            sep = \"\"),\n    \n    subtitle = \n      paste(\"<span style='color: #4e4b4b; font-size: 10pt'>\",\n            \"It was the top spending category across all generations in 2021.<br>\",\n            \"Overall, _Gen X_ spent the most ($83,357), followed by _Millennials_ ($69,091).\",\n            \"<\/span>\",\n            sep = \"\"\n            ),\n    \n    caption = \"Carolina Cornejo Castellano | Data: U.S. Bureau of Labor Statistics\",\n    theme = theme_tree()\n                  )\n\ntree\n\n\n\nSave plot:\nggsave(\"alternative_tree.png\", \n       plot = last_plot(), \n       path = \"images\", \n       width = 8.29, \n       height = 6.88, \n       units = \"in\", \n       dpi = 300)\nNeedless to say, replicating the graphic and proposing new visualizations were very learning exercises. Being able to design better graphics with cleaner and shorter code is still a longer term task.\n\n\n\nBateman, Scott, Regan L. Mandryk, Carl Gutwin, Aaron Genest, David McDine, and Christopher Brooks. 2010. “Useful Junk?: The Effects of Visual Embellishment on Comprehension and Memorability of Charts.” In Proceedings of the 28th International Conference on Human Factors in Computing Systems - CHI ’10, 2573. Atlanta, Georgia, USA: ACM Press. https://doi.org/10.1145/1753326.1753716.\n\n\nBump, Philip. 2021. “America’s Favorite Dog Breeds for the Past Two Decades, Ranked.” Washington Post, November 25, 2021. https://www.washingtonpost.com/news/wonk/wp/2015/02/27/americas-favorite-dog-breeds-for-the-past-two-decades-ranked/.\n\n\nCleveland, William S. 1985. The Elements of Graphing Data. Monterey, Calif: Wadsworth Advanced Books and Software.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical Introduction. Princeton, NJ: Princeton University Press.\n\n\nHeer, Jeffrey, and Michael Bostock. 2010. “Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.”\n\n\nLodha, Preethi. 2022. “How Do Americans Spend Their Money, By Generation?” Visual Capitalist. September 25, 2022. https://www.visualcapitalist.com/cp/how-americans-spend-their-money-2022/.\n\n\nTufte, Edward R. 2013. The visual display of quantitative information. 2nd ed., 8th print. Cheshire, Conn: Graphics Press.\n\n\nWilkinson, Leland, and Graham Wills. 2005. The Grammar of Graphics. 2nd ed. Statistics and Computing. New York: Springer.\n\n\n\n\n",
    "preview": "projects/2022/100481925/images/replica.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 994,
    "preview_height": 825
  },
  {
    "path": "projects/2022/100483607/",
    "title": "Distribution of state investment by autonomous communities",
    "description": "This following page is a guide, of how to reproduce step by step, the plot of \"El Mundo Gráficos\" done by the student Pablo Arroyo as a final project for the subject.",
    "author": [
      {
        "name": "Pablo Arroyo Rodriguez",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLabs\nLegend\n\nImprovements\nCode\n\nConclusion\n\nThe distribution of state investment by autonomous communities, it is a tricky topic that each year comes to the news. When the State´s budget is published, almost the first thing that each media do is to analyze what are the communities that receive more, and what are the ones that receive less. This could be important, because depending on the needing of support for the governance, more money would go to one community or another.\nThe point here, is in the differences between Madrid and Catalonia. However, as illustrated here, the budget from Catalonia is closer to Andalusia rather than Madrid. We can see notices of this kind in the national press channel “Catalonia and Andalusia lead state investment with almost twice the budget of Madrid and the Valencian Community” or the “El Mundo” from which I took the graph.\nJ.Aguirre | EL MUNDO GRÁFICOS. Figure from elmundo.es.Getting the data\nApparently, the data could be really easy to obtain from an official source, because if you observe this same data from different papers, figures vary a bit. But, as expected with public institutions, the process is really tedious. So, what I did is to obtain the data from the public institution in charge of this figures in Spain, La Intervención General de la Administración del Estado with data from 2009 to 2022.\nFor data about the budget for the next year, 2023, I used another official page which show the information in a visual way, Ministerio de Hacienda, epdata.\nOnce you get the file with the whole datasheet from one specific year, you have to sum the different budget items by communities. It appears spread by different concepts, as a page in an excel book and repeating the process for the four years. Having done that, it is possible to obtain the data in a .cvs file format. So, we will see how our data looks like:\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggtext)\nlibrary(ggsci)\nlibrary(ggforce)\nlibrary(glue)\nlibrary(systemfonts)\nlibrary(cowplot)\n\nsysfonts::font_add_google(\"Be Vietnam Pro\")\nshowtext::showtext_opts(dpi=300)\n\ndata<- read_delim(\"Clean_Data.csv\", delim = \";\", col_types = \"cnnnn\"  )\nglimpse(data)\n\nRows: 19\nColumns: 5\n$ Comunidad <chr> \"Andalucia\", \"Cataluña\", \"Com. de Madrid\", \"C. Val…\n$ `2018`    <dbl> 1379.7, 1312.1, 1117.2, 700.0, 894.8, 962.7, 533.9…\n$ `2021`    <dbl> 2146.16, 2199.30, 1133.90, 1106.90, 792.60, 799.20…\n$ `2022`    <dbl> 2267.07, 2430.74, 1054.90, 1155.60, 1033.50, 935.2…\n$ `2023`    <dbl> 2318.8, 2508.9, 1305.4, 1269.5, 1077.9, 955.8, 600…\n\nIt is impossible to observe the whole datasheet. So, with the previous function glimpse(), we can take a quick view of the general structure, in order to observe more or less how it is. But for observing the main measures of central tendency from our data and its evolution through this for years, it would be nice to include the summary () function.\n\n\nsummary(data)\n\n  Comunidad              2018             2021        \n Length:19          Min.   :  23.5   Min.   :  24.48  \n Class :character   1st Qu.: 195.3   1st Qu.: 216.80  \n Mode  :character   Median : 363.9   Median : 384.10  \n                    Mean   : 504.7   Mean   : 622.11  \n                    3rd Qu.: 797.4   3rd Qu.: 795.90  \n                    Max.   :1379.7   Max.   :2199.30  \n      2022              2023       \n Min.   :  31.85   Min.   :  28.9  \n 1st Qu.: 192.60   1st Qu.: 241.4  \n Median : 439.30   Median : 481.5  \n Mean   : 666.25   Mean   : 718.1  \n 3rd Qu.: 984.35   3rd Qu.:1016.9  \n Max.   :2430.74   Max.   :2508.9  \n\nOnce we have our raw data, it is time to start giving format to our variables, in order that they appear specifically how we want them, not as mere values in a table.\n\n\ndata<-data %>% \n  pivot_longer(c(\"2018\", \"2021\", \"2022\", \"2023\")) %>% \n  mutate(\n    Comunidad=as.factor(Comunidad),\n    name=as.factor(name),\n  )\n\n\nFirst thing to do is to mutate them as a long format, which is more useful for visualization and statistics approaches. Also, it is important to convert the name of the communities and the name of the year, 2023, 2022, 2021, 2018, as factors. That is the way that we have in R to specify the categories in the representation.\nNow, it is possible to say that our data seems to be what it would be expected to start the construction of the graph.\nBuilding the chart\nThe plot was selected because it could seem easy to reproduce, and was the first time dealing with this kind of representation on my own. However, it started to get harder and harder to deal with this grouped bar chart, and the small details were really time consuming. But finally, it was possible to come up with a result as could be seen in the following lines:\nCoordinates and axes\nI will try to reproduce the graph, step by step, before adding the data and obtaining the whole plot.\n\n\np <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\np\n\n\n\nWith this first chunk of code, the baseline of the plot appears. Based on which, we will be adding information and modifying the different characteristic, in order to satisfy the same specification as in the selected one. However, the names of the communities are all together and it is really difficult to understand. It is a pointless point, so it´s worth it to have a vertical disposition instead of a horizontal one, the categories would be more readable.\nAs it could be seen in the example, the graph has certain limits for the values of our data. One of the first points that we have to do, is to fix those values within the specific categories. In this case from 0 to 3000 in steps of 500. I decided to expand the limits a bit more than this 3000, because otherwise the label for this 3000 extended passed the axis and we could not see it.\nThere are also coordinates for the negative part of the graph despite not having negative information for the budgets. That is because we have to extend the lines and add the names of the communities in this part as annotations, otherwise it would be impossible.\nA good point to highlight here, and which was really hard to find, is how to set the y axis on both sides. Although it is a simple line of code, it took me a while to find this specific chunk of code, so if some of you need this in the future pay attention at this point, because the rest is more or less the same as in all plots.\n\n\np <- p + scale_y_continuous(\n    breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000),\n    limits = c(-1500, 3200),\n    sec.axis = dup_axis(),\n    name = NULL,\n    expand = c(0,0)\n  ) +\n  \n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \"Baleares\", \n               \"Cantabria\", \"Canarias\", \"Asturias\", \"Extremadura\", \n               \"Murcia\", \n               \"Aragón\", \"País Vasco\", \"Castilla-La Mancha\", \n               \"Castilla y León\", \"Galicia\", \"C. Valenciana\", \n               \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\np\n\n\n\nA last comment about this previous chunk. The names of the axis have been deleted, because we do not want it to appear in our last graph, but also, we set a specific order for the name of the communities, based on the highest budget for the year 2023.\nTheme\nThe theme for this project is very easy. As it can be seen, the background of the graph is empty, nothing inside, but for, the lines below the name of each community which separate one community from another. A key point here is that we have established the small tick that appears below each break. Maybe, in this position it is hard to identify, but once we apply for coord_flip() it is more easy to observe.\n\n\np <- p + theme_minimal()+\n  \n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n    \np\n\n\n\nWe have an empty graph, with nothing inside which is the case that we are trying to replicate. However, we need to add the guides, and coord_flip() to see something similar to the original one. So, we will do it.\n\n\np <- p +  coord_flip(clip = \"off\", ylim = c(-1500, 3100))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 3100),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\np\n\n\n\nInstead of having a vertical bar chart which is the usual scenario after applying for these changes, we have a horizontal plot, with nothing inside. The graph is starting to seem similar to the original one. However, it is a kind of graph that by its nature, it is much longer than wider, so we have to change the adjustment of our R.Markdown to obtain what we want.\nNotice, that we have changed the specification of the graph, the plot is more or less what we want. Now is the time to add the data and the annotations.\nAnnotations\nApparently, this graph does not have any kind of annotation. However, it is a bit misleading and there was no other way to add the name of the communities rather than as an annotation. To do so, what I did is to extend the dimension of the plot past the axis, and once we have that, adding in the negative part the name corresponding to the different communities as annotations.\n\n\np <- p + annotate(\"text\", x = 19, y = -1400, hjust=0, \n           label = \"Cataluña\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 18, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13, y = -1400, hjust=0,  \n           label = \"Castilla-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\np\n\n\n\nData\nThis graph is based on grouped data by an autonomous community. With the name of the different communities and their budget from four different years, that is why in the previous steps it was important to pivot longer the data, and establish the different year and communities as_factor(). So, it is the type of grouped bar chart.\nNow, we will add the data to the previous coordinates and axis that we have been preparing, but also we will establish the different colors of the bars.\n\n\np <- p + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\np\n\n\n\nThe graph it is closer to our final result. Few things are still left such as a good title, subtitle and caption. But also, we have to establish a good position for the legend which is almost higher than the plot, and this does not make any sense.\nLabs\nA key point that it is still missing in this graph are the labs. If we see the graph until this point, we do not know what the graph is about without an appropriate title, it is mandatory to modify it, and also adding the different subtitles and comments.\n\n\np <- p + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\n\nHowever, when we add all of these things, our plot is completely a mess, because we have added many different things, without the necessary adjustment. So, everything has moved from one place to another and appears to be untidy. Let´s try to solve it! Basically, we will be adjusting almost every position of the element on the plot.\n\n\np <- p + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n     axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, face=\"bold\", \n                              margin=margin(0,0,0,0)),\n     plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                  size=9.5, color= \"black\", \n                                  face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n    ) \np\n\n\n\nLegend\nHowever, we still have the legend in a position that modifies the whole graph, and we have to change that to obtain a real reproduction.\n\n\np<- p +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.285, 1.05), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n    ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\np\n\n\n\nOnce we have done that, the representation is consistent with what we want, because everything is adjusted and aligned, not as in the previous steps, that when you modify something everything changes and you have to start again. But never give up, you will finish doing it!\nIt is time to introduce the annotation near to the name of each community. I tried to do it at the same time in just one chunk of code, but only the names from 3 different communities and the other disappeared. I do not know the reason well. So that is why I decided to do it step by step although it is longer. Sure, there is a better option.\nAnd also we have to add a little more. Notice that at the bottom of the graph there is more information than just a simple caption, so we have to add also this information. The way that I found better to add this information is by using the ggdraw(), which will be included at the end of the next chunk.\n\n\np<- p +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\np <- ggdraw(add_sub(p, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\n\np\n\n\n\nImprovements\nThe plot that I decided to reproduce, was quite complete with almost all the elements that should be included for a good representation, such as: a nice axis with its reference, annotations of different values, a clear legend, nice colors and so on.\nHowever, as a reader of newspapers I miss an interesting point that all graphs should have, something that draws our attention and keeps us reading the notice. This could be done by introducing some interesting point, or maybe some controversial that keeps readers awake, that is why I decided to do the following graph:\nP.Arroyo | MUCSS.Mainly, I decided to do two thing:\nAdding the name of the policy party that is in charge of each community.\nIncluding the evolution of the budget per community with an ascending or descending arrow.\nBy doing that, we include some controversial questions that encourage readers to go deeper in the theme. That is because, as said in the introduction, in Spain it is believed by many people that the budget that each community receives depends on sympathy with the central government.\nWhat, surprised me when I was doing this tutorial, is that also the original author of the previous graph, Javier Aguirre, has introduced some modifications in line with the ones that I was doing. The idea was the same, but his ones were more visual so I decided to continue my path in that way because it was just a few lines of code and the appearance was better. “See news with the final graph” This is a good point to remark, that once you get a nice graph, there is always a way to improve it based on the previous one.\nI have to point out that I don’t like in his definitive graph the inclusion of the top X axis, because there is so much information in the positive part that you will end up missing.\nCode\nI want to comment on the key point that I made to modify the whole graph. Also, I know that a good point of improvement is reducing the code to reproduce exactly the same, by for example using sequences that is something that I would like to do in future steps.\nMain points to highlight:\nExtending the limits of the axis passed the data, from -1500 to 4500, to introduce the different elements as annotations.\nSelecting just one X axis for reference instead of dup_axis(), in order not to overload the plot.\nCompute the percentage variation and add the different elements as annotations in this new axis.\nNevertheless, I include the whole chunk of code, knowing as I said before that there is enough space to do it in fewer lines, but the first step is a nice way of starting.\n\n\n### Coordinates and axes\nt <- ggplot(data) +\n  aes(x=Comunidad, y=value)\n\nt <- t + scale_y_continuous(\n  breaks = c(0, 1000, 2000, 3000),\n  #sec.axis = dup_axis(),\n  name = NULL,\n  expand = c(0,0)\n) +\n  scale_x_discrete(\n    name = NULL,\n    limits = c(\"Ceuta\", \"Melilla\", \"La Rioja\", \"Navarra\", \n               \"Baleares\", \"Cantabria\", \"Canarias\", \"Asturias\", \n               \"Extremadura\", \"Murcia\", \"Aragón\", \"País Vasco\", \n               \"Castilla-La Mancha\", \"Castilla y León\", \"Galicia\", \n               \"C. Valenciana\", \"Com. de Madrid\", \"Andalucia\", \"Cataluña\"),\n    labels = NULL,\n    expand = c(0,0)\n  )\n\n### Theme\nt <- t + theme_minimal()+\n  theme(\n    panel.grid = element_blank(),\n    axis.ticks.x.top = element_line(\n      size = .5, colour = \"#696969\"), \n    axis.ticks.x.bottom = element_line(\n      size = .5, colour = \"#696969\"),\n    plot.background = element_rect(color=\"#ffffff\", fill=\"#ffffff\"),\n    plot.margin = margin(5,5,5,5))\n\nt <- t +  coord_flip(clip = \"off\", ylim = c(-1500, 4500))+\n  geom_segment(\n    data = data.frame(x = seq(1.5, 18.5, 1), ymin =-1500, ymax = 4500),\n    aes(x = x, xend = x, y = ymin, yend = ymax),\n    inherit.aes = FALSE,\n    color = \"#8e8e8e\"\n  )\n\n### Annotations for the left name of the communities\nt <- t + annotate(\"text\", x = 19.2, y = -1400, hjust=0, \n                  label = \"Cataluña\", size = 3, \n                  colour = \"#262626\")+\n  annotate(\"text\", x = 18.2, y = -1400, hjust=0, \n           label = \"Andalucia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 17.2, y = -1400, hjust=0,  \n           label = \"Com. de Madrid\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 16.2, y = -1400, hjust=0, \n           label = \"C. Valenciana\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 15.2, y = -1400, hjust=0,  \n           label = \"Galicia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 14.2, y = -1400, hjust=0, \n           label = \"Castilla y León\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 13.2, y = -1400, hjust=0,  \n           label = \"C.-La Mancha\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 12.2, y = -1400, hjust=0,  \n           label = \"País Vasco\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 11.2, y = -1400, hjust=0, \n           label = \"Aragón\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 10.2, y = -1400, hjust=0,  \n           label = \"Murcia\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 9.2, y = -1400, hjust=0, \n           label = \"Extremadura\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 8.2, y = -1400, hjust=0,  \n           label = \"Asturias\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 7.2, y = -1400, hjust=0, \n           label = \"Canarias\", size = 3, \n           colour = \"#262626\")+\n  annotate(\"text\", x = 6.2, y = -1400, hjust=0, \n           label = \"Cantabria\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 5.2, y = -1400, hjust=0,  \n           label = \"Baleares\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 4.2, y = -1400, hjust=0,  \n           label = \"Navarra\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 3.2, y = -1400, hjust=0,  \n           label = \"La Rioja\", size = 3,\n           colour = \"#262626\")+\n  annotate(\"text\", x = 2.2, y = -1400, hjust=0,  \n           label = \"Melilla\", size = 3,\n           colour = \"#262626\") +\n  annotate(\"text\", x = 1.2, y = -1400, hjust=0,  \n           label = \"Ceuta\", size = 3,\n           colour = \"#262626\")\n\n##Annotations for adding the different boxes based on the party in charge of each community\nt<- t + annotate(geom = \"rect\", xmin = 19, xmax = 18.75,\n                 ymin = -1400, ymax = -1200, fill = \"#f3af44\", alpha = 1) + #Cataluña\n  annotate(geom = \"rect\", xmin = 18, xmax = 17.75, #Andalucia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 17, xmax = 16.75, #Com.Mad\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 16, xmax = 15.75, #C.Valenciana\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) + \n  annotate(geom = \"rect\", xmin = 15, xmax = 14.75, #Galicia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 14, xmax = 13.75, #CyL\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 13, xmax = 12.75, #C.Mancha\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 12, xmax = 11.75, #País Vasco\n           ymin = -1400, ymax = -1200, fill = \"#22823a\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 11, xmax = 10.75, #Aragon\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 10, xmax = 9.75, #Murcia\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 9, xmax = 8.75, #Extremadura\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 8, xmax = 7.75, #Asturias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 7, xmax = 6.75, #Canarias\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 6, xmax = 5.75, #Cantabria\n           ymin = -1400, ymax = -1200, fill = \"#81b881\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 5, xmax = 4.75, #Baleares\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 4, xmax = 3.75, #Navarra\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 3, xmax = 2.75, #Rioja\n           ymin = -1400, ymax = -1200, fill = \"#e52b43\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 2, xmax = 1.75, #Melilla\n           ymin = -1400, ymax = -1200, fill = \"#d9d9d9\", alpha = 1) +\n  annotate(geom = \"rect\", xmin = 1, xmax = 0.75, #Ceuta\n           ymin = -1400, ymax = -1200, fill = \"#0086c5\", alpha = 1)\n\n###Annotation for the ascendent/descent arrow based on the budget.\nt<- t + geom_segment(\n  x = 18.85, y = 3700,\n  xend = 19.1, yend = 3700,\n  lineend = \"round\", \n  linejoin = \"round\",\n  size = 1, \n  arrow = arrow(length = unit(0.3, \"cm\")),\n  colour = \"#1d1d1b\" \n) +\n  geom_segment(\n    x = 17.85, y = 3700,\n    xend = 18.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 16.85, y = 3700,\n    xend = 17.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 15.85 , y = 3700,\n    xend = 16.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 14.85 , y = 3700,\n    xend = 15.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) + \n  geom_segment(\n    x = 14.1 , y = 3700,\n    xend = 13.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 12.85 , y = 3700,\n    xend = 13.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 11.85 , y = 3700,\n    xend = 12.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.85 , y = 3700,\n    xend = 11.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 10.1 , y = 3700,\n    xend = 9.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 8.85 , y = 3700,\n    xend = 9.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 7.85 , y = 3700,\n    xend = 8.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 6.85 , y = 3700,\n    xend = 7.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 5.85 , y = 3700,\n    xend = 6.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 4.85 , y = 3700,\n    xend = 5.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 3.85 , y = 3700,\n    xend = 4.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.85 , y = 3700,\n    xend = 3.1, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#1d1d1b\" \n  ) +\n  geom_segment(\n    x = 2.1, y = 3700,\n    xend = 1.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  ) +\n  geom_segment(\n    x = 1.1 , y = 3700,\n    xend = 0.85, yend = 3700,\n    lineend = \"round\", \n    linejoin = \"round\",\n    size = 1, \n    arrow = arrow(length = unit(0.3, \"cm\")),\n    colour = \"#dc3221\" \n  )\n\n### Annotation fot the variations in the GDP.\n\nt<- t + annotate(geom = \"text\", x = 18.975, y = 3950,\n                 label = \"3.2\", hjust = 0, size = 3) + #Cataluña\n  annotate(geom = \"text\", x = 17.975, y = 3950,\n           label = \"2.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.975, y = 3950,\n           label = \"13.4\", hjust = 0, size = 3) + #Madrid\n  annotate(geom = \"text\", x = 15.975, y = 3950,\n           label = \"5\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.975, y = 3950,\n           label = \"0.3\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.975, y = 3950,\n           label = \"-4.2\", hjust = 0, size = 3) + #CyL\n  annotate(geom = \"text\", x = 12.975, y = 3950,\n           label = \"11.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 11.975, y = 3950,\n           label = \"14.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.975, y = 3950,\n           label = \"4.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.975, y = 3950,\n           label = \"-33.4\", hjust = 0, size = 3) + #Murcia\n  annotate(geom = \"text\", x = 8.975, y = 3950,\n           label = \"16.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.975, y = 3950,\n           label = \"7.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.975, y = 3950,\n           label = \"23.9\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 4.975, y = 3950,\n           label = \"8.1\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.975, y = 3950,\n           label = \"34.7\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.975, y = 3950,\n           label = \"12.8\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.975, y = 3950,\n           label = \"-24.4\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.975, y = 3950,\n           label = \"-9.3\", hjust = 0, size = 3) \n\n\n##Anotation for adding the different text of the party in charge!\n\nt<- t + annotate(geom = \"text\", x = 18.875, y = -1100,\n                 label = \"ERC\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 17.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 16.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 15.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 14.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 13.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 12.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) + \n  annotate(geom = \"text\", x = 11.875, y = -1100,\n           label = \"PNV\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 10.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 9.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 8.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 7.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 6.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 5.875, y = -1100,\n           label = \"PRC\", hjust = 0, size = 3) + ##Cantabria\n  annotate(geom = \"text\", x = 4.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 3.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 2.875, y = -1100,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 1.875, y = -1100,\n           label = \"Indep\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 0.875, y = -1100,\n           label = \"PP\", hjust = 0, size = 3) \n\n\n##Anottation for the tittle of this column\nt<- t + annotate(geom = \"text\", x = 19.68, y = 3200,\n                 label = \"Var. % 2022/23\", hjust = 0, size = 3, fontface = \"bold\")\n\n### Adding the data\nt <- t + \n  geom_bar(position = \"dodge\", stat = \"identity\", width = 0.63) + \n  aes(fill = name) +\n  scale_fill_manual(breaks=c(\"2023\",\"2022\",\"2021\", \"2018\"), \n                    values = c(\"#ff1e26\", \"#5f9dc6\",   \"#8ccaf9\", \"#c5daeb\"))\n\n### Labs\nt <- t + \n  labs(\n    title = \"EL REPARTO DE LA INVERSIÓN ESTATAL POR CCAA\",\n    subtitle = \"INVERSIÓN REAL \\n\\n\\n\",\n    caption = \"Se añaden 20,52 millones de euros para Ceuta y Melilla \\n\",\n    fill = \"En millones de euros\")\n\nt <- t + \n  theme(\n    axis.title.x = element_text(hjust=.5, color=\"black\", \n                                size=10, face = \"bold\", \n                                margin = margin(10,0,0,0)),\n    axis.text = element_text(color=\"black\", \n                             size=8 ),\n    axis.text.y = element_text(color=\"black\",\n                               size=10),\n    plot.title = element_text(hjust=-0, size=11, \n                              color=\"black\",lineheight=.8, \n                              face=\"bold\", margin=margin(0,0,0,0)),\n    plot.subtitle = element_text(hjust=0, vjust = 1.2, \n                                 size=9.5, color= \"black\", \n                                 face = \"bold\", margin=margin(10,0,10,0)),\n    plot.caption = element_text(hjust= -0.05,margin=margin(10,0,0,0), \n                                size=8, color=\"black\", face=\"bold\"),\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\"\n  ) \n\n###Anotations for the homemade guide about the different policies parties.\n\nt<- t + annotate(geom = \"text\", x = 20.5, y = -1500,\n                 label = \"Presidencias de las CCAA\", hjust = 0, size = 3) +\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -1500, ymax = -1300, fill = \"#e52b43\", alpha = 1) +#Color PSOE\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = -500, ymax = -300, fill = \"#0086c5\", alpha = 1) + #Color PP\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 500, ymax = 700, fill = \"#f3af44\", alpha = 1)+ #Color ERC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 1500, ymax = 1700, fill = \"#22823a\", alpha = 1)+ #Color PNV\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 2500, ymax = 2700, fill = \"#81b881\", alpha = 1)+ #Color PRC\n  annotate(geom = \"rect\", xmin = 20.25, xmax = 20,\n           ymin = 3500, ymax = 3700, fill = \"#d9d9d9\", alpha = 1)+ #Color Indep.\n  annotate(geom = \"text\", x = 20.125, y = -1275,\n           label = \"PSOE\", hjust = 0, size = 3) +\n  annotate(geom = \"text\", x = 20.125, y = -275,\n           label = \"PP\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 725,\n           label = \"ERC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 1725,\n           label = \"PNV\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 2725,\n           label = \"PRC\", hjust = 0, size = 3)+\n  annotate(geom = \"text\", x = 20.125, y = 3725,\n           label = \"Indep.\", hjust = 0, size = 3)\n\n### Legend\nt<- t +\n  theme(\n    legend.direction = \"horizontal\",\n    legend.position = c(0.295, 1.027), \n    legend.margin = margin(0),\n    legend.title = element_text(color = \"black\", size = 8),\n    legend.text = element_text(color = \"black\", size = 8),\n    legend.spacing.x = unit(0.09, 'cm'),\n    legend.key.size = unit(0.6, \"cm\"),\n    legend.key.height= unit(0.3, 'cm'),\n    legend.key.width = unit(0.65, \"cm\"),\n    legend.spacing.y = unit(0.1,'cm')\n  ) +\n  guides(fill= guide_legend(title.position = \"top\", title.hjust = 0))\n\nt<- t +\n  geom_text(\n    aes(label= ifelse(value == c(\"2508.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"2318.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1305.4\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1, \n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1269.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"1077.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"955.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"600.7\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"558.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"547.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"481.5\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"473.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )+\n  geom_text(\n    aes(label= ifelse(value == c(\"420.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"391.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"296.6\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"186.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = - 0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"103.8\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"71.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) + \n  geom_text(\n    aes(label= ifelse(value == c(\"45.3\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  ) +\n  geom_text(\n    aes(label= ifelse(value == c(\"28.9\"), value, NA)), \n    position = position_dodge(0.8),\n    hjust = -0.1,\n    vjust = 0.75, size = 2.8,\n    colour = \"#262626\"\n  )\n\nt <- ggdraw(add_sub(t, \"Fuente:PGE 2023, 2022, 2021 Y 2018 \\nP.Arroyo | MUCSS\", \n                    y = 0.8, x = -0.01, hjust = 0, vjust = 0.85, size = 7.8, \n                    color = \"black\", lineheight = 0.85))\nt\n\n\n\nConclusion\nOnce I completed the whole project, I have to say that it is a challenging process. You will be dealing with new tools that we have never seen before although they are really useful.\nYou will realize that after many hours of work, those things that in the first lesson sound like double Dutch to us, little by little everything starts to make sense. So, enjoy the process because this wonderful world of Data Visualization has many things to discover.\n\n\n\n",
    "preview": "projects/2022/100483607/ccaa470.jpg",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {}
  },
  {
    "path": "projects/2022/100489635/",
    "title": "GDP Forecasts for China's Cities by 'The Economist': Coastal Areas Have the Highest Growth Potential",
    "description": "A layer-by-layer construction of a map of China containing information on forecasted GDP growth and population for over 100 cities.",
    "author": [
      {
        "name": "Elena Yustres",
        "url": {}
      }
    ],
    "date": "2023-01-05",
    "categories": [
      "2022"
    ],
    "contents": "\n\nContents\nThe original chart\nObtaining and processing the data\nBuilding the plot\n\nEvaluation and potential enhancements\nAlternative visualization\n\nAs both a cause and consequence of China’s rapid economic growth, the proportion of the country’s population living in cities has soared from 20% in 1980 to 60% in 2020. However, China’s Zero-Covid policy has stilted growth significantly. The “China Emerging City Rankings, 2022” Report, launched by the Economist Intelligence Unit (EIU), assesses the growth potential of 108 cities predicted to have a population of more than 1 million by 2025. Scores are calculated using historical data and forecasts on variables including demography, the local economy or the environment.\nThe Economist’s “March of the cities” map. Figure from economist.com.This post will seek to replicate this map, propose incremental enhancements and suggest an alternative visualization that depicts the relationship between growth potential, population and location (or distance to the coastline) taking cities as our units of analysis.\nThe original chart\nObtaining and processing the data\n\n\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(showtext)\nlibrary(maps)\nlibrary(maptools)\nlibrary(svglite)\nlibrary(plyr)\n\nsysfonts::font_add_google(\"IBM Plex Sans\", family=\"IBM Plex Sans\")\nshowtext::showtext_auto()\n\n\nDiving into data collection, we obtained the data on the ranking and population of our units of analysis from the EIU (‘Global Geo-Political Trends and Economics’ section) after contacting their office in Asia by email.\n\n\nranking <- read_csv(\"ranking.csv\")\npopulation <- read_csv(\"population.csv\")\n\n\nOnce we have loaded both sets of data, the summaries below show that the ‘ranking’ dataset contains data on scores for 106 cities (ordered from highest, i.e. Ranking = 1, to lowest) while the ‘population’ dataset includes population data for 397 cities in China.\n\n\nglimpse(ranking)\n\nRows: 106\nColumns: 2\n$ City    <chr> \"Hangzhou\", \"Shenzhen\", \"Shanghai\", \"Suzhou\", \"Guang…\n$ Ranking <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\nglimpse(population)\n\nRows: 397\nColumns: 2\n$ City       <chr> \"Shanghai\", \"Beijing\", \"Shenzhen\", \"Guangzhou\", \"…\n$ Population <dbl> 22315474, 18960744, 17494398, 16096724, 13568357,…\n\nIn order to get both attributes (“Ranking” and “Population”) on the same dataset, we used a left_join to merge both datasets by the unit of analysis (“City”). This produced a dataset with both variables for the 106 cities provided by the EIU. Please note that, while the original map in the article by ‘The Economist’ includes 108 cities, the EIU only provided us with data on 106.\n\n\noutput <- ranking %>% left_join(population, by=\"City\")\n\n\nIn order to obtain the “longitude” and “latitude” of each city, we used the world.cities database. This database includes these and other variables for over 40,000 cities in the world. We then filtered the cities in China and selected (as well as renamed) the variables of interest to later on construct my final database.\n\n\ndata <- world.cities %>%\n  filter(country.etc==\"China\") %>%\n  dplyr::select(name, lat, long) %>%\n  dplyr::rename(\"City\"=\"name\", \n         \"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\") \n\n\nWe then merged the location dataset (‘data’) and the dataset with information on ranking and location (‘output’).\n\n\nfulloutput <- output %>% left_join(data, by=\"City\")\n\n\nThe data also required some cleaning and adjustment. First, there were two cities with the same name (i.e. Suzhou) in the EIU ranking. Since they are located in different provinces, we used population and location data to cross check which city corresponded to which score provided by the EIU and renamed one of them to establish the difference. Second, there were several other cities in the ‘data’ dataset with the same name as cities in the ‘output’ one, which led to there being more than one row for each unit of analysis in the ‘fulloutput’ table. We removed the appropriate rows, as well as the rows for which latitude and longitude data were not available (i.e. NAs for those variables). We are left with 104 rows.\n\n\nfulloutputclean <- fulloutput[-c(5, 23, 49, 51, 70, 81, 104, 113),]\nfulloutputclean <- fulloutputclean[!is.na(fulloutputclean$Latitude) \n                                   & !is.na(fulloutputclean$Longitude), ]\nhead(fulloutputclean, 5)\n\n# A tibble: 5 × 5\n  City      Ranking Population Latitude Longitude\n  <chr>       <dbl>      <dbl>    <dbl>     <dbl>\n1 Hangzhou        1    9236032     30.2      120.\n2 Shenzhen        2   17494398     22.5      114.\n3 Shanghai        3   22315474     31.2      121.\n4 Suzhou          4    6715559     31.3      121.\n5 Guangzhou       5   16096724     23.1      113.\n\nThe final step in data processing was obtaining the data to plot the underlying map of China and its provinces. The ggplot2-china-map repository contains such information. We used the readOGR function to read the ‘shapefile’, cleaned the data and fortified into a dataframe. We then instructed that the islands in the South China Sea not be drawn by selecting only observations with “AREA” above 0.005. Finally, again, we renamed variables accordingly.\n\n\nchina <- rgdal::readOGR(dsn=(\"./china_shapefile/\"), layer=\"bou2_4p\", verbose=FALSE)\nchina@data$id<-rownames(china@data)\nchina.points<-fortify(china, region=\"id\")\nchina.df<-join(china.points, china@data, by=\"id\")\nchina<-subset(china.df, AREA>0.005) %>% \n  dplyr::rename(\"Latitude\"=\"lat\", \n         \"Longitude\"=\"long\",\n         \"Grouping\"=\"group\")\n\n\nBuilding the plot\nCoordinates of the map and data points\nUsing the data loaded in ‘china’ in the last step, we use geom_polygon() to draw the underlying map. The aes argument maps the longitude and latitude columns to the x and y coordinates, respectively. This function is also used to specify the fill and the transparency (alpha) level of the map.\nWe then use geom_path() to set the line demarcating the province limits. After indicating the use of the same variables and the same dataset as for the geom_polygon() function, we set the color and size of the border.\nFurther, coord_map() sets the coordinate system for the map by projecting the defined portion of the Earth onto a flat 2D plane.\n\n\np <- ggplot() +\n  geom_polygon(data=china,\n            aes(x=Longitude, y=Latitude, group=Grouping),\n            fill=\"cornsilk3\",\n            alpha=0.3) +\n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping),\n            color=\"white\",\n            size=0.2) +\n  coord_map() \np\n\n\n\nNext, we add the data points at the specific locations of the 104 cities (defined by their latitude and longitude) with geom_point(). Thus, on top of the map, we are plotting a scatterplot using data from ‘fulloutputclean’ where each point represents one city. The size of the point (more specifically, its area) represents its population and its fill depicts the relative position of a given city vis-à-vis other cities in the EIU ranking. We then set a black line around the point (shape=21) while specifying the color and thickness (stroke) of the border.\nA title, subtitle and caption are added to replicate the original chart using the labs function.\n\n\np2 <- p + \n  geom_point(data=fulloutputclean, \n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking), \n             shape=21,\n             color=\"black\",\n             stroke=0.03) +\n  labs(title=\"March of the cities\",                                                                   \n       subtitle=\"China, emerging city ranking, 2022\",\n       caption=\"Source: EIU\") \np2\n\n\n\nScales\nNext, the scale_fill_stepsn() and scale_size() functions are used to customize the appearance of the legends for the color and size aesthetics, respectively.\nFor the color legend (or rather, fill legend, given our points have borders defined by the color argument as introduced in the previous section), we first specify its title and title position. We then specify the details relating to the ticks and limits between the different boxes of the legend. We set the values for the 7 breaks in the variable ‘Ranking’ so as to create six categories of rank scores. By means of a drawing tool using the hexadecimal system, we set the colors for each of the six categories. Note that higher-ranked cities are represented with shades of blue and lower-ranked cities are represented with shades of orange or brown, whereby darker shades of both colors represent the ends of the spectrum.\nFor the size legend, we do the same as with the fill legend regarding the title and the breaks, although this time we are specifying 3 breaks. In this case we are also setting the labels for those breaks. This is because, by default, R uses scientific notation for population but the legend title already states that values are provided in millions. Finally, we set the range of the size of the bubbles from 0.04 to 6 mm.\n\n\np3 <- p2 + \n  scale_fill_stepsn(\n      guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE, \n                             show.limits=TRUE, \n                             ticks.colour= \"black\",\n                             ticks.linewidth = 1, \n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1),\n      breaks=c(1, 20, 40, 60, 80, 100, 106), \n      colors=c(\"#1c2c74\", \"#5483b3\", \"#99ccff\", \"#fcdb9b\", \"#fcbc04\", \"#ac6404\"),\n      space=\"Lab\") +\n  scale_size(\n      guide=guide_legend(title=\"Population, 2020, m\", \n                         title.position=\"top\",\n                         order=2),\n      breaks=c(1000000, 10000000, 20000000),\n      labels=c(\"1\", \"10\", \"20\"),\n      range=c(0.04, 6))\np3\n\n\n\nTheme\nDespite there being a special ‘The Economist’ theme, a completely empty theme (without the default background and axis elements) is what we want. Hence we use theme_void(). Under the theme() function, we first specify the (previously loaded) font most closely resembling the one used in the original map. Concerning title, subtitle and caption, we specify their size, as well as their vertical (vjust) and horizontal justification (hjust). Also using the helping function element_text(), we instruct that the title be bold and the caption have the color “gray”. We then set the position, direction and justification of the legend so that it is horizontal and gets centered to the north of China (approximately where Mongolia would be). We then specify that both legends be left-justified and set the font size for both the title and the text inside the legend (as well as the face in the case of the legend title). Finally, we customize the margins around the legend area and set the key width to 8mm, the key height to 2.5mm and the spacing between keys in the size legend to 0.1mm.\n\n\np4 <- p3 +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=22, vjust=-8, hjust=0.05), \n        plot.subtitle=element_text(size=18, vjust=-10, hjust=0.058),\n        plot.caption=element_text(color = \"gray\", size = 17, hjust = 0.05),\n        legend.position=c(0.73, 0.96),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.text=element_text(size=14),\n        legend.margin=margin(1, 1, 1, 1),\n        legend.key.width=unit(8, \"mm\"),\n        legend.key.height=unit(2.5, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'))\np4\n\n\n\nAnnotations\nThe last step to replicate the original map is the annotations, for which we use the annotate() function. While it may appear to be a caption, the text “1=best” is actually inside the plot and hence is introduced as an annotation. For this and the rest of annotations, we specify the type, the coordinates (x, y), the label, the size and the family (as well as the hjust, vjust, fontface and color for some).\nFor the textbox in the lower left corner in the original chart, we create a separate annotation for the title in order to be able to set its fontface to bold and assign it a different color. Further, we separate each of the five cities into different annotations as well because grouping them together under the same one led to there being too large of a vertical space between each of the five lines.\nFor the individual annotations of the eight highest ranked cities on their locations on the map, we simply use the coordinates for each city and adjust them to be able to see which point corresponds to each label. We also added separate annotations with the lines for five cities: Dongguan, Guangzhou, Suzhou, Jiaxing and Hangzhou (type= “segment”). These lines make identifying which label corresponds to each point easier when cities are clustered together.\n\n\np5 <- p4 + \n  annotate(\"text\", x=67, y=51.5, label=\"1=best\", \n           size=5.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=30, label=\"Highest ranked\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\",\n           fontface=\"bold\", color=\"blue4\") +\n  annotate(\"text\", x=65, y=28, label=\"1  Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=26, label=\"2  Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=24, label=\"3  Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=22, label=\"4  Suzhou\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=65, y=20, label=\"5  Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=26, label=\"Hangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=21, label=\"Shenzhen\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=33, label=\"Shanghai\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114, y=29, label=\"Suzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=102, y=23, label=\"Guangzhou\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=116, y=41,label=\"Beijing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=123, y=29, label=\"Jiaxing\", \n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=110, y=26, label=\"Dongguan\",\n           size=5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=113, y=25.5, \n           xend=113, yend=24) +\n  annotate(\"segment\", x=110, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=117, y=30, \n           xend=120, yend=31.5) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=122, y=27, \n           xend=120, yend=30)\np5\n\n\n\nEvaluation and potential enhancements\nThis section starts with a brief discussion of the positive and negative qualities of both the original chart and its replication. First, there are several limitations with our reproduction of the map. First, we were not able to reproduce the curved segments joining Hangzhou and Suzhou with their respective points or bubbles as the chart did not support geom_curve(). We were also unable to imitate the appearance of the fill legend exactly as the one in the original map contains spaces between the different boxes or ranges of scores.\nNext, an evaluation of the strengths and weaknesses of the original map is also necessary in order to suggest minor improvements.\nOverall, the original map is an effective visualization. The title and subtitle are concise and informative of its purpose and object, i.e. showing how, because of urbanization (“March of the cities”), cities of varying populations on the coast of China have different levels of growth potential as measured by a comprehensive score. The underlying map, which does not encode any information, does not distract from the information being shown as it is given a light color. Moreover, the legends are clear. This is especially important in the case of the size legend, which could be problematic since people perceive areas rather than radii as visual features in circles. In this case, the area of the circle seems to be proportional to population and so it correctly provides a reference point for readers to estimate the population of individual cities. The ‘expressiveness’ criterion is also met, as ordered data (“Ranking”) appears ordered by means of the hue scale. Finally, the annotations help readers focus on a small number of cities (eight for on-the-map annotations and five for the annotation on the bottom left corner), which facilitates the understanding of which cities have highest growth potential as well as of their characteristics (namely population and location).\nTherefore, the mapping of data into visual features communicates (and thus helps us understand) the “story” the author wants to tell in a clear, precise, efficient and truthful way.\nHowever, there may be some areas of potential improvement. The chart below includes several changes so as to enhance the ease of decoding visual information.\n\n\np <- ggplot() +\n  geom_polygon(data=china, \n               aes(x=Longitude, y=Latitude, group=Grouping),\n               fill=\"cornsilk3\",\n               alpha=0.3) +   \n  geom_path(data=china, aes(x=Longitude, y=Latitude, group=Grouping), \n            color=\"white\", \n            size=0.2) +\n  coord_map(xlim=c(100, 155), ylim=c(20, 50)) +\n  geom_point(data=fulloutputclean,\n             aes(x=Longitude, y=Latitude, size=Population, fill=Ranking),\n             shape=21, color=\"black\") +       \n  labs(title=\"March of the cities\",\n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Source: EIU\") +\n  scale_fill_stepsn(\n       guide=guide_colorsteps(title=\"Rank\",\n                             title.position=\"top\",\n                             ticks=TRUE,\n                             show.limits=TRUE,\n                             ticks.colour=\"black\",\n                             ticks.linewidth=1,\n                             draw.llim=TRUE,\n                             draw.ulim=TRUE,\n                             order=1), \n       colors=c(\"#00008b\", \"#6495ed\", \"#87cefa\", \"#e0ffff\"),\n       breaks=c(1, 30, 60, 90, 106),\n       space=\"Lab\") +\n  scale_size(\n       guide=guide_legend(title=\"Population, 2020, m\",\n                          title.position=\"top\",\n                          order=2), \n       breaks=c(1000000, 10000000, 20000000), \n       labels=c(\"1\", \"10\", \"20\"),\n       range=c(0.04, 6)) +\n  theme_void() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=20, \n                                vjust=-14, hjust=0), \n        plot.subtitle=element_text(size=13, \n                                   vjust=-21, hjust=0),\n        plot.caption=element_text(color=\"gray\", size=14, \n                                  hjust=0),\n        legend.position=c(1.01, 1.01),\n        legend.direction=\"horizontal\",\n        legend.justification=c(\"right\", \"top\"),\n        legend.box.just=\"left\",\n        legend.box.background=element_rect(fill=\"white\"),\n        legend.margin=margin(5, 15, 5, 10),\n        legend.key.width=unit(12, \"mm\"),\n        legend.key.height=unit(3, \"mm\"),\n        legend.spacing.x=unit(0.1, 'mm'),\n        legend.title=element_text(face=\"bold\", size=14),\n        legend.title.align=0,\n        legend.text=element_text(size=14)) +\n  annotate(\"text\", x=99, y=47.5, label=\"1=best\",\n           size=4.5, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=121, y=28, label=\"(1) Hangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=115, y=21.5, label=\"(2) Shenzhen\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=122, y=32, label=\"(3) Shanghai\",\n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=114.5, y=28, label=\"(4) Suzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"text\", x=103, y=23, label=\"(5) Guangzhou\", \n           size=4.5, hjust=0, vjust=0, family=\"IBM Plex Sans\") +\n  annotate(\"segment\", x=110.5, y=23, \n           xend=112.5, yend=23) +\n  annotate(\"segment\", x=123, y=29, \n           xend=121, yend=31) +\n  annotate(\"segment\", x=117.5, y=29, \n           xend=120, yend=31.5) +\n  geom_vline(xintercept=112, linetype=\"dashed\") \np\n\n\n\nAs suggested by the famous author in the field of visualization Edward Tufte, we should seek to maximize the data-ink ratio when displaying data. To that end, we should ask ourselves whether all elements (“ink”) in the chart are necessary to convey our message. Applying this notion to our map, we set limits for the coordinates through the arguments xlim and ylim inside the coord_map() function. This way, as seen in the map above, we “zoom in” to show the relevant data and remove the area west of meridian 100°. If we did this, we would only lose one observation (i.e. one city) and so it may be worth exploring this alternative. Since we have less “unused” space, we also set the legend background fill to “white” in order to establish a clear contrast between the legend and the map.\nMoreover, some changes to the fill legend may increase the ease of decoding visual information on ranking. In order to enhance discriminability on this scale, we reduce the number of categories from six to four. This way, it is easier for readers to figure out the order of cities according to their ranking and relate their scores to location and population without having to distinguish between too many values.\nAdditionally, despite being a small detail, the choice of the color palette may not be the most appropriate to depict this ordering. There does not seem to be an obvious reason for why stronger colors are assigned to the extremes in the ranking spectrum (i.e. highest- and lowest-ranked cities). Allocating different levels of saturation or lightness of the same hue could be an alternative way of visually conveying the ordering of cities according to growth potential. In the code above, we simply replace the colors for the original ‘40-60’ and ‘60-80’ categories with two lighter shades of blue under the scale_fill_stepsn()function.\nFurthermore, the fact that eight cities are annotated on the map and only five are included in the bottom left textbox is not too easy to realize at first and both annotations seem to include redundant information. By removing the textbox and adding the rank numbers directly to the cities annotated on the map, we simplify the visualization without removing essential information.\nFinally, in order to emphasize the idea that cities with the highest growth potential are on the coast, we might want to insert a vertical line (we use geom_vline()) at the (arbitrary) level of longitude 112°. This way we can see that among the 10 cities with the highest growth potential, only Chengdu (i.e. the “dark blue” bubble farthest west) is to the west of this longitude.\nAlternative visualization\nThe final section of this post proposes an alternative visualization to represent the relationship between the population, location and growth potential of cities in China. One possibility is the scatterplot shown below. We plot the ranking on the x-axis and population on the y-axis. We also use the geom_point() function just like in the original map.\nWe change the title and subtitle of the plot. We also add an informative caption and change the axis labels so as to make it even easier to understand what each variable represents and the message being conveyed. We alter the theme to theme_light() so as to increase the contrast between the background and the text and data points.\nThis time, by using the scale_y_continuous() function, we change the default scientific notation so that the axis itself shows population in ‘M’ (million). We then set the specifics for the font, title, subtitle, caption, axis title and axis text under the theme() function.\n\n\np <- ggplot(fulloutputclean) +\n  aes(x=Ranking, y=Population) +\n  geom_point() +\n  labs(title=\"Urbanization and economic growth in China\",      \n       subtitle=\"Emerging city ranking, 2022\",\n       caption=\"Coastal cities have highest growth potential\",\n       x=\"City Growth Ranking\",\n       y=\"City Population\") +\n  scale_y_continuous(labels=scales::label_number_si()) +\n  theme_light() +\n  theme(text=element_text(family=\"IBM Plex Sans\"),\n        plot.title=element_text(face=\"bold\", size=26),                                                            \n        plot.subtitle=element_text(size=20),\n        plot.caption=element_text(size=20, hjust=0),\n        axis.title=element_text(size=15),\n        axis.text=element_text(size=13))\np\n\n\n\nIn general, we can see that higher growth potential (lower value for the variable “City Growth Ranking”) tends to be associated with a larger population, which was perhaps harder to see on the original map. However, we still need to include information about the location (coordinates) of cities. Within the location variable, it seems that longitude is the most important factor: cities closer to the coastline (i.e. farther east, or higher values of x) appear to have higher growth potential. These high-ranking cities seem to be distributed more or less evenly from north to south, hence we disregard the latitude information for simplicity. Therefore, we could encode longitude through the color of the points by highlighting in blue those points representing cities that are located east of the (again, arbitrarily chosen) 112° meridian. We also add a text label (on top of a white rectangle constructed with geom_rect()) to indicate that blue dots represent cities farther east in China.\n\n\nannotation <- dplyr::filter(fulloutputclean, Longitude>112)\np <- p + \n    geom_point(data=annotation, color=\"#6495ED\") +\n    geom_rect(aes(xmin=79, xmax=130, ymin=15000000, ymax=16600000),\n              fill=\"white\",\n              color = \"#6495ED\") +\n    geom_text(aes(x=80, y=15800000, \n                  label=\"Cities to the east of the 112th meridian\"),\n              size=6, hjust=0, vjust=0, color = \"#6495ED\")\np\n\n\n\nFinally, to highlight the top 5 cities from the original map, We construct another annotation and insert it as an argument in the geom_text() function. We adjust the size and horizontal justification of the labels, and make them bold.\n\n\nannotation2 <- dplyr::filter(fulloutputclean, Ranking<=5)\np <- p +\n  geom_text(aes(label=City),\n            annotation2,\n            hjust=-0.2, nudge_x=0.1, size=6,\n            family = \"IBM Plex Sans\",\n            fontface=\"bold\") \np\n\n\n\nWe can see that highly-ranked cities are all near the coast (i.e. all highlighted in blue because they are east of the meridian 112°), but there is a rather wide range of population sizes among the top 5. For instance, both Shanghai and Suzhou have very high growth potential. Yet, the former has more than 3.5 times the population of the latter. This is because many variables are included in the calculation of scores. For instance, Hangzhou tops the ranking due to its nature as a big tech hub. While government regulation targeting tech firms may hamper its medium- and long-term growth, other factors such as its fiscal position, economic diversity or metropolitan development jointly yield a high growth potential for the city.\nAll in all, as the caption suggests, it seems that location (whose effect is hard to separate from other historical, economic and environmental factors) is more important than current population as a predictor of future economic growth.\n\n\n\n",
    "preview": "projects/2022/100489635/economist.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 1118
  },
  {
    "path": "projects/gapminder/",
    "title": "Gapminder's World Health Chart",
    "description": "This tutorial reproduces one of the most popular data visualizations ever\nand serves as an example project for this course",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-09-09",
    "categories": [
      "example"
    ],
    "contents": "\n\nContents\nGetting the data\nBuilding the chart\nCoordinates and axes\nTheme\nAnnotations\nData\nLegend\n\nFinal result\nSingle year\nMultiple years, static\nMultiple years, dynamic\n\n\nHans Rosling was a Swedish professor of International Health at the Karolinska Institute,\nand co-founder of the Gapminder Foundation,\nwhich developed the Trendalyzer software for animated data visualization.\nHis famous 2006 TED Talk,\nDebunking myths about the “third world”,\nhas inspired millions over the world thanks to his celebrated bubble chart\ndepicting the relationship between life expectancy and income.\nGapminder’s World Health Chart. Figure from gapminder.org.The goal of this tutorial is to replicate this famous data visualization step by step.\nGetting the data\nThe data consists of yearly observations of life expectancy values and GDP per capita for a number of countries in the world.\nThis is a very popular dataset.\nWe could download the data directly from the Gapminder homepage,\nbut we will use instead the gapminder package,\nwhich contains ready-to-use data for 142 countries from 1952 to 2007.\n\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\n\nLet’s take a glimpse of the data:\n\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   <fct> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afgh…\n$ continent <fct> Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, As…\n$ year      <int> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 19…\n$ lifeExp   <dbl> 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39…\n$ pop       <int> 8425333, 9240934, 10267083, 11537966, 13079460, 14…\n$ gdpPercap <dbl> 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, …\n\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Asia    :396   Median :1980   Median :60.71  \n Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.47  \n Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nThese are all the variables we need in a tidy format,\nincluding population counts, which will serve to define the size of the bubbles.\nAs we can see, the original visualization includes Oceania into Asia,\nso let’s do the same for our exercise:\n\n\ngapminder <- gapminder %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\"))\nsummary(gapminder)\n\n        country        continent        year         lifeExp     \n Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.60  \n Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.20  \n Algeria    :  12   Europe  :360   Median :1980   Median :60.71  \n Angola     :  12   Asia    :420   Mean   :1980   Mean   :59.47  \n Argentina  :  12                  3rd Qu.:1993   3rd Qu.:70.85  \n Australia  :  12                  Max.   :2007   Max.   :82.60  \n (Other)    :1632                                                \n      pop              gdpPercap       \n Min.   :6.001e+04   Min.   :   241.2  \n 1st Qu.:2.794e+06   1st Qu.:  1202.1  \n Median :7.024e+06   Median :  3531.8  \n Mean   :2.960e+07   Mean   :  7215.3  \n 3rd Qu.:1.959e+07   3rd Qu.:  9325.5  \n Max.   :1.319e+09   Max.   :113523.1  \n                                       \n\nBuilding the chart\nCoordinates and axes\nWe will work with a single year for now.\nThe base panel consists of simple Cartesian coordinates,\nand depicts life expectancy vs. GDP per capita,\nalthough the x label says the more understandable term “Income”.\n\n\np <- ggplot(filter(gapminder, year == 2007)) +\n  aes(gdpPercap, lifeExp) +\n  ylab(\"Life expectancy\") + xlab(\"Income\")\np\n\n\n\nBoth axes have fixed limits across the whole animation.\nAnother thing to note about the axes is that income is in logarithmic scale with very specific breaks.\nAlso, numbers above 10 thousand are labeled as “10k”.\nThe function scales::label_number comes in handy for this.\nNote that we make some space for annotations on top of the chart\nby setting the maximum limit of the y axis to 95.\n\n\nbreaks <- 500*2^c(0:8)\nklabel <- scales::label_number(suffix=\"k\", scale=1e-3)\nlabels <- c(breaks[1:5], klabel(breaks[-(1:5)]))\n\np <- p + scale_y_continuous(limits=c(10, 95), breaks=seq(10, 90, 10)) +\n  scale_x_log10(limits=range(breaks), breaks=breaks, labels=labels)\np\n\n\n\nTheme\nNote that the theme is very similar to theme_classic, but shows the major grid.\nWe also instruct the theme to remove the legend,\nbecause we will add a custom one later on.\n\n\np <- p + theme_classic() +\n  theme(panel.grid.major=element_line(), legend.position=\"none\")\np\n\n\n\nAdditionally, we could continue to tinker with fonts and other parameters.\nAnnotations\nThe base panel depicts three annotations:\nA big background number indicating the year in the middle.\nFour income levels on the top part, whose breaks seem to be 3k, 8k and 24k.\nThe axes’ units on the top left and bottom right corners.\nFor the background number, we could use annotate with a fixed label,\nbut we will use geom_text instead, even if we overplot it many times,\nso that the year is read from the data.\n\n\np <- p + geom_text(aes(8000, 50, label=year), size=65, color=\"lightgray\")\np\n\n\n\nNext, we add the income levels.\nAdditionally, we will take the liberty of adding vertical lines to clearly demarcate the breaks.\n\n\ntlevel <- c(1300, 5000, 14000, 40000)\nblevel <- c(3000, 8000, 24000)\nilevel <- c(\"INCOME LEVEL 1\", \"LEVEL 2\", \"LEVEL 3\", \"LEVEL 4\")\n\np <- p + geom_vline(xintercept=blevel, color=\"darkgray\") +\n  annotate(\"text\", x=tlevel, y=95, color=\"darkgray\", vjust=0, size=3, label=ilevel) +\n  annotate(\"text\", x=blevel, y=95, color=\"darkgray\", vjust=0, size=5, label=\"◆\")\np\n\n\n\nFinally, let’s add the units to the axes.\n\n\np <- p +\n  annotate(\"text\", x=128000, y=10, hjust=0.95, vjust=1, size=3,\n           label=\"per person (GDP/capita, PPP$ inflation-adjusted\") +\n  annotate(\"text\", x=500, y=95, hjust=0.5, vjust=-1.5, size=3, angle=90, label=\"years\")\np\n\n\n\nData\nThe chart is a type of scatterplot, with one point per country, and colored by continent.\nThe novelty here is that every dot is scaled up to represent the population size.\nAlso, we will add some transparency to the points.\n\n\np <- p + geom_point(aes(color=continent, size=pop), alpha=0.7)\np\n\n\n\nWe are close, but a couple of adjustments are required.\nLet’s add a black line around the points (see shape 21),\nand adjust the range of the bubbles a bit.\n\n\np <- p + geom_point(aes(size=pop), color=\"#333333\", shape=21) +\n  scale_size_area(max_size=25)\np\n\n\n\nFinally, let’s replicate the same color scale.\nWe need to provide them in the same order as the factor levels:\n\n\nlevels(gapminder$continent)\n\n[1] \"Africa\"   \"Americas\" \"Europe\"   \"Asia\"    \n\nTherefore, from the web, page we obtain:\nAfrica: Blue rgb(0, 213, 233) -> #00d5e9\nAmericas: Green rgb(127, 235, 0) -> #7feb00\nEurope: Yellow rgb(255, 231, 0) -> #ffe700\nAsia: Red rgb(255, 88, 114) -> #ff5872\n\n\nccolors <- c(\"#00d5e9\", \"#7feb00\", \"#ffe700\", \"#ff5872\")\np <- p + scale_color_manual(values=ccolors)\np\n\n\n\nLegend\nThis chart has an interesting legend:\nit takes advantage from the fact that continents are easily recognizable to use a map as a legend.\nLet’s replicate it separately using data from ggplot2::map_data.\n\n\nworld <- map_data(\"world\")\nglimpse(world)\n\nRows: 99,338\nColumns: 6\n$ long      <dbl> -69.89912, -69.89571, -69.94219, -70.00415, -70.06…\n$ lat       <dbl> 12.45200, 12.42300, 12.43853, 12.50049, 12.54697, …\n$ group     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,…\n$ order     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16,…\n$ region    <chr> \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Aruba\", \"Arub…\n$ subregion <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\nThis data needs to be tweaked a little bit. We need to:\nFilter out the Antarctica region.\nAdd a new column continent with the help of the countrycode package.\nInclude Oceania into Asia.\nDrop any missing values for continent.\n\n\nworld <- world %>%\n  filter(region != \"Antarctica\") %>%\n  mutate(continent = countrycode::countrycode(\n    sourcevar=region, origin=\"country.name\", destination=\"continent\")) %>%\n  mutate(continent = fct_other(continent, drop=\"Oceania\", other_level=\"Asia\")) %>%\n  drop_na(continent)\n\n\nNow, let’s create the map:\n\n\nlegend <- ggplot(world) +\n  aes(long, lat, group=group, map_id=region, fill=continent) +\n  geom_map(map=world) +\n  scale_fill_manual(values=ccolors) +\n  theme_void() + theme(legend.position=\"none\")\nlegend\n\n\n\nFinal result\nSingle year\nIn summary, so far we have\nBuild steps:\nset coordinates and axes, with custom breaks;\nset an appropriate theme and prevent the default legend from appearing;\nadded several annotations, including year, income levels and axis units;\nadded the data points and made several adjustments, including size and color;\ncreated a custom legend based on a simple colored world map.\nThere are several ways we can merge the main plot and the legend.\nIn this case, let’s add it as an inset with the custom annotation function.\nNote that, in contrast to the regular annotation function,\nthis one doesn’t seem to support logarithmic scales very well.\nAs a result, the user needs to provide the transformed values directly.\n\n\np <- p + annotation_custom(\n  ggplotGrob(legend), xmin=log10(16000), ymin=10, ymax=40)\np\n\n\n\nFinally, we can improve this static single-year visualization by adding some context,\ni.e. a title, a subtitle and a caption.\n\n\np + labs(\n  title = \"World Life Expectancy vs. Income in 2007\",\n  subtitle = paste(\n    \"African countries are still lagging behind in terms of general life\",\n    \"expectancy.\\nEuropean and American countries are the healthiest\",\n    \"and richest countries in the world.\"),\n  caption = \"Source: gapminder.org\"\n)\n\n\n\nMultiple years, static\nSo far, we covered the case for a single year.\nHow could we show the evolution, which is the point in this dataset?\nOf course we can define facets to plot all the years.\nIn the following chart,\ngginnards::delete_layers is used to remove the background year;\nwe switch to the whole dataset using the %+% operator;\ndata is faceted in two rows;\naxis labels are slightly rotated to make space for them.\nNote also that we need to manually scale down a bit the range of the bubbles\nto preserve more or less the previous aspect ratio.\n\n\ngginnards::delete_layers(p, match_type=\"GeomText\") %+% gapminder +\n  facet_wrap(\"year\", nrow=2) +\n  scale_size_area(max_size=7) +\n  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))\n\n\n\nMultiple years, dynamic\nAnd we can of course animate it!\nWe can easily convert any ggplot2 chart to plotly using plotly::ggplotly,\nwhich produces interactive web-based charts.\nFurthermore, if we set the frame aesthetic, it is automatically detected,\nand an animation is added based on the corresponding variable.\n\n\nplotly::ggplotly(p %+% gapminder + aes(frame=year))\n\n\n\n\n\n\n",
    "preview": "projects/gapminder/gapminder_files/figure-html5/titled-1.png",
    "last_modified": "2023-06-07T18:36:12+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 936
  }
]
