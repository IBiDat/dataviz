---
title: "Calgary"
description: |
  A visualization of travel times by bike and transit in the city of Calgary.
categories: "2025"
author: Miguel Agenjo
date: 2025-11-24
output:
  distill::distill_article:
    self_contained: false
---

I'm setting the chunk size to 34.375 because that will allow me to create a file the same height (3300px) as the original one (given default dpi for rmd in html is 96 [3300/96=34.375])

```{r setup, include = FALSE}
knitr::opts_chunk$set(out.width = "100%", fig.align = "center",
  fig.showtext = TRUE, fig.width = 34.375, fig.height = 34.375)
```

```{r set_options}
# Increase the amount of memory available to Java (this is necessary for large
# r5r queries).
options(java.parameters = "-Xmx2G") # I can change "2G" to other value if needed

# Increase timeout to be able to download larg files (necessary to download
# large file with osmextract)
options(timeout = 600) # Timeout 600 seconds (10 minutes)

```


```{r load_libraries}
library(tidyverse)
library(osmdata)
library(geojsonsf) # Used function geojson_sf to convert geojson into sf
library(glossa) # Used function invert_polygon (idea didn't work)
library(sf) # Used function st_intersection
library(funkyheatmap) # Used function geom_rounded_rect
library(ggspatial) # Used in north arrow and ¿SCALE? # NOT USING IT IN THE END
library(geosphere) # To calculate distance for the scale
library(r5r) # To calculate travel times by car
library(osmextract) # To download data necesesary to use r5r
library(ggnewscale)
```

## Replica

### Loading data

```{r load_data}
# Loading travel times
hexagons <- geojson_sf("original_data/hexagons.geojson")

# Loading roads
all_roads_dissolved <- geojson_sf("original_data/all_roads_dissolved.geojson")

# Loading water
water <- geojson_sf("original_data/water.geojson")
```


**EXPLAIN THIS BETTER IN THE FINAL VERSION** The id range in `hexagons`, `bike_times`, and `transit_times` are the same. Since the `hexagons` dataset includes `bike_times` and `transit_times`, it is most likely an object created by: 1) dividing the map area in hexagons, 2) getting the travel times for those Hexagons, 3) joining those two databases using the id column. I might be able **I REMOVED THE EXPLANATION OF WHY I WAS TRYING TO CONVERT MULTILINESTRING INTO POLYGON** When searching how to convert a multilinestring into a polygon, I came across [this post](https://stackoverflow.com/questions/69224441/find-intersection-between-multilinestring-and-polygons-sf-r), which mentions the funcion `st_intersection()`. This made me think i can maybe get an object that is the intersection between `hexagons` and `all_roads_dissolved`. Maybe I can plot this directly (not a full hexagon layer underneath). But if that doesn't work, the background hexagons idea can still work. In the documentation for st_intersection() there are other functions that may be helpful.

```{r prepare_data}
# This took several minutes to run, so I'll save the object and
# avoid running the line again.
# hexroads_intersection <- st_intersection(all_roads_dissolved, hexagons)
# SHOULD I LEAVE IT WITHOUT SAVE/LOAD IN THE FINAL VERSION? PROBABLY
# save(hexroads_intersection, file = "hexroads_intersection.RData")
load("hexroads_intersection.RData")

# NOTE: I'm computing time_difference as time by bike minus time by transit. That means that:
# - Negative numbers = faster by bike
# - Positive numbers = faster by transit
hexroads_intersection <- hexroads_intersection |> 
  mutate(
    "time_difference" = b_travel_time - travel_time,
    "time_color" = case_when(
      time_difference <= -30 ~ "-2", # Bike 30 or more minutes faster
      time_difference <= -10 ~ "-1", # Bike 10 or more minutes faster (<30)
      time_difference < 10 ~ "0", # Between -10 and 10 (both not included)
      time_difference < 30 ~ "1", # Transit 10 or more minutes faster (<30)
      time_difference >= 30 ~ "2"), # Transit 30 or more minutes faster 
    "time_color" = fct( # We make it factor 
                   time_color, levels = c("-2", "-1", "0", "1", "2"))
    )
```

### Plotting map

```{r plot_legendless_map}
# Just the map, without legend
calgary_legendless <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"    # transit >30 min faster
    )
  ) +
  geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth =1.1 # To make water thicker
    ) +
  theme_void()

calgary_legendless # To see it
```

### Plotting first legend

In order to change line spacing see [here](https://stackoverflow.com/questions/39721772/line-height-spacing-for-text-in-ggplot)

In order to see the options for the point annotation see [this](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)

I got the coordinates for calgary tower from [OSM](https://www.openstreetmap.org/way/25719793), and finetuned manually.


```{r plot_legend1}
# We add the font:
sysfonts::font_add_google("Atkinson Hyperlegible", family = "atkinson")
showtext::showtext_auto()

# We see what the bbox coordinates are and be able to adjust the annotation:
st_bbox(hexroads_intersection) # REMOVE FOR FINAL VERSION?

# And then annotate accordingly
calgary_legend1 <- calgary_legendless + 
  annotate( # The main text
    "text",
    x = -114.3100, 
    y = 50.9790,
    label = paste("This map shows the difference",
                  "in the time it takes to reach the",
                  "Calgary Tower     by bike and by",
                  "transit on a weekday morning.",
                  sep="\n"),
    hjust = 0, # Align left
    family = "atkinson",
    size = 12.9,
    lineheight = 1.05, # Line spacing
    color = "#000000"
  ) + 
   annotate(  # The blue point in the legend
    "point",
    x = -114.2420, ##################### LAST: 00
    y = 50.97495,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  )
  
calgary_legend1 # To seeit
  
ggsave(
  "calgary_02.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```




Almost perfect fit. Comparing with gimp changing opacity, it is really really close. I'm not sure I can get closer without using the same font as the original plot (which I cant). Maybe i could make the blue dot in the legend a little bit smaller, just to make it visually more similar.

### Plotting second legend

**CONTINUE FROM HERE**

Found about how to create rounded corners [here](https://albert-rapp.de/posts/ggplot2-tips/11_rounded_rectangles/11_rounded_rectangles.html) package `ggchiklet`. Seems like it is not available for the current version of R.

Another possibility for rounded corners is package `funkyheatmap` see [this](https://search.r-project.org/CRAN/refmans/funkyheatmap/html/geom_rounded_rect.html)


```{r plot_legend2}

######### Legend 2 settings #########
# To make it easier to manually adjust, i will set the settings for the
# rectangle sizes like this, and the plot calling this objects:
# Rectangles:
rectangle_left <- -114.3080
rectangle_top <- 50.9490 
rectangle_width <- 0.0250
rectangle_height <- 0.0050
rectangle_space <- 0.0005
rectangle_color <- c("#d26716", "#f8ad58", "#e3cdd5", "#ca8aba", "#8359a6")
# Minutes:
minute_separation <- 1.66 # Relative to rectangle_height
minute_size <- 9 # In points, not relativ to the map
minute_color <- "#000000"
minute_font <- "atkinson"
# Faster by:
faster_separation <- 0.7 # Relative to rectangle_height
faster_size <- 11 # In points, not relative to the map
faster_color <- "#000000"
faster_font <- "atkinson"
  
# THE COLORS ARE TOO DARK, PICK DIRECTLY FROM ORIGINAL LEGEND (NOT SAME TONE
# AS THE ROADS)

# Create a data frame for legend rectangles according to settings:
legend_rectangles <- tibble(
  xmin = c(
    rectangle_left,
    rectangle_left + (rectangle_width + rectangle_space),
    rectangle_left + 2*(rectangle_width + rectangle_space),
    rectangle_left + 3*(rectangle_width + rectangle_space),
    rectangle_left + 4*(rectangle_width + rectangle_space)),
  xmax = c(
    rectangle_left + rectangle_width,
    rectangle_left + rectangle_width + (rectangle_width + rectangle_space),
    rectangle_left + rectangle_width + (2*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (3*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (4*(rectangle_width + rectangle_space))),
  ymin = rectangle_top - rectangle_height,
  ymax = rectangle_top,
  fill_color = rectangle_color)

legend_rectangles # To see tibble, REMOVE IN FINAL VERSION!!!!!!!!!!!

# Create the dataframe for the minutes relative to previous:
legend_minutes <- tibble(
  label = c("30", "10", "10", "30", "   minutes"), # Like this is relative
  x = c(                                           # with nudge is absolute EXPLAIN BETTER IN FINAL VERSION WHY I DECIDED THIS
    rectangle_left + rectangle_width + (0.5*rectangle_space),
    rectangle_left + (2*rectangle_width) + (1.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space)), 
  y = rectangle_top - rectangle_height * minute_separation,
  hjust = c(0.5, 0.5, 0.5, 0.5, 0) # All justified center, "minutes" left
  )

legend_minutes # To see the tibble QUITALO EN LA VERSIÓN FINAL!!!!!!!!!!

# Create the tibble for the faster by relative to previous:
legend_faster <- tibble(
  label = c("faster by bike", "|", "faster by transit"),
  x = c(
    rectangle_left + (2*rectangle_width) + rectangle_space,
    rectangle_left + (2.5*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (3*rectangle_space)),
  y = rectangle_top + rectangle_height * faster_separation,
  hjust = c(1, 0.5, 0) # Justified: right, center, left
)

########## Plot legend according to above settings ##########
# Plot rounded rectangles for legend:
calgary_legend2 <- calgary_legend1 +
  geom_rounded_rect(
    data = legend_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = rectangle_color,
        radius = 0.3),
    color = NA,  # No border
    show.legend = FALSE
  ) +
  scale_fill_identity() + # So that the fill with rectangle_color
                        # isn't treated as characters, but as the colors
                        # EXPLAIN BETTER WITH DOCUMENTATION FOR FINAL VERSION
    # Now plot the minute numbers:
  geom_text(
    data = legend_minutes,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = minute_size,
    color = minute_color, 
    family = minute_font) +
  geom_text(
    data = legend_faster,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = faster_size,
    color = faster_color,
    family = faster_font
  )

calgary_legend2

ggsave(
  "calgary_03.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```
We now have the first two legends, they fit almost perfectly when comparing in Gimp. Now i need to add the arrow pointing north with scale underneath.

### Plotting third legend (north arrow)

Searching in duckduckgo "how to add north arrow ggplot" i find [here](https://stackoverflow.com/questions/61809382/how-can-i-put-a-scalebar-and-a-north-arrow-on-the-map-ggplot) package `ggspacial`. I read more about [here](https://cran.r-universe.dev/ggspatial/doc/manual.html). But ggspatial defaults don't work. I don't find other packages that could be useful, I'll have to do it manually. Actually, it shouldn't be too hard adding a triangle and a rounded rectangle with a box around them. Searching "add arrow ggplot" i find [here](https://www.statology.org/ggplot-arrows/) and [here](https://teunbrand.github.io/ggarrow/) there's function `arrow` already within ggplot, it can be used with geom_segment. I'll try using that one. It doesn't really work, can only make rounded arrows with this size (I think it is because of the stroke.)

There's a weird behaviour with geom_rounded_rectangle(), when linewidth increases it breack the shape. Since I can't match the linewdith that way, I will plot two rounded_rectangles, a white one on top of a bigger black one, to get the desired effect.

```{r plot_legend3}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_tip_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.9067 ######## last +1
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)






##### PLOTTING NORTH ARROW #####
calgary_legend3 <- calgary_legend2 +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

calgary_legend3 # To see it

ggsave(
  "calgary_04.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```

### Plot forth legend (scale [better than original])

It'll be faster to plot it relative to the box, so I wil use the same settings -> tibble -> plot approach as above.

**I've been thinking the wrong way about how to plot the line for the scale, i was trying to just imitate the position comparing the pictures, but i need to calculate what a km (and 3km) are in my map in order to properly plot the scale!** 

I need to keep investigating, but it is too late already, so I will keep on reviewin this tomorrow:

- https://stackoverflow.com/questions/54453236/compute-distance-and-add-lines-ggplot

- https://gis.stackexchange.com/questions/353798/what-is-the-proper-way-to-calculate-distance-in-km-from-degrees

- https://stackoverflow.com/questions/32363998/function-to-calculate-geospatial-distance-between-two-points-lat-long-using-r 

**THIS LAST ONE MIGHT BE IT** Let's read about `library(geosphere)` 

- https://cran.r-project.org/web/packages/geosphere/index.html

- https://cran.r-project.org/web/packages/geosphere/geosphere.pdf

It seems like `destPoint()` could be it.


```{r plot_legend_4}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

calgary_legend4 <- calgary_legend3 +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_legend4

ggsave(
  "calgary_05.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)


###############
#   Done :)   #
###############
```
And I pretty much have it. It fits basically perfectly comparing in GIMP. I believe the main difference is that the horizontal line in the scale exceeds the ticks in the original plot. I could make that worse to fit the original.

### Plot forth legend (worsened scale to fit original)

We have al the other objects in the chunk above, we just need a longer horizontal line so that it surpasses the ticks on the extremes, plot it on top of the ticks, and make it grey.

```{r plot_legend4_ugly}

#### Wrong horizontal line settings

# Horizontal line:
ugly_scale_length <- 3100 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
ugly_scale_color <- "#676767"
scale_thickness <- 2 # For argument linedwidth = in segment


# Then we compute what the end points of the scale should be with destPoint:
ugly_scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -ugly_scale_length/2)) # Distance in meters 

ugly_scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = ugly_scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
ugly_scale_horizontal <- tibble(
  x = ugly_scale_left$lon,
  xend = ugly_scale_right$lon,
  y = ugly_scale_left$lat,
  yend = ugly_scale_left$lat)


##############################
####### PLOTTING #############
##############################

calgary_legend_ugly <- calgary_legend3 +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
 geom_segment( ### Plotting the ugly horizontal line
    data = ugly_scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = ugly_scale_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_legend_ugly

ggsave(
  "calgary_06.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```

## Alternatives and enhancements

### Fix scale (minor enhancement)

```{r}
# Here I put the code with the correct scale
```


### Add missing water (just aesthetic)

```{r}
# Not sure this is an actual improvement worth working on
```


### From where in 30 minutes or less

#### Less than 30 minutes by bike

```{r}
# Under xx minutes by: 
under <- 30 # Minutes to get to Calgary Tower

# Under xx by bike:
under_mm_bike <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = b_travel_time < under),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) 

under_mm_bike

# Under xx by transit:
under_mm_transit <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = travel_time < under),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) 

under_mm_transit


# Under xx by car:
# under_mm_car <- ggplot() +
#   geom_sf( # We plot the roads:
#     data = hexroads_intersection2,
#     aes(color = car_tt < under),
#     linewidth = 1.1,  # To make roads thicker
#     show.legend = FALSE
#   ) 
# 
# under_mm_car

```

### From where is it faster by car

[OpenRouteService API](https://api.openrouteservice.org/) allows me to calculate travel times by car from my hexagons, but the API Limit is 2000 routes per day, 40 per minute, which means it would take me 4 days to get data for all the hexagons in `intersection_hexagons` (which are the map hexagons that intersect with roads, thus the only one that i need data for). If I needed to recurrently update the plot with up-to-date data this would probably be the best option.

But since I don't, I will use another option: `r5r` [(intro to r5r)](https://cran.r-project.org/web//packages/r5r/vignettes/r5r.html)

#### Collecting car data with r5r

In order to use r5r we need a network dataset from OSM in .pbf format. As the intro to r5r mentions, we can do this using the package `osmextract` [(more about it here)](https://docs.ropensci.org/osmextract/).

```{r}
oe_match("Calgary") # There's a direct match

calgary_oe <- oe_get( # We extract the OSM data and get our .pbf file
  place = "Calgary",
  download_directory = "oe_osm_data/") 

# I plot it to check the data is for the correct city
ggplot(calgary_oe) +
  geom_sf(linewidth = 0.1, color = "black") +
  theme_minimal()
# It is data for the correct city.
```

Now that we have the .pbf file we can calculate car travel times with `r5r`:

```{r}
# We build the network that we will need to pass into travel_time_matrix() 
r5r_network <- build_network("oe_osm_data/")

# travel_time_matrix needs points with longitudes and latitudes in both
# origins and destinations argument. But our hexagons are not points, so we
# will compute the center of the hexagons and create a tibble. We can compute
# only hexagons with roads to avoid unnecessary computation.
hexagons_center <- as_tibble(
  st_coordinates(st_centroid(hexroads_intersection$geometry)))

origins_tibble <- tibble(
  id = hexroads_intersection$id,
  lon = hexagons_center$X,
  lat = hexagons_center$Y,
)

# We get the coordinates for calgary tower on a data frame to be able to
# pass it into travel_time_matrix:
calgary_tower <- tibble(
  id = "tower",
  lon = -114.0631,
  lat = 51.04465)

# This takes long to compute (45') so I'll save the object so as to avoid
# running it again.
# ttm <- travel_time_matrix(
#   r5r_network = r5r_network, # We pass the network we just created
#   origins = origins_tibble,
#   destination = calgary_tower,
#   mode = "CAR",
#   departure_datetime = as.POSIXct("2024-11-29 08:00:00"),
# )
# save(ttm, file = "ttm.RData")
load("ttm.RData")
```


We now have the car travel times, now we can add them to to `hexroads_intersection`.

```{r}
# Car faster by more than xx minutes:
cf <- 15 # Minutes

# Less than xx minutes by bike or transit shows bike or transit (and not car).
min <- 0 # Minutes

hexroads_intersection2 <- hexroads_intersection |>
  mutate("id" = as.character(id)) |> 
  left_join(ttm, by = c("id" = "from_id")) |> # Join car travel times
  select(-c(fid, to_id)) |>  # Remove useless columns
  mutate( # Rename travel_time_p50 to car travel time (car_tt)
    "car_tt" =  travel_time_p50,
    "time_color_car" = case_when( # When car more than 10 minutes faster: "9"
      b_travel_time <= min | travel_time <= min ~ time_color,
      car_tt - b_travel_time < -cf & car_tt - travel_time < -cf ~ "9",
      car_tt - b_travel_time >= -cf | car_tt - travel_time >= -cf ~ time_color))
```

#### Plotting map with car data

```{r plot_map_car}
calgary_car <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection2,
    aes(color = time_color_car),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886",   # transit >30 min faster
      "9" = "#000000"     # car more than 10 minutes faster than both
    )
  )

calgary_car

```
## Notas hablando con Iñaki:

- Añadir anotaciones en el mapa que ayuden a leerlo (desde aquí hasta aquí es más de 30' más rápido ir en transporte público; desde aquí hasta aquí es más de 10' más rápido ir en bici).

- Añadir ischornes de tiempo en bici (o plotear el fondo del mapa con el tiempo en bici), y añadir líneas que digan "desde aquí es más rentable coger la bici, desde aquí es más rentable coger el tranporte público").

- Menciona buscar alguna manera de solucionar los errores.



## [Changed] New idea: bike in roads, transit difference in map

I've decided there will be discrete isochrones, continuous heatmap is an unreadable total mess.

I've been trying different improvement ideas for the legend and travel times (like adding new rectangle squares to the legend to be more precise with the difference), but making it more complex doesn't help. Doesn't add much new information, and makes it really really hard to plot the colors.



## Calculating isochrones (fastest):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r}
# SAME BUT FASTEST TRAVEL TIME
hexagons2 <- hexagons |> 
  mutate(
    "fastest_travel_time" = case_when(
      b_travel_time > travel_time ~ travel_time,
      travel_time > b_travel_time ~ b_travel_time),
    "fastest_travel_time" = case_when(
      fastest_travel_time < 20 ~ 1,
      fastest_travel_time < 40 ~ 2,
      fastest_travel_time < 60 ~ 3,
      fastest_travel_time < 80 ~ 5,
      fastest_travel_time >= 80 ~ 6)) |> 
  filter(fastest_travel_time != 6) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
hex_zones <- hexagons2 |>
  group_by(fastest_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler
```



### Black fastest (will not do)

Plotting the actual isocrhones is a mess: there's lots of lines, they don't form concentric areas, but there are islands within each other (probably due to public transport). Removing those islands to make the map readable would be liying with the data (that's real information, there's public transport stops there, i can't just omit those for the shake of the map looking good!)

```{r improved_black}
## Plotting in black background:

black <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = hex_zones, 
    aes(fill = fastest_travel_time),
    color = NA,
    alpha = 0.7,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "#aa5312", # Central isochrone
                      high = "black", # Outer isochrone
                      na.value = "black") +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "white",   # bike >30 min faster
      "-1" = "white",   # bike 10–30 min faster
      "0"  = "lightgray",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"    # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = hex_zones, 
    aes(fill = NA),
    color = "#ce9d78", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black # To see it
```



### White fastest (will not do)

```{r}
## Plotting in white background:

white <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = hex_zones, 
    aes(fill = fastest_travel_time), 
    color = NA, 
    alpha = 0.075,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "black", # Central isochrone
    high = "#ffffff", # Outer isochrone
    na.value = "white"
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = hex_zones, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.5
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white # To see it
```






## Calculating isochrones (bike):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r compute_isochrones}
# After quite some time of trial and error, 20' is the right balance between 
# making the map informative, and a total line mess.

# Calculating hexagons under each isochrone:
hexagons2 <- hexagons |> 
  mutate("iso_b_travel_time" = case_when(
      b_travel_time < 20 ~ 1,
      b_travel_time < 40 ~ 2,
      b_travel_time < 60 ~ 3,
      b_travel_time < 80 ~ 5,
      b_travel_time >= 80 ~ 6)) |> 
  filter(iso_b_travel_time != 6) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
hex_zones <- hexagons2 |>
  group_by(iso_b_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler
```
### Black bike

```{r improved_black}
## Plotting in black background:

black <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = hex_zones, 
    aes(fill = iso_b_travel_time),
    color = NA,
    alpha = 0.3,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "white", # Central isochrone
                      high = "black", # Outer isochrone
                      na.value = "black") +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = hex_zones, 
    aes(fill = NA),
    color = "#ce9d78", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black # To see it
```




### White bike

```{r improved_white}
## Plotting in white background:

white <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = hex_zones, 
    aes(fill = iso_b_travel_time), 
    color = NA, 
    alpha = 0.075,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "black", # Central isochrone
    high = "#ffffff", # Outer isochrone
    na.value = "white"
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = hex_zones, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.5
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white # To see it
```


## Adding street legend (white, top right)

Actually this would be redundant with the legend, why not plot the legend like this instead?

```{r lollipop_legend_top_right}
# Settings:
# =========

# Lines settings:
lines_x_end <- -113.90 # Same x end for all lines:
lines_width <- 0.5 # Lines width

purple_line_y_end <- 51.12 # Purple line y end + text y + point y
light_purple_line_y_end <- 51.11 # Light purple line y end + text y + point y
gray_line_y_end <- 51.10
yellow_line_y_end <- 51.09 # Yellow line line y end + text y + point y

dot_size <- 10 # Lollipop dot size

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 11
text_h_just <- 0 # 0 left, 0.5 center, 1 right



# Plot the legend:
#=================
white_lines <- white + 
  
#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -113.945,
    xend = lines_x_end,
    y = 51.115,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,       # Using the new variable name
    color = "#6a4886"
  ) +
  annotate( # Purple area text
    "text",
    label = "  +30' faster by transit",
    x = lines_x_end,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -113.965,
    xend = lines_x_end,
    y = 51.095,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    color = "#a36f96"
  ) +
  annotate( # Light purple area text
    "text",
    label = "  10-30' faster by transit",
    x = lines_x_end,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -113.965,                 
    xend = lines_x_end, 
    y = 51.0620,                  
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    color = "#b7a6ac"
  ) +
  annotate( # Gray area text
    "text",
    label = "  Similar travel time", # Standard label for gray
    x = lines_x_end,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -113.992, #-20
    xend = lines_x_end, 
    y = 51.033, # -2
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    color = "#c88c47"
  ) +
  annotate( # Yellow area text
    "text",
    label = "  10-30' faster by bike",
    x = lines_x_end,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) 

white_lines
```


### Adding street legend (white, bottom left)


```{r lollipop_legend_bottom_left}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 0.5 # Lines width

purple_line_y_end <- 50.955 # Purple line y end + text y + point y
light_purple_line_y_end <- 50.965 # Light purple line y end + text y + point y
gray_line_y_end <- 50.975
yellow_line_y_end <- 50.985 # Yellow line line y end + text y + point y

dot_size <- 20 # Lollipop dot size
dot_stroke <- 5

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 9
text_h_just <- 1.2 # 0 left, 0.5 center, 1 right


# Plot the legend:
#=================
white_main_legend <- white + 
    
#### The text paragraph #### 
  annotate(
    "text",
    x = lines_x_end, 
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower        on a weekday morning?",
                  sep="\n"),
    hjust = 0.95,
    family = text_family,
    size = 9.5,
    color = text_color,
    lineheight = 1
  ) +
  
#### The blue point in the legend ####
   annotate(  
    "point",
    x = -114.257, 
    y = 50.9941,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  
#### The blue point in the map (Calgary Tower) ####
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +

##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -114.100, 
    xend = lines_x_end, 
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#c88c47",  
    color = "white", # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow area text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -114.125,                 
    xend = lines_x_end, 
    y = 50.995,
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#b7a6ac",  
    color = "white", # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#a36f96",  
    color = "white", # Border
    stroke = dot_stroke # Border stroke width  
  ) +
  annotate( # Light purple area text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +  

#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,  
    shape = 21,        
    fill = "#6a4886",  
    color = "white", # Border
    stroke = dot_stroke # Border stroke width     
  ) +
  annotate( # Purple area text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )

white_main_legend
```

