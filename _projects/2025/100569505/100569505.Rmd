---
title: "Calgary"
description: |
  A visualization of travel times by bike and transit in the city of Calgary.
categories: "2025"
author: Miguel Agenjo
date: 2025-11-24
output:
  distill::distill_article:
    self_contained: false
---

I'm setting the chunk size to 34.375 because that will allow me to create a file the same height (3300px) as the original one (given default dpi for rmd in html is 96 [3300/96=34.375])

```{r setup, include = FALSE}
knitr::opts_chunk$set(out.width = "100%", fig.align = "center",
  fig.showtext = TRUE, fig.width = 34.375, fig.height = 34.375)
```

```{r load_libraries}
library(tidyverse)
library(osmdata)
library(geojsonsf) # Used function geojson_sf to convert geojson into sf
library(glossa) # Used function invert_polygon (idea didn't work)
library(sf) # Used function st_intersection
library(funkyheatmap) # Used function geom_rounded_rect
library(ggspatial) # Used in north arrow and ¿SCALE?
```



## Loading and plotting (checking json files)

```{r load_data}
# Loading travel times
hexagons <- geojson_sf("original_data/hexagons.geojson")

# Loading roads
all_roads_dissolved <- geojson_sf("original_data/all_roads_dissolved.geojson")

# Loading water
water <- geojson_sf("original_data/water.geojson")
```


**EXPLAIN THIS BETTER IN THE FINAL VERSION** The id range in `hexagons`, `bike_times`, and `transit_times` are the same. Since the `hexagons` dataset includes `bike_times` and `transit_times`, it is most likely an object created by: 1) dividing the map area in hexagons, 2) getting the travel times for those Hexagons, 3) joining those two databases using the id column. I might be able **I REMOVED THE EXPLANATION OF WHY I WAS TRYING TO CONVERT MULTILINESTRING INTO POLYGON** When searching how to convert a multilinestring into a polygon, I came across [this post](https://stackoverflow.com/questions/69224441/find-intersection-between-multilinestring-and-polygons-sf-r), which mentions the funcion `st_intersection()`. This made me think i can maybe get an object that is the intersection between `hexagons` and `all_roads_dissolved`. Maybe I can plot this directly (not a full hexagon layer underneath). But if that doesn't work, the background hexagons idea can still work. In the documentation for st_intersection() there are other functions that may be helpful.

```{r prepare_data}
# This took several minutes to run, so I'll save the object and
# avoid running the line again.
# hexroads_intersection <- st_intersection(all_roads_dissolved, hexagons)
# SHOULD I LEAVE IT WITHOUT SAVE/LOAD IN THE FINAL VERSION? PROBABLY
# save(hexroads_intersection, file = "hexroads_intersection.RData")
load("hexroads_intersection.RData")

# NOTE: I'm computing time_difference as time by bike minus time by transit. That means that:
# - Negative numbers = faster by bike
# - Positive numbers = faster by transit
hexroads_intersection <- hexroads_intersection |> 
  mutate(
    "time_difference" = b_travel_time - travel_time,
    "time_color" = case_when(
      time_difference <= -30 ~ "-2", # Bike 30 or more minutes faster
      time_difference <= -10 ~ "-1", # Bike 10 or more minutes faster (<30)
      time_difference < 10 ~ "0", # Between -10 and 10 (both not included)
      time_difference < 30 ~ "1", # Transit 10 or more minutes faster (<30)
      time_difference >= 30 ~ "2"), # Transit 30 or more minutes faster 
    "time_color" = fct( # We make it factor 
                   time_color, levels = c("-2", "-1", "0", "1", "2"))
    )
```

## Plotting map

```{r plot_legendless_map}
# Just the map, without legend
calgary_legendless <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = TRUE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"    # transit >30 min faster
    )
  ) +
  geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth =1.1 # To make water thicker
    ) +
  theme_void()

calgary_legendless # To see it
```

## Plotting first legend

In order to change line spacing see [here](https://stackoverflow.com/questions/39721772/line-height-spacing-for-text-in-ggplot)

In order to see the options for the point annotation see [this](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)

I got the coordinates for calgary tower from [OSM](https://www.openstreetmap.org/way/25719793), and finetuned manually.


```{r plot_legend1}
# We add the font:
sysfonts::font_add_google("Atkinson Hyperlegible", family = "atkinson")
showtext::showtext_auto()

# We see what the bbox coordinates are and be able to adjust the annotation:
st_bbox(hexroads_intersection) # REMOVE FOR FINAL VERSION?

# And then annotate accordingly
calgary_legend1 <- calgary_legendless + 
  annotate( # The main text
    "text",
    x = -114.3100, 
    y = 50.9790,
    label = paste("This map shows the difference",
                  "in the time it takes to reach the",
                  "Calgary Tower     by bike and by",
                  "transit on a weekday morning.",
                  sep="\n"),
    hjust = 0, # Align left
    family = "atkinson",
    size = 12.9,
    lineheight = 1.05, # Line spacing
    color = "#000000"
  ) + 
   annotate(  # The blue point in the legend
    "point",
    x = -114.2450, ##################### LAST: +10
    y = 50.97495,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  )
  
calgary_legend1 # To seeit
  
ggsave(
  "calgary_02.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```




Almost perfect fit. Comparing with gimp changing opacity, it is really really close. I'm not sure I can get closer without using the same font as the original plot (which I cant). Maybe i could make the blue dot in the legend a little bit smaller, just to make it visually more similar.

## Plotting second legend

**CONTINUE FROM HERE**

Found about how to create rounded corners [here](https://albert-rapp.de/posts/ggplot2-tips/11_rounded_rectangles/11_rounded_rectangles.html) package `ggchiklet`. Seems like it is not available for the current version of R.

Another possibility for rounded corners is package `funkyheatmap` see [this](https://search.r-project.org/CRAN/refmans/funkyheatmap/html/geom_rounded_rect.html)


```{r plot_legend2}

######### Legend 2 settings #########
# To make it easier to manually adjust, i will set the settings for the
# rectangle sizes like this, and the plot calling this objects:
# Rectangles:
rectangle_left <- -114.3080
rectangle_top <- 50.9490 
rectangle_width <- 0.0250
rectangle_height <- 0.0050
rectangle_space <- 0.0005
rectangle_color <- c("#d26716", "#f8ad58", "#e3cdd5", "#ca8aba", "#8359a6")
# Minutes:
minute_separation <- 1.66 # Relative to rectangle_height
minute_size <- 9 # In points, not relativ to the map
minute_color <- "#000000"
minute_font <- "atkinson"
# Faster by:
faster_separation <- 0.7 # Relative to rectangle_height
faster_size <- 11 # In points, not relative to the map
faster_color <- "#000000"
faster_font <- "atkinson"
  
# THE COLORS ARE TOO DARK, PICK DIRECTLY FROM ORIGINAL LEGEND (NOT SAME TONE
# AS THE ROADS)

# Create a data frame for legend rectangles according to settings:
legend_rectangles <- tibble(
  xmin = c(
    rectangle_left,
    rectangle_left + (rectangle_width + rectangle_space),
    rectangle_left + 2*(rectangle_width + rectangle_space),
    rectangle_left + 3*(rectangle_width + rectangle_space),
    rectangle_left + 4*(rectangle_width + rectangle_space)),
  xmax = c(
    rectangle_left + rectangle_width,
    rectangle_left + rectangle_width + (rectangle_width + rectangle_space),
    rectangle_left + rectangle_width + (2*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (3*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (4*(rectangle_width + rectangle_space))),
  ymin = rectangle_top - rectangle_height,
  ymax = rectangle_top,
  fill_color = rectangle_color)

legend_rectangles # To see tibble, REMOVE IN FINAL VERSION!!!!!!!!!!!

# Create the dataframe for the minutes relative to previous:
legend_minutes <- tibble(
  label = c("30", "10", "10", "30", "   minutes"), # Like this is relative
  x = c(                                           # with nudge is absolute EXPLAIN BETTER IN FINAL VERSION WHY I DECIDED THIS
    rectangle_left + rectangle_width + (0.5*rectangle_space),
    rectangle_left + (2*rectangle_width) + (1.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space)), 
  y = rectangle_top - rectangle_height * minute_separation,
  hjust = c(0.5, 0.5, 0.5, 0.5, 0) # All justified center, "minutes" left
  )

legend_minutes # To see the tibble QUITALO EN LA VERSIÓN FINAL!!!!!!!!!!

# Create the tibble for the faster by relative to previous:
legend_faster <- tibble(
  label = c("faster by bike", "|", "faster by transit"),
  x = c(
    rectangle_left + (2*rectangle_width) + rectangle_space,
    rectangle_left + (2.5*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (3*rectangle_space)),
  y = rectangle_top + rectangle_height * faster_separation,
  hjust = c(1, 0.5, 0) # Justified: right, center, left
)

########## Plot legend according to above settings ##########
# Plot rounded rectangles for legend:
calgary_legend2 <- calgary_legend1 +
  geom_rounded_rect(
    data = legend_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = rectangle_color,
        radius = 0.3),
    color = NA,  # No border
    show.legend = FALSE
  ) +
  scale_fill_identity() + # So that the fill with rectangle_color
                        # isn't treated as characters, but as the colors
                        # EXPLAIN BETTER WITH DOCUMENTATION FOR FINAL VERSION
    # Now plot the minute numbers:
  geom_text(
    data = legend_minutes,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = minute_size,
    color = minute_color, 
    family = minute_font) +
  geom_text(
    data = legend_faster,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = faster_size,
    color = faster_color,
    family = faster_font
  )

calgary_legend2

ggsave(
  "calgary_03.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```
We now have the first two legends, they fit almost perfectly when comparing in Gimp. Now i need to add the arrow pointing north with scale underneath.

## Plotting third legend

Searching in duckduckgo "how to add north arrow ggplot" i find [here](https://stackoverflow.com/questions/61809382/how-can-i-put-a-scalebar-and-a-north-arrow-on-the-map-ggplot) package `ggspacial`. I read more about [here](https://cran.r-universe.dev/ggspatial/doc/manual.html). But ggspatial defaults don't work. I don't find other packages that could be useful, I'll have to do it manually. Actually, it shouldn't be too hard adding a triangle and a rounded rectangle with a box around them. Searching "add arrow ggplot" i find [here](https://www.statology.org/ggplot-arrows/) and [here](https://teunbrand.github.io/ggarrow/) there's function `arrow` already within ggplot, it can be used with geom_segment. I'll try using that one. It doesn't really work, can only make rounded arrows with this size (I think it is because of the stroke.)

There's a weird behaviour with geom_rounded_rectangle(), when linewidth increases it breack the shape. Since I can't match the linewdith that way, I will plot two rounded_rectangles, a white one on top of a bigger black one, to get the desired effect.

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

arrow_color <- "red"

# Arrow triangle 
triangle_tip_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.9067 ######## last +1
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.45 # Relative to triangle width
arrow_rectangle_height <- 1.49 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #
# North text:
space <- 0.55 # Relative to triangle height
north_size <- 9
# Box (around the arrow):
box_width <- 2.20 # Relative to triangle width
box_height <- 2.43 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#6f6f6f"
box_line_width <- 0.7


######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height,
)

# Create the tibble for the box around the arrow:
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top



##### PLOTTING NORTH ARROW #####
calgary_legend3 <- calgary_legend2 +
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA) + # No border
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA) + # No border
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = "red", 
    family = "atkinson")+
  geom_rounded_rect(
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = NA,
    color = box_color,
    linewidth = box_line_width) # ALMOST GOT IT, BUT THERE'S A WEIRD BEHAVIOUR
                                # WHEN LINEWIDTH INCREASES

calgary_legend3 # To see it

ggsave(
  "calgary_04.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
#####################
#     Done :)       #
#####################
```
