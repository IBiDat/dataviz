---
title: "Calgary"
description: |
  A visualization of travel times by bike and transit in the city of Calgary.
categories: "2025"
author: Miguel Agenjo
date: 2025-11-24
output:
  distill::distill_article:
    self_contained: false
---

I'm setting the chunk size to 34.375 because that will allow me to create a file the same height (3300px) as the original one (given default dpi for rmd in html is 96 [3300/96=34.375])

```{r setup, include = FALSE}
knitr::opts_chunk$set(out.width = "100%", fig.align = "center",
  fig.showtext = TRUE, fig.width = 26.56057, fig.height = 34.375)
```

```{r set_options}
# Increase the amount of memory available to Java (this is necessary for large
# r5r queries).
options(java.parameters = "-Xmx2G") # I can change "2G" to other value if needed

# Increase timeout to be able to download larg files (necessary to download
# large file with osmextract)
options(timeout = 600) # Timeout 600 seconds (10 minutes)

```


```{r load_libraries}
library(tidyverse)
library(osmdata)
library(geojsonsf) # Used function geojson_sf to convert geojson into sf
library(glossa) # Used function invert_polygon (idea didn't work)
library(sf) # Used function st_intersection
library(funkyheatmap) # Used function geom_rounded_rect
library(ggspatial) # Used in north arrow and ¿SCALE? # NOT USING IT IN THE END
library(geosphere) # To calculate distance for the scale
library(r5r) # To calculate travel times by car
library(osmextract) # To download data necesesary to use r5r
library(ggnewscale)
library(ggtext) # To plot "highlighted" text easily.
library(nngeo) # To remove wholes in isochrones 
library(smoothr) # To smoothen out the borders of the isochrones
library(scales) # To be able to define alpha in certain arguments where it is
                # not possible by default
library(shadowtext) # To add shadows in the isochrone legend
```

## Replica

### Loading data

```{r load_data}
# Loading travel times
hexagons <- geojson_sf("original_data/hexagons.geojson")

# Loading roads
all_roads_dissolved <- geojson_sf("original_data/all_roads_dissolved.geojson")

# Loading water
water <- geojson_sf("original_data/water.geojson")
```


**EXPLAIN THIS BETTER IN THE FINAL VERSION** The id range in `hexagons`, `bike_times`, and `transit_times` are the same. Since the `hexagons` dataset includes `bike_times` and `transit_times`, it is most likely an object created by: 1) dividing the map area in hexagons, 2) getting the travel times for those Hexagons, 3) joining those two databases using the id column. I might be able **I REMOVED THE EXPLANATION OF WHY I WAS TRYING TO CONVERT MULTILINESTRING INTO POLYGON** When searching how to convert a multilinestring into a polygon, I came across [this post](https://stackoverflow.com/questions/69224441/find-intersection-between-multilinestring-and-polygons-sf-r), which mentions the funcion `st_intersection()`. This made me think i can maybe get an object that is the intersection between `hexagons` and `all_roads_dissolved`. Maybe I can plot this directly (not a full hexagon layer underneath). But if that doesn't work, the background hexagons idea can still work. In the documentation for st_intersection() there are other functions that may be helpful.

```{r prepare_data}
# This took several minutes to run, so I'll save the object and
# avoid running the line again.
# hexroads_intersection <- st_intersection(all_roads_dissolved, hexagons)
# SHOULD I LEAVE IT WITHOUT SAVE/LOAD IN THE FINAL VERSION? PROBABLY
# save(hexroads_intersection, file = "hexroads_intersection.RData")
load("hexroads_intersection.RData")

# NOTE: I'm computing time_difference as time by bike minus time by transit. That means that:
# - Negative numbers = faster by bike
# - Positive numbers = faster by transit
hexroads_intersection <- hexroads_intersection |> 
  mutate(
    "time_difference" = b_travel_time - travel_time,
    "time_color" = case_when(
      time_difference <= -30 ~ "-2", # Bike 30 or more minutes faster
      time_difference <= -10 ~ "-1", # Bike 10 or more minutes faster (<30)
      time_difference < 10 ~ "0", # Between -10 and 10 (both not included)
      time_difference < 30 ~ "1", # Transit 10 or more minutes faster (<30)
      time_difference >= 30 ~ "2"), # Transit 30 or more minutes faster 
    "time_color" = fct( # We make it factor 
                   time_color, levels = c("-2", "-1", "0", "1", "2"))
    )
```

### Plotting map

```{r plot_legendless_map}
# Just the map, without legend
calgary_legendless <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"    # transit >30 min faster
    )
  ) +
  geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth =1.1 # To make water thicker
    ) +
  theme_void()

calgary_legendless # To see it
```

### Plotting first legend

In order to change line spacing see [here](https://stackoverflow.com/questions/39721772/line-height-spacing-for-text-in-ggplot)

In order to see the options for the point annotation see [this](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)

I got the coordinates for calgary tower from [OSM](https://www.openstreetmap.org/way/25719793), and finetuned manually.


```{r plot_legend1}
# We add the font:
sysfonts::font_add_google("Atkinson Hyperlegible", family = "atkinson")
showtext::showtext_auto()

# We see what the bbox coordinates are and be able to adjust the annotation:
st_bbox(hexroads_intersection) # REMOVE FOR FINAL VERSION?

# And then annotate accordingly
calgary_legend1 <- calgary_legendless + 
  annotate( # The main text
    "text",
    x = -114.3100, 
    y = 50.9790,
    label = paste("This map shows the difference",
                  "in the time it takes to reach the",
                  "Calgary Tower     by bike and by",
                  "transit on a weekday morning.",
                  sep="\n"),
    hjust = 0, # Align left
    family = "atkinson",
    size = 12.9,
    lineheight = 1.05, # Line spacing
    color = "#000000"
  ) + 
   annotate(  # The blue point in the legend
    "point",
    x = -114.2420, ##################### LAST: 00
    y = 50.97495,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  )
  
calgary_legend1 # To seeit
  
ggsave(
  "calgary_02.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```




Almost perfect fit. Comparing with gimp changing opacity, it is really really close. I'm not sure I can get closer without using the same font as the original plot (which I cant). Maybe i could make the blue dot in the legend a little bit smaller, just to make it visually more similar.

### Plotting second legend

**CONTINUE FROM HERE**

Found about how to create rounded corners [here](https://albert-rapp.de/posts/ggplot2-tips/11_rounded_rectangles/11_rounded_rectangles.html) package `ggchiklet`. Seems like it is not available for the current version of R.

Another possibility for rounded corners is package `funkyheatmap` see [this](https://search.r-project.org/CRAN/refmans/funkyheatmap/html/geom_rounded_rect.html)


```{r plot_legend2}

######### Legend 2 settings #########
# To make it easier to manually adjust, i will set the settings for the
# rectangle sizes like this, and the plot calling this objects:

# Rectangles:
rectangle_left <- -114.3080
rectangle_top <- 50.9490 
rectangle_width <- 0.0250
rectangle_height <- 0.0050
rectangle_space <- 0.0005
rectangle_color <- c("#d26716", "#f8ad58", "#e3cdd5", "#ca8aba", "#8359a6")

# Minutes:
minute_separation <- 1.66 # Relative to rectangle_height
minute_size <- 9 # In points, not relativ to the map
minute_color <- "#000000"
minute_font <- "atkinson"

# Faster by:
faster_separation <- 0.7 # Relative to rectangle_height
faster_size <- 11 # In points, not relative to the map
faster_color <- "#000000"
faster_font <- "atkinson"
  
# THE COLORS ARE TOO DARK, PICK DIRECTLY FROM ORIGINAL LEGEND (NOT SAME TONE
# AS THE ROADS)

# Create a data frame for legend rectangles according to settings:
legend_rectangles <- tibble(
  xmin = c(
    rectangle_left,
    rectangle_left + (rectangle_width + rectangle_space),
    rectangle_left + 2*(rectangle_width + rectangle_space),
    rectangle_left + 3*(rectangle_width + rectangle_space),
    rectangle_left + 4*(rectangle_width + rectangle_space)),
  xmax = c(
    rectangle_left + rectangle_width,
    rectangle_left + rectangle_width + (rectangle_width + rectangle_space),
    rectangle_left + rectangle_width + (2*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (3*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (4*(rectangle_width + rectangle_space))),
  ymin = rectangle_top - rectangle_height,
  ymax = rectangle_top,
  fill_color = rectangle_color)

legend_rectangles # To see tibble, REMOVE IN FINAL VERSION!!!!!!!!!!!

# Create the dataframe for the minutes relative to previous:
legend_minutes <- tibble(
  label = c("30", "10", "10", "30", "   minutes"), # Like this is relative
  x = c(                                           # with nudge is absolute EXPLAIN BETTER IN FINAL VERSION WHY I DECIDED THIS
    rectangle_left + rectangle_width + (0.5*rectangle_space),
    rectangle_left + (2*rectangle_width) + (1.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space)), 
  y = rectangle_top - rectangle_height * minute_separation,
  hjust = c(0.5, 0.5, 0.5, 0.5, 0) # All justified center, "minutes" left
  )

legend_minutes # To see the tibble QUITALO EN LA VERSIÓN FINAL!!!!!!!!!!

# Create the tibble for the faster by relative to previous:
legend_faster <- tibble(
  label = c("faster by bike", "|", "faster by transit"),
  x = c(
    rectangle_left + (2*rectangle_width) + rectangle_space,
    rectangle_left + (2.5*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (3*rectangle_space)),
  y = rectangle_top + rectangle_height * faster_separation,
  hjust = c(1, 0.5, 0) # Justified: right, center, left
)

########## Plot legend according to above settings ##########
# Plot rounded rectangles for legend:
calgary_legend2 <- calgary_legend1 +
  geom_rounded_rect(
    data = legend_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = rectangle_color,
        radius = 0.3),
    color = NA,  # No border
    show.legend = FALSE
  ) +
  scale_fill_identity() + # So that the fill with rectangle_color
                        # isn't treated as characters, but as the colors
                        # EXPLAIN BETTER WITH DOCUMENTATION FOR FINAL VERSION
    # Now plot the minute numbers:
  geom_text(
    data = legend_minutes,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = minute_size,
    color = minute_color, 
    family = minute_font) +
  geom_text(
    data = legend_faster,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = faster_size,
    color = faster_color,
    family = faster_font
  )

calgary_legend2

ggsave(
  "calgary_03.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```
We now have the first two legends, they fit almost perfectly when comparing in Gimp. Now i need to add the arrow pointing north with scale underneath.

### Plotting third legend (north arrow)

Searching in duckduckgo "how to add north arrow ggplot" i find [here](https://stackoverflow.com/questions/61809382/how-can-i-put-a-scalebar-and-a-north-arrow-on-the-map-ggplot) package `ggspacial`. I read more about [here](https://cran.r-universe.dev/ggspatial/doc/manual.html). But ggspatial defaults don't work. I don't find other packages that could be useful, I'll have to do it manually. Actually, it shouldn't be too hard adding a triangle and a rounded rectangle with a box around them. Searching "add arrow ggplot" i find [here](https://www.statology.org/ggplot-arrows/) and [here](https://teunbrand.github.io/ggarrow/) there's function `arrow` already within ggplot, it can be used with geom_segment. I'll try using that one. It doesn't really work, can only make rounded arrows with this size (I think it is because of the stroke.)

There's a weird behaviour with geom_rounded_rectangle(), when linewidth increases it breack the shape. Since I can't match the linewdith that way, I will plot two rounded_rectangles, a white one on top of a bigger black one, to get the desired effect.

```{r plot_legend3}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_tip_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.9067 ######## last +1
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)






##### PLOTTING NORTH ARROW #####
calgary_legend3 <- calgary_legend2 +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

calgary_legend3 # To see it

ggsave(
  "calgary_04.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```

### Plot forth legend (scale [better than original])

It'll be faster to plot it relative to the box, so I wil use the same settings -> tibble -> plot approach as above.

**I've been thinking the wrong way about how to plot the line for the scale, i was trying to just imitate the position comparing the pictures, but i need to calculate what a km (and 3km) are in my map in order to properly plot the scale!** 

I need to keep investigating, but it is too late already, so I will keep on reviewin this tomorrow:

- https://stackoverflow.com/questions/54453236/compute-distance-and-add-lines-ggplot

- https://gis.stackexchange.com/questions/353798/what-is-the-proper-way-to-calculate-distance-in-km-from-degrees

- https://stackoverflow.com/questions/32363998/function-to-calculate-geospatial-distance-between-two-points-lat-long-using-r 

**THIS LAST ONE MIGHT BE IT** Let's read about `library(geosphere)` 

- https://cran.r-project.org/web/packages/geosphere/index.html

- https://cran.r-project.org/web/packages/geosphere/geosphere.pdf

It seems like `destPoint()` could be it.


```{r plot_legend_4}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

calgary_legend4 <- calgary_legend3 +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_legend4

ggsave(
  "calgary_05.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)


###############
#   Done :)   #
###############
```
And I pretty much have it. It fits basically perfectly comparing in GIMP. I believe the main difference is that the horizontal line in the scale exceeds the ticks in the original plot. I could make that worse to fit the original.

### Plot forth legend (worsened scale to fit original)

We have al the other objects in the chunk above, we just need a longer horizontal line so that it surpasses the ticks on the extremes, plot it on top of the ticks, and make it grey.

```{r plot_legend4_ugly}

#### Wrong horizontal line settings

# Horizontal line:
ugly_scale_length <- 3100 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
ugly_scale_color <- "#676767"
scale_thickness <- 2 # For argument linedwidth = in segment


# Then we compute what the end points of the scale should be with destPoint:
ugly_scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -ugly_scale_length/2)) # Distance in meters 

ugly_scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = ugly_scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
ugly_scale_horizontal <- tibble(
  x = ugly_scale_left$lon,
  xend = ugly_scale_right$lon,
  y = ugly_scale_left$lat,
  yend = ugly_scale_left$lat)


##############################
####### PLOTTING #############
##############################

calgary_legend_ugly <- calgary_legend3 +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
 geom_segment( ### Plotting the ugly horizontal line
    data = ugly_scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = ugly_scale_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_legend_ugly

ggsave(
  "calgary_06.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```

## Alternatives and enhancements

### Fix scale (minor enhancement)

```{r}
# Here I put the code with the correct scale
```


### Add missing water (just aesthetic)

```{r}
# Not sure this is an actual improvement worth working on
```




#### Less than 30 minutes by bike

```{r}
# Under xx minutes by: 
under <- 30 # Minutes to get to Calgary Tower

# Under xx by bike:
under_mm_bike <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = b_travel_time < under),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) 

under_mm_bike

# Under xx by transit:
under_mm_transit <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = travel_time < under),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) 

under_mm_transit


# Under xx by car:
# under_mm_car <- ggplot() +
#   geom_sf( # We plot the roads:
#     data = hexroads_intersection2,
#     aes(color = car_tt < under),
#     linewidth = 1.1,  # To make roads thicker
#     show.legend = FALSE
#   ) 
# 
# under_mm_car

```

### From where is it faster by car

[OpenRouteService API](https://api.openrouteservice.org/) allows me to calculate travel times by car from my hexagons, but the API Limit is 2000 routes per day, 40 per minute, which means it would take me 4 days to get data for all the hexagons in `intersection_hexagons` (which are the map hexagons that intersect with roads, thus the only one that i need data for). If I needed to recurrently update the plot with up-to-date data this would probably be the best option.

But since I don't, I will use another option: `r5r` [(intro to r5r)](https://cran.r-project.org/web//packages/r5r/vignettes/r5r.html)

#### Collecting car data with r5r

In order to use r5r we need a network dataset from OSM in .pbf format. As the intro to r5r mentions, we can do this using the package `osmextract` [(more about it here)](https://docs.ropensci.org/osmextract/).

```{r}
oe_match("Calgary") # There's a direct match

calgary_oe <- oe_get( # We extract the OSM data and get our .pbf file
  place = "Calgary",
  download_directory = "oe_osm_data/") 

# I plot it to check the data is for the correct city
ggplot(calgary_oe) +
  geom_sf(linewidth = 0.1, color = "black") +
  theme_minimal()
# It is data for the correct city.
```

Now that we have the .pbf file we can calculate car travel times with `r5r`:

```{r}
# We build the network that we will need to pass into travel_time_matrix() 
r5r_network <- build_network("oe_osm_data/")

# travel_time_matrix needs points with longitudes and latitudes in both
# origins and destinations argument. But our hexagons are not points, so we
# will compute the center of the hexagons and create a tibble. We can compute
# only hexagons with roads to avoid unnecessary computation.
hexagons_center <- as_tibble(
  st_coordinates(st_centroid(hexroads_intersection$geometry)))

origins_tibble <- tibble(
  id = hexroads_intersection$id,
  lon = hexagons_center$X,
  lat = hexagons_center$Y,
)

# We get the coordinates for calgary tower on a data frame to be able to
# pass it into travel_time_matrix:
calgary_tower <- tibble(
  id = "tower",
  lon = -114.0631,
  lat = 51.04465)

# This takes long to compute (45') so I'll save the object so as to avoid
# running it again.
# ttm <- travel_time_matrix(
#   r5r_network = r5r_network, # We pass the network we just created
#   origins = origins_tibble,
#   destination = calgary_tower,
#   mode = "CAR",
#   departure_datetime = as.POSIXct("2024-11-29 08:00:00"),
# )
# save(ttm, file = "ttm.RData")
load("ttm.RData")
```


We now have the car travel times, now we can add them to to `hexroads_intersection`.

```{r}
# Car faster by more than xx minutes:
cf <- 15 # Minutes

# Less than xx minutes by bike or transit shows bike or transit (and not car).
min <- 0 # Minutes

hexroads_intersection2 <- hexroads_intersection |>
  mutate("id" = as.character(id)) |> 
  left_join(ttm, by = c("id" = "from_id")) |> # Join car travel times
  select(-c(fid, to_id)) |>  # Remove useless columns
  mutate( # Rename travel_time_p50 to car travel time (car_tt)
    "car_tt" =  travel_time_p50,
    "time_color_car" = case_when( # When car more than 10 minutes faster: "9"
      b_travel_time <= min | travel_time <= min ~ time_color,
      car_tt - b_travel_time < -cf & car_tt - travel_time < -cf ~ "9",
      car_tt - b_travel_time >= -cf | car_tt - travel_time >= -cf ~ time_color))
```

#### Plotting map with car data

```{r plot_map_car}
calgary_car <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection2,
    aes(color = time_color_car),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886",   # transit >30 min faster
      "9" = "#000000"     # car more than 10 minutes faster than both
    )
  )

calgary_car

```
## Notas hablando con Iñaki:

- Añadir anotaciones en el mapa que ayuden a leerlo (desde aquí hasta aquí es más de 30' más rápido ir en transporte público; desde aquí hasta aquí es más de 10' más rápido ir en bici).

- Añadir ischornes de tiempo en bici (o plotear el fondo del mapa con el tiempo en bici), y añadir líneas que digan "desde aquí es más rentable coger la bici, desde aquí es más rentable coger el tranporte público").

- Menciona buscar alguna manera de solucionar los errores.



## [Changed] New idea: bike in roads, transit difference in map

I've decided there will be discrete isochrones, continuous heatmap is an unreadable total mess.

I've been trying different improvement ideas for the legend and travel times (like adding new rectangle squares to the legend to be more precise with the difference), but making it more complex doesn't help. Doesn't add much new information, and makes it really really hard to plot the colors.



## A) Isochrones by fastest

### Calculating isochrones (fastest):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r}
# SAME BUT FASTEST TRAVEL TIME
hexagons2 <- hexagons |> 
  mutate(
    "fastest_travel_time" = case_when(
      b_travel_time > travel_time ~ travel_time,
      travel_time > b_travel_time ~ b_travel_time),
    "fastest_travel_time" = case_when(
      fastest_travel_time < 20 ~ 4,
      fastest_travel_time < 40 ~ 3,
      fastest_travel_time < 60 ~ 2,
      fastest_travel_time >= 60 ~ 1)) |> 
  filter(fastest_travel_time != 1) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)
# Decreasing order because they will be plotted in this order, and i want
# the central ones to be on top.


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
iso_fastest <- hexagons2 |>
  group_by(fastest_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler

# To fix holes [see more details in "Calculating ischrones (bike)"]
iso_fastest <- iso_fastest |>
  st_cast("POLYGON") |>  # We separate multipolygons into polygons
  mutate("area" = st_area(geometry)) |>  # We calculate area of each polygon
  mutate("area" = as.numeric(area)) |> # To be able to filter
  #group_by(fastest_travel_time) |> # We group them by the same travel times
  filter(area > 500000) |>  # We keep only the polygons with a big area (m2)
  #select(-area)  |>  # Remove the area column
  st_remove_holes()


### Making area less sharp ("rounding" hexagons): 
#================================================
# I tried st_buffer (needed st_transform first for the function to work 
# properly, but it didn't look good).
iso_fastest <- iso_fastest |> 
  smooth(method = "ksmooth", smoothness = 4) # smooth(method = chaikin) also
                                             # looks good (more detailed though)  

```



### A.1 - Black fastest

Plotting the actual isocrohones is a mess: there's lots of lines, they don't form concentric areas, but there are islands within each other (probably due to public transport). Removing those islands to make the map readable would be liying with the data (that's real information, there's public transport stops there, i can't just omit those for the shake of the map looking good!)

```{r black_isochr_fastest}
## Plotting in black background:

black_fastest <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_fastest, 
    aes(fill = fastest_travel_time),
    color = NA,
    alpha = 0.2,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "gray", # Outer isochrone
                      high = "cyan" # Inner isochrone
                      ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.6,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#c88c47", # Decided to plot it this color because it makes more
                        # sense (seems like a result of faulty data)
      "-1" = "#c88c47", # bike 10–30 min faster
      "0"  = "#b7a6ac", # similar travel time
      "1"  = "#a36f96", # transit 10–30 min faster
      "2"  = "#6a4886" # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    #color = "#E0FFFF", # I tried a gradient instead, but didn't look good.
    #color = "#c88c47", # Alternative color
    #color = alpha("#47c8c8", 0.7), # Alternative color
    color = alpha("#e5fcff", 0.7), # Alternative color
    fill = NA,
    alpha = 0,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black_fastest # To see it
```


#### Option A) *Lollipops* legend

```{r black_isochr_fastest_street_legend}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y
gray_line_y_end <- 50.965
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
purple_line_y_end <- 50.935 # Purple line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "white"

text_color <- "white" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


?geom_shadowtext

# Plot the legend:
#=================
# black_fastest <- I don't save it because I prefer option B.
  black_fastest + 
    
# The text paragraph
  annotate(
    "text",
    x = lines_x_end + 0.0075,
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 1,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +

# The blue point in the legend
   annotate(  
    "point",
    x = -114.2585,
    y = 50.9935,  
    shape = 21, 
    size = 4,
    color = "#61d7ea",
    stroke = 4.5,
    fill = "white"
  ) +
  
# The blue point in the map (Calgary Tower)
  annotate(  
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, 
    size = 4,
    color = "#61d7ea",
    stroke = 4.5,
    fill = "white"
  ) +

##### Street color legend #####
# Yellow streets
  annotate( # Yellow line
    "segment",
    x = -114.105,
    xend = lines_x_end,
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#f8ad58",
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Gray streets
  annotate( # Gray line
    "segment",
    x = -114.125,
    xend = lines_x_end,
    y = 50.995,
    yend = gray_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#e3cdd5",
    color = dot_stroke_color, 
    stroke = dot_stroke 
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Light purple streets
  annotate( # Light purple  line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#ca8aba",
    color = dot_stroke_color, 
    stroke = dot_stroke
  ) +
  annotate( # Light purple text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Purple streets
  annotate( # Purple line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,
    y = purple_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#8359a6",
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Purple text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )
```


#### Option A) Street legend

We start by plotting the squares in the legend:

```{r}
# Settings
#=========
v_rectangle_top_y <- 50.984
v_rectangle_mid_x <- -114.17
v_rectangle_width <- 0.002
v_rectangle_height <- 0.0145
v_rectangle_space <- 0.0005
v_rectangle_radius <- 0.3
v_rectangle_fill <- c("#c88c47", "#b7a6ac", "#a36f96", "#6a4886")


  
# We calculate the coordinates:
#==============================
v_rectangles <- tibble(
  "xmin" = v_rectangle_mid_x - (v_rectangle_width/2),
  "xmax" = v_rectangle_mid_x + (v_rectangle_width/2),
  "ymin" = c(
    v_rectangle_top_y - v_rectangle_height,
    v_rectangle_top_y - ((2*v_rectangle_height) + v_rectangle_space),
    v_rectangle_top_y - ((3*v_rectangle_height) + (2*v_rectangle_space)),
    v_rectangle_top_y - ((4*v_rectangle_height) + (3*v_rectangle_space))),
  "ymax" = c(
    v_rectangle_top_y,
    v_rectangle_top_y - (v_rectangle_height + v_rectangle_space),
    v_rectangle_top_y - 2*(v_rectangle_height + v_rectangle_space),
    v_rectangle_top_y - 3*(v_rectangle_height + v_rectangle_space)),
  "fill" = v_rectangle_fill
  )

# We plot the rectangles:
#========================
black_fastest <- black_fastest +
  geom_rounded_rect(
    data = v_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = fill),
    radius = v_rectangle_radius,
    show.legend = FALSE
  ) +
  scale_fill_identity()

black_fastest
```

**A little extra: some arrows made out of streets**. First step: creating the "arrow" that we will plot next to the squares.

```{r}
# I used this to find an adequate area:
# OPTION A) 
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.082, -114.082, -114.0633, -114.0633) # The sums allow me to
#           + (-0.150)),                                # move fast around the
#     y = c(c(51.044, 51.0465, 51.047, 51.0375)         # map looking for an
#           + (-0.0259)),                               # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 1)

# OPTION B)
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.077, -114.077, -114.0633, -114.0633) # The sums allow me to
#           + (-0.054)),                                # move fast around the
#     y = c(c(51.044, 51.046, 51.050, 51.040)           # map looking for an
#           + (-0.0835)),                               # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 1)

# OPTION C) I'M USING THIS ONE
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.078, -114.078, -114.0631, -114.0631) # The sums allow me to
#           + (-0.054)),                                # move fast around the
#     y = c(c(51.0445, 51.0455, 51.051, 51.039)         # map looking for an
#           + (-0.08385)),                              # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 0.4)

# We now have the coordinates for the area I will use as arrow.
# We save them as a matrix because that's the object required by
# st_polygon:
selected_coordinates <- as.matrix(
  tibble(
   "x" = c(c(-114.078, -114.078, -114.0631, -114.0631) + (-0.054)),
   "y" = c(c(51.0445, 51.0455, 51.051, 51.039) + (-0.08385))
   ) |> 
  slice(1:4, 1)) # We need to repeat the first row in fifth place to close the
                 # polygon

 
# We create a polygon with those coordinates:
selected_polygon <- st_polygon(x = list(selected_coordinates))

# Then select the corresponding area from hexagons by intersection. But before
# we need to specify that our object uses the same coordinate reference system,
# otherwise st_intersection doesn't work.
selected_polygon <- st_sfc(
  selected_polygon,
  crs = st_crs(all_roads_dissolved))


# We can now get the intersection:
selected_street <- st_intersection(all_roads_dissolved, selected_polygon)

# We will create an object with this sf object, but substracting from its
# coordinates the coordinates of its centroid. That way, it will be easier to 
# move (plot) repeatedly (we can put it wherever we want by summing the
# coordinates that we want to make the centroid).
centroid <- st_centroid(st_union(selected_street))
street_arrow <- st_geometry(selected_street) - centroid
```

We now have our "street arrow", we just need to plot it next to the squares:

```{r}
# Settings
#=========
street_arrow_mid_x <- -0.0055 # From v_rectangle_mid_x
street_arrow_yellow_y <- 0 # From 1/2 height of the vertical rectangles

street_arrow_width <- 0.6

# We calculate the coordinates
#=============================

# Yellow street arrow:
street_arrow_yellow <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - (0.5*v_rectangle_height) + street_arrow_yellow_y)

# Gray street arrow:
street_arrow_gray <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((1.5*v_rectangle_height) + v_rectangle_space) + street_arrow_yellow_y)

# Light purple street arrow:
street_arrow_light_purple <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((2.5*v_rectangle_height) + (2*v_rectangle_space)) + street_arrow_yellow_y)

# Purple street arrow:
street_arrow_purple <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((3.5*v_rectangle_height) + (3*v_rectangle_space)) + street_arrow_yellow_y)

# Assign crs to every arrow again:
street_arrow_yellow <- st_sfc(street_arrow_yellow,
                              crs = st_crs(all_roads_dissolved))

street_arrow_gray <- st_sfc(street_arrow_gray,
                            crs = st_crs(all_roads_dissolved))

street_arrow_light_purple <- st_sfc(street_arrow_light_purple,
                                    crs = st_crs(all_roads_dissolved))

street_arrow_purple <- st_sfc(street_arrow_purple,
                              crs = st_crs(all_roads_dissolved))

# We plot the street arrows:
#===========================

black_fastest <- black_fastest +
  geom_sf( 
    data = street_arrow_yellow,
    color = "#c88c47",
    linewidth = street_arrow_width
  ) +
  geom_sf(
    data = street_arrow_gray,
    color = "#b7a6ac",
    linewidth = street_arrow_width
  ) +
  geom_sf(
    data = street_arrow_light_purple,
    color = "#a36f96",
    linewidth = street_arrow_width
  ) +
  # 4. Purple Arrow
  geom_sf(
    data = street_arrow_purple,
    color = "#6a4886",
    linewidth = street_arrow_width
  )

black_fastest
```

We then plot the text for the squares:

```{r}
# Settings:
# =========
v_rect_text_color <- "white"
v_rect_text_size <- 7.5
v_rect_text_family <- "atkinson"

v_rect_h_just <- 1 # Right
v_rect_text_h_space <- 0.020
v_rect_text_text <- c("10-30' faster by bike",
                      "similar travel time",
                      "10-30' faster by transit",
                      "+30' faster by transit")
  
# We calculate the coordinates:
#==============================
v_rect_text <- tibble(
  "x" = v_rectangle_mid_x - v_rect_text_h_space,
  "y" = v_rectangles$ymax - (v_rectangle_height/2),
  "label" = v_rect_text_text,
  "hjust" = v_rect_h_just
)

# We plot the text:
#==================
black_fastest <- black_fastest + 
  geom_text(
    data = v_rect_text,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = v_rect_text_size,
    color = v_rect_text_color,
    family = v_rect_text_family)

black_fastest
```

Finally, we plot the title question (and the Calgary Tower points) on top:

```{r}
# Settings:
# =========

# Text:
question_text_x <- v_rectangle_mid_x + (v_rectangle_width/2)
question_text_y <- 50.9960
question_text_h_space <- 0 # Relative to vertical rectangles mid x

question_text_size <- 10 
question_text_line_height <- 1.1
question_text_color <- "white" 
question_text_family <- "atkinson"
question_text_h_just <- 1 # Right alignment


# Blue point:
legend_blue_point_x <- -114.1886
legend_blue_point_y <- 50.9957

blue_point_size <- 4
blue_point_stroke <- 4.5 
blue_point_fill <- "#61d7ea"
blue_point_color <- "white"



# Plot the legend:
#=================

black_fastest <- black_fastest + 
    
# The question text:
  annotate(
    "text",
    x = question_text_x,
    y = question_text_y,
    label = paste("What's the fastest way to get",
                  "to Calgary Tower     on a",
                  "weekday morning?",
                  sep = "\n"),
    hjust = question_text_h_just,
    family = question_text_family,
    size = question_text_size,
    color = question_text_color,
    lineheight = question_text_line_height
  ) +

# The blue point inside the question:
   annotate(  
    "point",
    x = legend_blue_point_x, 
    y = legend_blue_point_y,  
    shape = 21, 
    size = blue_point_size,
    fill = blue_point_fill,
    color = blue_point_color,
    stroke = blue_point_stroke
    ) +

# The blue point in the map (Calgary Tower)  
  annotate(
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, 
    size = blue_point_size,
    fill = blue_point_fill,
    color = blue_point_color,
    stroke = blue_point_stroke
  )

black_fastest
```



#### Adding isochrone legend

For text following path: https://allancameron.github.io/geomtextpath/reference/geom_textpath.html

```{r black_isochr_fastest_isochr_legend}

# Settings
# ========

# Point
iso_point_size <- 12.5
iso_point_fill <- "black"
iso_point_stroke_width <- 1.5
iso_point_stroke_color <- alpha("#e5fcff", 0.7)

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.00


#white_fastest1 <- 
black_fastest <- black_fastest + 

#### "minutes by bike" curve and text ####
  annotate( # The curve
    "curve",
    x = x_60 - 0.001, #asdf
    y = y_60 + 0.001,
    xend = x_60 + 0.0020,
    yend = y_60 + 0.0065,
    curvature = 0.9,
    linewidth = 0.85,
    color = "white",
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "last",
                  type = "closed")
  ) +
  geom_shadowtext( # The text
    aes(x = x_60 - 0.006,
      y = y_60 + 0.0091,
      label = "minutes\nby fastest\nmode"),
   size = iso_text_size,
   lineheight = 0.85,
   vjust = 0.5,
   hjust = 0.5,
   color = iso_text_color, # Text color
   bg.color = NA, # Shadow color
   bg.r = 0, # Shadow width
   family = "atkinson"
 ) +
  
#### 20' isochrone point and text ####
  annotate(
   "point",
   x = x_20,
   y = y_20,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
   
 ) +
 annotate(
   "text",
   label = "20",
   x = x_20,
   y = y_20,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 ) +
    
#### 40' isochrone point and text ####
  annotate(
   "point",
   x = x_40,
   y = y_40,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
 ) +
 annotate(
   "text",
   label = "40",
   x = x_40,
   y = y_40,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 ) +

#### 60' isochrone point and text ####
 annotate(
   "point",
   x = x_60,
   y = y_60,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
 ) +
 annotate(
   "text",
   label = "60",
   x = x_60,
   y = y_60,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 )
  
  
### Other options for "minutes by fastest mode" #### [Keep them just in case]
# Option A) As line between 40 and 60
 #  geom_shadowtext(
 #   aes(x = x_40-((x_40-x_60)/2), # To place it in the middle of both points
 #      y = y_40+((y_60-y_40)/2),
 #      label = "minutes by\nfastest mode"),
 #   size = 5.4,
 #   lineheight = 0.85,
 #   color = "black", # Text color
 #   bg.color = "white", # Shadow color
 #   bg.r = 0.15, # Shadow width
 #   family = "atkinson",
 #   angle = 58.33
 # )

# Option B) Centered on top
#   geom_shadowtext(
#   aes(x = x_60,
#       y = y_60,
#       label = "minutes by\nfastest mode"),
#   size = iso_text_size,
#   lineheight = 0.85,
#   vjust = -0.67,
#   hjust = 0.5,
#   color = "black", # Text color
#   bg.color = "white", # Shadow color
#   bg.r = 0.15, # Shadow width
#   family = "atkinson"
# )

# #### ALTERNATIVE MINUTES #### [I like them worse, I'll keep them just in case]
#   geom_shadowtext(
#     aes(x = x_20,
#         y = y_20,
#         label = "20"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_40,
#         y = y_40,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_60,
#         y = y_60,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# )

black_fastest
```

#### Adding example point

```{r}
black_fastest <-  black_fastest +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.106,
    size = iso_text_size,
    vjust = 0,
    color = "white",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
#?geom_curve
  annotate(
    "curve",
    x = -114.107,
    y = 51.106,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    color = "white",
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "white", 
    stroke = 2
  ) 

black_fastest
```

#### Finishing

##### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "white"
# Arrow triangle 
triangle_tip_x <- -113.8825 
triangle_half_width <- 0.003325
triangle_bottom_y <- 50.8450 ######## last -100 #MASTEEEERRRRRRR
triangle_height <- 0.0021 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
space <- 0.75 # Relative to triangle height
north_size <- 6
north_color <- "white"

# Outer box:
box_width <- 2.40 # Relative to triangle width
box_height <- 2.75 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "white"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.05 # Range 0-1 (no border, full black box).
inner_box_color <- "black"




######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "N",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
# ===============================
black_fastest <- black_fastest +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    color = north_color, 
    family = "atkinson",
    fontface = "bold"
    )
```

##### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 2000 # In meters
scale_space <- 0.25 # Space between line and box, proportion of box width
scale_color <- "white"
scale_thickness <- 1.3 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.15 # Proportion of the box height
tick_color <- "white"
tick_thickness <- 1.3 # For argument linewidth =

# Kilometers:
km_space <- 0.6 # Space between km and scale, proportion of box height
km_size <- 7 # In points, not relativ to the map
km_color <- "white"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1", "2", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

black_fastest <-  black_fastest +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

black_fastest
```

### A.2 - White fastest 

```{r}
## Plotting in white background:

white_fastest <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_fastest, 
    aes(fill = fastest_travel_time), 
    color = NA, 
    alpha = 0.1,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "gray", # Central isochrone
    high = "black" # Outer isochrone
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.6,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    #color = "#E0FFFF", # I tried a gradient instead, but didn't look good.
    #color = "#c88c47", # Alternative color
    #color = alpha("#47c8c8", 0.7), # Alternative color
    color = alpha("#e5fcff", 0.7), # Alternative color
    fill = NA,
    alpha = 0,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.6
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white_fastest # To see it
```

#### Adding street legend

```{r lollipop_legend_bottom_left_fastest}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

purple_line_y_end <- 50.935 # Purple line y end + text y + point y
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
gray_line_y_end <- 50.965
yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "black"

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


# Plot the legend:
#=================
white_fastest <- white_fastest + 
    
#### The text paragraph #### 
  annotate(
    "text",
    x = lines_x_end, 
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 0.95,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +
  
#### The blue point in the legend ####
   annotate(  
    "point",
    x = -114.255, 
    y = 50.9935,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 7, # Make it a bit smaller than the point in the map
    color = "#000000",
    stroke = 4.03,
    fill = "#69eafe"
  ) +
  
#### The blue point in the map (Calgary Tower) ####
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +

##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -114.105, 
    xend = lines_x_end, 
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#f8ad58",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow area text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -114.125,                 
    xend = lines_x_end, 
    y = 50.995,
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#e3cdd5",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#ca8aba",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width  
  ) +
  annotate( # Light purple area text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +  

#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,  
    shape = 21,        
    fill = "#8359a6",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width     
  ) +
  annotate( # Purple area text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )

white_fastest
```
#### Adding isochrone legend

For text following path: https://allancameron.github.io/geomtextpath/reference/geom_textpath.html

```{r}

# Settings
# ========

# Point
iso_point_size <- 15
iso_point_fill <- "black"
iso_point_alpha <- 1

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.00


#white_fastest1 <- 
white_fastest <- white_fastest + 

#### "minutes by bike" curve and text ####
  annotate( # The curve
    "curve",
    x = x_60 - 0.001, #asdf
    y = y_60 + 0.001,
    xend = x_60 + 0.0015,
    yend = y_60 + 0.007,
    curvature = 0.9,
    linewidth = 0.85
  ) +
  geom_shadowtext( # The text
    aes(x = x_60 - 0.005,
      y = y_60 + 0.009,
      label = "minutes\nby fastest\nmode"),
   size = iso_text_size,
   lineheight = 0.85,
   vjust = 0.5,
   hjust = 0.5,
   color = "black", # Text color
   bg.color = NA, # Shadow color
   bg.r = 0, # Shadow width
   family = "atkinson"
 ) +
  
#### 20' isochrone point and text ####
  annotate(
   "point",
   x = x_20,
   y = y_20,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "20",
   x = x_20,
   y = y_20,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 ) +
    
#### 40' isochrone point and text ####
  annotate(
   "point",
   x = x_40,
   y = y_40,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "40",
   x = x_40,
   y = y_40,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 ) +

#### 60' isochrone point and text ####
 annotate(
   "point",
   x = x_60,
   y = y_60,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "60",
   x = x_60,
   y = y_60,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 )
  
  
### Other options for "minutes by fastest mode" #### [Keep them just in case]
# Option A) As line between 40 and 60
 #  geom_shadowtext(
 #   aes(x = x_40-((x_40-x_60)/2), # To place it in the middle of both points
 #      y = y_40+((y_60-y_40)/2),
 #      label = "minutes by\nfastest mode"),
 #   size = 5.4,
 #   lineheight = 0.85,
 #   color = "black", # Text color
 #   bg.color = "white", # Shadow color
 #   bg.r = 0.15, # Shadow width
 #   family = "atkinson",
 #   angle = 58.33
 # )

# Option B) Centered on top
#   geom_shadowtext(
#   aes(x = x_60,
#       y = y_60,
#       label = "minutes by\nfastest mode"),
#   size = iso_text_size,
#   lineheight = 0.85,
#   vjust = -0.67,
#   hjust = 0.5,
#   color = "black", # Text color
#   bg.color = "white", # Shadow color
#   bg.r = 0.15, # Shadow width
#   family = "atkinson"
# )

# #### ALTERNATIVE MINUTES #### [I like them worse, I'll keep them just in case]
#   geom_shadowtext(
#     aes(x = x_20,
#         y = y_20,
#         label = "20"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_40,
#         y = y_40,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_60,
#         y = y_60,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# )

white_fastest
```

#### Adding example point

```{r}
white_fastest <- white_fastest +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.105,
    size = iso_text_size,
    vjust = 0,
    color = "black",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
#?geom_curve
  annotate(
    "curve",
    x = -114.109,
    y = 51.105,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "black", 
    stroke = 2
  ) 



```
#### Finishing

##### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_tip_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.8650 ######## last +50 #MASTEEEERRRRRRR
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
# ===============================
white_fastest <- white_fastest +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

white_fastest
```

##### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

white_fastest <- white_fastest +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_improved_done
```



## B) Isochrones by bike

### Calculating isochrones (bike):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r compute_isochrones}
# After quite some time of trial and error, 20' is the right balance between 
# making the map informative, and a total line mess.

# Calculating hexagons under each isochrone:
hexagons2 <- hexagons |> 
  mutate("iso_b_travel_time" = case_when(
      b_travel_time < 20 ~ 1,
      b_travel_time < 40 ~ 2,
      b_travel_time < 60 ~ 3,
      b_travel_time < 80 ~ 4,
      b_travel_time >= 80 ~ 5)) |> 
  filter(iso_b_travel_time != 5) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
iso_bike <- hexagons2 |>
  group_by(iso_b_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler

##### A problem to fix: holes.
# ============================
# When plotting iso_bike small holes appear. I need to get those removed.

# I initially tried function st_remove_holes()  from package nngeo directly,
# like this:
# hexzones <- hexzones |> 
#   st_remove_holes()
# But it doesn't work. I think the problem is that our geometry is a
# multipolygon. Annd st_remove_holes remove the holes inside each "polygon"
# of the multipolygon (see the documentation of the function for a more
# visual explanation of what i mean).

# So I tried a new approach: first splitting the multipolygons into single 
# polygons, selecting only the biggest ones (thus removing the small "holes"),
# and then running st_remove_holes.
iso_bike <- iso_bike |>
  st_cast("POLYGON") |>  # We separate multipolygons into polygons
  mutate("area" = st_area(geometry)) |>  # We calculate area of each polygon
  group_by(iso_b_travel_time) |> # We group them by the same travel times
  slice_max(area, n = 1) |>  # We keep only the polygons with the biggest area
  #select(-area)  |>  # Remove the area column
  st_remove_holes()

# We see some warnings. Documentation says "If information gets lost while type
# casting, a warning is raised". I'm not sure what information is lost, but
# everything seems to work fine, so it isn't a problem.



### Making area less sharp ("rounding" hexagons): 
#================================================
# I tried st_buffer (needed st_transform first for the function to work 
# properly, but it didn't look good).
iso_bike <- iso_bike |> 
  smooth(method = "ksmooth", smoothness = 4) # smooth(method = chaikin) also
                                             # looks good (more detailed though)  
```

### Black bike

```{r improved_black}
## Plotting in black background:

black <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_bike, 
    aes(fill = iso_b_travel_time),
    color = NA,
    alpha = 0.3,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "white", # Central isochrone
                      high = "black" # Outer isochrone
  )+
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_bike, 
    aes(fill = NA),
    color = "#ce9d78", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black # To see it
```




### White bike

```{r improved_white}
## Plotting in white background:

white <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_bike, 
    aes(fill = iso_b_travel_time), 
    color = NA, 
    alpha = 0.1,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "black", # Central isochrone
    high = "white" # Outer isochrone
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_bike, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.6
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white # To see it
```



### Adding street legend (white, bottom left) (BIKE)


```{r lollipop_legend_bottom_left_bike}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

purple_line_y_end <- 50.935 # Purple line y end + text y + point y
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
gray_line_y_end <- 50.965
yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "black"

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


# Plot the legend:
#=================
white_main_legend <- white + 
    
#### The text paragraph #### 
  annotate(
    "text",
    x = lines_x_end, 
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 0.95,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +
  
#### The blue point in the legend ####
   annotate(  
    "point",
    x = -114.255, 
    y = 50.9935,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 7, # Make it a bit smaller than the point in the map
    color = "#000000",
    stroke = 4.03,
    fill = "#69eafe"
  ) +
  
#### The blue point in the map (Calgary Tower) ####
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +

##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -114.105, 
    xend = lines_x_end, 
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#f8ad58",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow area text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -114.125,                 
    xend = lines_x_end, 
    y = 50.995,
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#e3cdd5",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#ca8aba",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width  
  ) +
  annotate( # Light purple area text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +  

#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,  
    shape = 21,        
    fill = "#8359a6",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width     
  ) +
  annotate( # Purple area text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )

white_main_legend
```
### Adding isochrone legend

```{r}

# Settings
# ========

# Point
iso_point_size <- 15
iso_point_fill <- "black"
iso_point_alpha <- 1

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.119


white_iso_legend <- white_main_legend + 

#### "minutes by bike line" line and text ####
  annotate(
    "segment",
    x = x_60,
    y = y_60,
    xend = x_80,
    yend = y_80,
    linewidth = 0.7
  ) +
  annotate(
    "richtext", # Allows us to fill or "highlight" the text background
    label = "minutes<br>by bike", # I should change previous annotations to this
    x = x_80+((x_60-x_80)/2),  # To place it in the middle of both points
    y = y_60+((y_80-y_60)/2),
    size = iso_text_size,
    color = iso_point_fill,
    family = "atkinson",
    hjust = 0.5,
    angle = 59,
    fill = "white", # To make it readable (covering roads behind text)
    label.color = NA
  ) +
  
# Could have an a possibility, but looks worse in this case:
  # geom_shadowtext(
  #   aes(x = x_80+((x_60-x_80)/2), # To place it in the middle of both points
  #       y = y_60+((y_80-y_60)/2),
  #       label = "minutes by bike"),
  #   size = iso_text_size,
  #   lineheight = 0.80,
  #   color = "black", # Text color
  #   bg.color = "white", # Shadow color
  #   bg.r = 0.15, # Shadow width
  #   family = "atkinson",
  #   angle = 58.33
  # ) +
  
#### 20' isochrone point and text ####
  annotate(
    "point",
    x = x_20,
    y = y_20,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "20",
    x = x_20,
    y = y_20,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +
  
#### 40' isochrone point and text ####
   annotate(
    "point",
    x = x_40,
    y = y_40,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "40",
    x = x_40,
    y = y_40,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +
  
#### 60' isochrone point and text ####
   annotate(
    "point",
    x = x_60,
    y = y_60,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "60",
    x = x_60,
    y = y_60,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +

#### 80' isochrone point and text ####
   annotate(
    "point",
    x = x_80,
    y = y_80,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "80",
    x = x_80,
    y = y_80,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  )
  



white_iso_legend

```

### Adding example point (bike)

```{r}
white_example_legend <- white_iso_legend +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.105,
    size = iso_text_size,
    vjust = 0,
    color = "black",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
  
  annotate(
    "curve",
    x = -114.109,
    y = 51.105,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "black", 
    stroke = 2
  ) 

  

white_example_legend
```


### Finishing

#### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_tip_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.8650 ######## last +50 #MASTEEEERRRRRRR
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_tip_x, # Tip x
    triangle_tip_x - triangle_half_width, # Left corner x
    triangle_tip_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_tip_x,
  y = triangle_bottom_y + triangle_height + space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_tip_x - (triangle_half_width*box_width), # Left
  xmax = triangle_tip_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
calgary_improved_arrow <- white_example_legend +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

calgary_improved_arrow
```

#### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

calgary_improved_done <- calgary_improved_arrow +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_improved_done
```

