---
title: "Calgary"
description: |
  A visualization of travel times by bike and transit in the city of Calgary.
categories: "2025"
author: Miguel Agenjo
date: 2025-11-24
output:
  distill::distill_article:
    self_contained: false
---

I'm setting the chunk size to 34.375 because that will allow me to create a file the same height (3300px) as the original one (given default dpi for rmd in html is 96 [3300/96=34.375])

```{r setup, include = FALSE}
knitr::opts_chunk$set(out.width = "100%", fig.align = "center",
  fig.showtext = TRUE, fig.width = 34.375, fig.height = 34.375)
```

```{r load_libraries}
library(tidyverse)
library(osmdata)
library(geojsonsf) # Used function geojson_sf to convert geojson into sf
library(glossa) # Used function invert_polygon (idea didn't work)
library(sf) # Used function st_intersection
library(funkyheatmap) # Used function geom_rounded_rect
```



## Loading and plotting (checking json files)

```{r load_data}
# Loading travel times
hexagons <- geojson_sf("original_data/hexagons.geojson")

# Loading roads
all_roads_dissolved <- geojson_sf("original_data/all_roads_dissolved.geojson")

# Loading water
water <- geojson_sf("original_data/water.geojson")
```


**EXPLAIN THIS BETTER IN THE FINAL VERSION** The id range in `hexagons`, `bike_times`, and `transit_times` are the same. Since the `hexagons` dataset includes `bike_times` and `transit_times`, it is most likely an object created by: 1) dividing the map area in hexagons, 2) getting the travel times for those Hexagons, 3) joining those two databases using the id column. I might be able **I REMOVED THE EXPLANATION OF WHY I WAS TRYING TO CONVERT MULTILINESTRING INTO POLYGON** When searching how to convert a multilinestring into a polygon, I came across [this post](https://stackoverflow.com/questions/69224441/find-intersection-between-multilinestring-and-polygons-sf-r), which mentions the funcion `st_intersection()`. This made me think i can maybe get an object that is the intersection between `hexagons` and `all_roads_dissolved`. Maybe I can plot this directly (not a full hexagon layer underneath). But if that doesn't work, the background hexagons idea can still work. In the documentation for st_intersection() there are other functions that may be helpful.

```{r prepare_data}
# This took several minutes to run, so I'll save the object and
# avoid running the line again.
# hexroads_intersection <- st_intersection(all_roads_dissolved, hexagons)
# SHOULD I LEAVE IT WITHOUT SAVE/LOAD IN THE FINAL VERSION? PROBABLY
# save(hexroads_intersection, file = "hexroads_intersection.RData")
load("hexroads_intersection.RData")

# NOTE: I'm computing time_difference as time by bike minus time by transit. That means that:
# - Negative numbers = faster by bike
# - Positive numbers = faster by transit
hexroads_intersection <- hexroads_intersection |> 
  mutate(
    "time_difference" = b_travel_time - travel_time,
    "time_color" = case_when(
      time_difference <= -30 ~ "-2", # Bike 30 or more minutes faster
      time_difference <= -10 ~ "-1", # Bike 10 or more minutes faster (<30)
      time_difference < 10 ~ "0", # Between -10 and 10 (both not included)
      time_difference < 30 ~ "1", # Transit 10 or more minutes faster (<30)
      time_difference >= 30 ~ "2"), # Transit 30 or more minutes faster 
    "time_color" = fct( # We make it factor 
                   time_color, levels = c("-2", "-1", "0", "1", "2"))
    )
```

## Plotting map

```{r plot_legendless_map}
# Just the map, without legend
calgary_legendless <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = TRUE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"    # transit >30 min faster
    )
  ) +
  geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth =1.1 # To make water thicker
    ) +
  theme_void()

calgary_legendless # To see it
```

## Plotting first legend

In order to change line spacing see [here](https://stackoverflow.com/questions/39721772/line-height-spacing-for-text-in-ggplot)

In order to see the options for the point annotation see [this](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html)

I got the coordinates for calgary tower from [OSM](https://www.openstreetmap.org/way/25719793), and finetuned manually.


```{r plot_legend1}
# We add the font:
sysfonts::font_add_google("Atkinson Hyperlegible", family = "atkinson")
showtext::showtext_auto()

# We see what the bbox coordinates are and be able to adjust the annotation:
st_bbox(hexroads_intersection) # REMOVE FOR FINAL VERSION?

# And then annotate accordingly
calgary_legend1 <- calgary_legendless + 
  annotate( # The main text
    "text",
    x = -114.3100, 
    y = 50.9790,
    label = paste("This map shows the difference",
                  "in the time it takes to reach the",
                  "Calgary Tower     by bike and by",
                  "transit on a weekday morning.",
                  sep="\n"),
    hjust = 0, # Align left
    family = "atkinson",
    size = 12.9,
    lineheight = 1.05, # Line spacing
    color = "#000000"
  ) + 
   annotate(  # The blue point in the legend
    "point",
    x = -114.2450, ##################### LAST: +10
    y = 50.97495,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  )
  
calgary_legend1 # To seeit
  
ggsave(
  "calgary_02.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)
```




Almost perfect fit. Comparing with gimp changing opacity, it is really really close. I'm not sure I can get closer without using the same font as the original plot (which I cant). Maybe i could make the blue dot in the legend a little bit smaller, just to make it visually more similar.

## Plotting second legend

**CONTINUE FROM HERE**

Found about how to create rounded corners [here](https://albert-rapp.de/posts/ggplot2-tips/11_rounded_rectangles/11_rounded_rectangles.html) package `ggchiklet`. Seems like it is not available for the current version of R.

Another possibility for rounded corners is package `funkyheatmap` see [this](https://search.r-project.org/CRAN/refmans/funkyheatmap/html/geom_rounded_rect.html)


```{r plot_legend2}
# To make it easier to manually adjust, i will set the settings for the
# rectangle sizes like this, and the plot calling this objects:
# Rectangles:
rectangle_left <- -114.3080
rectangle_top <- 50.9490 
rectangle_width <- 0.0250
rectangle_height <- 0.0050
rectangle_space <- 0.0005
rectangle_color <- c("#d26716", "#f8ad58", "#e3cdd5", "#ca8aba", "#8359a6")
# Minutes:
minute_separation <- 1.6 # Relative to rectangle_height
minute_size <- 10 # In points, not relativ to the map
minute_color <- "#000000"
minute_font <- "atkinson"

  
# THE COLORS ARE TOO DARK, PICK DIRECTLY FROM ORIGINAL LEGEND (NOT SAME TONE
# AS THE ROADS)

# Create a data frame for legend rectangles according to settings:
legend_rectangles <- tibble(
  xmin = c(
    rectangle_left,
    rectangle_left + (rectangle_width + rectangle_space),
    rectangle_left + 2*(rectangle_width + rectangle_space),
    rectangle_left + 3*(rectangle_width + rectangle_space),
    rectangle_left + 4*(rectangle_width + rectangle_space)),
  xmax = c(
    rectangle_left + rectangle_width,
    rectangle_left + rectangle_width + (rectangle_width + rectangle_space),
    rectangle_left + rectangle_width + (2*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (3*(rectangle_width + rectangle_space)),
    rectangle_left + rectangle_width + (4*(rectangle_width + rectangle_space))),
  ymin = rectangle_top - rectangle_height,
  ymax = rectangle_top,
  fill_color = rectangle_color)

legend_rectangles # To see tibble, REMOVE IN FINAL VERSION!!!!!!!!!!!

# Create the dataframe for the minutes relative to previous:
legend_minutes <- tibble(
  label = c("30", "10", "10", "30"),
  x = c(
    rectangle_left + rectangle_width + (0.5*rectangle_space),
    rectangle_left + (2*rectangle_width) + (1.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space)
    ), 
  y = rectangle_top - rectangle_height * minute_separation)

legend_minutes # To see the tibble QUITALO EN LA VERSIÓN FINAL!!!!!!!!!!


# Plot rounded rectangles for legend:
calgary_legend2 <- calgary_legend1 +
  geom_rounded_rect(
    data = legend_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = rectangle_color,
        radius = 0.3),
    color = NA,  # No border
    show.legend = FALSE
  ) +
  scale_fill_identity() + # So that the fill with rectangle_color
                        # isn't treated as characters, but as the colors
                        # EXPLAIN BETTER WITH DOCUMENTATION FOR FINAL VERSION
    # Now plot the minute numbers:
  geom_text(
    data = legend_minutes,
    aes(x = x, y = y, label = label),
    size = minute_size,
    color = minute_color, 
    family = minute_font)

calgary_legend2

## CONTINUE ADDING TEXT HEREEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE####
##########################################################################
####### MORE SPECIFICALLY: ADD THE FASTER BY BIKE AND AND FASTER BY TRANSIT LABELS

ggsave(
  "calgary3.png",
  width = 34.375,
  height = 34.375,
  dpi = 96,
  bg = "white"
)

```
