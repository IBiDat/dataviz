---
title: "Calgary"
description: |
  A visualization of travel times by bike and transit in the city of Calgary.
categories: "2025"
author: Miguel Agenjo
date: 2025-11-24
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(out.width = "100%", fig.align = "center",
  fig.showtext = TRUE, fig.width = 26.5625, fig.height = 34.375)
# We've set the dimensions to match the size of the original plot.
```

```{r set_options, include =}
# Increase the amount of memory available to Java (this is necessary for large
# r5r queries).
options(java.parameters = "-Xmx2G") # I can change "2G" to other value if needed

# Increase timeout to be able to download large files (necessary to download
# large file with osmextract).
options(timeout = 600) # Timeout 600 seconds (10 minutes)

```


```{r load_libraries}
library(tidyverse)
library(osmdata)
library(geojsonsf) # Used function geojson_sf to convert geojson into sf
library(glossa) # Used function invert_polygon (idea didn't work)
library(sf) # Used function st_intersection
library(funkyheatmap) # Used function geom_rounded_rect
library(ggspatial) # Used in north arrow and ¿SCALE? # NOT USING IT IN THE END
library(geosphere) # To calculate distance for the scale
library(r5r) # To calculate travel times by car
library(osmextract) # To download data necesesary to use r5r
library(ggnewscale)
library(ggtext) # To plot "highlighted" text easily.
library(nngeo) # To remove wholes in isochrones 
library(smoothr) # To smoothen out the borders of the isochrones
library(scales) # To be able to define alpha in certain arguments where it is
                # not possible by default
library(shadowtext) # To add shadows in the isochrone legend
```

## Replica

### Loading the data

We reached Willem Klumpenhouwer, the author of the plot that we are replicating, and he kindly shared the data with which he built the original plot. This data consists of three .geojson files: 

- **`hexagons`** includes for variables: `geometry` (which contains polygons that form a hexagon grid of the map), `id` (an identification number for each hexagon), `b_travel_time` (travel time by bike from the centroid of each hexagon to Calgary Tower, in minutes), and `travel_time` (travel time by transit from the centroid of each hexagon to Calgary Tower, in minutes).

- **`all_roads_dissolved`**  with a multilinestring that represents all roads in Calgary.

-- **`water`** which contains mulitpolygons with the geometry of the water bodies in Calgary.

```{r load_data}
hexagons <- geojson_sf("original_data/hexagons.geojson")
all_roads_dissolved <- geojson_sf("original_data/all_roads_dissolved.geojson")
water <- geojson_sf("original_data/water.geojson")
```

### Data transformation

Given the structure of the provided data, we only need to do small transformations in order to be able able to plot the original map.

We start by creating a simple feature collection that combines the ids and travel time data from `hexagons` with the geometry of the roads that correspond with each hexagon. To do so, we calculate the intersection of `hexagons` and `all_roads_dissolved`.

```{r create_hexagons_roads_intersection}
# hexroads_intersection <- st_intersection(all_roads_dissolved, hexagons)

# This line takes minutes to run, so we save the object to avoid running it
# again. From now on, we can just load it.

# save(hexroads_intersection, file = "hexroads_intersection.RData")

load("hexroads_intersection.RData")
```

Then we add a new variable containing the difference in travel time by bike and by transit from each point. We also add a second variable with the differences binned in the ranges used in the original map.

```{r add_travel_time_difference}
# We are computing time_difference as time by bike minus time by transit. That means that:
# - negative numbers = faster by bike
# - positive numbers = faster by transit

hexroads_intersection <- hexroads_intersection |> 
  mutate(
    "time_difference" = b_travel_time - travel_time,
    "time_color" = case_when(
      time_difference <= -30 ~ "-2", # Bike 30 or more minutes faster
      time_difference <= -10 ~ "-1", # Bike 10 or more minutes faster (<30)
      time_difference < 10 ~ "0", # Between -10 and 10 (both not included)
      time_difference < 30 ~ "1", # Transit 10 or more minutes faster (<30)
      time_difference >= 30 ~ "2"), # Transit 30 or more minutes faster 
    "time_color" = fct( 
                   time_color, levels = c("-2", "-1", "0", "1", "2"))
    )
```

With our data ready, we can start plotting.

### Plotting

#### Roads and water

We start by plotting the map with roads adequately colored according to travel time differences. Notice that in the original map the water is plotted on top of the roads (we see there are no bridges over the rivers), we will do the same in our replica.

```{r plot_roads_water}
calgary_replica <- ggplot() +
  
  # Roads
  geom_sf( 
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312", # bike >30 min faster
      "-1" = "#c88c47", # bike 10–30 min faster
      "0"  = "#b7a6ac", # similar travel time
      "1"  = "#a36f96", # transit 10–30 min faster
      "2"  = "#6a4886"  # transit >30 min faster
    )
  ) +
  
  # Water:
  geom_sf( 
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth =1.1 
    ) +
  theme_void()

calgary_replica # To see it
```

After some time manually adjusting the values and comparing to the original plot, we have managed to plot roads and water with the same size as the original map.

#### Paragraph 

We will now add the paragraph that explains what the map represents, and identifies the blue point in the middle of the map as Calgary Tower.

```{r plot_paragraph}
# We add the font used in the original plot:
sysfonts::font_add_google("Atkinson Hyperlegible", family = "atkinson")
showtext::showtext_auto()

# And then plot the paragraph:
calgary_replica <- calgary_replica + 
  
  # The text:
  annotate(
    "text",
    x = -114.3100, 
    y = 50.9790,
    label = paste("This map shows the difference",
                  "in the time it takes to reach the",
                  "Calgary Tower     by bike and by",
                  "transit on a weekday morning.",
                  sep="\n"),
    hjust = 0,
    family = "atkinson",
    size = 12.9,
    lineheight = 1.05,
    color = "#000000"
  ) + 
  
  # The blue point in the legend
   annotate(
    "point",
    x = -114.2450,
    y = 50.97495,  
    shape = 21,
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +
  
  # The blue point in the map (Calgary Tower)
  annotate(  
    "point",
    x = -114.0631,
    y = 51.04465,
    shape = 21,
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  )
  
calgary_replica # To see it
```

#### Color legend

Now that we have the paragraph, we will plot the color legend underneath it. It is a non-standard legend which isn't part of ggplot's defaults. So we need to create the geometries and text manually.

Since there is a lot of elements here, and we need to manually adjust everything to fit the original plot, we will write the code in a way that will make it more convenient to use in this process of trial and error, by dividing it in three parts: a) *settings* where we will define the needed values, b) *calculations* of coordinate values according to the values defined in settings (this will allows us to avoid manually defining every single value needed), and c) the *plotting* according to the previous calculations.

**Note for Iñaki.** When I did this, I had doubts on whether it is an adequate approach. It was REALLY helpful to do it like this while plotting because this way I didn't have to navigate through the code to find the values i needed to slightly change, everything is together and clearly named at the top.

```{r plot_color_legend}
# Settings:
# =========

# Rectangles:
rectangle_left <- -114.3080
rectangle_top <- 50.9490 
rectangle_width <- 0.0250
rectangle_height <- 0.0050
rectangle_space <- 0.0005
rectangle_fill <- c("#d26716", "#f8ad58", "#e3cdd5", "#ca8aba", "#8359a6")
# THE COLORS ARE TOO DARK, PICK DIRECTLY FROM ORIGINAL LEGEND (NOT SAME TONE
# AS THE ROADS)

# Minutes:
minute_separation <- 1.66 # Relative to rectangle_height
minute_size <- 9 # For geom_text(size =
minute_color <- "#000000"
minute_font <- "atkinson"

# Faster by:
faster_separation <- 0.7 # Relative to rectangle_height
faster_size <- 11 # For geom_text(size = 
faster_color <- "#000000"
faster_font <- "atkinson"


# Calculations:
#=============

# Tibble for legend rectangles:
legend_rectangles <- tibble(
  "xmin" = rectangle_left + (0:4) * (rectangle_width + rectangle_space),
  "xmax" = xmin + rectangle_width,
  "ymin" = rectangle_top - rectangle_height,
  "ymax" = rectangle_top
)

# Tibble for minutes (relative to rectangles):
legend_minutes <- tibble(
  "label" = c("30", "10", "10", "30", "   minutes"),
  "x" = c(
    rectangle_left + ((1:4)*rectangle_width) + ((0.5:3.5) * rectangle_space),
    rectangle_left + (4*rectangle_width) + (3.5*rectangle_space)
  ),
  "y" = rectangle_top - rectangle_height * minute_separation,
  "hjust" = c(0.5, 0.5, 0.5, 0.5, 0) # All justified center, "minutes" left
)

# Tibble for "faster by" (relative to rectangles):
legend_faster <- tibble(
  "label" = c("faster by bike", "|", "faster by transit"),
  "x" = c(
    rectangle_left + (2*rectangle_width) + rectangle_space,
    rectangle_left + (2.5*rectangle_width) + (2.5*rectangle_space),
    rectangle_left + (3*rectangle_width) + (3*rectangle_space)),
  "y" = rectangle_top + rectangle_height * faster_separation,
  "hjust" = c(1, 0.5, 0) # Justified: right, center, left
)


# Plotting color legend:
# ======================
calgary_replica <- calgary_replica +

  # Rounded rectangles:
  geom_rounded_rect( # From package: funkyheatmap
    data = legend_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        radius = 0.3),
    fill = rectangle_fill,
    color = NA,  # No border
    show.legend = FALSE
  ) +

  # Minutes:
  geom_text(
    data = legend_minutes,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = minute_size,
    color = minute_color, 
    family = minute_font) +
  
  # Faster by:
  geom_text(
    data = legend_faster,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = faster_size,
    color = faster_color,
    family = faster_font
  )

calgary_replica
```


#### North arrow

Our map is only missing the spatial reference elements. We will start by plotting the arrow pointing North.

Once again, it is a non standard element. This means that default arrows do not work if we want a perfect replica. For example, the function `arrow()` inside `geom_segment(arrow = )` does not allow us to create an arrow that is at the same time as big as needed and as sharp (not rounded) as needed. There are packages like `ggspatial` that include functions to plot cardinal directions, but again, those don't fit our needs. So we will need to create a custom arrow. An easy solution that will allow us to plot a big arrow with a sharp head and a rounded shaft is plotting a triangular polygon with a rounded rectangle on top.

Another thing that we should not is that there is a weird behaviour in geom_rounded_rectangle(): when line width increases, it plots undesired lines that don't follow the rounded rectangle shape. Which means that we cannot use a single `geom_rounded_rectangle()` without fill but with a contour line to to plot the box around the arrow. To overcome this, we will plot a black `geom_rounded_rectangle()` with a smaller white one on top to get the desired effect.


Since, once again, there are lots of elements we need to build manually, and we will need lots of trial and error comparing to the original map until we get the exact replica, we will code using the same settings -> calculations -> plotting structure that we used before, which makes the trial-and error process much more comfortable. And we will often use relative values (relative to already existing shapes), which are easier to understand, read, and modify than absolute coordinate values with many decimals.


```{r plot_north_arrow}
# Settings:
# =========

arrow_color <- "#e3cdd5"

# Arrow triangle:
triangle_mid_x <- -114.2680 # This will be the reference for the rest of xs
triangle_bottom_y <- 50.9067 # This will be the reference for the rest of ys

triangle_half_width <- 0.0076
triangle_height <- 0.0048

# Arrow rectangle:
arrow_rectangle_width <- 0.435 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24

# North text:
north_space <- 0.55 # Relative to triangle height, space 0 = arrow tip
north_size <- 9
north_color <- "black"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (changes the size of the inner box, altering border size):
border_thickness <- 0.03 # Range 0-1 (0 = no border, 1 = full black box)
inner_box_color <- "white"



# Calculations:
# =============

# Tibble for arrow triangle (head):
triangle_polygon <- tibble(
  x = c(
    triangle_mid_x, # Tip x
    triangle_mid_x - triangle_half_width, # Left corner x
    triangle_mid_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Tibble for arrow rectangle (shaft):
arrow_rectangle <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top.   
                                                     # We add 0.25 of the
                                                     # triangle height to
                                                     # hide rounded edge on
                                                     # the rectangle top.

# Tibble for "north":
north <- tibble(
  label = "North",
  x = triangle_mid_x,
  y = triangle_bottom_y + triangle_height + north_space*triangle_height
)

# Tibble for outer box:
arrow_box <- tibble(
  "xmin" = triangle_mid_x - (triangle_half_width*box_width), # Left
  "xmax" = triangle_mid_x + (triangle_half_width*box_width), # Right
  "ymin" = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  "ymax" = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Tibble for inner box:
# We  first create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  "xmin" = arrow_box$xmin + box_vertical_border,
  "xmax" = arrow_box$xmax - box_vertical_border,
  "ymin" = arrow_box$ymin + box_horizontal_border,
  "ymax" = arrow_box$ymax - box_horizontal_border
)



# Plotting north arrow:
# =====================

calgary_replica <- calgary_replica +
  
  # Outer box:
  geom_rounded_rect(
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  
  # Inner box:
  geom_rounded_rect(
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  
  # Arrow head (triangle):
  geom_polygon( 
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA
    ) + 
  
  # Arrow shaft (rectangle):
  geom_rounded_rect( 
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA
    ) + 
  
  # "North" text:
  geom_text(
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

calgary_replica # To see it
```

#### Scale  

As was the case with the north-pointing arrow, the scale is non standard element, even packages like `ggspatial` do no include scales like the one we need. Once again, we will build it manually by trying different values until we get the exact replica as we did before. 

The only difference now is that there is one value which we do not have to find by trial and error: the scale must represent 3 kilometers. To make sure we get the proper length, we will use `destPoint()` from package `geosphere`, which, as it documentation states: "given a start point, initial bearing (direction), and distance, this function computes the destination point travelling along a the shortest path on an ellipsoid (the geodesic)".

Note that, even though it is an unusual choice, in the original map the ticks in the scale are plotted over the horizontal line. We will maintain that in our replica.

```{r plot_scale}
# Settings:
# =========

# Horizontal line:
scale_length <- 3100 # In meters (we set it a bit longer so that the ends
                     # extend over the ticks as in the original)
scale_space <- 0.13 # Space between scale and box, proportion of box height
scale_thickness <- 2 # For geom_segment(linewidth = )
scale_color <- "#676767"
  
# Ticks:
tick_distance <- 3000 # In meters, distance between the ticks at each end 
tick_length <- 0.08 # Proportion of the box height
tick_thickness <- 1.1 # For geom_segment(linewidth = )
tick_color <- "#000000"

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # For geom_text(size = )
km_font <- "atkinson"
km_color <- "#000000"


# Calculations:
# =============

# Auxiliary objects:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)

# Calculate right end of the horizontal line:
scale_left <- as_tibble(destPoint(
  p = c( 
    box_mid_x, # Starting x
    arrow_box$ymin - box_actual_height*scale_space), # Starting y
  b = 90, # b = bearing in degrees
  d = -scale_length/2)) # d = distance in meters 

# Calculate left end of the horizontal line:
scale_right <- as_tibble(destPoint(
  p = c(box_mid_x, arrow_box$ymin - box_actual_height*scale_space), 
  b = 90,
  d = scale_length/2))

# Tibble for horizontal line:
scale_horizontal <- tibble(
  "x" = scale_left$lon, "xend" = scale_right$lon,
  "y" = scale_left$lat, "yend" = scale_left$lat)

# Calculate left tick:
tick_left <- as_tibble(destPoint(
  p = c(box_mid_x, arrow_box$ymin - box_actual_height*scale_space), 
  b = 90,
  d = -tick_distance/2))

# Calculate right tick:
tick_right <- as_tibble(destPoint(
  p = c(box_mid_x, arrow_box$ymin - box_actual_height*scale_space), 
  b = 90,
  d = tick_distance/2))

# Tibble for ticks:
tick <- tibble(
  "x" = c(tick_left$lon, box_mid_x, tick_right$lon),
  "xend" = c(tick_left$lon, box_mid_x, tick_right$lon),
  "y" = tick_left$lat - ((box_actual_height/2)*tick_length), 
  "yend" = tick_left$lat + ((box_actual_height/2)*tick_length))

# Tibble for kilometers:
km <- tibble(
  "label" = c("0", "1.5", "3", "  km"),
  "x" = c(scale_left$lon, box_mid_x, scale_right$lon, scale_right$lon),
  "y" = scale_left$lat - ((box_actual_height/2)*km_space),
  "hjust" = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left



# Plotting:
# =========

calgary_replica <- calgary_replica +
  
  # Ticks:
  geom_segment( 
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  
  # Horizontal line:  
  geom_segment(
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  
  # Kilometers:
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font
    )


calgary_replica # To see it
```



## Alternative version




























### From where is it faster by car

[OpenRouteService API](https://api.openrouteservice.org/) allows me to calculate travel times by car from my hexagons, but the API Limit is 2000 routes per day, 40 per minute, which means it would take me 4 days to get data for all the hexagons in `intersection_hexagons` (which are the map hexagons that intersect with roads, thus the only one that i need data for). If I needed to recurrently update the plot with up-to-date data this would probably be the best option.

But since I don't, I will use another option: `r5r` [(intro to r5r)](https://cran.r-project.org/web//packages/r5r/vignettes/r5r.html)

#### Collecting car data with r5r

In order to use r5r we need a network dataset from OSM in .pbf format. As the intro to r5r mentions, we can do this using the package `osmextract` [(more about it here)](https://docs.ropensci.org/osmextract/).

```{r}
oe_match("Calgary") # There's a direct match

calgary_oe <- oe_get( # We extract the OSM data and get our .pbf file
  place = "Calgary",
  download_directory = "oe_osm_data/") 

# I plot it to check the data is for the correct city
ggplot(calgary_oe) +
  geom_sf(linewidth = 0.1, color = "black") +
  theme_minimal()
# It is data for the correct city.
```

Now that we have the .pbf file we can calculate car travel times with `r5r`:

```{r}
# We build the network that we will need to pass into travel_time_matrix() 
r5r_network <- build_network("oe_osm_data/")

# travel_time_matrix needs points with longitudes and latitudes in both
# origins and destinations argument. But our hexagons are not points, so we
# will compute the center of the hexagons and create a tibble. We can compute
# only hexagons with roads to avoid unnecessary computation.
hexagons_center <- as_tibble(
  st_coordinates(st_centroid(hexroads_intersection$geometry)))

origins_tibble <- tibble(
  id = hexroads_intersection$id,
  lon = hexagons_center$X,
  lat = hexagons_center$Y,
)

# We get the coordinates for calgary tower on a data frame to be able to
# pass it into travel_time_matrix:
calgary_tower <- tibble(
  id = "tower",
  lon = -114.0631,
  lat = 51.04465)

# This takes long to compute (45') so I'll save the object so as to avoid
# running it again.
# ttm <- travel_time_matrix(
#   r5r_network = r5r_network, # We pass the network we just created
#   origins = origins_tibble,
#   destination = calgary_tower,
#   mode = "CAR",
#   departure_datetime = as.POSIXct("2024-11-29 08:00:00"),
# )
# save(ttm, file = "ttm.RData")
load("ttm.RData")
```


We now have the car travel times, now we can add them to to `hexroads_intersection`.

```{r}
# Car faster by more than xx minutes:
cf <- 15 # Minutes

# Less than xx minutes by bike or transit shows bike or transit (and not car).
min <- 0 # Minutes

hexroads_intersection2 <- hexroads_intersection |>
  mutate("id" = as.character(id)) |> 
  left_join(ttm, by = c("id" = "from_id")) |> # Join car travel times
  select(-c(fid, to_id)) |>  # Remove useless columns
  mutate( # Rename travel_time_p50 to car travel time (car_tt)
    "car_tt" =  travel_time_p50,
    "time_color_car" = case_when( # When car more than 10 minutes faster: "9"
      b_travel_time <= min | travel_time <= min ~ time_color,
      car_tt - b_travel_time < -cf & car_tt - travel_time < -cf ~ "9",
      car_tt - b_travel_time >= -cf | car_tt - travel_time >= -cf ~ time_color))
```

#### Plotting map with car data

```{r plot_map_car}
calgary_car <- ggplot() +
  geom_sf( # We plot the roads:
    data = hexroads_intersection2,
    aes(color = time_color_car),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886",   # transit >30 min faster
      "9" = "#000000"     # car more than 10 minutes faster than both
    )
  )

calgary_car

```
## Notas hablando con Iñaki:

- Añadir anotaciones en el mapa que ayuden a leerlo (desde aquí hasta aquí es más de 30' más rápido ir en transporte público; desde aquí hasta aquí es más de 10' más rápido ir en bici).

- Añadir ischornes de tiempo en bici (o plotear el fondo del mapa con el tiempo en bici), y añadir líneas que digan "desde aquí es más rentable coger la bici, desde aquí es más rentable coger el tranporte público").

- Menciona buscar alguna manera de solucionar los errores.



## [Changed] New idea: bike in roads, transit difference in map

I've decided there will be discrete isochrones, continuous heatmap is an unreadable total mess.

I've been trying different improvement ideas for the legend and travel times (like adding new rectangle squares to the legend to be more precise with the difference), but making it more complex doesn't help. Doesn't add much new information, and makes it really really hard to plot the colors.



## A) Isochrones by fastest

### Calculating isochrones (fastest):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r}
# SAME BUT FASTEST TRAVEL TIME
hexagons2 <- hexagons |> 
  mutate(
    "fastest_travel_time" = case_when(
      b_travel_time > travel_time ~ travel_time,
      travel_time > b_travel_time ~ b_travel_time),
    "fastest_travel_time" = case_when(
      fastest_travel_time < 20 ~ 4,
      fastest_travel_time < 40 ~ 3,
      fastest_travel_time < 60 ~ 2,
      fastest_travel_time >= 60 ~ 1)) |> 
  filter(fastest_travel_time != 1) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)
# Decreasing order because they will be plotted in this order, and i want
# the central ones to be on top.


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
iso_fastest <- hexagons2 |>
  group_by(fastest_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler

# To fix holes [see more details in "Calculating ischrones (bike)"]
iso_fastest <- iso_fastest |>
  st_cast("POLYGON") |>  # We separate multipolygons into polygons
  mutate("area" = st_area(geometry)) |>  # We calculate area of each polygon
  mutate("area" = as.numeric(area)) |> # To be able to filter
  #group_by(fastest_travel_time) |> # We group them by the same travel times
  filter(area > 500000) |>  # We keep only the polygons with a big area (m2)
  #select(-area)  |>  # Remove the area column
  st_remove_holes()


### Making area less sharp ("rounding" hexagons): 
#================================================
# I tried st_buffer (needed st_transform first for the function to work 
# properly, but it didn't look good).
iso_fastest <- iso_fastest |> 
  smooth(method = "ksmooth", smoothness = 4) # smooth(method = chaikin) also
                                             # looks good (more detailed though)  

```



### A.1 - Black fastest

Plotting the actual isocrohones is a mess: there's lots of lines, they don't form concentric areas, but there are islands within each other (probably due to public transport). Removing those islands to make the map readable would be liying with the data (that's real information, there's public transport stops there, i can't just omit those for the shake of the map looking good!)

```{r black_isochr_fastest}
## Plotting in black background:

black_fastest <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_fastest, 
    aes(fill = fastest_travel_time),
    color = NA,
    alpha = 0.2,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "gray", # Outer isochrone
                      high = "cyan" # Inner isochrone
                      ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.6,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#c88c47", # Decided to plot it this color because it makes more
                        # sense (seems like a result of faulty data)
      "-1" = "#c88c47", # bike 10–30 min faster
      "0"  = "#b7a6ac", # similar travel time
      "1"  = "#a36f96", # transit 10–30 min faster
      "2"  = "#6a4886" # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    #color = "#E0FFFF", # I tried a gradient instead, but didn't look good.
    #color = "#c88c47", # Alternative color
    #color = alpha("#47c8c8", 0.7), # Alternative color
    color = alpha("#e5fcff", 0.7), # Alternative color
    fill = NA,
    alpha = 0,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black_fastest # To see it
```


#### Option A) *Lollipops* legend

```{r black_isochr_fastest_street_legend}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y
gray_line_y_end <- 50.965
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
purple_line_y_end <- 50.935 # Purple line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "white"

text_color <- "white" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


?geom_shadowtext

# Plot the legend:
#=================
# black_fastest <- I don't save it because I prefer option B.
  black_fastest + 
    
# The text paragraph
  annotate(
    "text",
    x = lines_x_end + 0.0075,
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 1,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +

# The blue point in the legend
   annotate(  
    "point",
    x = -114.2585,
    y = 50.9935,  
    shape = 21, 
    size = 4,
    color = "#61d7ea",
    stroke = 4.5,
    fill = "white"
  ) +
  
# The blue point in the map (Calgary Tower)
  annotate(  
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, 
    size = 4,
    color = "#61d7ea",
    stroke = 4.5,
    fill = "white"
  ) +

##### Street color legend #####
# Yellow streets
  annotate( # Yellow line
    "segment",
    x = -114.105,
    xend = lines_x_end,
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#f8ad58",
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Gray streets
  annotate( # Gray line
    "segment",
    x = -114.125,
    xend = lines_x_end,
    y = 50.995,
    yend = gray_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#e3cdd5",
    color = dot_stroke_color, 
    stroke = dot_stroke 
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Light purple streets
  annotate( # Light purple  line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#ca8aba",
    color = dot_stroke_color, 
    stroke = dot_stroke
  ) +
  annotate( # Light purple text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +

# Purple streets
  annotate( # Purple line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width,
    color = dot_stroke_color
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,
    y = purple_line_y_end,
    size = dot_size,
    shape = 21,
    fill = "#8359a6",
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Purple text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )
```


#### Option A) Street legend

We start by plotting the squares in the legend:

```{r}
# Settings
#=========
v_rectangle_top_y <- 50.984
v_rectangle_mid_x <- -114.17
v_rectangle_width <- 0.002
v_rectangle_height <- 0.0145
v_rectangle_space <- 0.0005
v_rectangle_radius <- 0.3
v_rectangle_fill <- c("#c88c47", "#b7a6ac", "#a36f96", "#6a4886")


  
# We calculate the coordinates:
#==============================
v_rectangles <- tibble(
  "xmin" = v_rectangle_mid_x - (v_rectangle_width/2),
  "xmax" = v_rectangle_mid_x + (v_rectangle_width/2),
  "ymin" = c(
    v_rectangle_top_y - v_rectangle_height,
    v_rectangle_top_y - ((2*v_rectangle_height) + v_rectangle_space),
    v_rectangle_top_y - ((3*v_rectangle_height) + (2*v_rectangle_space)),
    v_rectangle_top_y - ((4*v_rectangle_height) + (3*v_rectangle_space))),
  "ymax" = c(
    v_rectangle_top_y,
    v_rectangle_top_y - (v_rectangle_height + v_rectangle_space),
    v_rectangle_top_y - 2*(v_rectangle_height + v_rectangle_space),
    v_rectangle_top_y - 3*(v_rectangle_height + v_rectangle_space)),
  "fill" = v_rectangle_fill
  )

# We plot the rectangles:
#========================
black_fastest <- black_fastest +
  geom_rounded_rect(
    data = v_rectangles,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax, 
        fill = fill),
    radius = v_rectangle_radius,
    show.legend = FALSE
  ) +
  scale_fill_identity()

black_fastest
```

**A little extra: some arrows made out of streets**. First step: creating the "arrow" that we will plot next to the squares.

```{r}
# I used this to find an adequate area:
# OPTION A) 
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.082, -114.082, -114.0633, -114.0633) # The sums allow me to
#           + (-0.150)),                                # move fast around the
#     y = c(c(51.044, 51.0465, 51.047, 51.0375)         # map looking for an
#           + (-0.0259)),                               # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 1)

# OPTION B)
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.077, -114.077, -114.0633, -114.0633) # The sums allow me to
#           + (-0.054)),                                # move fast around the
#     y = c(c(51.044, 51.046, 51.050, 51.040)           # map looking for an
#           + (-0.0835)),                               # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 1)

# OPTION C) I'M USING THIS ONE
# black_fastest + annotate(
#     "polygon",
#     x = c(c(-114.078, -114.078, -114.0631, -114.0631) # The sums allow me to
#           + (-0.054)),                                # move fast around the
#     y = c(c(51.0445, 51.0455, 51.051, 51.039)         # map looking for an
#           + (-0.08385)),                              # area that i like.
#     color = "green",
#     fill = NA,
#     linewidth = 0.4)

# We now have the coordinates for the area I will use as arrow.
# We save them as a matrix because that's the object required by
# st_polygon:
selected_coordinates <- as.matrix(
  tibble(
   "x" = c(c(-114.078, -114.078, -114.0631, -114.0631) + (-0.054)),
   "y" = c(c(51.0445, 51.0455, 51.051, 51.039) + (-0.08385))
   ) |> 
  slice(1:4, 1)) # We need to repeat the first row in fifth place to close the
                 # polygon

 
# We create a polygon with those coordinates:
selected_polygon <- st_polygon(x = list(selected_coordinates))

# Then select the corresponding area from hexagons by intersection. But before
# we need to specify that our object uses the same coordinate reference system,
# otherwise st_intersection doesn't work.
selected_polygon <- st_sfc(
  selected_polygon,
  crs = st_crs(all_roads_dissolved))


# We can now get the intersection:
selected_street <- st_intersection(all_roads_dissolved, selected_polygon)

# We will create an object with this sf object, but substracting from its
# coordinates the coordinates of its centroid. That way, it will be easier to 
# move (plot) repeatedly (we can put it wherever we want by summing the
# coordinates that we want to make the centroid).
centroid <- st_centroid(st_union(selected_street))
street_arrow <- st_geometry(selected_street) - centroid
```

We now have our "street arrow", we just need to plot it next to the squares:

```{r}
# Settings
#=========
street_arrow_mid_x <- -0.0055 # From v_rectangle_mid_x
street_arrow_yellow_y <- 0 # From 1/2 height of the vertical rectangles

street_arrow_width <- 0.6

# We calculate the coordinates
#=============================

# Yellow street arrow:
street_arrow_yellow <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - (0.5*v_rectangle_height) + street_arrow_yellow_y)

# Gray street arrow:
street_arrow_gray <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((1.5*v_rectangle_height) + v_rectangle_space) + street_arrow_yellow_y)

# Light purple street arrow:
street_arrow_light_purple <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((2.5*v_rectangle_height) + (2*v_rectangle_space)) + street_arrow_yellow_y)

# Purple street arrow:
street_arrow_purple <- street_arrow + c(
  v_rectangle_mid_x + street_arrow_mid_x,
  v_rectangle_top_y - ((3.5*v_rectangle_height) + (3*v_rectangle_space)) + street_arrow_yellow_y)

# Assign crs to every arrow again:
street_arrow_yellow <- st_sfc(street_arrow_yellow,
                              crs = st_crs(all_roads_dissolved))

street_arrow_gray <- st_sfc(street_arrow_gray,
                            crs = st_crs(all_roads_dissolved))

street_arrow_light_purple <- st_sfc(street_arrow_light_purple,
                                    crs = st_crs(all_roads_dissolved))

street_arrow_purple <- st_sfc(street_arrow_purple,
                              crs = st_crs(all_roads_dissolved))

# We plot the street arrows:
#===========================

black_fastest <- black_fastest +
  geom_sf( 
    data = street_arrow_yellow,
    color = "#c88c47",
    linewidth = street_arrow_width
  ) +
  geom_sf(
    data = street_arrow_gray,
    color = "#b7a6ac",
    linewidth = street_arrow_width
  ) +
  geom_sf(
    data = street_arrow_light_purple,
    color = "#a36f96",
    linewidth = street_arrow_width
  ) +
  # 4. Purple Arrow
  geom_sf(
    data = street_arrow_purple,
    color = "#6a4886",
    linewidth = street_arrow_width
  )

black_fastest
```

We then plot the text for the squares:

```{r}
# Settings:
# =========
v_rect_text_color <- "white"
v_rect_text_size <- 7.5
v_rect_text_family <- "atkinson"

v_rect_h_just <- 1 # Right
v_rect_text_h_space <- 0.020
v_rect_text_text <- c("10-30' faster by bike",
                      "similar travel time",
                      "10-30' faster by transit",
                      "+30' faster by transit")
  
# We calculate the coordinates:
#==============================
v_rect_text <- tibble(
  "x" = v_rectangle_mid_x - v_rect_text_h_space,
  "y" = v_rectangles$ymax - (v_rectangle_height/2),
  "label" = v_rect_text_text,
  "hjust" = v_rect_h_just
)

# We plot the text:
#==================
black_fastest <- black_fastest + 
  geom_text(
    data = v_rect_text,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = v_rect_text_size,
    color = v_rect_text_color,
    family = v_rect_text_family)

black_fastest
```

Finally, we plot the title question (and the Calgary Tower points) on top:

```{r}
# Settings:
# =========

# Text:
question_text_x <- v_rectangle_mid_x + (v_rectangle_width/2)
question_text_y <- 50.9960
question_text_h_space <- 0 # Relative to vertical rectangles mid x

question_text_size <- 10 
question_text_line_height <- 1.1
question_text_color <- "white" 
question_text_family <- "atkinson"
question_text_h_just <- 1 # Right alignment


# Blue point:
legend_blue_point_x <- -114.1886
legend_blue_point_y <- 50.9957

blue_point_size <- 4
blue_point_stroke <- 4.5 
blue_point_fill <- "#61d7ea"
blue_point_color <- "white"



# Plot the legend:
#=================

black_fastest <- black_fastest + 
    
# The question text:
  annotate(
    "text",
    x = question_text_x,
    y = question_text_y,
    label = paste("What's the fastest way to get",
                  "to Calgary Tower     on a",
                  "weekday morning?",
                  sep = "\n"),
    hjust = question_text_h_just,
    family = question_text_family,
    size = question_text_size,
    color = question_text_color,
    lineheight = question_text_line_height
  ) +

# The blue point inside the question:
   annotate(  
    "point",
    x = legend_blue_point_x, 
    y = legend_blue_point_y,  
    shape = 21, 
    size = blue_point_size,
    fill = blue_point_fill,
    color = blue_point_color,
    stroke = blue_point_stroke
    ) +

# The blue point in the map (Calgary Tower)  
  annotate(
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, 
    size = blue_point_size,
    fill = blue_point_fill,
    color = blue_point_color,
    stroke = blue_point_stroke
  )

black_fastest
```



#### Adding isochrone legend

For text following path: https://allancameron.github.io/geomtextpath/reference/geom_textpath.html

```{r black_isochr_fastest_isochr_legend}

# Settings
# ========

# Point
iso_point_size <- 12.5
iso_point_fill <- "black"
iso_point_stroke_width <- 1.5
iso_point_stroke_color <- alpha("#e5fcff", 0.7)

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.00


#white_fastest1 <- 
black_fastest <- black_fastest + 

#### "minutes by bike" curve and text ####
  annotate( # The curve
    "curve",
    x = x_60 - 0.001, #asdf
    y = y_60 + 0.001,
    xend = x_60 + 0.0020,
    yend = y_60 + 0.0065,
    curvature = 0.9,
    linewidth = 0.85,
    color = "white",
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "last",
                  type = "closed")
  ) +
  geom_shadowtext( # The text
    aes(x = x_60 - 0.006,
      y = y_60 + 0.0091,
      label = "minutes\nby fastest\nmode"),
   size = iso_text_size,
   lineheight = 0.85,
   vjust = 0.5,
   hjust = 0.5,
   color = iso_text_color, # Text color
   bg.color = NA, # Shadow color
   bg.r = 0, # Shadow width
   family = "atkinson"
 ) +
  
#### 20' isochrone point and text ####
  annotate(
   "point",
   x = x_20,
   y = y_20,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
   
 ) +
 annotate(
   "text",
   label = "20",
   x = x_20,
   y = y_20,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 ) +
    
#### 40' isochrone point and text ####
  annotate(
   "point",
   x = x_40,
   y = y_40,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
 ) +
 annotate(
   "text",
   label = "40",
   x = x_40,
   y = y_40,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 ) +

#### 60' isochrone point and text ####
 annotate(
   "point",
   x = x_60,
   y = y_60,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   #alpha = iso_point_alpha,
   stroke = iso_point_stroke_width,
   color = iso_point_stroke_color
 ) +
 annotate(
   "text",
   label = "60",
   x = x_60,
   y = y_60,
   size = iso_text_size,
   family = "atkinson",
   color = iso_text_color
 )
  
  
### Other options for "minutes by fastest mode" #### [Keep them just in case]
# Option A) As line between 40 and 60
 #  geom_shadowtext(
 #   aes(x = x_40-((x_40-x_60)/2), # To place it in the middle of both points
 #      y = y_40+((y_60-y_40)/2),
 #      label = "minutes by\nfastest mode"),
 #   size = 5.4,
 #   lineheight = 0.85,
 #   color = "black", # Text color
 #   bg.color = "white", # Shadow color
 #   bg.r = 0.15, # Shadow width
 #   family = "atkinson",
 #   angle = 58.33
 # )

# Option B) Centered on top
#   geom_shadowtext(
#   aes(x = x_60,
#       y = y_60,
#       label = "minutes by\nfastest mode"),
#   size = iso_text_size,
#   lineheight = 0.85,
#   vjust = -0.67,
#   hjust = 0.5,
#   color = "black", # Text color
#   bg.color = "white", # Shadow color
#   bg.r = 0.15, # Shadow width
#   family = "atkinson"
# )

# #### ALTERNATIVE MINUTES #### [I like them worse, I'll keep them just in case]
#   geom_shadowtext(
#     aes(x = x_20,
#         y = y_20,
#         label = "20"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_40,
#         y = y_40,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_60,
#         y = y_60,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# )

black_fastest
```

#### Adding example point

```{r}
black_fastest <-  black_fastest +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.106,
    size = iso_text_size,
    vjust = 0,
    color = "white",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
#?geom_curve
  annotate(
    "curve",
    x = -114.107,
    y = 51.106,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    color = "white",
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "white", 
    stroke = 2
  ) 

black_fastest
```

#### Finishing

##### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "white"
# Arrow triangle 
triangle_mid_x <- -113.8825 
triangle_half_width <- 0.003325
triangle_bottom_y <- 50.8600 ######## #MASTEEEERRRRRRR +25
triangle_height <- 0.0021 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
north_space <- 0.75 # Relative to triangle height
north_size <- 6
north_color <- "white"

# Outer box:
box_width <- 2.40 # Relative to triangle width
box_height <- 2.75 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "white"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.05 # Range 0-1 (no border, full black box).
inner_box_color <- "black"




######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_mid_x, # Tip x
    triangle_mid_x - triangle_half_width, # Left corner x
    triangle_mid_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "N",
  x = triangle_mid_x,
  y = triangle_bottom_y + triangle_height + north_space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*box_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
# ===============================
black_fastest <- black_fastest +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    color = north_color, 
    family = "atkinson",
    fontface = "bold"
    )

black_fastest
```

##### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 2000 # In meters
scale_space <- 0.25 # Space between line and box, proportion of box width
scale_color <- "white"
scale_thickness <- 1.3 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.15 # Proportion of the box height
tick_color <- "white"
tick_thickness <- 1.3 # For argument linewidth =

# Kilometers:
km_space <- 0.6 # Space between km and scale, proportion of box height
km_size <- 7 # In points, not relativ to the map
km_color <- "white"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1", "2", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

black_fastest <- black_fastest+
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

black_fastest

# ggsave(
#   "black_fastest.png",
#   width = 26.56057,
#   height = 34.375,
#   dpi = 96,
#   bg = "white"
# )
```

### A.2 - White fastest 

```{r}
## Plotting in white background:

white_fastest <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_fastest, 
    aes(fill = fastest_travel_time), 
    color = NA, 
    alpha = 0.1,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "gray", # Central isochrone
    high = "black" # Outer isochrone
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.6,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    #color = "#E0FFFF", # I tried a gradient instead, but didn't look good.
    #color = "#c88c47", # Alternative color
    #color = alpha("#47c8c8", 0.7), # Alternative color
    color = alpha("#e5fcff", 0.7), # Alternative color
    fill = NA,
    alpha = 0,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_fastest, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.6
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white_fastest # To see it
```

#### Adding street legend

```{r lollipop_legend_bottom_left_fastest}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

purple_line_y_end <- 50.935 # Purple line y end + text y + point y
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
gray_line_y_end <- 50.965
yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "black"

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


# Plot the legend:
#=================
white_fastest <- white_fastest + 
    
#### The text paragraph #### 
  annotate(
    "text",
    x = lines_x_end, 
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 0.95,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +
  
#### The blue point in the legend ####
   annotate(  
    "point",
    x = -114.255, 
    y = 50.9935,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 7, # Make it a bit smaller than the point in the map
    color = "#000000",
    stroke = 4.03,
    fill = "#69eafe"
  ) +
  
#### The blue point in the map (Calgary Tower) ####
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +

##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -114.105, 
    xend = lines_x_end, 
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#f8ad58",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow area text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -114.125,                 
    xend = lines_x_end, 
    y = 50.995,
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#e3cdd5",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#ca8aba",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width  
  ) +
  annotate( # Light purple area text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +  

#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,  
    shape = 21,        
    fill = "#8359a6",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width     
  ) +
  annotate( # Purple area text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )

white_fastest
```
#### Adding isochrone legend

For text following path: https://allancameron.github.io/geomtextpath/reference/geom_textpath.html

```{r}

# Settings
# ========

# Point
iso_point_size <- 15
iso_point_fill <- "black"
iso_point_alpha <- 1

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.00


#white_fastest1 <- 
white_fastest <- white_fastest + 

#### "minutes by bike" curve and text ####
  annotate( # The curve
    "curve",
    x = x_60 - 0.001, #asdf
    y = y_60 + 0.001,
    xend = x_60 + 0.0015,
    yend = y_60 + 0.007,
    curvature = 0.9,
    linewidth = 0.85
  ) +
  geom_shadowtext( # The text
    aes(x = x_60 - 0.005,
      y = y_60 + 0.009,
      label = "minutes\nby fastest\nmode"),
   size = iso_text_size,
   lineheight = 0.85,
   vjust = 0.5,
   hjust = 0.5,
   color = "black", # Text color
   bg.color = NA, # Shadow color
   bg.r = 0, # Shadow width
   family = "atkinson"
 ) +
  
#### 20' isochrone point and text ####
  annotate(
   "point",
   x = x_20,
   y = y_20,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "20",
   x = x_20,
   y = y_20,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 ) +
    
#### 40' isochrone point and text ####
  annotate(
   "point",
   x = x_40,
   y = y_40,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "40",
   x = x_40,
   y = y_40,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 ) +

#### 60' isochrone point and text ####
 annotate(
   "point",
   x = x_60,
   y = y_60,
   size = iso_point_size,
   shape = 21,
   fill = iso_point_fill,
   alpha = iso_point_alpha
 ) +
 annotate(
   "text",
   label = "60",
   x = x_60,
   y = y_60,
   size = iso_text_size,
   family = "atkinson",
   color = "white"
 )
  
  
### Other options for "minutes by fastest mode" #### [Keep them just in case]
# Option A) As line between 40 and 60
 #  geom_shadowtext(
 #   aes(x = x_40-((x_40-x_60)/2), # To place it in the middle of both points
 #      y = y_40+((y_60-y_40)/2),
 #      label = "minutes by\nfastest mode"),
 #   size = 5.4,
 #   lineheight = 0.85,
 #   color = "black", # Text color
 #   bg.color = "white", # Shadow color
 #   bg.r = 0.15, # Shadow width
 #   family = "atkinson",
 #   angle = 58.33
 # )

# Option B) Centered on top
#   geom_shadowtext(
#   aes(x = x_60,
#       y = y_60,
#       label = "minutes by\nfastest mode"),
#   size = iso_text_size,
#   lineheight = 0.85,
#   vjust = -0.67,
#   hjust = 0.5,
#   color = "black", # Text color
#   bg.color = "white", # Shadow color
#   bg.r = 0.15, # Shadow width
#   family = "atkinson"
# )

# #### ALTERNATIVE MINUTES #### [I like them worse, I'll keep them just in case]
#   geom_shadowtext(
#     aes(x = x_20,
#         y = y_20,
#         label = "20"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_40,
#         y = y_40,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# ) +
#   geom_shadowtext(
#     aes(x = x_60,
#         y = y_60,
#         label = "60"),
#     size = iso_text_size,
#     lineheight = 0.85,
#     hjust = 0.5,
#     color = "white", # Text color
#     bg.color = "black", # Shadow color
#     bg.r = 0.25, # Shadow width
#     family = "atkinson"
# )

white_fastest
```

#### Adding example point

```{r}
white_fastest <- white_fastest +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.105,
    size = iso_text_size,
    vjust = 0,
    color = "black",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
#?geom_curve
  annotate(
    "curve",
    x = -114.109,
    y = 51.105,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "black", 
    stroke = 2
  ) 



```
#### Finishing

##### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_mid_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.8650 ######## last +50 #MASTEEEERRRRRRR
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
north_space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_mid_x, # Tip x
    triangle_mid_x - triangle_half_width, # Left corner x
    triangle_mid_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_mid_x,
  y = triangle_bottom_y + triangle_height + north_space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*box_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
# ===============================
white_fastest <- white_fastest +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

white_fastest
```

##### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

white_fastest <- white_fastest +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_improved_done
```



## B) Isochrones by bike

### Calculating isochrones (bike):

- Mergin polygons idea from [here](https://stackoverflow.com/questions/49354393/r-how-do-i-merge-polygon-features-in-a-shapefile-with-many-polygons-reproducib)

```{r compute_isochrones}
# After quite some time of trial and error, 20' is the right balance between 
# making the map informative, and a total line mess.

# Calculating hexagons under each isochrone:
hexagons2 <- hexagons |> 
  mutate("iso_b_travel_time" = case_when(
      b_travel_time < 20 ~ 1,
      b_travel_time < 40 ~ 2,
      b_travel_time < 60 ~ 3,
      b_travel_time < 80 ~ 4,
      b_travel_time >= 80 ~ 5)) |> 
  filter(iso_b_travel_time != 5) # So that we don't get an area for the 
                                 # last isohrone (which is the bb limit)


# To avoid "hexagon grid" effect, I need to merge adjacent hexagons where
# travel time by bike is the same.
iso_bike <- hexagons2 |>
  group_by(iso_b_travel_time) |> # We group hexagons with the same travel time
  summarise() # We could use st_union, but this is simpler

##### A problem to fix: holes.
# ============================
# When plotting iso_bike small holes appear. I need to get those removed.

# I initially tried function st_remove_holes()  from package nngeo directly,
# like this:
# hexzones <- hexzones |> 
#   st_remove_holes()
# But it doesn't work. I think the problem is that our geometry is a
# multipolygon. Annd st_remove_holes remove the holes inside each "polygon"
# of the multipolygon (see the documentation of the function for a more
# visual explanation of what i mean).

# So I tried a new approach: first splitting the multipolygons into single 
# polygons, selecting only the biggest ones (thus removing the small "holes"),
# and then running st_remove_holes.
iso_bike <- iso_bike |>
  st_cast("POLYGON") |>  # We separate multipolygons into polygons
  mutate("area" = st_area(geometry)) |>  # We calculate area of each polygon
  group_by(iso_b_travel_time) |> # We group them by the same travel times
  slice_max(area, n = 1) |>  # We keep only the polygons with the biggest area
  #select(-area)  |>  # Remove the area column
  st_remove_holes()

# We see some warnings. Documentation says "If information gets lost while type
# casting, a warning is raised". I'm not sure what information is lost, but
# everything seems to work fine, so it isn't a problem.



### Making area less sharp ("rounding" hexagons): 
#================================================
# I tried st_buffer (needed st_transform first for the function to work 
# properly, but it didn't look good).
iso_bike <- iso_bike |> 
  smooth(method = "ksmooth", smoothness = 4) # smooth(method = chaikin) also
                                             # looks good (more detailed though)  
```

### Black bike

```{r improved_black}
## Plotting in black background:

black <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_bike, 
    aes(fill = iso_b_travel_time),
    color = NA,
    alpha = 0.3,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(low = "white", # Central isochrone
                      high = "black" # Outer isochrone
  )+
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 0.5,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_bike, 
    aes(fill = NA),
    color = "#ce9d78", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 1
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background black:
  theme_void() +
  theme( # To make the plot area and the whole image have black background
    plot.background = element_rect(fill = "black", color = NA),
    panel.background = element_rect(fill = "black", color = NA)
  )

black # To see it
```




### White bike

```{r improved_white}
## Plotting in white background:

white <- ggplot() +
  
# A) We first plot the isochrone's areas (no borders yet)
  geom_sf(
    data = iso_bike, 
    aes(fill = iso_b_travel_time), 
    color = NA, 
    alpha = 0.1,
    show.legend = FALSE
  ) + 
  scale_fill_gradient(
    low = "black", # Central isochrone
    high = "white" # Outer isochrone
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# We plot the water first (so that roads appear on top)
    geom_sf( # We plot the water:
    data = water,
    fill = "#a6b0b9",
    color = "#a6b0b9",
    linewidth = 1.1 # To make water thicker
    ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing

# Then we plot the roads:
  geom_sf(
    data = hexroads_intersection,
    aes(color = time_color),
    linewidth = 1.1,  # To make roads thicker
    show.legend = FALSE
  ) +
  scale_color_manual(
    values = c(
      "-2" = "#aa5312",   # bike >30 min faster
      "-1" = "#c88c47",   # bike 10–30 min faster
      "0"  = "#b7a6ac",   # similar travel time
      "1"  = "#a36f96",   # transit 10–30 min faster
      "2"  = "#6a4886"   # transit >30 min faster
    )
  ) +

# Anf finally the isochrone's borders (so that they appear on top of roads)
  geom_sf(
    data = iso_bike, 
    aes(fill = NA),
    color = "black", # I tried a gradient instead, but didn't look good.
    fill = NA,
    alpha = 1,
    linewidth = 0.6
  ) +
  new_scale_color() + 
  new_scale_fill() + # We reset color an fill before continuing
  
# Finally, theming to make the background white:
  theme_void() +
  theme(
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA)
  )

white # To see it
```



### Adding street legend (white, bottom left) (BIKE)


```{r lollipop_legend_bottom_left_bike}
# Settings:
# =========

# Lines settings:
lines_x_end <- -114.18 # Same outside x for all lines
lines_width <- 1 # Lines width

purple_line_y_end <- 50.935 # Purple line y end + text y + point y
light_purple_line_y_end <- 50.950 # Light purple line y end + text y + point y
gray_line_y_end <- 50.965
yellow_line_y_end <- 50.980 # Yellow line line y end + text y + point y

dot_size <- 25 # Lollipop dot size
dot_stroke <- 2
dot_stroke_color <- "black"

text_color <- "black" # Text color
text_family <- "atkinson" # Typography
text_size <- 10
text_h_just <- 1 # 0 left, 0.5 center, 1 right
text_dot_space <- 0.0125 # Space between the text and the dots


# Plot the legend:
#=================
white_main_legend <- white + 
    
#### The text paragraph #### 
  annotate(
    "text",
    x = lines_x_end, 
    y = 50.9970,
    label = paste("What's the fastest way to get to",
                  "Calgary Tower     on a weekday morning?",
                  sep="\n"),
    hjust = 0.95,
    family = text_family,
    size = 10,
    color = text_color,
    lineheight = 1.15
  ) +
  
#### The blue point in the legend ####
   annotate(  
    "point",
    x = -114.255, 
    y = 50.9935,  
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 7, # Make it a bit smaller than the point in the map
    color = "#000000",
    stroke = 4.03,
    fill = "#69eafe"
  ) +
  
#### The blue point in the map (Calgary Tower) ####
  annotate(  # The blue point in the map (Calgary Tower)
    "point",
    x = -114.0631, 
    y = 51.04465,
    shape = 21, # Has to be one between 21 and 25 (according to documentation)
    size = 8.25,
    color = "#000000",
    stroke = 4.75,
    fill = "#69eafe"
  ) +

##### Annotation for yellow streets: ####
  annotate( # Yellow area line
    "segment",
    x = -114.105, 
    xend = lines_x_end, 
    y = 51.03,
    yend = yellow_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Yellow lollipop dot
    "point",
    x = lines_x_end,
    y = yellow_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#f8ad58",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Yellow area text
    "text",
    label = "10-30' faster by bike",
    x = lines_x_end - text_dot_space,
    y = yellow_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for gray streets: ####
  annotate( # Gray area line
    "segment",
    x = -114.125,                 
    xend = lines_x_end, 
    y = 50.995,
    yend = gray_line_y_end, 
    linewidth = lines_width
  ) +
  annotate( # Gray lollipop dot
    "point",
    x = lines_x_end,
    y = gray_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#e3cdd5",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width
  ) +
  annotate( # Gray area text
    "text",
    label = "similar travel time", # Standard label for gray
    x = lines_x_end - text_dot_space,
    y = gray_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +
  
#### Annotation for light purple streets: ####
  annotate( # Light purple area line
    "segment",
    x = -114.130,
    xend = lines_x_end,
    y = 50.94,
    yend = light_purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Light purple lollipop dot
    "point",
    x = lines_x_end,
    y = light_purple_line_y_end,
    size = dot_size,
    shape = 21,        
    fill = "#ca8aba",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width  
  ) +
  annotate( # Light purple area text
    "text",
    label = "10-30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = light_purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  ) +  

#### Annotation for purple streets: ####
  annotate( # Purple area line
    "segment",
    x = -114.110,
    xend = lines_x_end,
    y = 50.910,
    yend = purple_line_y_end,
    linewidth = lines_width
  ) +
  annotate( # Purple lollipop dot
    "point",
    x = lines_x_end,       
    y = purple_line_y_end, 
    size = dot_size,  
    shape = 21,        
    fill = "#8359a6",  
    color = dot_stroke_color, # Border
    stroke = dot_stroke # Border stroke width     
  ) +
  annotate( # Purple area text
    "text",
    label = "+30' faster by transit",
    x = lines_x_end - text_dot_space,
    y = purple_line_y_end,
    hjust = text_h_just,
    color = text_color,
    family = text_family,
    size = text_size
  )

white_main_legend
```
### Adding isochrone legend

```{r}

# Settings
# ========

# Point
iso_point_size <- 15
iso_point_fill <- "black"
iso_point_alpha <- 1

# Text
iso_text_size <- 6
iso_text_color <- "white"


# Point and text position
x_20 <- -114.045
y_20 <- 51.0632

x_40 <- -114.0263
y_40 <- 51.082

x_60 <- -114.0096
y_60 <- 51.099

x_80 <- -113.990
y_80 <- 51.119


white_iso_legend <- white_main_legend + 

#### "minutes by bike line" line and text ####
  annotate(
    "segment",
    x = x_60,
    y = y_60,
    xend = x_80,
    yend = y_80,
    linewidth = 0.7
  ) +
  annotate(
    "richtext", # Allows us to fill or "highlight" the text background
    label = "minutes<br>by bike", # I should change previous annotations to this
    x = x_80+((x_60-x_80)/2),  # To place it in the middle of both points
    y = y_60+((y_80-y_60)/2),
    size = iso_text_size,
    color = iso_point_fill,
    family = "atkinson",
    hjust = 0.5,
    angle = 59,
    fill = "white", # To make it readable (covering roads behind text)
    label.color = NA
  ) +
  
# Could have an a possibility, but looks worse in this case:
  # geom_shadowtext(
  #   aes(x = x_80+((x_60-x_80)/2), # To place it in the middle of both points
  #       y = y_60+((y_80-y_60)/2),
  #       label = "minutes by bike"),
  #   size = iso_text_size,
  #   lineheight = 0.80,
  #   color = "black", # Text color
  #   bg.color = "white", # Shadow color
  #   bg.r = 0.15, # Shadow width
  #   family = "atkinson",
  #   angle = 58.33
  # ) +
  
#### 20' isochrone point and text ####
  annotate(
    "point",
    x = x_20,
    y = y_20,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "20",
    x = x_20,
    y = y_20,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +
  
#### 40' isochrone point and text ####
   annotate(
    "point",
    x = x_40,
    y = y_40,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "40",
    x = x_40,
    y = y_40,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +
  
#### 60' isochrone point and text ####
   annotate(
    "point",
    x = x_60,
    y = y_60,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "60",
    x = x_60,
    y = y_60,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  ) +

#### 80' isochrone point and text ####
   annotate(
    "point",
    x = x_80,
    y = y_80,
    size = iso_point_size,
    shape = 21,
    fill = iso_point_fill,
    alpha = iso_point_alpha
  ) +
  annotate(
    "text",
    label = "80",
    x = x_80,
    y = y_80,
    size = iso_text_size,
    family = "atkinson",
    color = "white"
  )
  



white_iso_legend

```

### Adding example point (bike)

```{r}
white_example_legend <- white_iso_legend +
  annotate( # The text
    "richtext",
    label = "Bike is faster and<br>travel takes under 40'",
    x = -114.109,
    y = 51.105,
    size = iso_text_size,
    vjust = 0,
    color = "black",
    family = "atkinson",
    fill = NA,
    label.color = NA
  ) +
  
  annotate(
    "curve",
    x = -114.109,
    y = 51.105,
    xend = -114.085,
    yend = 51.0935,
    curvature = 0.5,
    linewidth = 0.7,
    arrow = arrow(angle = 30,
                  length = unit(0.1, "in"),
                  ends = "first",
                  type = "closed")
  ) +
  annotate( # The yellow dot in map
    "point",
    x = -114.085,
    y = 51.0935,
    size = 5,
    shape = 21,        
    fill = "#f8ad58",  
    color = "black", 
    stroke = 2
  ) 

  

white_example_legend
```


### Finishing

#### Adding arrow

```{r}
######## Settings to make it easier to manually adjust ###########
######## I also think the code is more readable this way, but maybe
######## I shouldn't do settings -> tibble -> ggplot
######## and should do settings -> ggplot, or ggpplot directly, but gets messy
######## ASK IÑAKI!

# Arrow:
arrow_color <- "#e3cdd5"
# Arrow triangle 
triangle_mid_x <- -114.2680 ######## LAST +5
triangle_half_width <- 0.0076 ####### Last: +1
triangle_bottom_y <- 50.8650 ######## last +50 #MASTEEEERRRRRRR
triangle_height <- 0.0048 ### last:-1
# Arrow rectangle:
arrow_rectangle_width <- 0.455 # Relative to triangle width
arrow_rectangle_height <- 1.495 # Relative to triangle height
arrow_rectangle_radius <- 0.24 #

# North text:
north_space <- 0.55 # Relative to triangle height
north_size <- 9
north_color <- "#000000"

# Outer box:
box_width <- 2.22 # Relative to triangle width
box_height <- 2.45 # Relative to triangle height
box_radius <- 0.20
box_y_position <- 0.255 # Relative to triangle tip (measured in triangle height)
box_color <- "#575757"

# Border thickness (i will use this to change size of inner box):
border_thickness <- 0.03 # Range 0-1 (no border, full black box).
inner_box_color <- "white"





######### Create tibble according to settins ##########################
# Create triangle tibble according to settings:
triangle_polygon <- tibble(
  x = c(
    triangle_mid_x, # Tip x
    triangle_mid_x - triangle_half_width, # Left corner x
    triangle_mid_x + triangle_half_width # Right corner x
  ),
  y = c(
    triangle_bottom_y + triangle_height, # Tip y 
    triangle_bottom_y, # Left corner y
    triangle_bottom_y)) # Right corner y
  
# Create rectangle tibble according to settings:
arrow_rectangle <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*arrow_rectangle_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*arrow_rectangle_width), # Right
  ymin = triangle_bottom_y - (triangle_height*arrow_rectangle_height), # Bottom
  ymax = triangle_bottom_y + (0.25*triangle_height)) # Top, i add 0.25 of the
                                                     # the triangle height to
                                                     # hide curve on top
  
# Create the tibble for "north" text relative to previous:
north <- tibble(
  label = "North",
  x = triangle_mid_x,
  y = triangle_bottom_y + triangle_height + north_space*triangle_height
)

# Create the tibble for the box around the arrow (outer box):
arrow_box <- tibble(
  xmin = triangle_mid_x - (triangle_half_width*box_width), # Left
  xmax = triangle_mid_x + (triangle_half_width*box_width), # Right
  ymin = triangle_bottom_y - (triangle_height*box_height) +
    (triangle_height*box_y_position), # Bottom
  ymax = triangle_bottom_y + (triangle_height*box_height) +
    (triangle_height*box_y_position)) # Top

# Create the tibble for the inner box:
# First we create an auxiliary object which we will add/substract to outer box:
box_vertical_border <- ((arrow_box$xmax - arrow_box$xmin)*border_thickness)/2 
box_horizontal_border <- ((arrow_box$ymax - arrow_box$ymin)*border_thickness)/2
# And then the tibble:
inner_box <- tibble(
  xmin = arrow_box$xmin + box_vertical_border,
  xmax = arrow_box$xmax - box_vertical_border,
  ymin = arrow_box$ymin + box_horizontal_border,
  ymax = arrow_box$ymax - box_horizontal_border
)



##### PLOTTING NORTH ARROW #####
calgary_improved_arrow <- white_example_legend +
  geom_rounded_rect( #### Plot outer box (for border) ####
    data = arrow_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = box_color,
    color = NA
    ) +
  geom_rounded_rect( ####Plot inner box (for border)
    data = inner_box,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = box_radius,
    fill = inner_box_color,
    color = NA
    )+
  geom_polygon( #### Plot the arrow triangle ####
    data = triangle_polygon,
    aes(x = x, y = y),
    fill = arrow_color,
    color = NA # No border
    ) + 
  geom_rounded_rect( #### Plot the arrow "body" ####
    data = arrow_rectangle,
    aes(xmin = xmin, xmax = xmax,
        ymin = ymin, ymax = ymax),
    radius = arrow_rectangle_radius,
    fill = arrow_color,
    color= NA # No border
    ) + 
  geom_text( #### Plot "North" text ####
    data = north,
    aes(x = x, y = y, label = label),
    size = north_size,
    fontface = "bold",
    color = north_color, 
    family = "atkinson"
    )

calgary_improved_arrow
```

#### Adding scale

```{r}
########## SETTINGS #############
# Horizontal line:
scale_length <- 3000 # In meters
scale_space <- 0.13 # Space between line and box, proportion of box width
scale_color <- "#000000"
scale_thickness <- 2 # For argument linedwidth = in segment
  
# Ticks:
tick_length <- 0.08 # Proportion of the box height
tick_color <- "#000000"
tick_thickness <- 1.1 # For argument linewidth =

# Kilometers:
km_space <- 0.275 # Space between km and scale, proportion of box height
km_size <- 9 # In points, not relativ to the map
km_color <- "#000000"
km_font <- "atkinson"

#################################
######### TIBBLES ###############
################################


### Tibble for scale horizontal line
####################################

# I first create an object with the actual outer box width, height, and x mid
# point, it will make code easier later:
box_actual_width <- arrow_box$xmax - arrow_box$xmin
box_actual_height <- arrow_box$ymax - arrow_box$ymin
box_mid_x <- arrow_box$xmin + (box_actual_width/2)


# Then we compute what the end points of the scale should be with destPoint:
scale_left <- as_tibble(destPoint( # I use as_tibble because it is more readable later
  p = c(box_mid_x,  # Start x coordinate (the middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degrees
  d = -scale_length/2)) # Distance in meters 

scale_right <- as_tibble(destPoint(
  p = c(box_mid_x,  # Start x coordinate (middle of the box)
        arrow_box$ymin - box_actual_height*scale_space), # Start y (box bottom)
  b = 90, # Bearing (direction) in degress 
  d = scale_length/2)) # Distance in meters 

# Then the tibble for the scale horizontal_line (could omit, but to make
# everything coherent (homogeneous) when plotting):
scale_horizontal <- tibble(
  x = scale_left$lon,
  xend = scale_right$lon,
  y = scale_left$lat,
  yend = scale_left$lat)

### Tibble for ticks
####################################
tick <- tibble(
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  xend = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon),
  y = scale_left$lat - ((box_actual_height/2)*tick_length), 
  yend = scale_left$lat + ((box_actual_height/2)*tick_length))

### Tibble for kms
####################################
km <- tibble(
  label = c("0", "1.5", "3", "  km"),
  x = c(
    scale_left$lon,
    box_mid_x,
    scale_right$lon,
    scale_right$lon
  ),
  y = scale_left$lat - ((box_actual_height/2)*km_space),
  hjust = c(0.5, 0.5, 0.5, 0)) # All justified center, "kilometers" left

##############################
####### PLOTTING #############
##############################

calgary_improved_done <- calgary_improved_arrow +
  geom_segment( ### Plotting the horizontal line
    data = scale_horizontal,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = scale_thickness,
    color = scale_color
    ) +
  geom_segment( ### Plotting the ticks
    data = tick,
    aes(x = x, xend = xend, 
        y = y, yend = yend),
    linewidth = tick_thickness,
    color = tick_color
    ) +
  geom_text(
    data = km,
    aes(x = x, y = y, hjust = hjust, label = label),
    size = km_size,
    color = km_color, 
    family = km_font)

calgary_improved_done
```

