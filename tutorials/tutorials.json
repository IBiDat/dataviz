[
  {
    "path": "tutorials/01/",
    "title": "01. Building Graphs Layer by Layer",
    "description": "This tutorial is a gentle introduction to ggplot2, one of the most successful\nsoftware packages for producing statistical graphics, created by Hadley\nWickham based on the \"Grammar of Graphs\" by Leland Wilkinson. It provides a\nsimple set of core principles, with carefully chosen defaults, to enable\nquick prototyping as well as publication-quality graphics. In what follows,\nwe will familiarize ourselves with the fundamental concepts and elements of\nevery ggplot2 graphic: how to create a plot object, add data, create a\nmapping to some aesthetics, and add layers of visual marks.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nPreliminaries\nWorkflow\nReading the documentation\nRequired packages\n\nData\nMain components\nMore aesthetics\nFaceting\nOutput\n\nSource: _tutorials/01/01.Rmd\nPreliminaries\nThis tutorial is heavily based on the First steps introductory chapter from the ggplot2 book. The best way to follow this tutorial is by using the RStudio IDE, so ensure that you have it installed in your computer (along with R).\nWorkflow\nTo start with, let’s create a new project by clicking on File > New Project.... Follow the steps to give it a sensible name (e.g., “dataviz”) and place it under a proper path in your computer. This creates a new folder where you can save all your files (scripts, plots, data…) related to this course, preferably organized following some logic (e.g., all scripts under a scripts subdirectory, etc.). Now, whenever you return to your project (if you close and open RStudio again, your last project is automatically opened; otherwise, click File > Recent Projects > ...), RStudio automatically sets the working directory (both of the file manager as well as the R session) to the project folder.\nOnce you open a new script (File > New File > R Script), the interface is divided in four sections:\nEditor (top-left), where you can edit the script file.\nConsole (bottom-left), where you can execute R commands in the current R session.\nEnvironment (top-right), where you can inspect the variables defined in the current R session.\nFiles / Plots / Packages / Help / Viewer (bottom-right), where you can browse your files, show your plots, inspect the installed packages, read the manual pages…\nSave that empty script (Ctrl + S) using a sensible name (e.g., 01-building_graphs_layer_by_layer.R) in your project folder (or some subfolder according to your organization logic).\nNow, the recommended workflow is to copy the chunks of code you’ll find in this tutorial into your script, and there you can run it (by selecting some lines and hitting Ctrl + Enter, or just hitting Ctrl + Enter sequentially to run code line by line), modify it, and try again. Be sure to save your progress with some frequency, just in case, and to comment your code (# comments starts with a hashtag like this). Future-you will thank you.\nAnother option would be to download the sources of this Rmd document, and use it to tinker with the chunks of code directly.\nReading the documentation\nA very important skill for every programming language is learning how to read its documentation. In R, we can quickly open the manual page for any function just by typing ?name-of-the-function in the console, for example, ?mean (try this yourself). Then, you’ll always find the same structure, more or less:\nDescription of the function, what the function does.\nUsage, how to call the function, sometimes with different objects.\nArguments, the description of every argument shown in the usage section.\nValue, what the function returns.\nOptionally, other sections with more details.\nOptionally, References.\nOptionally, a list of related functions called See Also.\nOptionally, but usually, Examples of usage.\nCheckpoint 1\nEnsure that you have\ncreated a new project for the course;\ncreated a new script in your project for this tutorial;\nlocated all the relevant panels and parts of the IDE;\nfigured out how to save the file;\nfigured out how to send the code from the script to the console for execution;\nbecome accustomed to the documentation.\nRequired packages\nFor this tutorial, we need these packages (run the following to install them if you don’t have them already):\n\n\ninstall.packages(\"ggplot2\")\n\n\nData\nIn this tutorial, we will mostly use one data set that is bundled with ggplot2: mpg. It includes information about the fuel economy of popular car models in 1999 and 2008, collected by the US Environmental Protection Agency.\n\n\nlibrary(ggplot2)\nmpg\n\n\n\n\nThe variables are mostly self-explanatory:\ncty and hwy record miles per gallon (mpg) for city and highway driving.\ndispl is the engine displacement in litres.\ndrv is the drivetrain: front wheel (f), rear wheel (r) or four wheel (4).\nmodel is the model of car. There are 38 models, selected because they had a new edition every year between 1999 and 2008.\nclass is a categorical variable describing the “type” of car: two seater, SUV, compact, etc.\nMain components\nThere are three main components to every ggplot:\nThe data in tidy format.\nA set of mappings from data attributes (variables) to visual channels (aesthetics).\nAt least one layer of visual marks to represent the observations in the dataset, which is usually created with a geom function.\nEvery ggplot starts with the object creation, via the ggplot() function:\n\n\nggplot()\n\n\nAs you can see, this generates just an empty frame: there is no data, no mappings, and therefore no guides or other elements. Even if we add some data, there are still nothing connecting it to any visual feature:\n\n\nggplot(mpg)\n\n\nNext, we can add some mappings. For instance, if we are interested in the relationship between miles per gallon in highway driving (hwy) vs. the engine displacement (displ), we would assign those attributes to y and x positions respectively using the aes() function:\n\n\nggplot(mpg, aes(x=displ, y=hwy))\n\n\nNow we obtained something new. Now, because there is data and mappings to x and y positions, ggplot2 applies some sensible defaults, and automatically adds Cartesian coordinates as well as linear continuous scales that nicely fit to the range of our data (you can check this with e.g. range(mpg$hwy)). Moreover, these scales display nicely formatted guides, with labeled ticks at regular intervals (not too many, not too few), major and minor grid lines, and axis labels after the names of our variables.\nWhat is missing here? Of course, the most important bit, which is the visual mark we are going to use to actually represent each observation. In this case, let us use simple points:\n\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point()\n\n\nEven if there is always the temptation to put everything together in a single line, it is a good practice to separate every function and layer in each own line for readability reasons. Also note that position channels x and y are so important that you do not need to name them (i.e. x=displ, y=hwy), but just remember that x comes first. Other channels like color, fill, shape, alpha, size… must be always named.\nAs shown above, it is common practice to add data and mapping to the very function that creates the chart object (see ?ggplot), and in this way they apply as defaults to every single layer we add. It is also possible to delay the mapping and still act as a default as follows:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point()\n\n\nThis is maybe more readable, especially when the mapping is complex, but the result is the same. We can also avoid setting a default dataset and mapping altogether, and just directly plug them into the layers that need them (note that now the order is mapping, then data):\n\n\nggplot() +\n  geom_point(aes(displ, hwy), mpg)\n\n\nHowever, usually we add several layers that refer to the same data, and occasionally some annotation layer that uses another dataset. Therefore, it is generally best to add a default dataset and mapping to avoid duplicated code across layers… or missing ones. For instance, where are the lines here?\n\n\nggplot() +\n  geom_point(aes(displ, hwy), mpg) +\n  geom_line()\n\n\nObviously, there are no lines because they do not have any mapping. It data and mapping are set as defaults, then we have both elements:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point() +\n  geom_line()\n\n\nCheckpoint 2\nHow would you describe the relationship between cty and hwy? Do you have any concerns about drawing conclusions from that plot?\nWhat does ggplot(mpg, aes(model, manufacturer)) + geom_point() show? Is it useful? How could you modify the data to make it more informative?\nDescribe the data, aesthetic mappings and layers used for each of the following plots. You’ll need to guess a little because you haven’t seen all the datasets and functions yet, but use your common sense! See if you can predict what the plot will look like before running the code.\nggplot(mpg, aes(cty, hwy)) + geom_point()\nggplot(diamonds, aes(carat, price)) + geom_point()\nggplot(economics, aes(date, unemploy)) + geom_line()\nggplot(mpg, aes(cty)) + geom_histogram()\n\nMore aesthetics\nTo add additional variables to a plot, we can map them into other channels such as color, shape, or size. For instance, let’s represent the car class as the color of the dots:\n\n\nggplot(mpg) +\n  aes(displ, hwy, color=class) +\n  geom_point()\n\n\nBased on the previous plot, we can see that the group of cars with unusually high fuel economy for their engine size are two seaters: cars with big engines, but lightweight bodies.\nOnce again, we can observe how ggplot2 applies some more sensible defaults:\nIt detects that class is a categorical variable, a factor, and applies a default color scale based on hue.\nAt the same time, the scale is responsible for creating a guide, in this case a legend that shows the class levels along with their associated mapping.\nSometimes it is also useful to split up some aesthetics that may apply only to certain layers. For example, in this case:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_line() +\n  geom_point(aes(color=class))\n\n\nHere, position aesthetics apply to all layers, and color is specific to the layer of points.\nEvery single aesthetic, every single channel, can be set to a fixed value. For instance, if we do not apply any mapping to color, we have previously seen that ggplot2 just draws black dots by default. But of course, this can be changed:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(color=\"blue\")\n\n\nMastering data mappings is an important skill and you will learn more about it in subsequent tutorials. See vignette(\"ggplot2-specs\") for a comprehensive guide on aesthetics.\nCheckpoint 3\nCompare the following two plots and reason why you get this result:\n\n\nggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = \"blue\"))\nggplot(mpg, aes(displ, hwy)) + geom_point(colour = \"blue\")\n\n\nExperiment with the color, shape and size aesthetics. What happens when you map them to continuous values? What about categorical values? What happens when you use more than one aesthetic in a plot?\nWhat happens if you map a continuous variable to shape? Why? What happens if you map trans to shape? Why?\nHow is drive train related to fuel economy? How is drive train related to engine size and class?\nFaceting\nThis is another fundamental technique for mapping categorical variables. It is most useful e.g. as an alternative to color hue when there are too many categories an no way of further aggregating the data.\nTake for instance the previous class example, with 7 different categories. A solution here is to trade color for position: faceting splits the data in as many subsets as categories in the mapped variable. The only difference with other mappings is that it cannot be applied as an aes(), but directly into the dedicated faceting function, and as a formula, preceded by a ~:\n\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  facet_wrap(~class) +\n  geom_point()\n\n\nCheckpoint 4\nWhat happens if you try to facet by a continuous variable like hwy? What about cyl? What’s the key difference?\nUse faceting to explore the 3-way relationship between fuel economy, engine size, and number of cylinders. How does faceting by number of cylinders change your assessment of the relationship between engine size and fuel economy?\nRead the documentation for facet_wrap(). What arguments can you use to control how many rows and columns appear in the output?\nWhat does the scales argument to facet_wrap() do? When might you use it?\nOutput\nIt should be noted that, with all the code above, we are not only creating chart objects, but also generating and displaying them in one go. This happens with other R objects too: when we do not assign an object to a variable, it is printed. In this case, printing a ggplot means constructing the visual object and displaying it. But of course, as with any other R object, we can save it in a variable and print it later:\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point()\nprint(p)\np # print is implicit\n\n\nWe can even build it step by step:\n\n\np <- ggplot(mpg)\np\np <- p + aes(displ, hwy)\np\np <- p + geom_point()\np\n\n\nOr using different variables:\n\n\np_base <- ggplot(mpg)\np_aes <- aes(displ, hwy)\np_dot <- geom_point()\np_base + p_aes + p_dot\n\n\nThis is convenient for interactive usage or reports as this one. But at other times we might want to produce a graph in a script and save it somewhere else as a standalone image or PDF. This is achieved with the ggsave() function:\n\n\nggsave(\"plot.png\", p, width = 5, height = 5)\n\n\nCheckpoint 5\nRead the documentation for ggsave(). What happens if you do not specify the plot argument?\nHow can you save the plot as a PDF file?\nHow can you modify the proportions of the plot?\nWhat happens if you change the resolution for a PNG output? And a SVG?\n\n\n\n",
    "preview": "tutorials/01/preview.png",
    "last_modified": "2022-10-10T17:48:02+02:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 600
  },
  {
    "path": "tutorials/02/",
    "title": "02. Scales and Guides",
    "description": "Scales are responsible for turning your mapping from data to aesthetics into\nsomething that you can see, and they also provide the guides that let you\ninterpret the plot: axes and legends. Scales are automatically inferred based\non the input data, and guides are added as well based on the layers in your\nplot, which is convenient and saves a lot of time. However, sometimes it is\nrequired to fine-tune how the mapping is performed, or how the guide should\nlook like. This tutorial explores the tools available for this.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nScale specification\nScale names\nLimits\nBreaks and labels\nGuides\nTransformations\n\nSource: _tutorials/02/02.Rmd\nScale specification\nWhile geoms represent visual objects (points, lines…), a scale is a procedure that actually performs the mapping of data attributes into the properties of those visual objects (position, color, size…). On the other hand, a guide is a visual cue that allows us to perform the inverse procedure: converting their properties back to data.\n\n\nlibrary(ggplot2)\n\n# convert number of cylinders to factor (only 3 levels)\nmtcars$Cylinders <- as.factor(mtcars$cyl)\n\np <- ggplot(mtcars) +\n  aes(mpg, wt) +\n  geom_point(aes(color=Cylinders))\np\n\n\nCommon components of axes and legends. Figure from the ggplot2 book.In the example above, two position scales (x and y)\ndetected that the data (mpg and wt) is continuous;\nset proper limits to the axes according to the range of data values;\nassigned a position in the chart space to each point according to such coordinates;\nadded the corresponding guides to the axes, including\nnicely and evenly spaced breaks, with tick marks and labels,\ncentered axis labels with the name of the variables.\n\nAdditionally, a color scale\ndetected that the data (Cylinders) is discrete (a categorical variable, a factor);\nassigned a color to each category following a default hue-based scale;\nadded the corresponding guide to the legend, including\nset of keys (colors),\nset of labels (categories in the data),\nlegend title with the name of the variable.\n\nIn other words, the plot above is equivalent to the following:\n\n\np +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_color_discrete()\n\n\nThe last three instructions are just inferred from the data and automatically added. We will only need to specify the scales manually whenever we want to override any of the defaults provided.\nThere are three fundamental scale types:\ncontinuous, for numerical quantities;\ndiscrete, for categorical variables;\nbinned, which is a special type for numerical quantities that first discretize the data.\nBased on these, the fundamental scales, in general, are constructed as follows:\nscale_<aes>_<type>()\nFor example:\nFor aesthetic x and a continuous variable: scale_x_continuous().\nFor aesthetic color and a categorical variable: scale_color_discrete().\nThen there are a bunch of special scales that are shortcuts for specific common tasks, such as scale_x_log10(), which is a continuous scale that also applies a logarithmic transformation, or scale_color_brewer(), which provides a bunch of discrete color schemes from ColorBrewer.\nCheckpoint 1\nTake the first example and assign the original cyl variable to color instead of Cylinders. What happens? Why? What is the scale function that is being applied here? What happens if we try to force scale_color_discrete() in this setting? Why?\nRead the documentation for scale_x_continuous(). How can you change the name of the axis? What happens if we manually specify the same scale twice (try adding different names)? Why?\nHow can you change the position of the axes?\nScale names\nAs you may have discovered in the previous section, all scales have a name argument that is used for the axis label (for position scales) or legend title (for other scales), and which by default prints the name of the variable. There is however a shortcut, a more direct way of setting these labels, via the labs() function.\n\n\np +\n  labs(\n    x = \"Fuel consumption in miles per gallon\",\n    y = \"Weight in thousands of pounds\",\n    color = \"Number of cylinders\"\n  )\n\n\nIn these strings, you can use \\n to insert a line break, but you can also supply mathematical expressions and other formatting options wrapped in quote(). See ?plotmath for documentation on which expressions can be used and how they are interpreted.\n\n\nx <- seq(from = -2, to = 2, by = .01)\nggplot(data.frame(x=x, y=x^3)) +\n  aes(x, y) +\n  geom_path() +\n  labs(y = quote(f(x) == x^3))\n\n\nCheckpoint 2\nHow can you remove an axis label, or a legend title?\nRead the documentation for labs(). Investigate what other labels, apart from the aesthetics, can be set with this function. Experiment with them.\nRead the documentation for ?plotmath. How can you set a title with some words in bold, others in italics…? How can you wrap a very long subtitle with line breaks?\nLimits\nScale limits are the region of the data space in which the mapping is defined: for continuous variables, ggplot2 defaults to the range() of the data; for categorical variables, it is just a discrete set of categories. However, you may have noticed that the limits of the axes extend a little bit past the range of the data. This is to ensure that the visual marks do not collide with the axes.\n\n\n# compare\nrange(mtcars$mpg)\nrange(mtcars$wt)\n# with the limits in\np\n\n\nSometimes, this automatic expansion is not desirable. It can be modified by providing an expansion() to the scales’ expand argument. E.g., to remove any expansion:\n\n\np +\n  scale_x_continuous(expand=expansion(0)) +\n  scale_y_continuous(expand=expansion(0))\n\n\nThis is often useful for maps and other area-based plots, but not so much for scatterplots, since it hides some points.\nAs with the name, all scales have a limits argument that can be used to change this default behavior, e.g. to increase the range for continuous variables, or to include some category that is not in our data for categorical variables. And again, this is also so common that there is a shortcut via the lims() function.\n\n\np +\n  lims(\n    x = c(0, 50),\n    y = c(0, 10),\n    color = factor(c(2, 4, 6, 8, 10))\n  )\n\n\nIn the plot above we increased the limits, but what happens if we try to “zoom-in”?, if we specify a range that leaves “out of bounds” (oob) values falling outside these limits?\n\n\np +\n  lims(\n    x = c(20, 25),\n    y = c(2, 4)\n  )\n\n\nAs you can see, the default behavior is to censor (by assigning a NA) those out-of-bounds values. Scales have an oob argument to modify this behavior, which default to scales::oob_censor.\n\n\np +\n  scale_x_continuous(limits=c(20, 25), oob=scales::oob_censor) +\n  scale_y_continuous(limits=c(2, 4), oob=scales::oob_censor)\n\n\nCheckpoint 3\nTake the last example and add a geom_smooth() layer. What is the difference between applying the default scales::oob_censor, scales::oob_squish and scales::oob_keep to the position scales?\nWhat happens if you provide a set of levels to the limits of the color scale that does not contain any of the categories present in the data?\nBreaks and labels\nWhen ggplot2’s algorithm to infer the appropriate number of tick marks for axes and legends fails, we can give it a hint using the n.breaks argument.\n\n\np +\n  scale_x_continuous(n.breaks=4)\n\n\nIf that is not good enough for our purposes, another option is to use the breaks argument (maybe in conjunction with minor_breaks) to explicitly set which ones we want.\n\n\np +\n  scale_x_continuous(breaks=c(10, 15, 30, 40), minor_breaks=c(20, 25))\n\n\nNote that the last break, 40, is not shown because it is out of range.\nAdditionally, another common task is to tune the label assigned to each break. This can be accomplished with the labels argument. We can set anything as labels, but these must match the number of breaks, so it is best to specify both at the same time.\n\n\np +\n  scale_x_continuous(breaks=c(10, 15, 30), labels=c(\"ten\", \"fifteen\", \"thirty\"))\n\n\nHelper functions scales::label_*() allow us to format the breaks following some pattern.\n\n\np +\n  scale_y_continuous(labels=scales::label_number(suffix=\"k\"))\n\n\nIn the previous example, we added “k” to indicate that the weight is in thousands of pounds. Other useful functions are scales::label_percent() to format numbers between 0 and 1 as percentages, or scales::label_dollar() to format numbers as currencies.\nCheckpoint 4\nModify the breaks and labels for the color scale in the previous plot. What happens if a category present in the data is dropped compared to what happens for the limits argument?\nGuides\nSo far we have been talking about scale names, breaks and labels, but they are really properties of the guides, axes and legends, which are the visual cues that allows us to interpret the visual objects and transform them back into data. Guides can be set, unset or fine-tuned using the guide argument, or via the special function guides(), which works similarly to labs() and lims().\n\n\np +\n  guides(\n    x = guide_axis(position=\"top\", angle=45),\n    color = guide_legend(reverse=TRUE)\n  )\n\n\nSee ?guide_axis, ?guide_legend and the more specific ?guide_colorbar for more options.\nTransformations\nScale transformations are specified using the trans argument. They transform the mapping without transforming the data. The most common use case is to adjust a continuous scale using some non-linear transformation to emphasize some values in the data that are hard to see in linear scale.\n\n\np +\n  scale_x_continuous(trans=\"log10\")\n\n\nSome common transformations, such as the logarithmic scale, have dedicated functions.\n\n\np +\n  scale_x_log10()\n\n\nCheckpoint 5\nCompare the last example with ggplot(mtcars) + aes(log10(mpg), wt) + geom_point(aes(color=Cylinders)). What are the differences? Why?\nRead the documentation for scale_x_continuous() and investigate how to do this. What is the default transformation? What does the \"reverse\" transformation do?\n\n\n\n",
    "preview": "tutorials/02/scale-guides.png",
    "last_modified": "2022-11-07T11:31:46+01:00",
    "input_file": {},
    "preview_width": 744,
    "preview_height": 367
  },
  {
    "path": "tutorials/03/",
    "title": "03. Coordinate Systems",
    "description": "The meaning of position aesthetics and how they produce a 2D position on the\nplot depend on the coordinate system. This is also responsible for drawing\nthe axes and panel backgrounds (grid lines, etc.). As with scales, Cartesian\ncoordinates are applied by default unless stated otherwise, which preserves\nthe common meaning of x and y.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nCartesian coordinates\nHow to make a pie\nTransformations\nMaps\n\nSource: _tutorials/03/03.Rmd\nCartesian coordinates\nMost of the plots we know and love use Cartesian coordinates, where the position of an element is given by orthogonal distances, x and y, to an origin.\n\n\nlibrary(ggplot2)\n\nggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=class))\n\n\nEven when one of the axis is a categorical variable, the same concept of “distance to an origin” applies, because internally those categories are mapped to positions 1, 2, 3…\n\n\nggplot(mpg) +\n  aes(displ, class) +\n  geom_col() +\n  geom_text(aes(label=class), data.frame(\n    displ = 200, class = c(1, 2, 3, 4, 5, 6, 7)\n  ))\n\n\nAs with scales, coord_cartesian() is the default, and it does not need to be explicitly specified to produce a plot. However, this function has some useful options that makes some things easier. Particularly, you may recall from the previous tutorial that zooming in by setting the limits of a scale by default censors points that are out of bounds (meaning that they are marked as missing with a NA). For scales, an additional argument oob must be specified in order to keep those points (e.g. for smoothing calculations). In contrast, coord_cartesian() provides limits that do not censor data. Therefore, the following plots are equivalent:\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=class)) +\n  geom_smooth()\n\np +\n  scale_x_continuous(limits=c(3, 4), oob=scales::oob_keep) +\n  scale_y_continuous(limits=c(20, 30), oob=scales::oob_keep)\n\np +\n  coord_cartesian(xlim=c(3, 4), ylim=c(20, 30))\n\n\nCheckpoint 1\nFunction coord_flip() comes in handy to exchange the x and y axes. Take the first example and add geom_smooth(method=\"lm\"). What is the difference between adding coord_flip() and directly exchanging the x and y mapping in the aes()? Why?\nTake the first example and add coord_fixed(). Then use variable cty instead of displ to compare. What does this function do? What could be a good use case for this?\nHow to make a pie\nA pie chart is just a single stacked bar in polar coordinates. For instance, take this one:\n\n\np <- ggplot(mpg) +\n  aes(\"cars\", fill=class) +\n  geom_bar()\np\n\n\nThen, we just need to fold it using y (the count produced by geom_bar) as the angle:\n\n\np + coord_polar(theta=\"y\")\n\n\nSo much effort for such a meaningless visualization. :)\nTransformations\nTransformations can be performed at two levels: at the scale level, via the trans argument to the scale functions (or the dedicated scales such as scale_x_log10()), or at the coordinate system level, via coord_trans(). The only difference is that the first ones occur before any statistics are computed, while the second ones occur after those.\nCheckpoint 2\nTake the first example and add geom_smooth(method=\"lm\"). What is the difference between adding scale_x_log10() and adding coord_trans(x=\"log10\")? Why?\nMaps\nFinally, an important family of coordinate systems are map projections. Enter the fascinating world of how to map a sphere to a plane.\n\n\np <- ggplot(map_data(\"world\")) +\n  aes(long, lat, group=group) +\n  geom_path()\n\np # No projection specified, simply long, lat as x, y\np + coord_map(xlim=c(-180, 180)) # Mercator projection by default\np + coord_map(\"orthographic\", xlim=c(-180, 180))\np + coord_map(\"sinusoidal\", xlim=c(-180, 180))\n\n\nSee ?mapproj::mapproject for more info about projections.\nCheckpoint 3\nClick “Zoom” in the plot panel for each of the four plots proposed above. What happens if you stretch and shrink the width of the plot panel in each case? Why?\n\n\n\n",
    "preview": "tutorials/03/preview.png",
    "last_modified": "2022-10-10T20:12:20+02:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 675
  },
  {
    "path": "tutorials/04/",
    "title": "04. Faceting",
    "description": "Faceting is a way to trade off some discrete aesthetic (e.g. hue) for position.\nIt generates multiple subsets of the data (filtered by the values of some\ntypically categorical variable) and shows them side by side. In this tutorial,\nthe three kinds of facets available are explored as well as how they interact\nwith position scales.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nFacet specification\nFacet wrap\nFacet grid\nControlling the scales\nMissing faceting variables\n\nSource: _tutorials/04/04.Rmd\nFacet specification\nFaceting is a powerful tool for exploratory data analysis. It is not just a mapping to position, but also a data filtering operation: it generates as many different views of the dataset as levels of the variable(s) selected. Therefore, instead of being specified as another aesthetic, faceting is performed via three functions:\nfacet_null(): this is the default, meaning that no faceting is performed.\nfacet_wrap(): wraps a 1D ribbon of panels defined by a variable (or interaction between variables) into 2D, by default using the same number of rows and columns as much as possible.\nfacet_grid(): produces a matrix, a 2D grid of panels, with rows and columns respectively indexed by a different variable (or interaction between variables).\nDifferences between facet_grid and facet_wrap. Figure from the ggplot2 book.The differences between facet_wrap() and facet_grid() are depicted in the figure above. Essentially, on the left we have two factors: the first one indexes rows with levels 1, 2, 3; the second one indexes columns with levels A, B, C. On the other hand, on the right, a single factor has nine levels, and the set of panels are just arranged sequentially on a 3x3 grid.\nFacet wrap\nfacet_wrap() takes a long ribbon of panels and wraps it in a space-efficient manner, i.e. in a grid with a balanced number of rows and columns. In its simplest form, each panel depicts the data filtered by the factor level defined by a single variable.\n\n\nlibrary(ggplot2)\n\np <- ggplot(mpg, aes(displ, hwy)) + \n  geom_point()\n\np + facet_wrap(~ class)\n\n\nNote the use of the formula notation, ~ class, and the strips on top labeled with the values of the variable class. Note also that all the facets share the same x/y scales (same limits, same guides…).\nMore variables can be added to such formula, and this is interpreted as the _interaction between the variables. Therefore, the facets depict all the possible combinations of the levels of those variables.\n\n\np + facet_wrap(~ class + cyl)\n\n\nYou can control the dimensions of this grid with ncol and nrow (you only need to set one), while as.table and dir define how the grid is filled. The position of the strip can be controlled with strip.position.\nFacet grid\nfacet_grid() is a similar concept, but now the left and right side of the formula index the rows and columns respectively.\n\n\np + facet_grid(class ~ .) # by row\np + facet_grid(~ class)   # by column\n\n\nOn the one hand, the number of rows and columns cannot be fixed anymore, because it depends on the number of levels that the associated variable contains. On the other hand, positioning by row facilitates the comparison of x values, because horizontal scales are all aligned (useful to compare distributions), while positioning by column facilitates the comparison of y values (useful to compare bar heights).\nMoreover, comparing the levels of two factors is easier too:\n\n\np + facet_grid(cyl ~ class) # cyl by row, class by column\n\n\nCheckpoint 1\nConsider the last example. Using the same specification, cyl ~ class, how many panels are produced with facet_wrap() and facet_grid()? Why? Investigate how to produce the exact same panel layout of the facet_grid() invocation by modifying the arguments of the facet_wrap() function.\nfacet_grid() has the same parameter you modified above. Why is it not taking any effect? When would it take effect?\nInvestigate the margins argument for the facet_grid() function. Add color by cyl and by class alternatively to demonstrate the effect of the margins argument.\nControlling the scales\nBy default, all panels share the same position scales, which is the best choice for most applications to avoid confusing the reader. However, sometimes it is useful to be able to zoom in the data, or, in other words, to drop some empty parts in order to increase the data-ink ratio. This is achieved via the scales argument:\nscales = \"fixed\": x and y scales are fixed across all panels (default).\nscales = \"free_x\": the x scale is free, and the y scale is fixed.\nscales = \"free_y\": the y scale is free, and the x scale is fixed.\nscales = \"free\": x and y scales vary across panels.\nThis is particularly interesting for comparing time series that may be measured in very different units.\n\n\np <- ggplot(economics_long) +\n  aes(date, value) +\n  geom_line()\n\np + facet_grid(variable ~ .)\np + facet_grid(variable ~ ., scales=\"free_y\")\n\n\nCheckpoint 2\nfacet_grid() has an additional parameter space that is very useful in conjunction with scales. Using ggplot(mpg) + aes(cty, model) + geom_point() as your base graph, set facets so that rows are indexed by manufacturer, and investigate how to use the scales and space arguments to improve the visualization.\nMissing faceting variables\nUnlike aesthetics, faceting is always set globally and cannot be specified per geometry. What happens then if we specify multiple datasets in multiple geometries and faceting variables are missing in some of them? Let’s find out:\n\n\ndf1 <- data.frame(x = 1:3, y = 1:3, gender = c(\"f\", \"f\", \"m\"))\ndf2 <- data.frame(x = 2.5, y = 2.5)\n\nggplot(df1) +\n  aes(x, y) +\n  geom_point(data = df2, color = \"red\") + \n  geom_point() +\n  facet_wrap(~ gender)\n\n\nAs can be seen, the red dot, corresponding to the dataset without the gender variable, appears in all facets.\nCheckpoint 3\nUse the first example (hwy vs. displ, faceted by class) as your base plot. Add another geom_point() layer with a new dataset, in the appropriate place, so that all the points appear in all the facets but dimmed in the background.\nHow can we add to the previous plot a geom_smooth() curve to all facets based on the whole dataset?\n\n\n\n",
    "preview": "tutorials/04/position-facets.png",
    "last_modified": "2022-11-07T11:31:46+01:00",
    "input_file": {},
    "preview_width": 557,
    "preview_height": 310
  },
  {
    "path": "tutorials/05/",
    "title": "05. Themes",
    "description": "The final piece in the ggplot2 equation is theming. The powerful theme system\ndoes not affect any perceptual properties of the plot, but it help us make\nproduction-quality graphs through a fine control over things like fonts, ticks,\npanel strips, backgrounds...",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nIntroduction\nPredefined themes\nBuilt-in themes\nMore themes\n\nModifying theme components\nText elements\nLine elements\nRectangle elements\n\nTheme elements\nPlot elements\nAxis elements\nLegend elements\nPanel elements\nFaceting elements\n\nAdvanced font usage\nSetting the DPI\nFiguring out a font\n\n\nSource: _tutorials/05/05.Rmd\nIntroduction\nThe central part of the theme system is the theme() function, which has 40+ configurable elements divided into 5 main categories: plot, axis, legend, panel and faceting elements. In those categories, individual elements are arranged in a hierarchical structure with self-explanatory names. For instance, plot.title controls the appearance of the plot title; axis.ticks.x, the ticks on the x axis, etc.\nEach of these elements can be set with one of three basic types: element_text(), for text elements; element_line(), for lines, and element_rect(), for borders and backgrounds. Additionally, elements can be unset, or removed, with element_blank(), which draws nothing.\nThemes can be built with a + theme(...) invocation by specifying each one of these elements to the desired style via the corresponding element function. However, there are many predefined themes available, and oftentimes it is much simpler to specify the theme that best suits our needs and then change small details via the theme() function. For example, here we change the default theme to theme_bw() and then we tweak the legend so that is displayed inside the plot, on the top-right corner.\n\n\nlibrary(ggplot2)\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=factor(cyl)))\n\np\np +\n  theme_bw() +\n  theme(\n    legend.position = c(0.99, 0.99),\n    legend.justification = c(1, 1)\n  )\n\n\nPredefined themes\nggplot2 comes with a number of built-in themes, and there are many ggplot2 extensions that are specifically dedicated to provide new themes. These themes can be set on a per-plot basis, as we did in the previous example, or you can set a global theme that replaces the default one.\n\n\ntheme_set(theme_classic())\n\np # now this uses the classic theme by default\n\n\nThis global theme can be tweaked too via the theme_update() function, which accepts the same arguments as theme().\n\n\ntheme_update(\n  legend.position = c(0.99, 0.99),\n  legend.justification = c(1, 1)\n)\n\np # now the legend is inside the plot by default\n\n\nBuilt-in themes\nggplot’s characteristic visual signature (grey background with white grid lines) is defined in theme_grey(), which is applied by default to all plots unless replaced as done previously.\n\n\ntheme_set(theme_grey())\n\np # back to the default\n\n\nThere are seven other built-in themes:\ntheme_bw(): a variation on theme_grey() that uses a white background and thin grey grid lines.\ntheme_linedraw(): A theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing.\ntheme_light(): similar to theme_linedraw() but with light grey lines and axes, to direct more attention towards the data.\ntheme_dark(): the dark cousin of theme_light(), with similar line sizes but a dark background. Useful to make thin coloured lines pop out.\ntheme_minimal(): A minimalistic theme with no background annotations.\ntheme_classic(): A classic-looking theme, with x and y axis lines and no gridlines.\ntheme_void(): A completely empty theme.\nInternally, themes are just a call to theme() that sets the complete set of parameters available to the appropriate values, like theme_grey:\n\n\n# execute this line as is, without parentheses, to inspect the internals\ntheme_grey\n\n\nOthers are based on some theme, and then perform some tweaks:\n\n\ntheme_bw # based on theme_grey\n\n\nCheckpoint 1\nSee the manual page for the built-in set of themes, and play with the examples to familiarize yourself with the different styles.\nIn which theme is based each one of the built-in themes?\nMore themes\nThere are numerous packages that provide themes as part of their functionality, but also entire packages specifically dedicated to this. This is a non-comprehensive list that highlights some noteworthy themes:\ncowplot: Provides some themes that are opinionated versions of built-in ones.\nggdark: Dark versions of built-in themes.\nggtech: Classic-like themes in the style of several tech companies.\nggthemes: Includes themes inspired by The Economist, The Wall Street Journal, FiveThirtyEight, and Tufte among others.\nggthemr: Themes with special care for color palettes.\nhrbrthemes: Nicely curated set of themes, with special care for the fonts, by Bob Rudis.\ntvthemes: Collection of themes inspired by TV shows.\nModifying theme components\nOnce we have set a predefined theme that is close enough to what we try to achieve, it is time for tweaking. To modify individual theme components, you use code like plot + theme(element.name = element_type(...)). Apart from element_blank(), which unsets an element,\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  labs(title=\"This is a title\")\n\np\np + theme(panel.grid.major = element_blank())\n\n\nthere are three basic types of elements (text, line, rect), and the setter function must match that type.\nText elements\nelement_text() draws labels and headings. You can control the font family, face, colour, size (in points), hjust, vjust, angle (in degrees) and lineheight (as ratio of fontcase). More details on the parameters can be found in vignette(\"ggplot2-specs\").\n\n\np + theme(plot.title = element_text(size = 30))\np + theme(plot.title = element_text(face = \"bold\", color = \"red\"))\np + theme(plot.title = element_text(hjust = 1))\n\n\nLine elements\nelement_line() draws lines parametrized by color, size and linetype.\n\n\np + theme(panel.grid.major = element_line(color = \"black\"))\np + theme(panel.grid.major = element_line(color = \"black\", size = 2))\np + theme(panel.grid.major = element_line(color = \"black\", linetype = \"dotted\"))\n\n\nRectangle elements\nelement_rect() draws rectangles, mostly used for backgrounds, parametrized by fill color and border color, size and linetype.\n\n\np + theme(plot.background = element_rect(fill = \"grey80\", color = NA))\np + theme(plot.background = element_rect(color = \"red\", size = 2))\np + theme(panel.background = element_rect(fill = \"linen\"))\n\n\nTheme elements\nThere are four general elements that affect all elements of their kind:\n\nElement\nSetter\nDescription\nline\nelement_line()\nAffects all line elements.\nrect\nelement_rect()\nAffects all rectangular elements.\ntext\nelement_text()\nAffects all text elements.\ntitle\nelement_text()\nAffects all title elements.\nplot.margin\nunit()\nMargin around the plot.\n\nAll individual elements that can be set with element_line() inherit from line, and so on and so forth. Then, individual elements can be fine-tuned via their specific configuration option, that can be subdivided into plot, axis, legend, panel and faceting elements. These individual elements have a hierarchical structure too, meaning that e.g. axis.title.*.*, if not specified, inherits from axis.title.\n\nOverview of theme elements. Figure from ggplot2 Theme Elements Demonstration by Henry Wang.\nPlot elements\nSome elements affect the plot as a whole:\n\nElement\nSetter\nDescription\nplot.background\nelement_rect()\nBackground for the entire plot.\nplot.titleplot.subtitleplot.captionplot.tag\nelement_rect()\nPlot title, subtitle, caption and tag. Elements subtitle, caption and tag inherit from title by default, but can be set separately.\nplot.title.positionplot.caption.position\ncharacter\nAlignment of title (affects subtitle too) and caption (“panel” and “plot”, which align with and without margins respectively).\nplot.tag.position\ncharacter or numeric\nAligment of tag (“topleft”, “top”, “topright”, “left”, “right”, “bottomleft”, “bottom”, “bottomright”, or a coordinate).\nplot.margin\nunit()\nMargin around the plot.\n\nBy default, ggplot2 uses a white background to ensure that the plot can be read no matter where it is placed. Sometimes you may want to blend it with the background color of a document (e.g., a presentation), in which case it is useful to set a transparent background with fill=NA. In a similar way, if the destination document already defines margins around the plot, you may want to eliminate those.\n\n\np + theme(\n  plot.background = element_rect(fill=\"blue\", color=\"red\", size=3),\n  plot.title = element_text(size = 30),\n  plot.margin = margin(50, 10, 10, 10)\n)\n\n\nAxis elements\nThe axis elements control the appearance of the axes:\n\nElement\nSetter\nDescription\naxis.titleaxis.title.xaxis.title.x.topaxis.title.x.bottomaxis.title.yaxis.title.y.leftaxis.title.y.right\nelement_text()\nAxis titles.\naxis.textaxis.text.xaxis.text.x.topaxis.text.x.bottomaxis.text.yaxis.text.y.leftaxis.text.y.right\nelement_text()\nAxis tick labels.\naxis.ticksaxis.ticks.xaxis.ticks.x.topaxis.ticks.x.bottomaxis.ticks.yaxis.ticks.y.leftaxis.ticks.y.right\nelement_line()\nAxis tick marks.\naxis.ticks.lengthaxis.ticks.length.xaxis.ticks.length.x.topaxis.ticks.length.x.bottomaxis.ticks.length.yaxis.ticks.length.y.leftaxis.ticks.length.y.right\nunit()\nLength of tick marks.\naxis.lineaxis.line.xaxis.line.x.topaxis.line.x.bottomaxis.line.yaxis.line.y.leftaxis.line.y.right\nelement_line()\nLine parallel to axis (hidden in default theme).\n\nNote that anything set for axis.line is inherited by axis.line.x and axis.line.y.\n\n\np + theme(\n  axis.line = element_line(size=5),\n  axis.line.y = element_line(color=\"red\"),\n)\n\n\nA common task is to rotate labels to avoid overlap of very long labels.\n\n\np +\n  scale_x_continuous(labels=scales::label_number(prefix=\"a very long label \")) +\n  theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1))\n\n\nLegend elements\nThe legend elements control the appearance of all legends. You can also modify the appearance of individual legends by modifying the same elements in guide_legend() or guide_colourbar().\n\nElement\nSetter\nDescription\nlegend.background\nelement_rect()\nBackground of legend.\nlegend.margin\nmargin()\nMargin around each legend.\nlegend.spacinglegend.spacing.xlegend.spacing.y\nunit()\nSpacing between legends.\nlegend.key\nelement_rect()\nBackground of legend keys.\nlegend.key.sizelegend.key.heightlegend.key.width\nunit()\nLegend key size. Height and width inherit from size unless specified separately.\nlegend.text\nelement_text()\nLegend item labels.\nlegend.text.align\n0–1\nLegend label alignment (0 = right, 1 = left).\nlegend.title\nelement_text()\nTitle of legend.\nlegend.title.align\n0–1\nLegend title alignment (0 = right, 1 = left).\nlegend.position\ncharacter or numeric\nPosition of legends (“none”, “left”, “right”, “bottom”, “top” for outside placement; two-element numeric vector for inside placement: 0 = bottom/left, 1 = top/right).\nlegend.direction\ncharacter\nLayout of items in legends (“horizontal” or “vertical”).\nlegend.justification\ncharacter or numeric\nAnchor point for legend positioning (“center” or two-element numeric vector: 0 = bottom/left, 1 = top/right).\nlegend.box\ncharacter\nArrangement of multiple legends (“horizontal” or “vertical”).\nlegend.box.just\ncharacter\nJustification of each legend (“top”, “bottom”, “left”, “right”).\nlegend.box.margin\nmargin()\nMargin around full legend area.\nlegend.box.background\nelement_rect()\nBackground of legend area.\nlegend.box.spacing\nunit()\nSpacing between plotting area and legend box.\n\nA common task is to modify legend placement.\n\n\np1 <- p + geom_point(aes(color=factor(cyl)))\n\np1\np1 + theme(\n  legend.position = \"top\",\n  legend.justification = \"right\"\n)\np1 + theme(\n  legend.position = c(1, 1),\n  legend.justification = c(1, 1)\n)\np1 + theme(\n  legend.position = c(1, 1),\n  legend.justification = c(1, 1),\n  legend.background = element_rect(fill=NA)\n)\n\n\nPanel elements\nPanel elements control the appearance of the plotting panels:\n\nElement\nSetter\nDescription\naspect.ratio\nnumeric\nAspect ratio of the panel.\npanel.background\nelement_rect()\nBackground of plotting area (under data).\npanel.border\nelement_rect()\nBorder around plotting area (over data).\npanel.gridpanel.grid.majorpanel.grid.major.xpanel.grid.major.ypanel.grid.minorpanel.grid.minor.xpanel.grid.minor.y\nelement_line()\nGrid lines. Major and minor grid lines, as well as individual ones for axis x and y, can be specified separately.\npanel.ontop\nlogical\nOption to place the panel over the data layers (usually used with a transparent or blank panel.background).\n\nNote that aspect.ratio fixes the aspect ratio of just the panel, but not the plot.\n\n\np + theme(aspect.ratio = 2/1)\n\n\nFaceting elements\nThe following theme elements are associated with faceted ggplots:\n\nElement\nSetter\nDescription\npanel.spacingpanel.spacing.xpanel.spacing.y\nunit()\nSpacing between facets.\nstrip.backgroundstrip.background.xstrip.background.y\nelement_rect()\nBackground of facet labels.\nstrip.placement\ncharacter\nPlacement of facet labels with respect to axes (“inside” or “outside”).\nstrip.textstrip.text.xstrip.text.y\nelement_text()\nFacet labels.\nstrip.switch.pad.gridstrip.switch.pad.wrap\nunit()\nSpace between facet labels and axes when strips are switched.\n\nNote that strip.text.x affects both facet_wrap() and facet_grid(), but strip.text.y only affects facet_grid().\nCheckpoint 2\ntheme_dark() makes the inside of the plot dark, but not the outside. Change the plot background to black, and then update the text settings so you can still read the labels.\nAdvanced font usage\nSetting fonts is a tricky issue. The reason is that we have to rely on the few fonts available to R by default. If a font is not available, a default one will be used instead. For example, compare this to Futura:\n\n\np + \n  theme(text = element_text(family=\"Futura\")) +\n  labs(subtitle=\"This is not Futura\")\n\n\nEven if this font is installed in your system (which most probably will not, because it is a non-free font), it is not available to R by default. There are packages, such as extrafont, that makes it easier to use your system fonts, or arbitrary font files, in R. But there is a better way.\nThe easiest way of ensuring reproducible results across platforms is to select a free font available in Google Fonts, and then apply it to your theme. For this, we need to install the showtext package, and a couple of additional commands. In this example, we apply the nice handwritten font Caveat:\n\n\nsysfonts::font_add_google(\"Caveat\", family=\"caveat\")\nshowtext::showtext_auto()\n\np + theme(text = element_text(family=\"caveat\"))\n\n\nNote also that font selection is so important for the look and feel of a graphic that many predefined themes provide specific arguments to change the font family and size.\n\n\np + theme_bw(base_family=\"caveat\")\n\n\nSetting the DPI\nThe DPI, or Dots Per Inch, is a measure of image resolution. RStudio’s Plot pane uses a resolution of only 96 DPI for speed reasons, but ggsave() uses a default of 300 DPI, which is the standard quality for printing. The issue with showtext is that DPI is not automatically detected. It works well for 96 DPI (so plots in the panel look fine), but it needs to be set manually for higher DPIs. E.g., the font here will look too small:\n\n\nggsave(\"test_96.png\", p + theme_bw(base_family=\"caveat\"))\n\n\nTherefore, you must set the proper DPI beforehand:\n\n\nshowtext::showtext_opts(dpi=300)\nggsave(\"test_300.png\", p + theme_bw(base_family=\"caveat\"))\nshowtext::showtext_opts(dpi=96) # reset default\n\n\nFor R Markdown documents, there is a special chunk option, fig.showtext=TRUE, that performs this for you:\n\n```{r, fig.showtext=TRUE}\np + theme_bw(base_family=\"caveat\")\n```\n\nSee this issue for further discussion.\nCheckpoint 3\nFind two fonts of your liking in Google Fonts. Apply one of them to all text elements except for the subtitle, that should use the second font.\nFiguring out a font\nSometimes we find a nice font that we would like to use in a graph (or, in general, in any document). How to figure out which font it is?, or, at least, a similar one… There are two levels of difficulty here depending on the source medium:\nA webpage: If the intended font is included in some webpage, you are in luck, because these are the easiest to figure out. One way is to manually search in the source code of the webpage: with a right-click on the text, you need to choose the menu item that opens the page’s code (Inspect in Chrome), then you can look for a CSS property called font-family in the Styles tab. An even easier way is to just copy the text and paste it in a document (e.g. a Google Docs). The font family will be automatically recognized.\nAn image: (Or anything that can be saved as an image). There are multiple online services dedicated to identifying fonts in images. A popular one is What The Font.\n\n\n\n",
    "preview": "tutorials/05/theme-elements.png",
    "last_modified": "2024-01-22T19:05:43+01:00",
    "input_file": {},
    "preview_width": 1193,
    "preview_height": 880
  },
  {
    "path": "tutorials/06/",
    "title": "06. Annotations",
    "description": "When constructing a graph, it is often necessary to make annotations to the\ndata displayed. Annotations provide the necessary context to direct the\nreader's attention and build an effective story. This metadata, as a form of\ndata, will use the same geoms and tools that we already know. However, there\nare some helpers, in ggplot2 as well as other extension packages, that may be\nuseful for certain special use cases.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nPlot titles and guides\nText labels\nCustom annotations\nHighlighting points\nReference lines\nReference areas\nIndividual annotations\nWorking with spatial coordinates\n\nDirect labeling\n\nSource: _tutorials/06/06.Rmd\nPlot titles and guides\nThe most simple and useful form of annotation is to set a proper title to the plot and the guides (axes and legend), which can be done in one go by using the labs() helper. Additionally, the plot subtitle is a good opportunity to further help the interested reader, and the caption is an unobtrusive place to put your data sources.\n\n\np <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point(aes(color=factor(cyl)))\n\np +\n  labs(\n    x = \"Engine displacement [litres]\",\n    y = \"Highway mileage [miles/gallon]\",\n    color = \"Number of\\ncylinders\",\n    title = \"Mileage by engine size and cylinders\",\n    subtitle = paste(\n      \"Highway mileage seems to be correlated with engine size,\",\n      \"but differences are mostly driven by the number of cylinders\",\n      sep=\"\\n\"),\n    caption = \"Source: http://fueleconomy.gov\"\n  )\n\n\nNote that newline characters \\n must be set to avoid text overflow. For arbitrary text, given a maximum width size in characters, this can be automated:\n\n\nlong_string <- stringi::stri_rand_lipsum(1)\nlong_string\n\nshort_strings <- strwrap(long_string, width=60)\nshort_strings\n\n# collapse with newlines\np + labs(subtitle = paste(short_strings, collapse=\"\\n\"))\n\n\nThe ggtext package provides improved text rendering capabilities via Markdown and HTML. To enable this functionality, the relevant elements must be set to ggtext::element_markdown().\n\n\np +\n  labs(title = \"A title with *italics* and **boldface**\") +\n  theme(plot.title = ggtext::element_markdown())\n\n\nText labels\nAdding text annotations at particular (x, y) coordinates is one of the most common annotation tasks. The main tool for this is the geom_text() function, which obeys the label aesthetic.\n\n\np + geom_text(aes(label=model))\n\n\nThis geom automatically draws every single label in the dataset, which is rarely appropriate. There is an automated way of checking overlapping labels and remove some of them.\n\n\np + geom_text(aes(label=model), check_overlap=TRUE)\n\n\nHowever, labeling must be carefully considered to highlight specific data points, such as outliers or other data of interest. To this end, the best approach is to filter the original data to the subset of interest.\n\n\nannotation <- dplyr::filter(mpg, hwy > 40)\np + geom_text(aes(label=model), annotation)\n\n\nUsually, proper placement must be adjusted via hjust and/or vjust, which is a number between 0 and 1. By default, text is centered (vertically and horizontally), i.e. hjust=0.5 and vjust=0.5.\n\n\np + geom_text(aes(label=model), annotation, hjust=0)\n\n\nIt is possible to go beyond this 0-1 (0-100%) range to set some space between the point and the label.\n\n\np + geom_text(aes(label=model), annotation, hjust=-0.2)\n\n\nBut, being a percentage, this approach would set different spaces for label with different lengths. A better approach is to use the nudge_* argument to add a small space that does not depend on the label length.\n\n\np + geom_text(aes(label=model), annotation, hjust=0, nudge_x=0.1)\n\n\nEven after filtering, in the example above we still have overlapping labels, because there are overlapping outliers. In these situations, the utilities offered by the ggrepel package come in handy.\n\n\np + ggrepel::geom_text_repel(aes(label=model), annotation)\n\n\nTo better distinguish the label from the background, sometimes it is useful to use geom_label() instead, or the _repel version. The only difference is that these functions draw an actual label around the text.\n\n\np + ggrepel::geom_label_repel(aes(label=model), annotation)\n\n\nIf the result still looks a bit confusing, there are further options to customize ggrepel’s behavior.\n\n\np + ggrepel::geom_label_repel(aes(label=model), annotation,\n                              direction=\"x\", nudge_x=0.1)\n\n\nCheckpoint 1\nUsing the mpg dataset, make a barplot of the number of vehicles per class. Remove the axis and annotate the bars with the counts instead.\nInvestigate how to do this using the ggfittext package instead.\nCustom annotations\nMany geoms can be used to make custom annotations, including points, lines, rectangles and other shapes. This, together with the technique of filtering the original data to produce an annotation dataset, or even building an entirely new dataset for this purpose, opens up a world of possibilities.\nHighlighting points\nSpecific points may be highlighted by changing the color, size, shape, or stroke.\n\n\np + geom_point(data=annotation, shape=4, size=3)\n\n\nReference lines\nAny line can be used as an annotation, but horizontal, vertical and oblique reference lines that span the entire plot are commonly used to divide regions of the plot. This is achieved via the special geoms geom_hline(), geom_vline() and geom_abline() respectively.\n\n\n# line to highlight the outliers above y=40\np + geom_hline(yintercept=40, linetype=\"dashed\")\n\n# divide regions approximately by cyl\np + geom_vline(xintercept=c(2.6, 4.1), linetype=\"dashed\")\n\n\nReference areas\nThe division of the panel area into regions can be further stressed by adding slightly colored rectangles that expand towards infinity. In this case, such rectangles should be drawn before the actual data to avoid masking it.\n\n\ndivisions <- c(2.6, 4.1)\ndf.rect <- data.frame(\n  xmin = c(-Inf, divisions),\n  xmax = c(divisions, Inf),\n  ymin = -Inf,\n  ymax = Inf,\n  cyl =  c(4, 6, 8)\n)\n\nggplot(mpg) +\n  aes(fill=factor(cyl)) +\n  geom_rect(aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),\n            df.rect, alpha=0.2, show.legend=FALSE) +\n  geom_point(aes(displ, hwy, color=factor(cyl))) +\n  theme_bw()\n\n\nIndividual annotations\nThe special function annotate() allows us to select any geom to make an individual annotation. The arguments should match the aesthetics required by the geom as well as other optional parameters.\n\n\np +\n  annotate(\"segment\", x=2, xend=3, y=unique(annotation$hwy), yend=42) +\n  annotate(\"text\", x=3, y=42, hjust=0, nudge_x=0.1, label=\"These are outliers\")\n\n\nCheckpoint 2\nUsing the mpg dataset, make a scatterplot of y=hwy vs. x=displ, and highlight some points by placing a yellowish shadow under them.\nUsing the previous plot as the base, investigate how to apply geom_abline() to trace an oblique dashed line that goes through the coordinates (2, 10) and (3, 30).\nUsing the previous plot as the base, draw a small rectangle around the points with cyl=5, put a label somewhere in the empty space of the panel, and connect the rectangle with the label with a curved segment ending in an arrow.\nWorking with spatial coordinates\nAnnotations on maps need to be specified in the same units as the Coordinate Reference System of the underlying geometries. In the following example, a segment is drawn from Ottawa to Melbourne using their approximate longitude/latitude positions:\n\n\nworld <- giscoR::gisco_get_countries()\nottawa <- c(-75, 45)\nmelbourne <- c(145, -38)\n\nggplot(world) +\n  geom_sf() +\n  annotate(\"segment\", x=ottawa[1], y=ottawa[2],\n           xend=melbourne[1], yend=melbourne[2])\n\n\nHowever, if we switch e.g. to the Robinson projection, it does not work anymore:\n\n\nggplot(world) +\n  geom_sf() +\n  annotate(\"segment\", x=ottawa[1], y=ottawa[2],\n           xend=melbourne[1], yend=melbourne[2]) +\n  coord_sf(crs=\"+proj=robin\")\n\n\nInstead, we need to transform those coordinates to the new projection beforehand:\n\n\nottawa <- sf::st_sfc(sf::st_point(ottawa), crs=4326)\nmelbourne <- sf::st_sfc(sf::st_point(melbourne), crs=4326)\nottawa <- sf::st_transform(ottawa, \"+proj=robin\")[[1]]\nmelbourne <- sf::st_transform(melbourne, \"+proj=robin\")[[1]]\n\nggplot(world) +\n  geom_sf() +\n  annotate(\"segment\", x=ottawa[1], y=ottawa[2],\n           xend=melbourne[1], yend=melbourne[2]) +\n  coord_sf(crs=\"+proj=robin\")\n\n\nDirect labeling\nDirect labeling is the art of using annotations, instead of a legend, to identify shapes.\n\n\nlibrary(dplyr)\n\ndf <- ggstream::blockbusters\ndf.labels <- ggstream::blockbusters %>%\n  group_by(genre) %>%\n  arrange(year) %>%\n  slice(n())\n\nggplot(df) +\n  aes(year, box_office, color=genre) +\n  geom_line() +\n  geom_text(aes(label=genre), df.labels, hjust=0, nudge_x=0.2) +\n  expand_limits(x=2023) +\n  theme(legend.position=\"none\")\n\n\nThe broader ggplot2 ecosystem provide many tools to make this kind of task easier, such as the directlabels package:\n\n\nggplot(df) +\n  aes(year, box_office, color=genre) +\n  geom_line() +\n  directlabels::geom_dl(aes(label=genre), method=\"last.points\") +\n  expand_limits(x=2023) +\n  theme(legend.position=\"none\")\n\n\nThe ggforce::geom_mark_*() functions are useful for annotating groups of points:\n\n\nggplot(mpg) +\n  aes(displ, hwy, color=factor(cyl)) + \n  geom_point() +\n  ggforce::geom_mark_ellipse(aes(label=cyl, group=cyl)) +\n  theme(legend.position=\"none\")\n\n\nThe gghighlight package makes it easy to highlight filtered data while preserving the context:\n\n\nggplot(nlme::Oxboys) +\n  aes(age, height, group=Subject) + \n  geom_line() + \n  geom_point() + \n  gghighlight::gghighlight(Subject %in% 1:3)\n\n\nAnd also in facets:\n\n\nggplot(mpg) +\n  aes(displ, hwy, color=factor(cyl)) +\n  geom_point() +\n  facet_wrap(~cyl) +\n  gghighlight::gghighlight()\n\n\nCheckpoint 3\nInvestigate how to use ggforce::geom_mark_rect() to make an annotation similar to checkpoint 2.3.\nUsing line plot with the blockbusters dataset, investigate how to annotate the lines as a secondary axis using gghighlight::gghighlight().\n\n\n\n",
    "preview": "tutorials/06/preview.png",
    "last_modified": "2022-11-28T16:17:18+01:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 675
  },
  {
    "path": "tutorials/07/",
    "title": "07. Arranging plots",
    "description": "The grammar presented so far is concerned with creating single plots. However,\nit is often necessary to assemble several different plots together in order to\nbuild a story. In this tutorial, we will learn to produce such arrangements in\nan automated manner without requiring external graphic design tools and\nnon-reproducible manual work.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Chapter 2"
    ],
    "contents": "\n\nContents\nCompositions\nBasic usage\nControlling the layout\nFixed-aspect plots\nControlling the guides\nAdding arbitrary elements\nAnnotating the composition\n\nInsets\n\nSource: _tutorials/07/07.Rmd\nCompositions\nSince the existence of the patchwork package, it is extremely simple to compose, align and annotate different ggplot graphs, and even merge them with other arbitrary elements. To demonstrate its capabilities, we will use the following plots:\n\n\np1 <- ggplot(mpg) +\n  aes(displ, hwy) +\n  geom_point() +\n  labs(title=\"Plot 1\")\n\np2 <- ggplot(mpg) +\n  aes(as.character(year), fill=drv) +\n  geom_bar(position=\"dodge\") + \n  labs(title=\"Plot 2\", x=\"year\")\n\np3 <- ggplot(mpg) +\n  aes(hwy, fill=drv) +\n  geom_density(color=NA) + \n  facet_grid(drv~.) +\n  labs(title=\"Plot 3\")\n\np4 <- ggplot(mpg) +\n  aes(drv, hwy) +\n  stat_summary(aes(fill=drv), geom=\"col\", fun.data=mean_se) +\n  stat_summary(geom=\"errorbar\", fun.data=mean_se, width=0.5) +\n  labs(title=\"Plot 4\")\n\n\nBasic usage\nOnce loaded, this package extends the + operator to add plots together in a grid:\n\n\nlibrary(patchwork)\n\np1 + p2\np1 + p2 + p3\np1 + p2 + p3 + p4\np1 + plot_spacer() + p2 + plot_spacer() + p3 + plot_spacer()\n\n\nFor a finer control, it also provides the | (besides) and / (over) operators for plot stacking and packing:\n\n\np1 | p2\np1 / p2\n(p1 / p2) | p3\np1 / (p2 | p3)\n\n\nNote that patchwork automagically sets the proper margins for all the guides (axes, legends, titles…) so that all panels are perfectly aligned.\nControlling the layout\nFor even a richer control of the layout, we can just add the plots together and then add a plot_layout(), which has a bunch of options (see the help page) to control the grid:\n\n\np1 + p2 + p3 + p4 + \n  plot_layout(ncol=3)\np1 + p2 + p3 + p4 + \n  plot_layout(widths=c(2, 1))\np1 + p2 + p3 + p4 + \n  plot_layout(widths=c(2, 1), heights=unit(c(5, 1), c('cm', 'null')))\n\n\nMoving beyond the grid, the design argument allows us to define textual representations of the layout:\n\n\nlayout <- \"\n#BB\nACD\n#CD\n\"\np1 + p2 + p3 + p4 +\n  plot_layout(design=layout)\n\nlayout <- \"\nAAB\nC#B\nCDD\n\"\np1 + p2 + p3 + p4 +\n  plot_layout(design=layout)\n\n\nInstead, a more programmatic approach uses the area() function for the same purpose:\n\n\nlayout <- c(\n  area(1, 1, 1, 2),\n  area(1, 3, 2, 3),\n  area(2, 1, 3, 1),\n  area(3, 2, 3, 3)\n)\np1 + p2 + p3 + p4 +\n  plot_layout(design=layout)\n\n\nIf the number of plots is not known beforehand, the wrap_plots() function makes it easy to take a list of plots and add them together into one composition, along with layout specifications.\n\n\nplots <- list(p1, p2, p3, p4)\nwrap_plots(plots, design=layout)\n\n\nCheckpoint 1\nCompose the four plots p1, p2, p3, p3 in a single column using only operators (+, /, |).\nMake the same arrangement but using the plot_layout() function and without using the design argument.\nMake the same arrangement but using the design argument.\nMake the same arrangement but using the wrap_plots() function.\nFixed-aspect plots\nPlots created with coord_fixed(), coord_polar() and coord_sf() cannot be resized to align with other plots. By default, patchwork aligns the other plots to them when possible.\n\n\np_fixed <- ggplot(mpg) +\n  aes(hwy, cty) +\n  geom_point() +\n  coord_fixed() +\n  labs(title=\"Fixed coords\")\n\np_fixed + p1 + p2 + p3\n\n\nBut if we try to force the width, then the plot cannot be aligned.\n\n\np_fixed + p1 + p2 + p3 + plot_layout(widths=1)\n\n\nControlling the guides\nWhen composing plots with multiple guides, it is often useful to collect all the guides and put them in the same place. Compare the following:\n\n\np1 + p2 + p3 + p4\np1 + p2 + p3 + p4 + plot_layout(guides=\"collect\")\n\n\nNote that guides were not only collected, but duplicates were removed. This option can be specified at several points for a finer control:\n\n\np1 + p2 + (p3 + plot_layout(guides=\"keep\")) + p4 + plot_layout(guides=\"collect\")\n\n\nBy default, guides are collected on the right of the composition, but a guide_area() can be specified as a place to put them:\n\n\nlayout <- \"\nAAB\nCEB\nCDD\n\"\np1 + p2 + p3 + p4 + guide_area() +\n  plot_layout(design=layout, guides=\"collect\")\n\n\nCheckpoint 2\nTake p2 and move the legend to the left in a standard way (modifying the theme).\nAchieve the same result but using patchwork (use the widths argument to adjust the spacing).\nAdding arbitrary elements\nThe wrap_elements() function can be used to wrap arbitrary grid grobs and add them to a composition.\n\n\ntext <- wrap_elements(grid::textGrob(\"Some really important text\"))\ntable <- wrap_elements(gridExtra::tableGrob(mtcars[1:10, c(\"mpg\", \"disp\")]))\n\np1 + table\ntext + p1\n\n\nThe ggplotify package provides functions for converting different graphics (base graphics, lattice graphics and others) to grobs, so that they can be composed too with ggplot objects.\nAnnotating the composition\nThe final composition can be annotated with titles, captions, tags, etc., via the plot_annotation() function:\n\n\np1 + p2 + p3 + p4 +\n  plot_annotation(\n    title = \"Composition title\",\n    subtitle = \"Composition subtitle\",\n    caption = \"Composition caption\",\n    tag_levels = \"a\",\n    tag_suffix = \")\",\n    theme = theme(plot.title=element_text(color=\"red\"))\n  )\n\n\nInsets\nInsets are essentially plot annotations, i.e., a plot on top of another plot. This can be achieved with multiple overlapping area() specifications, but the specific function inset_element() makes this task much easier. It allows us to freely position the inset relative either to the panel, plot of full area of the plot by specifying the left, bottom, right and top edges of the inset:\n\n\np1 + inset_element(p2, left=0.6, bottom=0.6, right=1, top=1, align_to=\"panel\")\np1 + inset_element(p2, left=0.6, bottom=0.6, right=1, top=1, align_to=\"plot\")\np1 + inset_element(p2, left=0.6, bottom=0.6, right=1, top=1, align_to=\"full\")\n\n\nAnd autotagging works as expected:\n\n\np1 + inset_element(p2, left=0.6, bottom=0.6, right=1, top=1, align_to=\"full\") +\n  plot_annotation(tag_levels=\"a\")\n\n\nOne interesting use case of this technique is to zoom in a particular region:\n\n\nxlim <- c(2.9, 3.2)\nylim <- c(21, 28)\n\np_zoom <- p1 +\n  coord_cartesian(xlim=xlim, ylim=ylim, expand=FALSE) +\n  labs(title=NULL) +\n  theme_light() +\n  theme(\n    axis.title = element_blank(),\n    plot.background = element_blank(),\n    plot.margin = unit(c(0, 0, 0, 0), \"mm\")\n  )\n\np1 +\n  annotate(\"rect\", xmin=xlim[1], xmax=xlim[2], ymin=ylim[1], ymax=ylim[2],\n           fill=NA, color=\"black\") +\n  annotate(\"segment\", x=xlim[2], xend=5.2, y=ylim[1], yend=29, linetype=\"dashed\") +\n  annotate(\"segment\", x=xlim[1], xend=4.5, y=ylim[2], yend=45, linetype=\"dashed\") +\n  inset_element(p_zoom, left=0.5, bottom=0.45, right=0.65, top=0.95)\n\n\nCheckpoint 3\nOpen the last plot in RStudio’s zoom panel. Play with the aspect ratio of the pop-up window. What is the issue with the segment specification above? How could this be improved? Investigate ggplot’s annotation_custom() for this task.\n\n\n\n",
    "preview": "tutorials/07/preview.png",
    "last_modified": "2022-11-28T18:55:31+01:00",
    "input_file": {},
    "preview_width": 1050,
    "preview_height": 675
  },
  {
    "path": "tutorials/project/",
    "title": "Creating and Submitting your Project",
    "description": "The course's final goal is to publish a visualization project in our website,\nwhere you are reading this tutorial. The website is an R Markdown project\nthat lives in a GitHub repository. This tutorial will help you fork the\nrepository, create a new draft for your project, and submit it using GitHub's\nPull Request workflow.",
    "author": [
      {
        "name": "Iñaki Ucar",
        "url": {}
      }
    ],
    "date": "2022-10-05",
    "categories": [
      "Project"
    ],
    "contents": "\n\nContents\nPrerequisites\nCreating the initial skeleton\nForking the source code\nCreating a new project\nAdding your own article\nCommitting and pushing the changes\nContributing your article\n\nWorking on your project\nThe Pull Request workflow\nAdding changes to the article\n\nGeneral guidelines\nProject guidelines\nPresentation guidelines\n\n\nSource: _tutorials/project/project.Rmd\nPrerequisites\nThis tutorial assumes that you have a working installation of R and RStudio. For starters, you can read about the big picture motivation: Why Git? Why GitHub?, and here is a checklist of all the steps required to prepare for this tutorial.\nRegister a free GitHub account if you do not have one already.\nInstall Git. There are specific instructions for Windows, macOS and Linux.\nIntroduce yourself to Git.\nConfigure a personal access token.\nFollow this webinar to familiarize yourself with GitHub and RStudio’s interface to Git.\nIt is also recommended that you read about some Git basics.\nCreating the initial skeleton\nForking the source code\nThis web page is a Distill website, and as such it consists of a series of R Markdown source files that are compiled into HTML. Data projects, like any other software project, greatly benefits from version control, and this website is no exception. Its sources, along with the resulting HTML products, are hosted in (and published from) a GitHub repository. You can access this repository by clicking on the top-right logo.\n\n\n\nCollaboration on GitHub, as in any other Git-based platform, is done via Pull Requests. Essentially, you work on a copy of the project, make changes, and then propose them to be included in the original repository. So in the first place, you need to fork the repository, meaning that you get a copy in your personal account that is linked to the original one, so that you can later submit your changes. To do this, just click the fork button in the dataviz repository.\n\n\n\nBy clicking Create fork, you will be redirected to your new repository. Once there, click the green Code button and copy the HTTPS URL.\n\n\n\nCreating a new project\nBack in RStudio, start the dialog to create a new project.\n\n\n\nNow, select a Version Control project, managed by Git, and then paste the repository URL you copied in the last step. Adjust the destination path if required.\n\n\n\nIf everything is properly configured, RStudio will download a copy of the GitHub’s repository in your personal account to your PC (in Git terms, it will clone the remote repository locally), and the project will be opened.\nAdding your own article\nNow it is time to generate some new content. To create the basic structure of visualization project, first install the distill R package, and then execute the following code:\n\n\n# install.packages(\"distill\") # if required\n\ndistill::create_post(\n  title = \"The Title of my Article\",\n  collection = paste0(\"projects/\", format(Sys.Date(), \"%Y\")),\n  author = \"My name\",\n  slug = NIA,\n  date_prefix = NULL\n)\n\n\nwhere NIA should be your student identifier (i.e. the 9-digit identifier of the form 100xxxxxx). If you inspect RStudio’s Files pane, you will notice that a new directory _projects/<year>/100xxxxxx has been generated. The Rmd file with the same name under that directory is now open in the editor pane. Edit the file header as follows:\nSet a tentative title and description for your project. It does not need to be definitive, so do not take to much time thinking about this right now.\nAdd categories: \"<year>\" below the description (substituting <year> by the current year, obviously).\nSet your full name.\nSet the date as follows: date: \"`r Sys.Date()`\". In this way, the date of the article will be the date of the last compilation, which is convenient.\nAdd toc: true to the distill_article options.\nThe header should look like this:\n\n\n\nAlso, remove the following part, because this prevents the R code chunks for being displayed in the article, and we want precisely the opposite:\n\n\n\nThen save and hit the knit button to compile the document.\n\n\n\nAs a result, the article _projects/<year>/100xxxxxx/100xxxxxx.html has been generated.\nCommitting and pushing the changes\nNow it is time to tell Git what changes we want to incorporate. There is a new Git pane in RStudio in the top-right panel set. Important: you must always select only the files that were modified under your NIA (i.e., the _projects/<year>/100xxxxxx directory), and nothing else.\n\n\n\nIn the case above, mark as Staged only the yellow directories, ignoring the other files. Once checked, click the Commit button.\n\n\n\nIn the new dialogue, check once again that all files under your NIA—and only those— are selected. Then, write a descriptive commit message and hit Commit.\n\n\n\nClose the dialogue. Currently, you local copy of the repository contains the changes, but not the remote one on GitHub (the Git pane reads “Your branch is ahead of ‘origin/main’ by 1 commit”). To synchronize the changes, you need to click the Push button.\n\n\n\nContributing your article\nFinally, you can contribute your article by opening a Pull Request. In your fork, you will see that GitHub notices that your copy is 1 commit ahead of the original repository, and offers you to contribute.\n\n\n\nClick the Contribute button to start a new Pull Request.\n\n\n\nIn this new dialogue,\nset the title to something like Project - <your_name>;\nyou can write a description;\nensure that “Allow edits by maintainers” is checked;\nclick the down arrow in the green button to “create a draft pull request”.\nThen click Create a draft pull request. Congratulations! You have created your first Pull Request (i.e., something like this), and paved the way to contribute a visualization project for this course.\nWorking on your project\nUsually, Pull Requests contain a more complete version of the final contribution, but here we are learning. So far, we just created a skeleton of the article in “Draft” mode, and we will be adding content gradually.\nThe Pull Request workflow\nA Pull Request is a space where maintainers and collaborators work together to shape the final contribution:\nA collaborator commits some changes and asks for feedback.\nThe maintainer reviews the changes and proposes corrections.\nNote that, once the Pull Request is open, every commit that the collaborator pushes to their fork is automatically added to the Pull Request. So the cycle repeats until everybody is happy with the result, and the maintainer finally merges the Pull Request.\nAdding changes to the article\nThe workflow is pretty straightforward:\nModify the Rmd file with text, code and images (external images need to be placed under _projects/<year>/100xxxxxx/, and then referenced by name in the Rmd).\nCompile the article by clicking the Knit button.\nMark as Staged in the Git pane all (and only) the files under _projects/<year>/100xxxxxx/.\nCommit (with a descriptive commit message) and push.\nFinally, when the project is finished, please click the “Ready for review” button in the Pull Request (at the bottom, on top of the comment box). Then I will check that everything is ok, ask for minor changes if required, and then merge the Pull Request and your project will be live!\nGeneral guidelines\nProject guidelines\nCommit messages are for future-you. Put something descriptive of what you have done, so that, if future-you finds an issue and wants to undo something, it is easy to remember what each commit did. If you want to communicate with me, commit messages are not a good way; instead, the PR has a nice web interface where you can add comments (with Markdown syntax, yay!).\nUse level 2 headings (## Title) as the highest level for headings. In other words, please do not use level 1 headings in your posts (# Title), because the title of the post is already level 1, so it looks nicer if sections start one level below.\nNote that you do not need to add echo=TRUE to every chunk, because they are shown by default.\nIt is a good practice to set an initial chunk, right below the YAML header, as the following to ensure that images use the whole width available and are centered:\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(out.width=\"100%\", fig.align=\"center\")\n```\nIt is a good practice to set the whole width in Markdown images:\n![This is a caption.](my-image.png){width=\"100%\"}\nFor external images (the ones that you downloaded from somewhere, such as the chart you are trying to replicate), it is a good practice to set the “external” class too:\n![This is another caption.](external-image.png){.external width=\"100%\"}\nIn distill articles, you can set images and tables that span a width larger than the text column. It looks nicer e.g. for images that are very wide. There are a couple of examples in the Gapminder project. You can see how this is done in the Rmd, here and here, just in case you want to use this feature.\nNote also the preview=TRUE option here. Adding this option to a chunk makes the image produced by that chunk as the preview image for your article in the “Projects” gallery.\nOne of most important best practices is to limit the width of your code. If you write code lines that are very long, they are harder to read. And especially in this case, these long lines will jump the width of the post and will be lost in the margin, outside of the visible area. So in general it is a good idea to break your lines of code at a maximum width. The common practice is to use a maximum width of 80 characters. There is an option in RStudio to show a visual guide in the editor for this limit. You can activate this in Tools > Global Options > Code > Display > Show margin. There is also a package called styler that allows you to style your document automatically. After installing the package, if you click “Addins” in the RStudio toolbar, there is a new addin called “Style active file”. This could be a good starting point (although you may not like other styling options that this package applies).\nPresentation guidelines\nOnce the project is finished and merged, you will need to prepare a short presentation.\nThe document format should be a presentation, but I do not particularly care about the file format. If you wish to try an R Markdown presentation, that is great; but a PowerPoint or PDF would be fine too.\nSuggested structure:\n~1 minute to present the selected chart, strengths and weaknesses;\n~2 minutes to present your replication work;\n~2 minutes to present enhancements and alternatives.\n\nBe brief, it is 5 minutes, so do not try to explain everything, there will be a post in our web for that.\nDo not show all the code, there will be a post in our web for that. Just highlight some small portions of the code that you found specially tricky, challenging, clever…\n\n\n\n",
    "preview": "tutorials/project/13-commit.png",
    "last_modified": "2023-09-13T15:30:15+02:00",
    "input_file": {},
    "preview_width": 509,
    "preview_height": 304
  }
]
